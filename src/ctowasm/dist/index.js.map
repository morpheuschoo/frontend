{"mappings":"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YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QACD,sBAAsB,OAAO,CAAC;QAE9B,IAAI,oBAAoB;YACtB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA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AAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,EAAE,EACpC,KAAK,CAAC,EAAE,GAAG,QAAQ,UAAU,CAAC;gBAEhC,OAAO;YACT,EAAE,OAAO,GAAG;gBACV,MAAM,IAAI,MAAM;YAClB;QACF;QAEA,6EAA6E;QAC7E,kFAAkF;QAClF,SAAS,kBAAkB,QAAQ;YACjC,IAAI,CAAC,UAAU,WACb;YAGF,OAAO,mBAAmB,SAAS,KAAK,CAAC,cAAc,MAAM;QAC/D;QACA,8BAA8B;QAC9B,MAAM,CAAC,aAAa,GAAG;QACvB,MAAM,CAAC,QAAQ,GAAG;QAClB,MAAM,CAAC,QAAQ,GAAG;QAClB,MAAM,CAAC,cAAc,GAAG;QACxB,MAAM,CAAC,kBAAkB,GAAG;QAC5B,IAAI,wBAAwB;YAC1B;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QACD,sBAAsB,OAAO,CAAC;QAE9B,IAAI,oBAAoB;YACtB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QACD,kBAAkB,OAAO,CAAC;QAE1B,IAAI;QAEJ,wBAAwB,SAAS;YAC/B,kHAAkH;YAClH,IAAI,CAAC,WAAW;YAChB,IAAI,CAAC,WAAW,wBAAwB,WAAW,qDAAqD;QAC1G;QAEA,SAAS;YACP,6EAA6E;YAC7E,kFAAkF;YAClF,QAAQ;YACR;YACA,+DAA+D;YAC/D;QACF;QAEA,SAAS;YACP,IAAI,kBAAkB,GACpB;YAGF;YAEA;YAEA,wDAAwD;YACxD,IAAI,kBAAkB,GACpB;YAGF,SAAS;gBACP,8FAA8F;gBAC9F,wDAAwD;gBACxD,IAAI,WAAW;gBACf,YAAY;gBACZ,MAAM,CAAC,YAAY,GAAG;gBAEtB,IAAI,OAAO;gBAEX;gBAEA,oBAAoB;gBACpB,IAAI,MAAM,CAAC,uBAAuB,EAAE,MAAM,CAAC,uBAAuB;gBAElE,OACE,CAAC,MAAM,CAAC,QAAQ,EAChB;gBAGF;YACF;YAEA,IAAI,MAAM,CAAC,YAAY,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AI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IAAI,UAAU;IACd,IA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","sources":["src/index.ts","src/modules/index.ts","src/modules/math/index.ts","src/modules/types.ts","src/modules/math/emscripten/math.js","src/modules/pix_and_flix/index.ts","src/modules/constants.ts","src/modules/source_stdlib/memory.ts","src/modules/util.ts","src/common/utils.ts","src/common/constants.ts","src/translator/memoryUtil.ts","src/translator/dataTypeUtil.ts","src/errors.ts","src/modules/stackFrameUtils.ts","src/modules/source_stdlib/index.ts","src/modules/utility/index.ts","src/modules/utility/emscripten/utility.js","src/compiler.ts","src/parser/index.ts","src/parser/peggyjs/preprocessor.js","src/parser/peggyjs/lexer.js","src/parser/peggyjs/parser.js","src/processor/index.ts","src/processor/processFunctionDefinition.ts","src/processor/symbolTable.ts","src/processor/memoryManager.ts","src/processor/memoryAddressMap.ts","src/processor/dataTypeUtil.ts","src/processor/evaluateCompileTimeExpression.ts","src/processor/expressionUtil.ts","src/processor/processExpression.ts","src/processor/util.ts","src/processor/lvalueUtil.ts","src/processor/processConstant.ts","src/processor/processBlockItem.ts","src/processor/processDeclaration.ts","src/processor/byteStrUtil.ts","src/processor/processEnumDeclaration.ts","src/processor/warningUtil.ts","src/processor/constraintChecks.ts","src/wat-generator/index.ts","src/wat-generator/constants.ts","src/wat-generator/generateWatExpression.ts","src/wat-generator/util.ts","src/wat-generator/generateWatStatement.ts","src/wat-to-wasm/index.ts","src/translator/index.ts","src/translator/util.ts","src/translator/translateExpression.ts","src/translator/translateBinaryExpression.ts","src/translator/translateStatement.ts","src/translator/translateFunctionCall.ts","src/translator/loopUtil.ts","src/translator/constants.ts","src/translator/translateSwitchStatement.ts","src/translator/translateUnaryExpression.ts","src/translator/translateFunction.ts","src/translator/processImportedFunctions.ts","src/interpreter/index.ts","src/interpreter/interpret.ts","src/interpreter/runtime.ts","src/interpreter/utils/control.ts","src/interpreter/utils/stack.ts","src/interpreter/controlItems/instructions.ts","src/interpreter/utils/stash.ts","src/interpreter/evaluators/nodeEvaluator.ts","src/interpreter/utils/jumpStatementChecking.ts","src/interpreter/utils/addressUtils.ts","src/interpreter/utils/constantsUtils.ts","src/interpreter/evaluators/instructionEvaluator.ts","src/interpreter/memory.ts","src/interpreter/stackFrame.ts","src/interpreter/controlItems/index.ts","src/interpreter/controlItems/types.ts"],"sourcesContent":["import ModuleRepository, {\n  ModuleName,\n  ModulesGlobalConfig,\n} from \"~src/modules\";\nimport {\n  compile as originalCompile,\n  compileToWat as originalCompileToWat,\n  generate_C_AST as original_generate_C_AST,\n  generate_WAT_AST as originalGenerate_WAT_AST,\n  generate_processed_C_AST as original_generate_processed_C_AST,\n  interpret_C_AST as original_interpter_C_AST,\n  evaluate as originalEvaluate,\n  WatCompilationResult,\n  CompilationResult,\n  EvaluationResult,\n} from \"./compiler\";\nimport { calculateNumberOfPagesNeededForBytes } from \"~src/common/utils\";\nimport { WASM_PAGE_SIZE } from \"~src/translator/memoryUtil\";\nimport { InstructionType } from \"./interpreter/controlItems/instructions\";\nimport { controlItemToString } from \"./interpreter\";\n\nexport { InstructionType, controlItemToString };\n\nexport const defaultModuleRepository = new ModuleRepository(); // default repository containing module information without any custom configs or wasm memory\n\nexport function compileToWat(program: string): WatCompilationResult {\n  return originalCompileToWat(program, defaultModuleRepository);\n}\n\nexport function generate_WAT_AST(program: string) {\n  return originalGenerate_WAT_AST(program, defaultModuleRepository);\n}\n\nexport function interpret_C_AST(\n  program: string,\n  modulesConfig: ModulesGlobalConfig,\n) {\n  return original_interpter_C_AST(\n    program,\n    defaultModuleRepository,\n    modulesConfig,\n  );\n}\n\nexport async function evaluate(\n  program: string,\n  modulesConfig: ModulesGlobalConfig,\n  targetStep: number,\n): Promise<EvaluationResult> {\n  return await originalEvaluate(program, defaultModuleRepository, targetStep);\n}\n\nexport async function compile(program: string): Promise<CompilationResult> {\n  const compilationResult = await originalCompile(\n    program,\n    defaultModuleRepository,\n  );\n\n  // check if compilation failed\n  if (compilationResult.status === \"failure\") {\n    return compilationResult;\n  }\n\n  return compilationResult;\n}\n\n/**\n * Compiles the given C program, including all default imported functions.\n */\nexport async function compileAndRun(\n  program: string,\n  modulesConfig?: ModulesGlobalConfig,\n): Promise<CompilationResult> {\n  const compilationResult = await originalCompile(\n    program,\n    defaultModuleRepository,\n  );\n\n  // check if compilation failed\n  if (compilationResult.status === \"failure\") {\n    return compilationResult;\n  }\n\n  const { wasm, dataSegmentSize, functionTableSize, importedModules } =\n    compilationResult;\n  await runWasm(\n    wasm,\n    dataSegmentSize,\n    functionTableSize,\n    importedModules,\n    modulesConfig,\n  );\n\n  return compilationResult;\n}\n\nexport async function runWasm(\n  wasm: Uint8Array,\n  dataSegmentSize: number,\n  functionTableSize: number,\n  importedModules: ModuleName[],\n  modulesConfig?: ModulesGlobalConfig,\n) {\n  const numberOfInitialPagesNeeded =\n    calculateNumberOfPagesNeededForBytes(dataSegmentSize);\n  const moduleRepository = new ModuleRepository(\n    new WebAssembly.Memory({ initial: numberOfInitialPagesNeeded }),\n    new WebAssembly.Table({ element: \"anyfunc\", initial: functionTableSize }),\n    modulesConfig,\n  );\n  moduleRepository.setStackPointerValue(\n    numberOfInitialPagesNeeded * WASM_PAGE_SIZE,\n  );\n  moduleRepository.setBasePointerValue(\n    numberOfInitialPagesNeeded * WASM_PAGE_SIZE,\n  );\n  moduleRepository.setHeapPointerValue(Math.ceil(dataSegmentSize / 4) * 4); // align to 4 bytes\n\n  const wasmImports =\n    await moduleRepository.createWasmImportsObject(importedModules);\n  await WebAssembly.instantiate(wasm, wasmImports);\n}\n\nexport function generate_processed_C_AST(program: string) {\n  return original_generate_processed_C_AST(program, defaultModuleRepository);\n}\n\nexport function generate_C_AST(program: string) {\n  return original_generate_C_AST(program, defaultModuleRepository);\n}\n","import { MathStdLibModule, mathStdlibName } from \"~src/modules/math\";\nimport {\n  PixAndFlixLibrary,\n  pixAndFlixLibraryModuleImportName,\n} from \"~src/modules/pix_and_flix\";\nimport {\n  SourceStandardLibraryModule,\n  sourceStandardLibraryModuleImportName,\n} from \"~src/modules/source_stdlib\";\nimport { Module } from \"~src/modules/types\";\nimport { UtilityStdLibModule, utilityStdLibName } from \"~src/modules/utility\";\nimport { WASM_ADDR_TYPE } from \"~src/translator/memoryUtil\";\n\nexport interface ModulesGlobalConfig {\n  printFunction: (str: string) => void; // the print function to use for printing to \"stdout\"\n  externalFunctions?: { [functionName: string]: Function };\n}\n\nconst defaultModulesGlobalConfig: ModulesGlobalConfig = {\n  printFunction: (str: string) => console.log(str),\n};\n\nexport interface SharedWasmGlobalVariables {\n  stackPointer: WebAssembly.Global;\n  heapPointer: WebAssembly.Global;\n  basePointer: WebAssembly.Global;\n}\n\n// all the names of the modules\nexport type ModuleName =\n  | typeof sourceStandardLibraryModuleImportName\n  | typeof pixAndFlixLibraryModuleImportName\n  | typeof mathStdlibName\n  | typeof utilityStdLibName;\n\n/**\n * Holds all the modules that define functions that can be imported and used in C source program.\n */\nexport default class ModuleRepository {\n  memory: WebAssembly.Memory;\n  functionTable: WebAssembly.Table; // table of functions of webassembly module\n  config: ModulesGlobalConfig;\n  modules: Record<ModuleName, Module>;\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables;\n\n  constructor(\n    memory?: WebAssembly.Memory,\n    functionTable?: WebAssembly.Table,\n    config?: ModulesGlobalConfig,\n  ) {\n    this.memory = memory ?? new WebAssembly.Memory({ initial: 0 });\n    this.functionTable =\n      functionTable ??\n      new WebAssembly.Table({ element: \"anyfunc\", initial: 0 });\n    this.config = config ? { ...config } : defaultModulesGlobalConfig;\n\n    this.sharedWasmGlobalVariables = {\n      stackPointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        0,\n      ),\n      basePointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        0,\n      ),\n      heapPointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        0,\n      ),\n    };\n\n    this.modules = {\n      [sourceStandardLibraryModuleImportName]: new SourceStandardLibraryModule(\n        this.memory,\n        this.functionTable,\n        this.config,\n        this.sharedWasmGlobalVariables,\n      ),\n      [pixAndFlixLibraryModuleImportName]: new PixAndFlixLibrary(\n        this.memory,\n        this.functionTable,\n        this.config,\n        this.sharedWasmGlobalVariables,\n      ),\n      [mathStdlibName]: new MathStdLibModule(\n        this.memory,\n        this.functionTable,\n        this.config,\n        this.sharedWasmGlobalVariables,\n      ),\n      [utilityStdLibName]: new UtilityStdLibModule(\n        this.memory,\n        this.functionTable,\n        this.config,\n        this.sharedWasmGlobalVariables,\n      ),\n    };\n  }\n\n  setStackPointerValue(value: number) {\n    this.sharedWasmGlobalVariables.stackPointer.value = value;\n  }\n\n  setBasePointerValue(value: number) {\n    this.sharedWasmGlobalVariables.basePointer.value = value;\n  }\n\n  setHeapPointerValue(value: number) {\n    this.sharedWasmGlobalVariables.heapPointer.value = value;\n  }\n\n  setMemory(numberOfPages: number) {\n    this.memory = new WebAssembly.Memory({ initial: numberOfPages });\n  }\n\n  /**\n   * Returns the object that can be used as argument to Webassembly.instantiate.\n   * @param importedModules the names of all modules that are being imported and used in a particular compiled wasm output file.\n   */\n  async createWasmImportsObject(\n    importedModules: ModuleName[],\n  ): Promise<WebAssembly.Imports> {\n    const imports: WebAssembly.Imports = {\n      js: {\n        mem: this.memory,\n        function_table: this.functionTable,\n        sp: this.sharedWasmGlobalVariables.stackPointer,\n        hp: this.sharedWasmGlobalVariables.heapPointer,\n        bp: this.sharedWasmGlobalVariables.basePointer,\n      },\n    };\n\n    for (const moduleName of importedModules) {\n      const module = this.modules[moduleName];\n      const moduleImportObject: WebAssembly.ModuleImports = {};\n      if (typeof this.modules[moduleName].instantiate !== \"undefined\") {\n        await (this.modules[moduleName].instantiate as () => Promise<void>)();\n      }\n      Object.keys(this.modules[moduleName].moduleFunctions).map(\n        (moduleFunctionName) => {\n          moduleImportObject[moduleFunctionName] =\n            module.moduleFunctions[moduleFunctionName].jsFunction;\n        },\n      );\n      imports[moduleName] = moduleImportObject;\n    }\n    return imports;\n  }\n}\n","import { ModulesGlobalConfig, SharedWasmGlobalVariables } from \"~src/modules\";\nimport { Module, ModuleFunction } from \"~src/modules/types\";\nimport { StructDataType } from \"~src/parser/c-ast/dataTypes\";\nimport mathModuleFactoryFn from \"~src/modules/math/emscripten/math\";\n\n// the name that this module is imported into wasm by,\n// as well as the include name to use in C program file.\nexport const mathStdlibName = \"math\";\n\nexport class MathStdLibModule extends Module {\n  moduleDeclaredStructs: StructDataType[];\n  moduleFunctions: Record<string, ModuleFunction>;\n  heapAddress: number; // address of first item in heap\n\n  constructor(\n    memory: WebAssembly.Memory,\n    functionTable: WebAssembly.Table,\n    config: ModulesGlobalConfig,\n    sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  ) {\n    super(memory, functionTable, config, sharedWasmGlobalVariables);\n    this.heapAddress = this.sharedWasmGlobalVariables.heapPointer.value;\n    this.moduleDeclaredStructs = [];\n    this.instantiate = async () => {\n      const mathModule = await mathModuleFactoryFn();\n      // need to set the jsFunctions of all moduleFunctions here\n      this.moduleFunctions.acos.jsFunction = mathModule._acos;\n      this.moduleFunctions.asin.jsFunction = mathModule._asin;\n      this.moduleFunctions.atan.jsFunction = mathModule._atan;\n      this.moduleFunctions.cos.jsFunction = mathModule._cos;\n      this.moduleFunctions.cosh.jsFunction = mathModule._cosh;\n      this.moduleFunctions.sin.jsFunction = mathModule._sin;\n      this.moduleFunctions.sinh.jsFunction = mathModule._sinh;\n      this.moduleFunctions.tanh.jsFunction = mathModule._tanh;\n      this.moduleFunctions.exp.jsFunction = mathModule._exp;\n      this.moduleFunctions.log.jsFunction = mathModule._log;\n      this.moduleFunctions.log10.jsFunction = mathModule._log10;\n      this.moduleFunctions.pow.jsFunction = mathModule._pow;\n      this.moduleFunctions.sqrt.jsFunction = mathModule._sqrt;\n      this.moduleFunctions.ceil.jsFunction = mathModule._ceil;\n      this.moduleFunctions.floor.jsFunction = mathModule._floor;\n      this.moduleFunctions.tan.jsFunction = mathModule._tan;\n    };\n    this.moduleFunctions = {\n      acos: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      asin: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      atan: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      cos: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      cosh: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      sin: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      sinh: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      tan: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      tanh: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      exp: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      log: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      log10: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      pow: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      sqrt: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      ceil: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n      floor: {\n        parentImportedObject: mathStdlibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => {}, // temp value for now, will be set later\n      },\n    };\n  }\n}\n","import {\n  FloatDataType,\n  IntegerDataType,\n  PointerCDataType,\n} from \"~src/common/types\";\nimport { ModulesGlobalConfig, SharedWasmGlobalVariables } from \"~src/modules\";\nimport { MemoryBlock } from \"~src/modules/source_stdlib/memory\";\nimport { FunctionDataType, StructDataType } from \"~src/parser/c-ast/dataTypes\";\n\n// Configuration parameters for WasmModuleImports object\n\nexport interface ImportedModulesGlobalConfig {\n  printFunction?: (str: string) => void; // the print function to use for printing to \"stdout\"\n  externalFunctions?: { [functionName: string]: Function };\n}\n// Defines the signature of a wasm imported function\n\nexport interface ModuleFunction {\n  parentImportedObject: string; // parent imported object\n  functionType: FunctionDataType;\n  // eslint-disable-next-line\n  jsFunction: Function; // the actual JS function that is called\n}\n\n/**\n * Base class for all Modules.\n */\nexport abstract class Module {\n  memory: WebAssembly.Memory;\n  functionTable: WebAssembly.Table;\n  config: ModulesGlobalConfig;\n  freeList: MemoryBlock[] = [];\n  allocatedBlocks: Map<number, number> = new Map(); // allocated memory blocks <address, size>\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables;\n  instantiate?: () => Promise<void>; // any instantiation of the module that must be done before use\n  abstract moduleDeclaredStructs: StructDataType[];\n  abstract moduleFunctions: Record<string, ModuleFunction>; // all the functions within this module\n\n  constructor(\n    memory: WebAssembly.Memory,\n    functionTable: WebAssembly.Table,\n    config: ModulesGlobalConfig,\n    sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  ) {\n    this.memory = memory;\n    this.functionTable = functionTable;\n    this.config = config;\n    this.sharedWasmGlobalVariables = sharedWasmGlobalVariables;\n  }\n\n  /**\n   * Print to \"stdout\" by calling the printFunction defined in config.\n   */\n  print(str: string) {\n    this.config.printFunction(str);\n  }\n}\n\nexport type StackFrameArg = IntegerStackFrameArg | FloatStackFrameArg;\n\n/**\n * Represents a stack frame argument to be placed on a stack frame.\n */\ninterface IntegerStackFrameArg {\n  value: bigint;\n  type: IntegerDataType | PointerCDataType;\n}\n\n/**\n * Represents a stack frame argument to be placed on a stack frame.\n */\ninterface FloatStackFrameArg {\n  value: number;\n  type: FloatDataType;\n}\n","var Module = (() => {\n  var _scriptDir =\n    typeof document !== \"undefined\" && document.currentScript\n      ? document.currentScript.src\n      : undefined;\n\n  return function (moduleArg = {}) {\n    // include: shell.js\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n    var Module = moduleArg;\n\n    // Set up the promise that indicates the Module is initialized\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    [\n      \"_acos\",\n      \"_asin\",\n      \"_atan\",\n      \"_cos\",\n      \"_cosh\",\n      \"_sin\",\n      \"_sinh\",\n      \"_tan\",\n      \"_tanh\",\n      \"_exp\",\n      \"_log\",\n      \"_log10\",\n      \"_pow\",\n      \"_sqrt\",\n      \"_ceil\",\n      \"_floor\",\n      \"_memory\",\n      \"_fflush\",\n      \"___indirect_function_table\",\n      \"onRuntimeInitialized\",\n    ].forEach((prop) => {\n      if (!Object.getOwnPropertyDescriptor(Module[\"ready\"], prop)) {\n        Object.defineProperty(Module[\"ready\"], prop, {\n          get: () =>\n            abort(\n              \"You are getting \" +\n                prop +\n                \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\",\n            ),\n          set: () =>\n            abort(\n              \"You are setting \" +\n                prop +\n                \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\",\n            ),\n        });\n      }\n    });\n\n    // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n    var moduleOverrides = Object.assign({}, Module);\n\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n\n    // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n\n    if (Module[\"ENVIRONMENT\"]) {\n      throw new Error(\n        \"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\",\n      );\n    }\n\n    // `/` should be present at the end if `scriptDirectory` is not empty\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    // Hooks that are implemented differently in different runtime environments.\n    var read_, readAsync, readBinary, setWindowTitle;\n\n    if (ENVIRONMENT_IS_SHELL) {\n      if (\n        (typeof process == \"object\" && typeof require === \"function\") ||\n        typeof window == \"object\" ||\n        typeof importScripts == \"function\"\n      )\n        throw new Error(\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\n        );\n\n      if (typeof read != \"undefined\") {\n        read_ = read;\n      }\n\n      readBinary = (f) => {\n        if (typeof readbuffer == \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n        let data = read(f, \"binary\");\n        assert(typeof data == \"object\");\n        return data;\n      };\n\n      readAsync = (f, onload, onerror) => {\n        setTimeout(() => onload(readBinary(f)));\n      };\n\n      if (typeof clearTimeout == \"undefined\") {\n        globalThis.clearTimeout = (id) => {};\n      }\n\n      if (typeof setTimeout == \"undefined\") {\n        // spidermonkey lacks setTimeout but we use it above in readAsync.\n        globalThis.setTimeout = (f) => (typeof f == \"function\" ? f() : abort());\n      }\n\n      if (typeof scriptArgs != \"undefined\") {\n        arguments_ = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        arguments_ = arguments;\n      }\n\n      if (typeof quit == \"function\") {\n        quit_ = (status, toThrow) => {\n          // Unlike node which has process.exitCode, d8 has no such mechanism. So we\n          // have no way to set the exit code and then let the program exit with\n          // that code when it naturally stops running (say, when all setTimeouts\n          // have completed). For that reason, we must call `quit` - the only way to\n          // set the exit code - but quit also halts immediately.  To increase\n          // consistency with node (and the web) we schedule the actual quit call\n          // using a setTimeout to give the current stack and any exception handlers\n          // a chance to run.  This enables features such as addOnPostRun (which\n          // expected to be able to run code after main returns).\n          setTimeout(() => {\n            if (!(toThrow instanceof ExitStatus)) {\n              let toLog = toThrow;\n              if (toThrow && typeof toThrow == \"object\" && toThrow.stack) {\n                toLog = [toThrow, toThrow.stack];\n              }\n              err(`exiting due to exception: ${toLog}`);\n            }\n            quit(status);\n          });\n          throw toThrow;\n        };\n      }\n\n      if (typeof print != \"undefined\") {\n        // Prefer to use print/printErr where they exist, as they usually work better.\n        if (typeof console == \"undefined\")\n          console = /** @type{!Console} */ ({});\n        console.log = /** @type{!function(this:Console, ...*): undefined} */ (\n          print\n        );\n        console.warn = console.error =\n          /** @type{!function(this:Console, ...*): undefined} */ (\n            typeof printErr != \"undefined\" ? printErr : print\n          );\n      }\n    }\n\n    // Note that this includes Node.js workers when relevant (pthreads is enabled).\n    // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n    // ENVIRONMENT_IS_NODE.\n    else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (typeof document != \"undefined\" && document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      }\n      // When MODULARIZE, this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n      // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n      // they are removed because they could contain a slash.\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1,\n        );\n      } else {\n        scriptDirectory = \"\";\n      }\n\n      if (!(typeof window == \"object\" || typeof importScripts == \"function\"))\n        throw new Error(\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\n        );\n\n      // Differentiate the Web Worker from the Node Worker case, as reading must\n      // be done differently.\n      {\n        // include: web_or_worker_shell_read.js\n        read_ = (url) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n          };\n        }\n\n        readAsync = (url, onload, onerror) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = () => {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              // file URLs can return 0\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n\n        // end include: web_or_worker_shell_read.js\n      }\n\n      setWindowTitle = (title) => (document.title = title);\n    } else {\n      throw new Error(\"environment detection error\");\n    }\n\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.error.bind(console);\n\n    // Merge back in the overrides\n    Object.assign(Module, moduleOverrides);\n    // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n    moduleOverrides = null;\n    checkIncomingModuleAPI();\n\n    // Emit code to handle expected values on the Module object. This applies Module.x\n    // to the proper local x. This has two benefits: first, we only emit it if it is\n    // expected to arrive, and second, by using a local everywhere else that can be\n    // minified.\n\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    legacyModuleProp(\"arguments\", \"arguments_\");\n\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    legacyModuleProp(\"thisProgram\", \"thisProgram\");\n\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    legacyModuleProp(\"quit\", \"quit_\");\n\n    // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n    // Assertions on removed incoming Module JS APIs.\n    assert(\n      typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\",\n      \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\",\n      \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\",\n      \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"filePackagePrefixURL\"] == \"undefined\",\n      \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"read\"] == \"undefined\",\n      \"Module.read option was removed (modify read_ in JS)\",\n    );\n    assert(\n      typeof Module[\"readAsync\"] == \"undefined\",\n      \"Module.readAsync option was removed (modify readAsync in JS)\",\n    );\n    assert(\n      typeof Module[\"readBinary\"] == \"undefined\",\n      \"Module.readBinary option was removed (modify readBinary in JS)\",\n    );\n    assert(\n      typeof Module[\"setWindowTitle\"] == \"undefined\",\n      \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\",\n    );\n    assert(\n      typeof Module[\"TOTAL_MEMORY\"] == \"undefined\",\n      \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\",\n    );\n    legacyModuleProp(\"asm\", \"wasmExports\");\n    legacyModuleProp(\"read\", \"read_\");\n    legacyModuleProp(\"readAsync\", \"readAsync\");\n    legacyModuleProp(\"readBinary\", \"readBinary\");\n    legacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\n    var IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\n    var PROXYFS =\n      \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\n    var WORKERFS =\n      \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\n    var FETCHFS =\n      \"FETCHFS is no longer included by default; build with -lfetchfs.js\";\n    var ICASEFS =\n      \"ICASEFS is no longer included by default; build with -licasefs.js\";\n    var JSFILEFS =\n      \"JSFILEFS is no longer included by default; build with -ljsfilefs.js\";\n    var OPFS = \"OPFS is no longer included by default; build with -lopfs.js\";\n\n    var NODEFS =\n      \"NODEFS is no longer included by default; build with -lnodefs.js\";\n\n    assert(\n      !ENVIRONMENT_IS_WORKER,\n      \"worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.\",\n    );\n\n    assert(\n      !ENVIRONMENT_IS_NODE,\n      \"node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.\",\n    );\n\n    assert(\n      !ENVIRONMENT_IS_SHELL,\n      \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\",\n    );\n\n    // end include: shell.js\n    // include: preamble.js\n    // === Preamble library stuff ===\n\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    legacyModuleProp(\"wasmBinary\", \"wasmBinary\");\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    legacyModuleProp(\"noExitRuntime\", \"noExitRuntime\");\n\n    if (typeof WebAssembly != \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n\n    // Wasm globals\n\n    var wasmMemory;\n\n    //========================================\n    // Runtime essentials\n    //========================================\n\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n    var ABORT = false;\n\n    // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n    var EXITSTATUS;\n\n    /** @type {function(*, string=)} */\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n      }\n    }\n\n    // We used to include malloc/free by default in the past. Show a helpful error in\n    // builds with assertions.\n    function _malloc() {\n      abort(\n        \"malloc() called but not included in the build - add '_malloc' to EXPORTED_FUNCTIONS\",\n      );\n    }\n    function _free() {\n      // Show a helpful error since we used to include free by default in the past.\n      abort(\n        \"free() called but not included in the build - add '_free' to EXPORTED_FUNCTIONS\",\n      );\n    }\n\n    // Memory management\n\n    var HEAP,\n      /** @type {!Int8Array} */\n      HEAP8,\n      /** @type {!Uint8Array} */\n      HEAPU8,\n      /** @type {!Int16Array} */\n      HEAP16,\n      /** @type {!Uint16Array} */\n      HEAPU16,\n      /** @type {!Int32Array} */\n      HEAP32,\n      /** @type {!Uint32Array} */\n      HEAPU32,\n      /** @type {!Float32Array} */\n      HEAPF32,\n      /** @type {!Float64Array} */\n      HEAPF64;\n\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n    }\n\n    assert(\n      !Module[\"STACK_SIZE\"],\n      \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\",\n    );\n\n    assert(\n      typeof Int32Array != \"undefined\" &&\n        typeof Float64Array !== \"undefined\" &&\n        Int32Array.prototype.subarray != undefined &&\n        Int32Array.prototype.set != undefined,\n      \"JS engine does not provide full typed array support\",\n    );\n\n    // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n    assert(\n      !Module[\"wasmMemory\"],\n      \"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally\",\n    );\n    assert(\n      !Module[\"INITIAL_MEMORY\"],\n      \"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically\",\n    );\n\n    // include: runtime_init_table.js\n    // In regular non-RELOCATABLE mode the table is exported\n    // from the wasm module and this will be assigned once\n    // the exports are available.\n    var wasmTable;\n    // end include: runtime_init_table.js\n    // include: runtime_stack_check.js\n    // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n    function writeStackCookie() {\n      var max = _emscripten_stack_get_end();\n      assert((max & 3) == 0);\n      // If the stack ends at address zero we write our cookies 4 bytes into the\n      // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n      // monitor writes to address zero.\n      if (max == 0) {\n        max += 4;\n      }\n      // The stack grow downwards towards _emscripten_stack_get_end.\n      // We write cookies to the final two words in the stack and detect if they are\n      // ever overwritten.\n      HEAPU32[max >> 2] = 0x02135467;\n      HEAPU32[(max + 4) >> 2] = 0x89bacdfe;\n      // Also test the global address 0 for integrity.\n      HEAPU32[0 >> 2] = 1668509029;\n    }\n\n    function checkStackCookie() {\n      if (ABORT) return;\n      var max = _emscripten_stack_get_end();\n      // See writeStackCookie().\n      if (max == 0) {\n        max += 4;\n      }\n      var cookie1 = HEAPU32[max >> 2];\n      var cookie2 = HEAPU32[(max + 4) >> 2];\n      if (cookie1 != 0x02135467 || cookie2 != 0x89bacdfe) {\n        abort(\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(\n            max,\n          )}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(\n            cookie2,\n          )} ${ptrToString(cookie1)}`,\n        );\n      }\n      // Also test the global address 0 for integrity.\n      if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */) {\n        abort(\n          \"Runtime error: The application has corrupted its heap memory area (address zero)!\",\n        );\n      }\n    }\n    // end include: runtime_stack_check.js\n    // include: runtime_assertions.js\n    // Endianness check\n    (function () {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 0x6373;\n      if (h8[0] !== 0x73 || h8[1] !== 0x63)\n        throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\n    })();\n\n    // end include: runtime_assertions.js\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n    var __ATINIT__ = []; // functions called during startup\n    var __ATEXIT__ = []; // functions called during shutdown\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n\n    var runtimeKeepaliveCounter = 0;\n\n    function keepRuntimeAlive() {\n      return noExitRuntime || runtimeKeepaliveCounter > 0;\n    }\n\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\")\n          Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n\n      checkStackCookie();\n\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function postRun() {\n      checkStackCookie();\n\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\")\n          Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    // include: runtime_math.js\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n    assert(\n      Math.imul,\n      \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    assert(\n      Math.fround,\n      \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    assert(\n      Math.clz32,\n      \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    assert(\n      Math.trunc,\n      \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    // end include: runtime_math.js\n    // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (\n          runDependencyWatcher === null &&\n          typeof setInterval != \"undefined\"\n        ) {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(() => {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err(\"still waiting on run dependencies:\");\n              }\n              err(`dependency: ${dep}`);\n            }\n            if (shown) {\n              err(\"(end of list)\");\n            }\n          }, 10000);\n        }\n      } else {\n        err(\"warning: run dependency added without ID\");\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err(\"warning: run dependency removed without ID\");\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    /** @param {string|number=} what */\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n\n      what = \"Aborted(\" + what + \")\";\n      // TODO(sbc): Should we remove printing and leave it up to whoever\n      // catches the exception?\n      err(what);\n\n      ABORT = true;\n      EXITSTATUS = 1;\n\n      // Use a wasm runtime error, because a JS error might be seen as a foreign\n      // exception, which means we'd run destructors on it. We need the error to\n      // simply make the program stop.\n      // FIXME This approach does not work in Wasm EH because it currently does not assume\n      // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n      // a trap or not based on a hidden field within the object. So at the moment\n      // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n      // allows this in the wasm spec.\n\n      // Suppress closure compiler warning here. Closure compiler's builtin extern\n      // defintion for WebAssembly.RuntimeError claims it takes no arguments even\n      // though it can.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n      /** @suppress {checkTypes} */\n      var e = new WebAssembly.RuntimeError(what);\n\n      readyPromiseReject(e);\n      // Throw the error whether or not MODULARIZE is set because abort is used\n      // in code paths apart from instantiation where an exception is expected\n      // to be thrown when abort is called.\n      throw e;\n    }\n\n    // include: memoryprofiler.js\n    // end include: memoryprofiler.js\n    // show errors on likely calls to FS when it was not included\n    var FS = {\n      error() {\n        abort(\n          \"Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM\",\n        );\n      },\n      init() {\n        FS.error();\n      },\n      createDataFile() {\n        FS.error();\n      },\n      createPreloadedFile() {\n        FS.error();\n      },\n      createLazyFile() {\n        FS.error();\n      },\n      open() {\n        FS.error();\n      },\n      mkdev() {\n        FS.error();\n      },\n      registerDevice() {\n        FS.error();\n      },\n      analyzePath() {\n        FS.error();\n      },\n\n      ErrnoError() {\n        FS.error();\n      },\n    };\n    Module[\"FS_createDataFile\"] = FS.createDataFile;\n    Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n\n    // include: URIUtils.js\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n    // Indicates whether filename is a base64 data URI.\n    function isDataURI(filename) {\n      // Prefix of data URIs emitted by SINGLE_FILE and related options.\n      return filename.startsWith(dataURIPrefix);\n    }\n\n    // Indicates whether filename is delivered via file protocol (as opposed to http/https)\n    function isFileURI(filename) {\n      return filename.startsWith(\"file://\");\n    }\n    // end include: URIUtils.js\n    function createExportWrapper(name) {\n      return function () {\n        assert(\n          runtimeInitialized,\n          `native function \\`${name}\\` called before runtime initialization`,\n        );\n        var f = wasmExports[name];\n        assert(f, `exported native function \\`${name}\\` not found`);\n        return f.apply(null, arguments);\n      };\n    }\n\n    // include: runtime_exceptions.js\n    // end include: runtime_exceptions.js\n    var wasmBinaryFile;\n    wasmBinaryFile =\n      \"data:application/octet-stream;base64,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\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      var binary = tryParseAsDataURI(file);\n      if (binary) {\n        return binary;\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n\n    function getBinaryPromise(binaryFile) {\n      // Otherwise, getBinarySync should be able to get it synchronously\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then((binary) => {\n          return WebAssembly.instantiate(binary, imports);\n        })\n        .then((instance) => {\n          return instance;\n        })\n        .then(receiver, (reason) => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n\n          // Warn on some common problems.\n          if (isFileURI(wasmBinaryFile)) {\n            err(\n              `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`,\n            );\n          }\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n\n    // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n    function createWasm() {\n      // prepare imports\n      var info = {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports,\n      };\n      // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n      /** @param {WebAssembly.Module=} module*/\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n\n        wasmExports = exports;\n\n        wasmMemory = wasmExports[\"memory\"];\n\n        assert(wasmMemory, \"memory not found in wasm exports\");\n        // This assertion doesn't hold when emscripten is run in --post-link\n        // mode.\n        // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\n        //assert(wasmMemory.buffer.byteLength === 16777216);\n        updateMemoryViews();\n\n        wasmTable = wasmExports[\"__indirect_function_table\"];\n\n        assert(wasmTable, \"table not found in wasm exports\");\n\n        addOnInit(wasmExports[\"__wasm_call_ctors\"]);\n\n        removeRunDependency(\"wasm-instantiate\");\n        return exports;\n      }\n      // wait for the pthread pool (if any)\n      addRunDependency(\"wasm-instantiate\");\n\n      // Prefer streaming instantiation if available.\n      // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n      var trueModule = Module;\n      function receiveInstantiationResult(result) {\n        // 'result' is a ResultObject object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(\n          Module === trueModule,\n          \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\",\n        );\n        trueModule = null;\n        // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above PTHREADS-enabled path.\n        receiveInstance(result[\"instance\"]);\n      }\n\n      // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to\n      // run the instantiation parallel to any other async startup actions they are\n      // performing.\n      // Also pthreads and wasm workers initialize the wasm instance through this\n      // path.\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          return Module[\"instantiateWasm\"](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          // If instantiation fails, reject the module ready promise.\n          readyPromiseReject(e);\n        }\n      }\n\n      // If instantiation fails, reject the module ready promise.\n      instantiateAsync(\n        wasmBinary,\n        wasmBinaryFile,\n        info,\n        receiveInstantiationResult,\n      ).catch(readyPromiseReject);\n      return {}; // no exports yet; we'll fill them in later\n    }\n\n    // Globals used by JS i64 conversions (see makeSetValue)\n    var tempDouble;\n    var tempI64;\n\n    // include: runtime_debug.js\n    function legacyModuleProp(prop, newName, incomming = true) {\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n        Object.defineProperty(Module, prop, {\n          configurable: true,\n          get() {\n            let extra = incomming\n              ? \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\"\n              : \"\";\n            abort(\n              `\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra,\n            );\n          },\n        });\n      }\n    }\n\n    function ignoredModuleProp(prop) {\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\n        abort(\n          `\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`,\n        );\n      }\n    }\n\n    // forcing the filesystem exports a few things by default\n    function isExportedByForceFilesystem(name) {\n      return (\n        name === \"FS_createPath\" ||\n        name === \"FS_createDataFile\" ||\n        name === \"FS_createPreloadedFile\" ||\n        name === \"FS_unlink\" ||\n        name === \"addRunDependency\" ||\n        // The old FS has some functionality that WasmFS lacks.\n        name === \"FS_createLazyFile\" ||\n        name === \"FS_createDevice\" ||\n        name === \"removeRunDependency\"\n      );\n    }\n\n    function missingGlobal(sym, msg) {\n      if (typeof globalThis !== \"undefined\") {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            warnOnce(\n              \"`\" + sym + \"` is not longer defined by emscripten. \" + msg,\n            );\n            return undefined;\n          },\n        });\n      }\n    }\n\n    missingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\n    missingGlobal(\"asm\", \"Please use wasmExports instead\");\n\n    function missingLibrarySymbol(sym) {\n      if (\n        typeof globalThis !== \"undefined\" &&\n        !Object.getOwnPropertyDescriptor(globalThis, sym)\n      ) {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            // Can't `abort()` here because it would break code that does runtime\n            // checks.  e.g. `if (typeof SDL === 'undefined')`.\n            var msg =\n              \"`\" +\n              sym +\n              \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\";\n            // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n            // library.js, which means $name for a JS name with no prefix, or name\n            // for a JS name like _name.\n            var librarySymbol = sym;\n            if (!librarySymbol.startsWith(\"_\")) {\n              librarySymbol = \"$\" + sym;\n            }\n            msg +=\n              \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\" +\n              librarySymbol +\n              \"')\";\n            if (isExportedByForceFilesystem(sym)) {\n              msg +=\n                \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n            }\n            warnOnce(msg);\n            return undefined;\n          },\n        });\n      }\n      // Any symbol that is not included from the JS libary is also (by definition)\n      // not exported on the Module object.\n      unexportedRuntimeSymbol(sym);\n    }\n\n    function unexportedRuntimeSymbol(sym) {\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n        Object.defineProperty(Module, sym, {\n          configurable: true,\n          get() {\n            var msg =\n              \"'\" +\n              sym +\n              \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\";\n            if (isExportedByForceFilesystem(sym)) {\n              msg +=\n                \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n            }\n            abort(msg);\n          },\n        });\n      }\n    }\n\n    // Used by XXXXX_DEBUG settings to output debug messages.\n    function dbg(text) {\n      // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n      // logging to show up as warnings.\n      console.warn.apply(console, arguments);\n    }\n    // end include: runtime_debug.js\n    // === Body ===\n\n    // end include: preamble.js\n\n    /** @constructor */\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n\n    var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n    function getValue(ptr, type = \"i8\") {\n      if (type.endsWith(\"*\")) type = \"*\";\n      switch (type) {\n        case \"i1\":\n          return HEAP8[ptr >> 0];\n        case \"i8\":\n          return HEAP8[ptr >> 0];\n        case \"i16\":\n          return HEAP16[ptr >> 1];\n        case \"i32\":\n          return HEAP32[ptr >> 2];\n        case \"i64\":\n          abort(\"to do getValue(i64) use WASM_BIGINT\");\n        case \"float\":\n          return HEAPF32[ptr >> 2];\n        case \"double\":\n          return HEAPF64[ptr >> 3];\n        case \"*\":\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n\n    var ptrToString = (ptr) => {\n      assert(typeof ptr === \"number\");\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      ptr >>>= 0;\n      return \"0x\" + ptr.toString(16).padStart(8, \"0\");\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n    function setValue(ptr, value, type = \"i8\") {\n      if (type.endsWith(\"*\")) type = \"*\";\n      switch (type) {\n        case \"i1\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i8\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i16\":\n          HEAP16[ptr >> 1] = value;\n          break;\n        case \"i32\":\n          HEAP32[ptr >> 2] = value;\n          break;\n        case \"i64\":\n          abort(\"to do setValue(i64) use WASM_BIGINT\");\n        case \"float\":\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case \"double\":\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case \"*\":\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n\n    var warnOnce = (text) => {\n      if (!warnOnce.shown) warnOnce.shown = {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n\n    var getCFunc = (ident) => {\n      var func = Module[\"_\" + ident]; // closure exported function\n      assert(\n        func,\n        \"Cannot call unknown function \" + ident + \", make sure it is exported\",\n      );\n      return func;\n    };\n\n    var writeArrayToMemory = (array, buffer) => {\n      assert(\n        array.length >= 0,\n        \"writeArrayToMemory array must have a length (should be an array or typed array)\",\n      );\n      HEAP8.set(array, buffer);\n    };\n\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7f) {\n          len++;\n        } else if (c <= 0x7ff) {\n          len += 2;\n        } else if (c >= 0xd800 && c <= 0xdfff) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === \"string\");\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0)) return 0;\n\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xd800 && u <= 0xdfff) {\n          var u1 = str.charCodeAt(++i);\n          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);\n        }\n        if (u <= 0x7f) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7ff) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xc0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xffff) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xe0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10ffff)\n            warnOnce(\n              \"Invalid Unicode code point \" +\n                ptrToString(u) +\n                \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\",\n            );\n          heap[outIdx++] = 0xf0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(\n        typeof maxBytesToWrite == \"number\",\n        \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\n      );\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n\n    var UTF8Decoder =\n      typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = \"\";\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xe0) == 0xc0) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xf0) == 0xe0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xf8) != 0xf0)\n            warnOnce(\n              \"Invalid UTF-8 leading byte \" +\n                ptrToString(u0) +\n                \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\",\n            );\n          u0 =\n            ((u0 & 7) << 18) |\n            (u1 << 12) |\n            (u2 << 6) |\n            (heapOrArray[idx++] & 63);\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(\n            0xd800 | (ch >> 10),\n            0xdc00 | (ch & 0x3ff),\n          );\n        }\n      }\n      return str;\n    };\n\n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == \"number\");\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    };\n\n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n    var ccall = (ident, returnType, argTypes, args, opts) => {\n      // For fast lookup of conversion functions\n      var toC = {\n        string: (str) => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        array: (arr) => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        },\n      };\n\n      function convertReturnValue(ret) {\n        if (returnType === \"string\") {\n          return UTF8ToString(ret);\n        }\n        if (returnType === \"boolean\") return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== \"array\", 'Return type should not be \"array\".');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n\n      ret = onDone(ret);\n      return ret;\n    };\n\n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n    var cwrap = (ident, returnType, argTypes, opts) => {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    };\n    function checkIncomingModuleAPI() {\n      ignoredModuleProp(\"fetchSettings\");\n    }\n    var wasmImports = {};\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\");\n    var ___errno_location = createExportWrapper(\"__errno_location\");\n    var _acos = (Module[\"_acos\"] = createExportWrapper(\"acos\"));\n    var _asin = (Module[\"_asin\"] = createExportWrapper(\"asin\"));\n    var _atan = (Module[\"_atan\"] = createExportWrapper(\"atan\"));\n    var _ceil = (Module[\"_ceil\"] = createExportWrapper(\"ceil\"));\n    var _cos = (Module[\"_cos\"] = createExportWrapper(\"cos\"));\n    var _cosh = (Module[\"_cosh\"] = createExportWrapper(\"cosh\"));\n    var _exp = (Module[\"_exp\"] = createExportWrapper(\"exp\"));\n    var _fflush = (Module[\"_fflush\"] = createExportWrapper(\"fflush\"));\n    var _floor = (Module[\"_floor\"] = createExportWrapper(\"floor\"));\n    var _log = (Module[\"_log\"] = createExportWrapper(\"log\"));\n    var _log10 = (Module[\"_log10\"] = createExportWrapper(\"log10\"));\n    var _pow = (Module[\"_pow\"] = createExportWrapper(\"pow\"));\n    var _sin = (Module[\"_sin\"] = createExportWrapper(\"sin\"));\n    var _sinh = (Module[\"_sinh\"] = createExportWrapper(\"sinh\"));\n    var _sqrt = (Module[\"_sqrt\"] = createExportWrapper(\"sqrt\"));\n    var _tan = (Module[\"_tan\"] = createExportWrapper(\"tan\"));\n    var _tanh = (Module[\"_tanh\"] = createExportWrapper(\"tanh\"));\n    var _emscripten_stack_init = () =>\n      (_emscripten_stack_init = wasmExports[\"emscripten_stack_init\"])();\n    var _emscripten_stack_get_free = () =>\n      (_emscripten_stack_get_free = wasmExports[\"emscripten_stack_get_free\"])();\n    var _emscripten_stack_get_base = () =>\n      (_emscripten_stack_get_base = wasmExports[\"emscripten_stack_get_base\"])();\n    var _emscripten_stack_get_end = () =>\n      (_emscripten_stack_get_end = wasmExports[\"emscripten_stack_get_end\"])();\n    var stackSave = createExportWrapper(\"stackSave\");\n    var stackRestore = createExportWrapper(\"stackRestore\");\n    var stackAlloc = createExportWrapper(\"stackAlloc\");\n    var _emscripten_stack_get_current = () =>\n      (_emscripten_stack_get_current =\n        wasmExports[\"emscripten_stack_get_current\"])();\n\n    // include: postamble.js\n    // === Auto-generated postamble setup entry stuff ===\n\n    // include: base64Utils.js\n    // Converts a string of base64 into a byte array.\n    // Throws error on invalid input.\n    function intArrayFromBase64(s) {\n      try {\n        var decoded = atob(s);\n        var bytes = new Uint8Array(decoded.length);\n        for (var i = 0; i < decoded.length; ++i) {\n          bytes[i] = decoded.charCodeAt(i);\n        }\n        return bytes;\n      } catch (_) {\n        throw new Error(\"Converting base64 string to bytes failed.\");\n      }\n    }\n\n    // If filename is a base64 data URI, parses and returns data (Buffer on node,\n    // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\n    function tryParseAsDataURI(filename) {\n      if (!isDataURI(filename)) {\n        return;\n      }\n\n      return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n    }\n    // end include: base64Utils.js\n    Module[\"ccall\"] = ccall;\n    Module[\"cwrap\"] = cwrap;\n    var missingLibrarySymbols = [\n      \"writeI53ToI64\",\n      \"writeI53ToI64Clamped\",\n      \"writeI53ToI64Signaling\",\n      \"writeI53ToU64Clamped\",\n      \"writeI53ToU64Signaling\",\n      \"readI53FromI64\",\n      \"readI53FromU64\",\n      \"convertI32PairToI53\",\n      \"convertI32PairToI53Checked\",\n      \"convertU32PairToI53\",\n      \"zeroMemory\",\n      \"exitJS\",\n      \"getHeapMax\",\n      \"abortOnCannotGrowMemory\",\n      \"growMemory\",\n      \"isLeapYear\",\n      \"ydayFromDate\",\n      \"arraySum\",\n      \"addDays\",\n      \"setErrNo\",\n      \"inetPton4\",\n      \"inetNtop4\",\n      \"inetPton6\",\n      \"inetNtop6\",\n      \"readSockaddr\",\n      \"writeSockaddr\",\n      \"getHostByName\",\n      \"initRandomFill\",\n      \"randomFill\",\n      \"getCallstack\",\n      \"emscriptenLog\",\n      \"convertPCtoSourceLocation\",\n      \"readEmAsmArgs\",\n      \"jstoi_q\",\n      \"jstoi_s\",\n      \"getExecutableName\",\n      \"listenOnce\",\n      \"autoResumeAudioContext\",\n      \"dynCallLegacy\",\n      \"getDynCaller\",\n      \"dynCall\",\n      \"handleException\",\n      \"runtimeKeepalivePush\",\n      \"runtimeKeepalivePop\",\n      \"callUserCallback\",\n      \"maybeExit\",\n      \"safeSetTimeout\",\n      \"asmjsMangle\",\n      \"asyncLoad\",\n      \"alignMemory\",\n      \"mmapAlloc\",\n      \"handleAllocatorInit\",\n      \"HandleAllocator\",\n      \"getNativeTypeSize\",\n      \"STACK_SIZE\",\n      \"STACK_ALIGN\",\n      \"POINTER_SIZE\",\n      \"ASSERTIONS\",\n      \"uleb128Encode\",\n      \"sigToWasmTypes\",\n      \"generateFuncType\",\n      \"convertJsFunctionToWasm\",\n      \"getEmptyTableSlot\",\n      \"updateTableMap\",\n      \"getFunctionAddress\",\n      \"addFunction\",\n      \"removeFunction\",\n      \"reallyNegative\",\n      \"unSign\",\n      \"strLen\",\n      \"reSign\",\n      \"formatString\",\n      \"intArrayFromString\",\n      \"intArrayToString\",\n      \"AsciiToString\",\n      \"stringToAscii\",\n      \"UTF16ToString\",\n      \"stringToUTF16\",\n      \"lengthBytesUTF16\",\n      \"UTF32ToString\",\n      \"stringToUTF32\",\n      \"lengthBytesUTF32\",\n      \"stringToNewUTF8\",\n      \"registerKeyEventCallback\",\n      \"maybeCStringToJsString\",\n      \"findEventTarget\",\n      \"findCanvasEventTarget\",\n      \"getBoundingClientRect\",\n      \"fillMouseEventData\",\n      \"registerMouseEventCallback\",\n      \"registerWheelEventCallback\",\n      \"registerUiEventCallback\",\n      \"registerFocusEventCallback\",\n      \"fillDeviceOrientationEventData\",\n      \"registerDeviceOrientationEventCallback\",\n      \"fillDeviceMotionEventData\",\n      \"registerDeviceMotionEventCallback\",\n      \"screenOrientation\",\n      \"fillOrientationChangeEventData\",\n      \"registerOrientationChangeEventCallback\",\n      \"fillFullscreenChangeEventData\",\n      \"registerFullscreenChangeEventCallback\",\n      \"JSEvents_requestFullscreen\",\n      \"JSEvents_resizeCanvasForFullscreen\",\n      \"registerRestoreOldStyle\",\n      \"hideEverythingExceptGivenElement\",\n      \"restoreHiddenElements\",\n      \"setLetterbox\",\n      \"softFullscreenResizeWebGLRenderTarget\",\n      \"doRequestFullscreen\",\n      \"fillPointerlockChangeEventData\",\n      \"registerPointerlockChangeEventCallback\",\n      \"registerPointerlockErrorEventCallback\",\n      \"requestPointerLock\",\n      \"fillVisibilityChangeEventData\",\n      \"registerVisibilityChangeEventCallback\",\n      \"registerTouchEventCallback\",\n      \"fillGamepadEventData\",\n      \"registerGamepadEventCallback\",\n      \"registerBeforeUnloadEventCallback\",\n      \"fillBatteryEventData\",\n      \"battery\",\n      \"registerBatteryEventCallback\",\n      \"setCanvasElementSize\",\n      \"getCanvasElementSize\",\n      \"demangle\",\n      \"demangleAll\",\n      \"jsStackTrace\",\n      \"stackTrace\",\n      \"getEnvStrings\",\n      \"checkWasiClock\",\n      \"flush_NO_FILESYSTEM\",\n      \"wasiRightsToMuslOFlags\",\n      \"wasiOFlagsToMuslOFlags\",\n      \"createDyncallWrapper\",\n      \"setImmediateWrapped\",\n      \"clearImmediateWrapped\",\n      \"polyfillSetImmediate\",\n      \"getPromise\",\n      \"makePromise\",\n      \"idsToPromises\",\n      \"makePromiseCallback\",\n      \"ExceptionInfo\",\n      \"findMatchingCatch\",\n      \"setMainLoop\",\n      \"getSocketFromFD\",\n      \"getSocketAddress\",\n      \"FS_createPreloadedFile\",\n      \"FS_modeStringToFlags\",\n      \"FS_getMode\",\n      \"FS_stdin_getChar\",\n      \"_setNetworkCallback\",\n      \"heapObjectForWebGLType\",\n      \"heapAccessShiftForWebGLHeap\",\n      \"webgl_enable_ANGLE_instanced_arrays\",\n      \"webgl_enable_OES_vertex_array_object\",\n      \"webgl_enable_WEBGL_draw_buffers\",\n      \"webgl_enable_WEBGL_multi_draw\",\n      \"emscriptenWebGLGet\",\n      \"computeUnpackAlignedImageSize\",\n      \"colorChannelsInGlTextureFormat\",\n      \"emscriptenWebGLGetTexPixelData\",\n      \"__glGenObject\",\n      \"emscriptenWebGLGetUniform\",\n      \"webglGetUniformLocation\",\n      \"webglPrepareUniformLocationsBeforeFirstUse\",\n      \"webglGetLeftBracePos\",\n      \"emscriptenWebGLGetVertexAttrib\",\n      \"__glGetActiveAttribOrUniform\",\n      \"writeGLArray\",\n      \"registerWebGlEventCallback\",\n      \"runAndAbortIfError\",\n      \"SDL_unicode\",\n      \"SDL_ttfContext\",\n      \"SDL_audio\",\n      \"GLFW_Window\",\n      \"ALLOC_NORMAL\",\n      \"ALLOC_STACK\",\n      \"allocate\",\n      \"writeStringToMemory\",\n      \"writeAsciiToMemory\",\n    ];\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\n\n    var unexportedSymbols = [\n      \"run\",\n      \"addOnPreRun\",\n      \"addOnInit\",\n      \"addOnPreMain\",\n      \"addOnExit\",\n      \"addOnPostRun\",\n      \"addRunDependency\",\n      \"removeRunDependency\",\n      \"FS_createFolder\",\n      \"FS_createPath\",\n      \"FS_createDataFile\",\n      \"FS_createLazyFile\",\n      \"FS_createLink\",\n      \"FS_createDevice\",\n      \"FS_readFile\",\n      \"FS_unlink\",\n      \"out\",\n      \"err\",\n      \"callMain\",\n      \"abort\",\n      \"keepRuntimeAlive\",\n      \"wasmMemory\",\n      \"wasmTable\",\n      \"wasmExports\",\n      \"stackAlloc\",\n      \"stackSave\",\n      \"stackRestore\",\n      \"getTempRet0\",\n      \"setTempRet0\",\n      \"writeStackCookie\",\n      \"checkStackCookie\",\n      \"intArrayFromBase64\",\n      \"tryParseAsDataURI\",\n      \"ptrToString\",\n      \"ENV\",\n      \"MONTH_DAYS_REGULAR\",\n      \"MONTH_DAYS_LEAP\",\n      \"MONTH_DAYS_REGULAR_CUMULATIVE\",\n      \"MONTH_DAYS_LEAP_CUMULATIVE\",\n      \"ERRNO_CODES\",\n      \"ERRNO_MESSAGES\",\n      \"DNS\",\n      \"Protocols\",\n      \"Sockets\",\n      \"timers\",\n      \"warnOnce\",\n      \"UNWIND_CACHE\",\n      \"readEmAsmArgsArray\",\n      \"getCFunc\",\n      \"freeTableIndexes\",\n      \"functionsInTableMap\",\n      \"setValue\",\n      \"getValue\",\n      \"PATH\",\n      \"PATH_FS\",\n      \"UTF8Decoder\",\n      \"UTF8ArrayToString\",\n      \"UTF8ToString\",\n      \"stringToUTF8Array\",\n      \"stringToUTF8\",\n      \"lengthBytesUTF8\",\n      \"UTF16Decoder\",\n      \"stringToUTF8OnStack\",\n      \"writeArrayToMemory\",\n      \"JSEvents\",\n      \"specialHTMLTargets\",\n      \"currentFullscreenStrategy\",\n      \"restoreOldWindowedStyle\",\n      \"ExitStatus\",\n      \"promiseMap\",\n      \"uncaughtExceptionCount\",\n      \"exceptionLast\",\n      \"exceptionCaught\",\n      \"Browser\",\n      \"wget\",\n      \"SYSCALLS\",\n      \"preloadPlugins\",\n      \"FS_stdin_getChar_buffer\",\n      \"FS\",\n      \"MEMFS\",\n      \"TTY\",\n      \"PIPEFS\",\n      \"SOCKFS\",\n      \"tempFixedLengthArray\",\n      \"miniTempWebGLFloatBuffers\",\n      \"miniTempWebGLIntBuffers\",\n      \"GL\",\n      \"emscripten_webgl_power_preferences\",\n      \"AL\",\n      \"GLUT\",\n      \"EGL\",\n      \"GLEW\",\n      \"IDBStore\",\n      \"SDL\",\n      \"SDL_gfx\",\n      \"GLFW\",\n      \"allocateUTF8\",\n      \"allocateUTF8OnStack\",\n    ];\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n    var calledRun;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n\n    function stackCheckInit() {\n      // This is normally called automatically during __wasm_call_ctors but need to\n      // get these values before even running any of the ctors so we call it redundantly\n      // here.\n      _emscripten_stack_init();\n      // TODO(sbc): Move writeStackCookie to native to to avoid this.\n      writeStackCookie();\n    }\n\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n\n      stackCheckInit();\n\n      preRun();\n\n      // a preRun added a dependency, run will be called later\n      if (runDependencies > 0) {\n        return;\n      }\n\n      function doRun() {\n        // run may have just been called through dependencies being fulfilled just in this very frame,\n        // or while the async setStatus time below was happening\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n\n        if (ABORT) return;\n\n        initRuntime();\n\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n\n        assert(\n          !Module[\"_main\"],\n          'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]',\n        );\n\n        postRun();\n      }\n\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var oldOut = out;\n      var oldErr = err;\n      var has = false;\n      out = err = (x) => {\n        has = true;\n      };\n      try {\n        // it doesn't matter if it fails\n        _fflush(0);\n      } catch (e) {}\n      out = oldOut;\n      err = oldErr;\n      if (has) {\n        warnOnce(\n          \"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\",\n        );\n        warnOnce(\n          \"(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)\",\n        );\n      }\n    }\n\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\")\n        Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n\n    run();\n\n    // end include: postamble.js\n\n    return moduleArg.ready;\n  };\n})();\nif (typeof exports === \"object\" && typeof module === \"object\")\n  module.exports = Module;\nelse if (typeof define === \"function\" && define[\"amd\"])\n  define([], () => Module);\n","import { ModulesGlobalConfig, SharedWasmGlobalVariables } from \"~src/modules\";\nimport { voidDataType } from \"~src/modules/constants\";\nimport {\n  freeFunction,\n  mallocFunction,\n} from \"~src/modules/source_stdlib/memory\";\nimport wrapFunctionPtrCall from \"~src/modules/stackFrameUtils\";\nimport { Module, ModuleFunction, StackFrameArg } from \"~src/modules/types\";\nimport {\n  extractCStyleStringFromMemory,\n  getExternalFunction,\n} from \"~src/modules/util\";\nimport { StructDataType } from \"~src/parser/c-ast/dataTypes\";\n\n// the name that this module is imported into wasm by,\n// as well as the include name to use in C program file.\nexport const pixAndFlixLibraryModuleImportName = \"pix_n_flix\";\n\nexport class PixAndFlixLibrary extends Module {\n  moduleDeclaredStructs: StructDataType[];\n  moduleFunctions: Record<string, ModuleFunction>;\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables;\n\n  constructor(\n    memory: WebAssembly.Memory,\n    functionTable: WebAssembly.Table,\n    config: ModulesGlobalConfig,\n    sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  ) {\n    super(memory, functionTable, config, sharedWasmGlobalVariables);\n    this.sharedWasmGlobalVariables = sharedWasmGlobalVariables;\n    this.moduleDeclaredStructs = [];\n    this.moduleFunctions = {\n      use_image_url: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n              },\n            },\n          ],\n          returnType: voidDataType,\n        },\n        jsFunction: (strAddress: number) => {\n          const url = extractCStyleStringFromMemory(memory.buffer, strAddress);\n          getExternalFunction(\"use_image_url\", config)(url);\n        },\n      },\n      use_video_url: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n              },\n            },\n          ],\n          returnType: voidDataType,\n        },\n        jsFunction: (strAddress: number) => {\n          const url = extractCStyleStringFromMemory(memory.buffer, strAddress);\n          getExternalFunction(\"use_video_url\", config)(url);\n        },\n      },\n      // prints an unsigned int (4 bytes and smaller)\n      start: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: voidDataType,\n        },\n        jsFunction: () => {\n          getExternalFunction(\"start\", config)();\n        },\n      },\n      image_height: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: {\n            type: \"primary\",\n            primaryDataType: \"signed int\",\n          },\n        },\n        jsFunction: () => getExternalFunction(\"image_height\", config)(),\n      },\n      image_width: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: {\n            type: \"primary\",\n            primaryDataType: \"signed int\",\n          },\n        },\n        jsFunction: () => getExternalFunction(\"image_width\", config)(),\n      },\n      set_dimensions: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\", // height of image\n              primaryDataType: \"signed int\",\n            },\n            {\n              type: \"primary\", // width of image\n              primaryDataType: \"signed int\",\n            },\n          ],\n          returnType: voidDataType,\n        },\n        jsFunction: (width: number, height: number) => {\n          getExternalFunction(\"set_dimensions\", config)(width, height);\n        },\n      },\n      install_filter: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"function\",\n                parameters: [\n                  {\n                    type: \"pointer\",\n                    pointeeType: {\n                      type: \"array\",\n                      elementDataType: {\n                        type: \"array\",\n                        elementDataType: {\n                          type: \"primary\",\n                          primaryDataType: \"signed char\",\n                        },\n                        numElements: {\n                          type: \"IntegerConstant\",\n                          value: 4n,\n                          suffix: null,\n                          position: {\n                            start: { line: 0, offset: 0, column: 0 },\n                            end: { line: 0, offset: 0, column: 0 },\n                          },\n                        },\n                      },\n                      numElements: {\n                        type: \"IntegerConstant\",\n                        value: 400n,\n                        suffix: null,\n                        position: {\n                          start: { line: 0, offset: 0, column: 0 },\n                          end: { line: 0, offset: 0, column: 0 },\n                        },\n                      },\n                    },\n                  },\n                  {\n                    type: \"pointer\",\n                    pointeeType: {\n                      type: \"array\",\n                      elementDataType: {\n                        type: \"array\",\n                        elementDataType: {\n                          type: \"primary\",\n                          primaryDataType: \"signed char\",\n                        },\n                        numElements: {\n                          type: \"IntegerConstant\",\n                          value: 4n,\n                          suffix: null,\n                          position: {\n                            start: { line: 0, offset: 0, column: 0 },\n                            end: { line: 0, offset: 0, column: 0 },\n                          },\n                        },\n                      },\n                      numElements: {\n                        type: \"IntegerConstant\",\n                        value: 400n,\n                        suffix: null,\n                        position: {\n                          start: { line: 0, offset: 0, column: 0 },\n                          end: { line: 0, offset: 0, column: 0 },\n                        },\n                      },\n                    },\n                  },\n                  {\n                    type: \"primary\", // height of image\n                    primaryDataType: \"signed int\",\n                  },\n                  {\n                    type: \"primary\", // width of image\n                    primaryDataType: \"signed int\",\n                  },\n                ],\n                returnType: voidDataType,\n              },\n            },\n          ],\n          returnType: voidDataType,\n        },\n        jsFunction: (funcPtr: number) => {\n          const filter = (src: number[][][], dest: number[][][]) => {\n            const memSize = src.length * src[0].length * src[0][0].length;\n\n            // allocate buffers on the heap\n            const srcAddress = mallocFunction({\n              memory,\n              sharedWasmGlobalVariables,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n              bytesRequested: memSize,\n            });\n            const destAddress = mallocFunction({\n              memory,\n              sharedWasmGlobalVariables,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n              bytesRequested: memSize,\n            });\n\n            // copy the values in\n            let currAddress = 0;\n            const srcArr = new Uint8Array(memory.buffer, srcAddress, memSize);\n            for (let i = 0; i < src.length; ++i) {\n              for (let j = 0; j < src[0].length; ++j) {\n                for (let k = 0; k < src[0][0].length; ++k) {\n                  srcArr[currAddress++] = src[i][j][k];\n                }\n              }\n            }\n\n            const stackFrameArgs: StackFrameArg[] = [\n              {\n                value: BigInt(srcAddress),\n                type: \"unsigned int\",\n              },\n              {\n                value: BigInt(destAddress),\n                type: \"unsigned int\",\n              },\n              {\n                value: BigInt(src.length),\n                type: \"unsigned int\",\n              },\n              {\n                value: BigInt(src[0].length),\n                type: \"unsigned int\",\n              },\n            ];\n\n            // call the function pointer\n            wrapFunctionPtrCall(\n              memory,\n              functionTable,\n              funcPtr,\n              sharedWasmGlobalVariables,\n              stackFrameArgs,\n              [],\n            );\n\n            // copy the values out\n            const destArr = new Uint8Array(memory.buffer, destAddress, memSize);\n            currAddress = 0;\n            for (let i = 0; i < dest.length; ++i) {\n              for (let j = 0; j < dest[0].length; ++j) {\n                for (let k = 0; k < dest[0][0].length; ++k) {\n                  dest[i][j][k] = destArr[currAddress++];\n                }\n              }\n            }\n\n            // free both buffers\n            freeFunction({\n              address: srcAddress,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n            });\n            freeFunction({\n              address: destAddress,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n            });\n          };\n          getExternalFunction(\"install_filter\", config)(filter);\n        },\n      },\n      reset_filter: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: voidDataType,\n        },\n        jsFunction: () => {\n          getExternalFunction(\"reset_filter\", config)();\n        },\n      },\n      set_fps: {\n        parentImportedObject: pixAndFlixLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"signed int\",\n            },\n          ],\n          returnType: voidDataType,\n        },\n        jsFunction: () => {\n          getExternalFunction(\"set_fps\", config)();\n        },\n      },\n    };\n  }\n}\n","import { VoidDataType } from \"~src/parser/c-ast/dataTypes\";\n\nexport const voidDataType: VoidDataType = {\n  type: \"void\",\n};\n","/**\n * The js functions used for memory related imported functions - malloc, free etc.\n */\n\nimport { SharedWasmGlobalVariables } from \"~src/modules\";\nimport { checkAndExpandMemoryIfNeeded } from \"~src/modules/util\";\n\n// represents a memory block that is allocated/deallocated\nexport interface MemoryBlock {\n  address: number; // base address of the memory block in WebAssembly memory\n  size: number; // size of the memory block in bytes\n}\n\ninterface MallocFunctionParams {\n  memory: WebAssembly.Memory;\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables;\n  freeList: MemoryBlock[];\n  allocatedBlocks: Map<number, number>; // map of address of allocated memory block to size\n  bytesRequested: number;\n}\n\nexport function mallocFunction({\n  memory,\n  sharedWasmGlobalVariables,\n  bytesRequested,\n  allocatedBlocks,\n  freeList,\n}: MallocFunctionParams): number {\n  // see if freeList has any deallocated memory blocks\n  // simple first fit algorithm\n  let i = 0;\n  let foundBlock = false;\n  for (; i < freeList.length; ++i) {\n    const block = freeList[i];\n    if (block.size >= bytesRequested) {\n      foundBlock = true;\n      break;\n    }\n  }\n\n  // a block was found in the free list\n  if (foundBlock) {\n    const block = freeList[i];\n    freeList.splice(i, 1);\n    if (block.size > bytesRequested) {\n      const splitBlock = {\n        address: block.address + bytesRequested,\n        size: block.size - bytesRequested,\n      };\n      freeList.push(splitBlock);\n    }\n    allocatedBlocks.set(block.address, bytesRequested);\n    return block.address;\n  }\n\n  // no suitable block on the free list, need to expand heap\n  checkAndExpandMemoryIfNeeded(\n    memory,\n    bytesRequested,\n    sharedWasmGlobalVariables,\n  );\n\n  // enlarge heap segment\n  const address = sharedWasmGlobalVariables.heapPointer.value;\n  sharedWasmGlobalVariables.heapPointer.value += bytesRequested;\n\n  allocatedBlocks.set(address, bytesRequested);\n  return address;\n}\n\ninterface FreeFunctionParameters {\n  address: number;\n  allocatedBlocks: Map<number, number>; // map of address of allocated memory block to size\n  freeList: MemoryBlock[];\n}\n\nexport function freeFunction({\n  address,\n  freeList,\n  allocatedBlocks,\n}: FreeFunctionParameters) {\n  // shrink heap segment\n  const sizeOfBlock = allocatedBlocks.get(address);\n  if (typeof sizeOfBlock === \"undefined\") {\n    throw new Error(\"free(): No allocated block with given address\");\n  }\n\n  // add the freed memory block to freeList\n  freeList.push({ address: address, size: sizeOfBlock });\n  allocatedBlocks.delete(address);\n}\n\n/**\n * Helper debug function for printing contents of the heap as an array of bytes.\n */\nexport function printHeap(\n  memory: WebAssembly.Memory,\n  heapAddress: number,\n  heapPointer: number,\n) {\n  const memoryView = new Uint8Array(\n    memory.buffer,\n    heapAddress,\n    heapPointer - heapAddress,\n  );\n  console.log(memoryView);\n}\n\nexport function printStack(memory: WebAssembly.Memory, stackPointer: number) {\n  const memoryView = new Uint8Array(\n    memory.buffer,\n    stackPointer,\n    memory.buffer.byteLength - stackPointer,\n  );\n  console.log(memoryView);\n}\n","import BigNumber from \"bignumber.js\";\nimport { calculateNumberOfPagesNeededForBytes } from \"~src/common/utils\";\nimport { ModulesGlobalConfig, SharedWasmGlobalVariables } from \"~src/modules\";\n\n// export function extractImportedFunctionCDetails(\n//   wasmModuleImports: Record<string, ImportedFunction>\n// ) {\n//   const importedFunctionCDetails: Record<string, FunctionDataType> = {};\n//   Object.keys(wasmModuleImports).forEach((importedFuncName) => {\n//     importedFunctionCDetails[importedFuncName] =\n//       wasmModuleImports[importedFuncName].functionType;\n//   });\n//   return importedFunctionCDetails;\n// }\n\n/**\n * Function for converting a float to the c style (\"%f\" format specifier) - 6 decimal places.\n */\nexport function convertFloatToCStyleString(float: number): string {\n  if (float === Infinity) {\n    return \"inf\";\n  } else if (float === -Infinity) {\n    return \"-inf\";\n  }\n\n  let floatStr = float.toString(16);\n  if (floatStr[0] === \"-\") {\n    floatStr = \"-0x\" + floatStr.slice(1, floatStr.length);\n  } else {\n    floatStr = \"0x\" + floatStr;\n  }\n  const bigNumber = new BigNumber(floatStr);\n  return bigNumber.toFixed(6);\n}\n\n/**\n * Extracts a C-style string from memory buffer, starting at given address.\n */\nexport function extractCStyleStringFromMemory(\n  buffer: ArrayBuffer,\n  strAddress: number,\n) {\n  const uInt8Arr = new Uint8Array(buffer);\n  let str = \"\";\n  let i = strAddress;\n  while (uInt8Arr[i] !== 0) {\n    // keep recording chars until null terminator\n    str += String.fromCharCode(uInt8Arr[i++]);\n  }\n  return str;\n}\n\nexport function getExternalFunction(\n  funcName: string,\n  config: ModulesGlobalConfig,\n): Function {\n  if (!config.externalFunctions || !(funcName in config.externalFunctions)) {\n    throw Error(\n      `External function ${funcName} not provided in compiler configs`,\n    );\n  }\n  return config.externalFunctions[funcName];\n}\n\nexport function checkAndExpandMemoryIfNeeded(\n  memory: WebAssembly.Memory,\n  bytesRequested: number,\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n) {\n  const stackPointer = sharedWasmGlobalVariables.stackPointer;\n  const heapPointer = sharedWasmGlobalVariables.heapPointer;\n  const basePointer = sharedWasmGlobalVariables.basePointer;\n  const freeSpace = stackPointer.value - heapPointer.value;\n  if (freeSpace < bytesRequested) {\n    // need to grow memory\n    const additionalPagesNeeded = calculateNumberOfPagesNeededForBytes(\n      bytesRequested - freeSpace,\n    );\n    const stackSegmentSize = memory.buffer.byteLength - stackPointer.value;\n    const oldMemorySize = memory.buffer.byteLength;\n    memory.grow(additionalPagesNeeded);\n    // need to copy stack segment starting from the end of the new memory buffer\n    const memoryView = new Uint8Array(memory.buffer);\n    for (let i = 0; i < stackSegmentSize; i++) {\n      memoryView[memoryView.length - i - 1] = memoryView[oldMemorySize - i - 1];\n    }\n    // set base pointer\n    const bpOffsetFromSp = basePointer.value - stackPointer.value;\n    // set stack pointer\n    stackPointer.value = memoryView.length - stackSegmentSize;\n    // set base pointer\n    basePointer.value = stackPointer.value + bpOffsetFromSp;\n  }\n}\n\nexport function printSharedGlobalVariables(\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n) {\n  for (const [name, value] of Object.entries(sharedWasmGlobalVariables)) {\n    console.log(`${name}: ${value.value}`);\n  }\n}\n","/**\n * Contains a set of common utility functions used across modules.\n */\n\nimport { CNodeBase } from \"~src/parser/c-ast/core\";\nimport { PrimaryCDataType, ScalarCDataType } from \"~src/common/types\";\nimport { MemoryVariableByteSize } from \"~src/translator/wasm-ast/memory\";\nimport { POINTER_SIZE } from \"~src/common/constants\";\nimport { WASM_PAGE_SIZE } from \"~src/translator/memoryUtil\";\n\n/**\n * Definitions of the sizes in bytes of the supported C variables types.\n */\nexport const primaryDataTypeSizes: Record<\n  PrimaryCDataType,\n  MemoryVariableByteSize\n> = {\n  [\"unsigned char\"]: 1,\n  [\"signed char\"]: 1,\n  [\"unsigned short\"]: 2,\n  [\"signed short\"]: 2,\n  [\"unsigned int\"]: 4,\n  [\"signed int\"]: 4,\n  [\"unsigned long\"]: 8,\n  [\"signed long\"]: 8,\n  [\"float\"]: 4,\n  [\"double\"]: 8,\n};\n\nexport function getSizeOfScalarDataType(dataType: ScalarCDataType) {\n  if (dataType === \"pointer\") {\n    return POINTER_SIZE;\n  }\n  return primaryDataTypeSizes[dataType];\n}\n\nexport function isSignedIntegerType(dataType: ScalarCDataType) {\n  return (\n    dataType === \"signed char\" ||\n    dataType === \"signed short\" ||\n    dataType === \"signed int\" ||\n    dataType === \"signed long\"\n  );\n}\n\nexport function isUnsignedIntegerType(dataType: ScalarCDataType) {\n  return (\n    dataType === \"unsigned char\" ||\n    dataType === \"unsigned short\" ||\n    dataType === \"unsigned int\" ||\n    dataType === \"unsigned long\"\n  );\n}\n\nexport function isFloatType(dataType: ScalarCDataType) {\n  return dataType === \"float\" || dataType === \"double\";\n}\n\nexport function isIntegerType(dataType: ScalarCDataType) {\n  return isUnsignedIntegerType(dataType) || isSignedIntegerType(dataType);\n}\n\nexport function isConstant(node: CNodeBase) {\n  return node.type === \"IntegerConstant\" || node.type === \"FloatConstant\";\n}\n\n/**\n * Returns the total number of wasm memory pages needed to store the given number of bytes.\n */\nexport function calculateNumberOfPagesNeededForBytes(numBytes: number) {\n  return Math.floor(numBytes / WASM_PAGE_SIZE) + 1;\n}\n","/**\n * A collection of constant objects and values.\n * These constants are used across compiler modules.\n */\n\nexport const WASM_ADDR_SIZE = 4; // number of bytes of a wasm address\nexport const POINTER_SIZE = WASM_ADDR_SIZE; // size of a pointer in bytes - should be same as WASM_ADDR_SIZE\nexport const SIZE_T = \"unsigned int\"; // implmentation-defined\nexport const PTRDIFF_T = \"signed int\"; // defined type for difference between pointers\nexport const POINTER_TYPE = \"unsigned int\"; // type equivalent to pointer for this compiler implementation\nexport const ENUM_DATA_TYPE = \"signed int\"; // the datatype that enum directly corresponds to in this compiler implementation\n\nexport const KB = 1024; // number of bytes in 1 KB\nexport const WASM_PAGE_IN_HEX = 0x10000;\n","import { WasmDataObjectMemoryDetails } from \"~src/translator/wasm-ast/functions\";\nimport { WasmExpression, WasmStatement } from \"~src/translator/wasm-ast/core\";\nimport { WasmGlobalGet } from \"~src/translator/wasm-ast/variables\";\nimport { WASM_ADDR_SIZE } from \"~src/common/constants\";\nimport { convertScalarDataTypeToWasmType } from \"./dataTypeUtil\";\nimport { PrimaryDataTypeMemoryObjectDetails } from \"~src/processor/dataTypeUtil\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport { FunctionDetails } from \"~src/processor/c-ast/function\";\n\n/**\n * Collection of constants and functions related to the memory model.\n */\nexport const PARAM_PREFIX = \"param_\";\nexport const WASM_PAGE_SIZE = 65536;\nexport const WASM_ADDR_TYPE = \"i32\"; // the wasm type of addresses\nexport const WASM_ADDR_ADD_INSTRUCTION = WASM_ADDR_TYPE + \".add\"; // insruction to use when adding wasm address\nexport const WASM_ADDR_SUB_INSTRUCTION = WASM_ADDR_TYPE + \".sub\";\nexport const WASM_ADDR_MUL_INSTRUCTION = WASM_ADDR_TYPE + \".mul\";\nexport const WASM_ADDR_DIV_INSTRUCTION = WASM_ADDR_TYPE + \".div_u\";\nexport const WASM_ADDR_LE_INSTRUCTION = WASM_ADDR_TYPE + \".le_u\";\nexport const WASM_ADDR_LT_INSTRUCTION = WASM_ADDR_TYPE + \".lt_u\";\n// the names of stack and base pointer, which are global variables.\nexport const STACK_POINTER = \"sp\"; // points to the topmost byte of the stack\nexport const BASE_POINTER = \"bp\";\nexport const HEAP_POINTER = \"hp\"; // points to the address of first byte after heap\nexport const REG_1 = \"r1\"; // general purpose register\nexport const REG_2 = \"r2\";\nexport const REG_I64 = \"ri64\"; // gpr for i64 type\nexport const REG_F32 = \"rf32\"; // gpr for f32 type\nexport const REG_F64 = \"rf64\"; // gpr for f64 type\n\n// Wasm AST node for getting the value of base pointer at run time\nexport const basePointerGetNode: WasmGlobalGet = {\n  type: \"GlobalGet\",\n  name: BASE_POINTER,\n};\n\nexport const stackPointerGetNode: WasmGlobalGet = {\n  type: \"GlobalGet\",\n  name: STACK_POINTER,\n};\n\nexport const heapPointerGetNode: WasmGlobalGet = {\n  type: \"GlobalGet\",\n  name: HEAP_POINTER,\n};\n\nconst reg1GetNode: WasmGlobalGet = {\n  type: \"GlobalGet\",\n  name: REG_1,\n};\n\n// Returns the wasm ast node for setting base pointer to the value of an expression\nfunction getBasePointerSetNode(value: WasmExpression): WasmStatement {\n  return {\n    type: \"GlobalSet\",\n    name: BASE_POINTER,\n    value,\n  };\n}\n\nfunction getStackPointerSetNode(value: WasmExpression): WasmStatement {\n  return {\n    type: \"GlobalSet\",\n    name: STACK_POINTER,\n    value,\n  };\n}\n\n// Returns the wasm ast node for setting base pointer to the value of an expression\nfunction getReg1SetNode(value: WasmExpression): WasmStatement {\n  return {\n    type: \"GlobalSet\",\n    name: REG_1,\n    value,\n  };\n}\n\nexport function getReg2SetNode(value: WasmExpression): WasmStatement {\n  return {\n    type: \"GlobalSet\",\n    name: REG_2,\n    value,\n  };\n}\n\nexport function convertPrimaryDataObjectDetailsToWasmDataObjectDetails(\n  primaryDataObject: PrimaryDataTypeMemoryObjectDetails,\n): WasmDataObjectMemoryDetails {\n  return {\n    dataType: convertScalarDataTypeToWasmType(primaryDataObject.dataType),\n    offset: primaryDataObject.offset,\n    size: getSizeOfScalarDataType(primaryDataObject.dataType),\n  };\n}\n\n/**\n * Returns the WASM AST nodes needed to perform arithmetic on a pointer and push the result on WASM stack.\n */\nexport function getRegisterPointerArithmeticNode(\n  registerPointer: \"sp\" | \"bp\" | \"hp\" | \"r1\",\n  operator: \"+\" | \"-\",\n  operand: number,\n): WasmExpression {\n  return {\n    type: \"BinaryExpression\",\n    instruction:\n      operator === \"+\" ? WASM_ADDR_ADD_INSTRUCTION : WASM_ADDR_SUB_INSTRUCTION,\n    leftExpr: {\n      type: \"GlobalGet\",\n      name: registerPointer,\n    },\n    rightExpr: {\n      type: \"IntegerConst\",\n      wasmDataType: WASM_ADDR_TYPE,\n      value: BigInt(operand),\n    },\n  };\n}\n\nexport function getPointerIncrementNode(\n  pointer: \"sp\" | \"bp\" | \"hp\" | \"r1\",\n  incVal: number,\n): WasmStatement {\n  return {\n    type: \"GlobalSet\",\n    name: pointer,\n    value: getRegisterPointerArithmeticNode(pointer, \"+\", incVal),\n  };\n}\n\nexport function getPointerDecrementNode(\n  pointer: \"sp\" | \"bp\" | \"hp\",\n  decVal: number,\n): WasmStatement {\n  return {\n    type: \"GlobalSet\",\n    name: pointer,\n    value: getRegisterPointerArithmeticNode(pointer, \"-\", decVal),\n  };\n}\n\n/**\n * Returns the teardown statements for a function stack frame.\n */\nexport function getFunctionCallStackFrameTeardownStatements(\n  functionDetails: FunctionDetails,\n): WasmStatement[] {\n  return [\n    // bring the stack pointer back down to end of previous stack frame\n    getStackPointerSetNode({\n      type: \"BinaryExpression\",\n      instruction: WASM_ADDR_ADD_INSTRUCTION,\n      leftExpr: basePointerGetNode,\n      rightExpr: {\n        type: \"IntegerConst\",\n        wasmDataType: \"i32\",\n        value: BigInt(WASM_ADDR_SIZE + functionDetails.sizeOfReturn),\n      },\n    }),\n    // set base pointer to base pointer of prv frame\n    getBasePointerSetNode({\n      type: \"MemoryLoad\",\n      addr: basePointerGetNode,\n      wasmDataType: WASM_ADDR_TYPE,\n      numOfBytes: WASM_ADDR_SIZE,\n    }),\n  ];\n}\n\n/**\n * Returns the statements required to check that there is sufficient memory to expand the stack.\n * If not, attempts to expand linear memory.\n */\nexport function getStackSpaceAllocationCheckStatement(\n  allocationSize: number,\n): WasmStatement {\n  return {\n    type: \"SelectionStatement\",\n    condition: {\n      type: \"BooleanExpression\",\n      expr: {\n        type: \"BinaryExpression\",\n        instruction: WASM_ADDR_LE_INSTRUCTION,\n        leftExpr: {\n          type: \"BinaryExpression\",\n          instruction: WASM_ADDR_SUB_INSTRUCTION,\n          leftExpr: {\n            type: \"GlobalGet\",\n            name: STACK_POINTER,\n          },\n          rightExpr: {\n            type: \"IntegerConst\",\n            wasmDataType: \"i32\",\n            value: BigInt(allocationSize),\n          },\n        },\n        rightExpr: heapPointerGetNode,\n      },\n      wasmDataType: \"i32\",\n    },\n\n    actions: [\n      // expand the memory since not enough space\n      // save the last address of linear memory in REG_1\n      {\n        type: \"GlobalSet\",\n        name: REG_1,\n        value: {\n          type: \"BinaryExpression\",\n          instruction: WASM_ADDR_MUL_INSTRUCTION,\n          leftExpr: {\n            type: \"MemorySize\",\n          },\n          rightExpr: {\n            type: \"IntegerConst\",\n            wasmDataType: WASM_ADDR_TYPE,\n            value: BigInt(WASM_PAGE_SIZE),\n          },\n        },\n      },\n      // save address of last item in memory to REG_2\n      {\n        type: \"GlobalSet\",\n        name: REG_2,\n        value: {\n          type: \"BinaryExpression\",\n          instruction: WASM_ADDR_SUB_INSTRUCTION,\n          leftExpr: {\n            type: \"GlobalGet\",\n            name: REG_1,\n          },\n          rightExpr: {\n            type: \"IntegerConst\",\n            value: 1n,\n            wasmDataType: WASM_ADDR_TYPE,\n          },\n        },\n      },\n      // save the size of stack in REG_1\n      {\n        type: \"GlobalSet\",\n        name: REG_1,\n        value: {\n          type: \"BinaryExpression\",\n          instruction: WASM_ADDR_SUB_INSTRUCTION,\n          leftExpr: {\n            type: \"GlobalGet\",\n            name: REG_1,\n          },\n          rightExpr: stackPointerGetNode,\n        },\n      },\n      // expand the memory since not enough space\n      {\n        type: \"MemoryGrow\",\n        pagesToGrowBy: {\n          type: \"IntegerConst\",\n          wasmDataType: \"i32\",\n          value: BigInt(Math.ceil(allocationSize / WASM_PAGE_SIZE)),\n        },\n      },\n\n      // set stack pointer to target stack pointer adddress\n      getStackPointerSetNode({\n        type: \"BinaryExpression\",\n        instruction: WASM_ADDR_SUB_INSTRUCTION,\n        leftExpr: {\n          type: \"BinaryExpression\",\n          instruction: WASM_ADDR_MUL_INSTRUCTION,\n          leftExpr: {\n            type: \"MemorySize\",\n          },\n          rightExpr: {\n            type: \"IntegerConst\",\n            wasmDataType: WASM_ADDR_TYPE,\n            value: BigInt(WASM_PAGE_SIZE),\n          },\n        },\n        rightExpr: {\n          type: \"GlobalGet\",\n          name: REG_1,\n        },\n      }),\n\n      // set REG_1 to the last address of new memory\n      {\n        type: \"GlobalSet\",\n        name: REG_1,\n        value: {\n          type: \"BinaryExpression\",\n          instruction: WASM_ADDR_SUB_INSTRUCTION,\n          leftExpr: {\n            type: \"BinaryExpression\",\n            instruction: WASM_ADDR_MUL_INSTRUCTION,\n            leftExpr: {\n              type: \"MemorySize\",\n            },\n            rightExpr: {\n              type: \"IntegerConst\",\n              wasmDataType: WASM_ADDR_TYPE,\n              value: BigInt(WASM_PAGE_SIZE),\n            },\n          },\n          rightExpr: {\n            type: \"IntegerConst\",\n            value: 1n,\n            wasmDataType: WASM_ADDR_TYPE,\n          },\n        },\n      },\n\n      // copy the stack memory to the end, get REG_1 to below stack pointer\n      {\n        type: \"Block\",\n        label: \"memcopy_block\",\n        body: [\n          {\n            type: \"Loop\",\n            label: \"memcopy_loop\",\n            body: [\n              {\n                type: \"BranchIf\",\n                label: \"memcopy_block\",\n                condition: {\n                  type: \"BooleanExpression\",\n                  expr: {\n                    type: \"BinaryExpression\",\n                    instruction: WASM_ADDR_LT_INSTRUCTION,\n                    leftExpr: {\n                      type: \"GlobalGet\",\n                      name: REG_1,\n                    },\n                    rightExpr: stackPointerGetNode,\n                  },\n                  wasmDataType: WASM_ADDR_TYPE,\n                },\n              },\n              // load item addressed by REG_2 to addr of REG_1\n              {\n                type: \"MemoryStore\",\n                addr: {\n                  type: \"GlobalGet\",\n                  name: REG_1,\n                },\n                value: {\n                  type: \"MemoryLoad\",\n                  addr: {\n                    type: \"GlobalGet\",\n                    name: REG_2,\n                  },\n                  wasmDataType: WASM_ADDR_TYPE,\n                  numOfBytes: WASM_ADDR_SIZE,\n                },\n                wasmDataType: WASM_ADDR_TYPE,\n                numOfBytes: WASM_ADDR_SIZE,\n              },\n              // decrement REG_1\n              {\n                type: \"GlobalSet\",\n                name: REG_1,\n                value: {\n                  type: \"BinaryExpression\",\n                  instruction: WASM_ADDR_SUB_INSTRUCTION,\n                  leftExpr: {\n                    type: \"GlobalGet\",\n                    name: REG_1,\n                  },\n                  rightExpr: {\n                    type: \"IntegerConst\",\n                    value: 1n,\n                    wasmDataType: WASM_ADDR_TYPE,\n                  },\n                },\n              },\n              // decrement REG_2\n              {\n                type: \"GlobalSet\",\n                name: REG_2,\n                value: {\n                  type: \"BinaryExpression\",\n                  instruction: WASM_ADDR_SUB_INSTRUCTION,\n                  leftExpr: {\n                    type: \"GlobalGet\",\n                    name: REG_2,\n                  },\n                  rightExpr: {\n                    type: \"IntegerConst\",\n                    value: 1n,\n                    wasmDataType: WASM_ADDR_TYPE,\n                  },\n                },\n              },\n              {\n                type: \"Branch\",\n                label: \"memcopy_loop\",\n              },\n            ],\n          },\n        ],\n      },\n    ],\n    elseStatements: [],\n  };\n}\n\n/**\n * Returns the wasm nodes responsible for the pre function call setup.\n */\nexport function getFunctionCallStackFrameSetupStatements(\n  functionDetails: FunctionDetails,\n  functionArgs: WasmExpression[], // arguments passed to this function call\n): WasmStatement[] {\n  const statements: WasmStatement[] = [];\n\n  const totalStackSpaceRequired =\n    functionDetails.sizeOfParams +\n    functionDetails.sizeOfReturn +\n    WASM_ADDR_SIZE;\n\n  statements.push(\n    getStackSpaceAllocationCheckStatement(totalStackSpaceRequired),\n  );\n\n  //allocate space for Return type on stack (if have)\n  if (functionDetails.sizeOfReturn > 0) {\n    statements.push(\n      getPointerDecrementNode(STACK_POINTER, functionDetails.sizeOfReturn),\n    );\n  }\n\n  //allocate space for BP on stack\n  statements.push(getPointerDecrementNode(STACK_POINTER, WASM_ADDR_SIZE));\n\n  //store BP of previous frame\n  statements.push({\n    type: \"MemoryStore\",\n    addr: stackPointerGetNode,\n    value: basePointerGetNode,\n    wasmDataType: WASM_ADDR_TYPE,\n    numOfBytes: WASM_ADDR_SIZE,\n  });\n\n  // allocate space for and set the values of each param\n  // args are already in correct order for loading into the stack from high to low address\n  for (let i = 0; i < functionDetails.parameters.length; ++i) {\n    statements.push(\n      getPointerDecrementNode(\n        STACK_POINTER,\n        getSizeOfScalarDataType(functionDetails.parameters[i].dataType),\n      ),\n    );\n    const param = functionDetails.parameters[i];\n\n    statements.push({\n      type: \"MemoryStore\",\n      addr: stackPointerGetNode,\n      value: functionArgs[i],\n      wasmDataType: convertScalarDataTypeToWasmType(param.dataType),\n      numOfBytes: getSizeOfScalarDataType(param.dataType),\n    });\n  }\n\n  // set BP to be sp + size of params\n  statements.push(\n    getBasePointerSetNode(\n      getRegisterPointerArithmeticNode(\"sp\", \"+\", functionDetails.sizeOfParams),\n    ),\n  );\n\n  return statements;\n}\n","/**\n * Defiinition of various utility functions relating to manaaging Wasm data types.\n */\n\nimport { PrimaryCDataType, ScalarCDataType } from \"~src/common/types\";\nimport { isUnsignedIntegerType, isSignedIntegerType } from \"~src/common/utils\";\nimport { TranslationError } from \"~src/errors\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { WASM_ADDR_TYPE } from \"~src/translator/memoryUtil\";\nimport { WasmConst } from \"~src/translator/wasm-ast/consts\";\nimport { WasmExpression } from \"~src/translator/wasm-ast/core\";\nimport {\n  WasmDataType,\n  WasmFloatType,\n  WasmIntType,\n} from \"~src/translator/wasm-ast/dataTypes\";\nimport { NumericConversionInstruction } from \"./wasm-ast/numericConversion\";\n\n/**\n * Mapping of C variable types to the Wasm variable type used to perform operations on it.\n */\n\nexport const priamryCDataTypeToWasmType: Record<\n  PrimaryCDataType,\n  WasmDataType\n> = {\n  [\"unsigned char\"]: \"i32\",\n  [\"signed char\"]: \"i32\",\n  [\"unsigned short\"]: \"i32\",\n  [\"signed short\"]: \"i32\",\n  [\"unsigned int\"]: \"i32\",\n  [\"signed int\"]: \"i32\",\n  [\"unsigned long\"]: \"i64\",\n  [\"signed long\"]: \"i64\",\n  [\"float\"]: \"f32\",\n  [\"double\"]: \"f64\",\n};\n\n/**\n * Converts a scalar type to a primary data type\n */\n\nexport function convertScalarDataTypeToWasmType(\n  scalarType: ScalarCDataType,\n): WasmDataType {\n  if (scalarType === \"pointer\") {\n    return WASM_ADDR_TYPE;\n  } else {\n    return priamryCDataTypeToWasmType[scalarType];\n  }\n}\nfunction getNeededNumericConversionInstruction(\n  from: WasmDataType,\n  to: WasmDataType,\n  signage: \"unsigned\" | \"signed\",\n): NumericConversionInstruction {\n  if (from === \"i32\" && to === \"i64\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from i32 to i64\",\n      );\n    } else if (signage === \"signed\") {\n      return \"i64.extend_i32_s\";\n    } else {\n      return \"i64.extend_i32_u\";\n    }\n  } else if (from === \"i64\" && to === \"i32\") {\n    return \"i32.wrap_i64\";\n  } else if (from === \"f32\" && to === \"f64\") {\n    return \"f64.promote_f32\";\n  } else if (from === \"f64\" && to === \"f32\") {\n    return \"f32.demote_f64\";\n  } else if (from === \"i32\" && to === \"f32\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from i32 to f32\",\n      );\n    } else if (signage === \"signed\") {\n      return \"f32.convert_i32_s\";\n    } else {\n      return \"f32.convert_i32_u\";\n    }\n  } else if (from === \"i64\" && to === \"f32\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from i64 to f32\",\n      );\n    } else if (signage === \"signed\") {\n      return \"f32.convert_i64_s\";\n    } else {\n      return \"f32.convert_i64_u\";\n    }\n  } else if (from === \"i32\" && to === \"f64\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from i32 to f64\",\n      );\n    } else if (signage === \"signed\") {\n      return \"f64.convert_i32_s\";\n    } else {\n      return \"f64.convert_i32_u\";\n    }\n  } else if (from === \"i64\" && to === \"f64\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from i64 to f64\",\n      );\n    } else if (signage === \"signed\") {\n      return \"f64.convert_i64_s\";\n    } else {\n      return \"f64.convert_i64_u\";\n    }\n  } else if (from === \"f32\" && to === \"i32\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from f32 to i32\",\n      );\n    } else if (signage === \"signed\") {\n      return \"i32.trunc_f32_s\";\n    } else {\n      return \"i32.trunc_f32_u\";\n    }\n  } else if (from === \"f64\" && to === \"i32\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from f64 to i32\",\n      );\n    } else if (signage === \"signed\") {\n      return \"i32.trunc_f64_s\";\n    } else {\n      return \"i32.trunc_f64_u\";\n    }\n  } else if (from === \"f32\" && to === \"i64\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from f32 to i64\",\n      );\n    } else if (signage === \"signed\") {\n      return \"i64.trunc_f32_s\";\n    } else {\n      return \"i64.trunc_f32_u\";\n    }\n  } else if (from === \"f64\" && to === \"i64\") {\n    if (typeof signage === \"undefined\") {\n      throw new TranslationError(\n        \"Missing sign information for numeric conversion from f64 to i64\",\n      );\n    } else if (signage === \"signed\") {\n      return \"i64.trunc_f64_s\";\n    } else {\n      return \"i64.trunc_f64_u\";\n    }\n  } else {\n    // should not happen\n    throw new TranslationError(\n      `Unhandled numeric conversion between wasm types: ${from} to ${to}`,\n    );\n  }\n}\n/**\n * Get the WAT AST NumericWrapper node that converts a primary C data type \"from\" to another type \"to\".\n */\nexport function getTypeConversionWrapper(\n  from: ScalarCDataType, // the C variable type of value being assigned\n  to: ScalarCDataType, // the C variable type of variable being assigned to\n  translatedExpression: WasmExpression, // the translated expression being assiged to the variable\n): WasmExpression {\n  const fromWasmType = convertScalarDataTypeToWasmType(from);\n  const toWasmType = convertScalarDataTypeToWasmType(to);\n\n  // sanity checks\n  if (typeof toWasmType === \"undefined\") {\n    throw new TranslationError(\n      `getTypeConversionWrapper: undefined variableWasmType: original type: ${to}`,\n    );\n  }\n  if (typeof fromWasmType === \"undefined\") {\n    throw new TranslationError(\n      `getTypeConversionWrapper: undefined valueWasmType: original type: ${from}`,\n    );\n  }\n\n  if (toWasmType === fromWasmType) {\n    // same wasm type already. no need any numeric conversion, and C implicit conversion rules will be adhered to\n    return translatedExpression;\n  }\n\n  if (isUnsignedIntegerType(from) || from === \"pointer\") {\n    return {\n      type: \"NumericWrapper\",\n      instruction: getNeededNumericConversionInstruction(\n        fromWasmType,\n        toWasmType,\n        \"unsigned\",\n      ),\n      expr: translatedExpression,\n    };\n  } else if (isSignedIntegerType(from)) {\n    return {\n      type: \"NumericWrapper\",\n      instruction: getNeededNumericConversionInstruction(\n        fromWasmType,\n        toWasmType,\n        \"signed\",\n      ),\n      expr: translatedExpression,\n    };\n  } else {\n    // for float types, conversion should be signed\n    return {\n      type: \"NumericWrapper\",\n      instruction: getNeededNumericConversionInstruction(\n        fromWasmType,\n        toWasmType,\n        \"signed\",\n      ),\n      expr: translatedExpression,\n    };\n  }\n}\n\n/**\n * Converts a constant to a Wasm const.\n */\nexport function convertConstantToWasmConst(constant: ConstantP): WasmConst {\n  if (constant.type === \"IntegerConstant\") {\n    return {\n      type: \"IntegerConst\",\n      wasmDataType: priamryCDataTypeToWasmType[\n        constant.dataType\n      ] as WasmIntType,\n      value: constant.value,\n    };\n  } else {\n    return {\n      type: \"FloatConst\",\n      wasmDataType: priamryCDataTypeToWasmType[\n        constant.dataType\n      ] as WasmFloatType,\n      value: constant.value,\n    };\n  }\n}\n","/**\n * This file contains all the error classes that can be thrown by the compiler.\n */\n\nimport { Position } from \"~src/parser/c-ast/misc\";\n\nfunction generateCompilationMessage(\n  message: string,\n  sourceCode: string,\n  position: Position,\n) {\n  let errorMessage = `${message}\\n${position.start.line} | `;\n  let currLine = position.start.line;\n  for (let i = position.start.offset; i < position.end.offset; ++i) {\n    if (sourceCode[i] === \"\\n\") {\n      errorMessage += `\\n${++currLine} | `;\n    } else {\n      errorMessage += sourceCode[i];\n    }\n  }\n  errorMessage += \"\\n\";\n  return errorMessage;\n}\n\n/**\n * Generates a compilation error message with positional information.\n * @param message\n * @param sourceCode\n * @param position\n * @returns\n */\nfunction generateCompilationErrorMessage(\n  message: string,\n  sourceCode: string,\n  position: Position,\n): string {\n  return `Error: ${generateCompilationMessage(message, sourceCode, position)}`;\n}\n\n/**\n * Generates a compilation warning message with positional information.\n * @param message\n * @param sourceCode\n * @param position\n * @returns\n */\nexport function generateCompilationWarningMessage(\n  message: string,\n  sourceCode: string,\n  position: Position,\n): string {\n  return `Warning: ${generateCompilationMessage(\n    message,\n    sourceCode,\n    position,\n  )}`;\n}\n\n/**\n * An error that occured in relation to the C source code during compilation.\n * Contains positional information for debugging purposes.\n */\nexport class SourceCodeError extends Error {\n  position: Position | null;\n  constructor(message: string, position?: Position) {\n    super();\n    this.message = message;\n    this.position = position ?? null;\n  }\n\n  addPositionInfo(position: Position) {\n    this.position = position;\n  }\n\n  /**\n   * Add sourcecode and generate full error message with position info if available.\n   * @param sourceCode preprocessed C program where comments are removed\n   * @param position\n   */\n  generateCompilationErrorMessage(sourceCode: string): string {\n    if (this.position !== null) {\n      this.message = generateCompilationErrorMessage(\n        this.message,\n        sourceCode,\n        this.position,\n      );\n    } else {\n      this.message = `Error: ${this.message}\\n`;\n    }\n    return this.message;\n  }\n}\n\n/**\n * Represents an error thrown by\n */\nexport class ParserCompilationErrors extends Error {\n  constructor(\n    sourceCode: string,\n    errors: { message: string; position: Position }[],\n  ) {\n    super(\n      errors\n        .map((e) =>\n          generateCompilationErrorMessage(e.message, sourceCode, e.position),\n        )\n        .join(\"\\n\"),\n    );\n  }\n}\n\nexport class ProcessingError extends SourceCodeError {\n  constructor(message: string, position?: Position) {\n    super(message, position);\n  }\n}\n\nexport class SemanticAnalysisError extends SourceCodeError {\n  constructor(message: string, position?: Position) {\n    super(message, position);\n  }\n}\n\nexport class TranslationError extends Error {\n  constructor(message: string) {\n    super(\"Translation Error: \" + message);\n  }\n}\n\nexport class WatGeneratorError extends Error {\n  constructor(message: string) {\n    super(\"WAT Generator Error: \" + message);\n  }\n}\n\n/**\n * Helper error to indicate features not yet supported by the compiler.\n */\nexport class UnsupportedFeatureError extends Error {\n  constructor(message: string) {\n    super(\"Unsupported Feature Error: \" + message);\n  }\n}\n\n/**\n * Convert aribtrary object to json string. Needed to support bigints.\n */\nexport function toJson(obj: any) {\n  const clone = structuredClone(obj);\n  function recursionHelper(obj: any) {\n    if ((typeof obj !== \"object\" && !Array.isArray(obj)) || obj === null) {\n      return;\n    }\n    for (const fieldName of Object.keys(obj)) {\n      if (typeof obj[fieldName] === \"bigint\") {\n        obj[fieldName] = obj[fieldName].toString() + \"n\"; // stringify bigints first\n      } else {\n        recursionHelper(obj[fieldName]);\n      }\n    }\n  }\n  recursionHelper(clone);\n  return JSON.stringify(clone, null, 2);\n}\n","/**\n * Contains utility function related to setting up a stack frame to wrap wasm function calls made from the JS runtime.\n */\n\nimport { WASM_ADDR_SIZE } from \"~src/common/constants\";\nimport { ScalarCDataType } from \"~src/common/types\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport { SharedWasmGlobalVariables } from \"~src/modules\";\nimport { StackFrameArg } from \"~src/modules/types\";\nimport { checkAndExpandMemoryIfNeeded } from \"~src/modules/util\";\n\n/**\n * For a call of a function ptr from the JS runtime, handles:\n * 1. Instantiation of the stack frame for the function call\n * 2. Calling of the function\n * 3. Teardown of the function stack frame\n */\nexport default function wrapFunctionPtrCall(\n  memory: WebAssembly.Memory,\n  functionTable: WebAssembly.Table,\n  functionPtr: number,\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  stackFrameArgs: StackFrameArg[],\n  returnTypes: ScalarCDataType[], // data type of the returns of the function\n): (number | bigint)[] {\n  const sizeOfReturns = returnTypes.reduce(\n    (prv, curr) => prv + getSizeOfScalarDataType(curr),\n    0,\n  );\n  // instantiate stack frame\n  const stackFrameSize = loadStackFrame(\n    memory,\n    sharedWasmGlobalVariables,\n    stackFrameArgs,\n    sizeOfReturns,\n  );\n\n  // call the function pointed to be functionPtr\n  functionTable.get(functionPtr)();\n\n  const stackFrameReturnObjectView = new DataView(\n    memory.buffer,\n    sharedWasmGlobalVariables.basePointer.value + WASM_ADDR_SIZE,\n    sizeOfReturns,\n  );\n\n  const returnValues: (number | bigint)[] = [];\n  let currOffset = 0;\n  for (const returnType of returnTypes) {\n    switch (returnType) {\n      case \"double\":\n        returnValues.push(\n          stackFrameReturnObjectView.getFloat64(currOffset, true),\n        );\n        break;\n      case \"float\":\n        returnValues.push(\n          stackFrameReturnObjectView.getFloat32(currOffset, true),\n        );\n        break;\n      case \"signed char\":\n        returnValues.push(stackFrameReturnObjectView.getInt8(currOffset));\n        break;\n      case \"unsigned char\":\n      case \"pointer\":\n        returnValues.push(stackFrameReturnObjectView.getUint8(currOffset));\n        break;\n      case \"signed short\":\n        returnValues.push(\n          stackFrameReturnObjectView.getInt16(currOffset, true),\n        );\n        break;\n      case \"unsigned short\":\n        returnValues.push(\n          stackFrameReturnObjectView.getUint16(currOffset, true),\n        );\n        break;\n      case \"signed int\":\n        returnValues.push(\n          stackFrameReturnObjectView.getInt32(currOffset, true),\n        );\n        break;\n      case \"unsigned int\":\n        returnValues.push(\n          stackFrameReturnObjectView.getUint32(currOffset, true),\n        );\n        break;\n      case \"signed long\":\n        returnValues.push(\n          stackFrameReturnObjectView.getBigInt64(currOffset, true),\n        );\n        break;\n      case \"unsigned long\":\n        returnValues.push(\n          stackFrameReturnObjectView.getBigUint64(currOffset, true),\n        );\n        break;\n    }\n    currOffset += getSizeOfScalarDataType(returnType);\n  }\n  // extract return value\n  tearDownStackFrame(\n    memory,\n    stackFrameSize,\n    sharedWasmGlobalVariables.stackPointer,\n    sharedWasmGlobalVariables.basePointer,\n  );\n\n  return returnValues;\n}\n\nfunction loadStackFrame(\n  memory: WebAssembly.Memory,\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  stackFrameArgs: StackFrameArg[],\n  sizeOfReturn: number,\n): number {\n  const totalArgsSize = stackFrameArgs.reduce(\n    (prv, curr) => prv + getSizeOfScalarDataType(curr.type),\n    0,\n  );\n  const bytesNeeded = totalArgsSize + sizeOfReturn + WASM_ADDR_SIZE; // need to add base pointer\n  checkAndExpandMemoryIfNeeded(memory, bytesNeeded, sharedWasmGlobalVariables);\n\n  const stackFrameDataView = new DataView(\n    memory.buffer,\n    sharedWasmGlobalVariables.stackPointer.value - bytesNeeded,\n    bytesNeeded,\n  );\n\n  // fill in old bp\n  stackFrameDataView.setUint32(\n    totalArgsSize,\n    sharedWasmGlobalVariables.basePointer.value,\n    true, //little endian\n  );\n\n  // fill in param values\n  let currOffset = bytesNeeded - sizeOfReturn - WASM_ADDR_SIZE;\n  for (const arg of stackFrameArgs) {\n    currOffset -= getSizeOfScalarDataType(arg.type);\n    switch (arg.type) {\n      case \"double\":\n        stackFrameDataView.setFloat64(currOffset, Number(arg.value), true);\n        break;\n      case \"float\":\n        stackFrameDataView.setFloat32(currOffset, Number(arg.value), true);\n        break;\n      case \"signed char\":\n        stackFrameDataView.setInt8(currOffset, Number(arg.value));\n        break;\n      case \"unsigned char\":\n      case \"pointer\":\n        stackFrameDataView.setUint8(currOffset, Number(arg.value));\n        break;\n      case \"signed short\":\n        stackFrameDataView.setInt16(currOffset, Number(arg.value), true);\n        break;\n      case \"unsigned short\":\n        stackFrameDataView.setUint16(currOffset, Number(arg.value), true);\n        break;\n      case \"signed int\":\n        stackFrameDataView.setInt32(currOffset, Number(arg.value), true);\n        break;\n      case \"unsigned int\":\n        stackFrameDataView.setUint32(currOffset, Number(arg.value), true);\n        break;\n      case \"signed long\":\n        stackFrameDataView.setBigInt64(currOffset, BigInt(arg.value), true);\n        break;\n      case \"unsigned long\":\n        stackFrameDataView.setBigUint64(currOffset, BigInt(arg.value), true);\n        break;\n    }\n  }\n\n  // set the value of bp\n  sharedWasmGlobalVariables.basePointer.value =\n    sharedWasmGlobalVariables.stackPointer.value -\n    sizeOfReturn -\n    WASM_ADDR_SIZE;\n  // set the value of sp\n  sharedWasmGlobalVariables.stackPointer.value =\n    sharedWasmGlobalVariables.stackPointer.value - bytesNeeded;\n\n  return bytesNeeded;\n}\n\nfunction tearDownStackFrame(\n  memory: WebAssembly.Memory,\n  stackFrameSize: number,\n  stackPointer: WebAssembly.Global,\n  basePointer: WebAssembly.Global,\n) {\n  stackPointer.value += stackFrameSize;\n  const dataView = new DataView(\n    memory.buffer,\n    basePointer.value,\n    WASM_ADDR_SIZE,\n  );\n  basePointer.value = dataView.getUint32(0, true);\n}\n","import { SIZE_T } from \"~src/common/constants\";\nimport { ModulesGlobalConfig, SharedWasmGlobalVariables } from \"~src/modules\";\nimport {\n  freeFunction,\n  mallocFunction,\n  printHeap,\n  printStack,\n} from \"~src/modules/source_stdlib/memory\";\nimport { Module, ModuleFunction } from \"~src/modules/types\";\nimport {\n  convertFloatToCStyleString,\n  extractCStyleStringFromMemory,\n} from \"~src/modules/util\";\nimport { StructDataType } from \"~src/parser/c-ast/dataTypes\";\n\n// the name that this module is imported into wasm by,\n// as well as the include name to use in C program file.\nexport const sourceStandardLibraryModuleImportName = \"source_stdlib\";\n\nexport class SourceStandardLibraryModule extends Module {\n  moduleDeclaredStructs: StructDataType[];\n  moduleFunctions: Record<string, ModuleFunction>;\n  heapAddress: number; // address of first item in heap\n\n  constructor(\n    memory: WebAssembly.Memory,\n    functionTable: WebAssembly.Table,\n    config: ModulesGlobalConfig,\n    sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  ) {\n    super(memory, functionTable, config, sharedWasmGlobalVariables);\n    this.heapAddress = this.sharedWasmGlobalVariables.heapPointer.value;\n    this.moduleDeclaredStructs = [];\n    this.moduleFunctions = {\n      print_int: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"signed int\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (int: number) => {\n          // to print the correct int (4 bytes), need to handle signage\n          if (int > Math.pow(2, 32) - 1) {\n            // negative number\n            this.print((-int).toString());\n          } else {\n            this.print(int.toString());\n          }\n        },\n      },\n      // prints an unsigned int (4 bytes and smaller)\n      print_int_unsigned: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"unsigned int\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (val: number) => {\n          // need to intepret val as unsigned 4 byte int\n          if (val < 0) {\n            this.print((val + Math.pow(2, 32)).toString());\n          } else {\n            this.print(val.toString());\n          }\n        },\n      },\n      // prints a char (signed) as a character\n      print_char: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"signed char\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (char: number) => {\n          // signed int overflow is undefined, no need to worry about handling that\n          this.print(String.fromCharCode(char));\n        },\n      },\n      // print a signed long type (8 bytes)\n      print_long: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"signed long\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (long: bigint) => {\n          // to prlong the correct long (4 bytes), need to handle signage\n          if (long > 2n ** 64n - 1n) {\n            // negative number\n            this.print((-long).toString());\n          } else {\n            this.print(long.toString());\n          }\n        },\n      },\n      // print an usigned long type (8 bytes)\n      print_long_unsigned: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"unsigned long\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (val: bigint) => {\n          // need to intepret val as unsigned 8 byte unsigned int\n          if (val < 0) {\n            this.print((BigInt(val) + 2n ** 64n).toString());\n          } else {\n            this.print(val.toString());\n          }\n        },\n      },\n      print_float: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"float\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (float: number) =>\n          this.print(convertFloatToCStyleString(float)),\n      },\n      print_double: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"double\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (float: number) =>\n          this.print(convertFloatToCStyleString(float)),\n      },\n      // for printing the value of pointers. behaves the same as print_int_unsigned\n      print_address: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: { type: \"void\" },\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (val: number) => {\n          // need to intepret val as unsigned 4 byte int\n          if (val < 0) {\n            this.print((val + Math.pow(2, 32)).toString());\n          } else {\n            this.print(val.toString());\n          }\n        },\n      },\n      // print a C style string\n      print_string: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n                isConst: true,\n              },\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (strAddress: number) => {\n          const str = extractCStyleStringFromMemory(memory.buffer, strAddress);\n          this.print(str);\n        },\n      },\n      malloc: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: SIZE_T,\n            },\n          ],\n          returnType: {\n            type: \"pointer\",\n            pointeeType: { type: \"void\" },\n          },\n        },\n        jsFunction: (numBytes: number) =>\n          mallocFunction({\n            memory: this.memory,\n            sharedWasmGlobalVariables: this.sharedWasmGlobalVariables,\n            freeList: this.freeList,\n            allocatedBlocks: this.allocatedBlocks,\n            bytesRequested: numBytes,\n          }),\n      },\n      free: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: { type: \"void\" },\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (address: number) =>\n          freeFunction({\n            address,\n            freeList: this.freeList,\n            allocatedBlocks: this.allocatedBlocks,\n          }),\n      },\n      print_heap: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: () =>\n          printHeap(\n            this.memory,\n            this.heapAddress,\n            this.sharedWasmGlobalVariables.heapPointer.value,\n          ),\n      },\n      print_stack: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: () =>\n          printStack(\n            this.memory,\n            this.sharedWasmGlobalVariables.stackPointer.value,\n          ),\n      },\n      // only works in browser environment, node.js support can be added in future\n      prompt_int: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"primary\", primaryDataType: \"signed int\" },\n        },\n        jsFunction: () => prompt(\"Enter a signed integer\"),\n      },\n      prompt_long: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"primary\", primaryDataType: \"signed long\" },\n        },\n        jsFunction: () => prompt(\"Enter a long signed integer\"),\n      },\n      // only works in browser environment, node.js support can be added in future\n      prompt_float: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"primary\", primaryDataType: \"float\" },\n        },\n        jsFunction: () => prompt(\"Enter a float\"),\n      },\n      prompt_double: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: () => prompt(\"Enter a double\"),\n      },\n      // only works in browser environment, node.js support can be added in future\n      prompt_string: {\n        parentImportedObject: sourceStandardLibraryModuleImportName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n              },\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (strAddr: number) => {\n          const str = prompt(\"Enter a string\");\n          const encoder = new TextEncoder();\n          const strBuffer = new Uint8Array(this.memory.buffer, strAddr);\n          if (str === null) {\n            strBuffer[0] = 0;\n            return;\n          }\n          const buf = encoder.encode(str);\n          for (let i = 0; i < str.length; ++i) {\n            strBuffer[i] = buf[i];\n          }\n          strBuffer[str.length] = 0;\n        },\n      },\n      // EXAMPLE of how to have a function taking aggregate type and returning aggreate type - TESTED AND WORKING\n      // adjust_a: {\n      //   parentImportedObject: sourceStandardLibraryModuleImportName,\n      //   functionType: {\n      //     type: \"function\",\n      //     parameters: [\n      //       {\n      //         type: \"primary\",\n      //         primaryDataType: \"signed int\"\n      //       },\n      //       {\n      //         type: \"struct\",\n      //         tag: \"A\",\n      //         fields: [\n      //           {\n      //             tag: \"i\",\n      //             dataType: {\n      //               type: \"primary\",\n      //               primaryDataType: \"signed int\",\n      //             },\n      //           },\n      //           {\n      //             tag: \"c\",\n      //             dataType: {\n      //               type: \"primary\",\n      //               primaryDataType: \"signed char\",\n      //             },\n      //           },\n      //           {\n      //             tag: \"l\",\n      //             dataType: {\n      //               type: \"primary\",\n      //               primaryDataType: \"signed long\",\n      //             },\n      //           },\n      //         ],\n      //       },\n      //       {\n      //         type: \"primary\",\n      //         primaryDataType: \"signed char\"\n      //       },\n      //     ],\n      //     returnType: {\n      //       type: \"struct\",\n      //       tag: \"A\",\n      //       fields: [\n      //         {\n      //           tag: \"i\",\n      //           dataType: {\n      //             type: \"primary\",\n      //             primaryDataType: \"signed int\",\n      //           },\n      //         },\n      //         {\n      //           tag: \"c\",\n      //           dataType: {\n      //             type: \"primary\",\n      //             primaryDataType: \"signed char\",\n      //           },\n      //         },\n      //         {\n      //           tag: \"l\",\n      //           dataType: {\n      //             type: \"primary\",\n      //             primaryDataType: \"signed long\",\n      //           },\n      //         },\n      //       ],\n      //     },\n      //   },\n      //   jsFunction: (a: number, i: number, c: number, l: bigint, z: number) => [\n      //     i + a,\n      //     c + 1,\n      //     l + BigInt(z),\n      //   ],\n      // },\n    };\n  }\n}\n","import { ModulesGlobalConfig, SharedWasmGlobalVariables } from \"~src/modules\";\nimport { Module, ModuleFunction, StackFrameArg } from \"~src/modules/types\";\nimport { StructDataType } from \"~src/parser/c-ast/dataTypes\";\nimport { SIZE_T } from \"~src/common/constants\";\nimport utilityEmscriptenModuleFactoryFn from \"~src/modules/utility/emscripten/utility\";\nimport { extractCStyleStringFromMemory } from \"~src/modules/util\";\nimport wrapFunctionPtrCall from \"~src/modules/stackFrameUtils\";\nimport {\n  freeFunction,\n  mallocFunction,\n} from \"~src/modules/source_stdlib/memory\";\n\n// the name that this module is imported into wasm by,\n// as well as the include name to use in C program file.\nexport const utilityStdLibName = \"utility\";\n\nexport class UtilityStdLibModule extends Module {\n  moduleDeclaredStructs: StructDataType[];\n  moduleFunctions: Record<string, ModuleFunction>;\n  heapAddress: number; // address of first item in heap\n\n  // functions whose value is be filled later after this.instantiate() is called.\n  stringToNewUTF8: Function = () => {};\n  addFunction: Function = () => {};\n  malloc: Function = () => {};\n  free: Function = () => {};\n  atof: Function = () => {};\n  atoi: Function = () => {};\n  atol: Function = () => {};\n  abs: Function = () => {};\n  labs: Function = () => {};\n  rand: Function = () => {};\n  srand: Function = () => {};\n  qsort: Function = () => {};\n  emscriptenMemory?: WebAssembly.Memory;\n\n  constructor(\n    memory: WebAssembly.Memory,\n    functionTable: WebAssembly.Table,\n    config: ModulesGlobalConfig,\n    sharedWasmGlobalVariables: SharedWasmGlobalVariables,\n  ) {\n    super(memory, functionTable, config, sharedWasmGlobalVariables);\n    this.heapAddress = this.sharedWasmGlobalVariables.heapPointer.value;\n    this.moduleDeclaredStructs = [];\n    this.instantiate = async () => {\n      const utilityModule = await utilityEmscriptenModuleFactoryFn();\n      // need to set the jsFunctions of all moduleFunctions here\n      this.stringToNewUTF8 = utilityModule.stringToNewUTF8;\n      this.addFunction = utilityModule.addFunction;\n      this.malloc = utilityModule._malloc;\n      this.free = utilityModule._free;\n      this.atof = utilityModule._atof;\n      this.atoi = utilityModule._atoi;\n      this.atol = utilityModule._atol;\n      this.abs = utilityModule._abs;\n      this.labs = utilityModule._labs;\n      this.rand = utilityModule._rand;\n      this.srand = utilityModule._srand;\n      this.qsort = utilityModule._qsort;\n      this.emscriptenMemory = utilityModule.wasmMemory;\n    };\n    this.moduleFunctions = {\n      atof: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                isConst: true,\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n              },\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"double\" },\n        },\n        jsFunction: (strAddress: number) => {\n          const str = extractCStyleStringFromMemory(memory.buffer, strAddress);\n          const strPtr = this.stringToNewUTF8(str);\n          const floatVal = this.atof(strPtr);\n          this.free(strPtr);\n          return floatVal;\n        },\n      },\n      atoi: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                isConst: true,\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n              },\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"signed int\" },\n        },\n        jsFunction: (strAddress: number) => {\n          const str = extractCStyleStringFromMemory(memory.buffer, strAddress);\n          const strPtr = this.stringToNewUTF8(str);\n          const intVal = this.atoi(strPtr);\n          this.free(strPtr);\n          return intVal;\n        },\n      },\n      atol: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                isConst: true,\n                type: \"primary\",\n                primaryDataType: \"signed char\",\n              },\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"signed long\" },\n        },\n        jsFunction: (strAddress: number) => {\n          const str = extractCStyleStringFromMemory(memory.buffer, strAddress);\n          const strPtr = this.stringToNewUTF8(str);\n          const intVal = this.atol(strPtr);\n          this.free(strPtr);\n          return intVal;\n        },\n      },\n      abs: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"signed int\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"signed int\" },\n        },\n        jsFunction: (val: number) => {\n          return this.abs(val);\n        },\n      },\n      labs: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"signed long\",\n            },\n          ],\n          returnType: { type: \"primary\", primaryDataType: \"signed long\" },\n        },\n        jsFunction: (val: number) => {\n          return this.labs(val);\n        },\n      },\n      rand: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [],\n          returnType: { type: \"primary\", primaryDataType: \"signed int\" },\n        },\n        jsFunction: () => {\n          return this.rand();\n        },\n      },\n      srand: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"primary\",\n              primaryDataType: \"unsigned int\",\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (val: number) => {\n          this.srand(val);\n        },\n      },\n      qsort: {\n        parentImportedObject: utilityStdLibName,\n        functionType: {\n          type: \"function\",\n          parameters: [\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"void\",\n              },\n            },\n            {\n              type: \"primary\",\n              primaryDataType: SIZE_T,\n            },\n            {\n              type: \"primary\",\n              primaryDataType: SIZE_T,\n            },\n            {\n              type: \"pointer\",\n              pointeeType: {\n                type: \"function\",\n                parameters: [\n                  {\n                    type: \"pointer\",\n                    pointeeType: { type: \"void\" },\n                    isConst: true,\n                  },\n                  {\n                    type: \"pointer\",\n                    pointeeType: { type: \"void\" },\n                    isConst: true,\n                  },\n                ],\n                returnType: {\n                  type: \"primary\",\n                  primaryDataType: \"signed int\",\n                },\n              },\n            },\n          ],\n          returnType: { type: \"void\" },\n        },\n        jsFunction: (\n          ptr: number,\n          count: number,\n          size: number,\n          funcPtr: number,\n        ) => {\n          const sortFn = (a: number, b: number) => {\n            // need to allocate and copy a and b pointer objects to our memory (they are pointers to emscripten memory)\n            const copiedAAddr: number = mallocFunction({\n              memory,\n              sharedWasmGlobalVariables,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n              bytesRequested: size,\n            });\n            const copiedBAddr: number = mallocFunction({\n              memory,\n              sharedWasmGlobalVariables,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n              bytesRequested: size,\n            });\n            const copiedABuff = new Uint8Array(\n              this.memory.buffer,\n              copiedAAddr,\n              size,\n            );\n            const copiedBBuff = new Uint8Array(\n              this.memory.buffer,\n              copiedBAddr,\n              size,\n            );\n            const origABuff = new Uint8Array(\n              this.emscriptenMemory!.buffer,\n              a,\n              size,\n            );\n            const origBBuff = new Uint8Array(\n              this.emscriptenMemory!.buffer,\n              b,\n              size,\n            );\n            for (let i = 0; i < size; ++i) {\n              copiedABuff[i] = origABuff[i];\n              copiedBBuff[i] = origBBuff[i];\n            }\n\n            // a and b are pointers to objects in memory\n            const stackFrameArgs: StackFrameArg[] = [\n              { value: BigInt(copiedAAddr), type: \"unsigned int\" },\n              { value: BigInt(copiedBAddr), type: \"unsigned int\" },\n            ];\n\n            // call the function pointer\n            const result = wrapFunctionPtrCall(\n              memory,\n              functionTable,\n              funcPtr,\n              sharedWasmGlobalVariables,\n              stackFrameArgs,\n              [\"signed int\"],\n            )[0];\n\n            freeFunction({\n              address: copiedAAddr,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n            });\n            freeFunction({\n              address: copiedBAddr,\n              freeList: this.freeList,\n              allocatedBlocks: this.allocatedBlocks,\n            });\n            return result;\n          };\n          // create funcPtr for the emscripten compiled module - 2nd arg is the function siganture,\n          // see https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html\n          // section on \"Calling JavaScript functions as function pointers from C\"\n          const emscriptenFuncPtr = this.addFunction(sortFn, \"iii\");\n\n          const memSize = count * size;\n\n          // allocate space in emscripten module memory space\n          const copiedObjectAddress: number = this.malloc(memSize);\n\n          // copy contents from our memory space to the emscripten memory\n          const srcBuffer = new Uint8Array(this.memory.buffer, ptr, memSize);\n          const destBuffer = new Uint8Array(\n            this.emscriptenMemory!.buffer,\n            copiedObjectAddress,\n            memSize,\n          );\n          for (let i = 0; i < memSize; ++i) {\n            destBuffer[i] = srcBuffer[i];\n          }\n          // perform the sorting operation\n          this.qsort(copiedObjectAddress, count, size, emscriptenFuncPtr);\n\n          // copy sorted result back into our memory\n          for (let i = 0; i < memSize; ++i) {\n            srcBuffer[i] = destBuffer[i];\n          }\n\n          // free buffer from emscriptens memory\n          this.free(copiedObjectAddress);\n        },\n      },\n    };\n  }\n}\n","var Module = (() => {\n  var _scriptDir =\n    typeof document !== \"undefined\" && document.currentScript\n      ? document.currentScript.src\n      : undefined;\n\n  return function (moduleArg = {}) {\n    // include: shell.js\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n    var Module = moduleArg;\n\n    // Set up the promise that indicates the Module is initialized\n    var readyPromiseResolve, readyPromiseReject;\n    Module[\"ready\"] = new Promise((resolve, reject) => {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n    [\n      \"_atoi\",\n      \"_atof\",\n      \"_abs\",\n      \"_labs\",\n      \"_rand\",\n      \"_bsearch\",\n      \"_qsort\",\n      \"_srand\",\n      \"_free\",\n      \"_malloc\",\n      \"_memory\",\n      \"_fflush\",\n      \"___indirect_function_table\",\n      \"onRuntimeInitialized\",\n    ].forEach((prop) => {\n      if (!Object.getOwnPropertyDescriptor(Module[\"ready\"], prop)) {\n        Object.defineProperty(Module[\"ready\"], prop, {\n          get: () =>\n            abort(\n              \"You are getting \" +\n                prop +\n                \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\",\n            ),\n          set: () =>\n            abort(\n              \"You are setting \" +\n                prop +\n                \" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js\",\n            ),\n        });\n      }\n    });\n\n    // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n    var moduleOverrides = Object.assign({}, Module);\n\n    var arguments_ = [];\n    var thisProgram = \"./this.program\";\n    var quit_ = (status, toThrow) => {\n      throw toThrow;\n    };\n\n    // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n\n    if (Module[\"ENVIRONMENT\"]) {\n      throw new Error(\n        \"Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)\",\n      );\n    }\n\n    // `/` should be present at the end if `scriptDirectory` is not empty\n    var scriptDirectory = \"\";\n    function locateFile(path) {\n      if (Module[\"locateFile\"]) {\n        return Module[\"locateFile\"](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    // Hooks that are implemented differently in different runtime environments.\n    var read_, readAsync, readBinary, setWindowTitle;\n\n    if (ENVIRONMENT_IS_SHELL) {\n      if (\n        (typeof process == \"object\" && typeof require === \"function\") ||\n        typeof window == \"object\" ||\n        typeof importScripts == \"function\"\n      )\n        throw new Error(\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\n        );\n\n      if (typeof read != \"undefined\") {\n        read_ = read;\n      }\n\n      readBinary = (f) => {\n        if (typeof readbuffer == \"function\") {\n          return new Uint8Array(readbuffer(f));\n        }\n        let data = read(f, \"binary\");\n        assert(typeof data == \"object\");\n        return data;\n      };\n\n      readAsync = (f, onload, onerror) => {\n        setTimeout(() => onload(readBinary(f)));\n      };\n\n      if (typeof clearTimeout == \"undefined\") {\n        globalThis.clearTimeout = (id) => {};\n      }\n\n      if (typeof setTimeout == \"undefined\") {\n        // spidermonkey lacks setTimeout but we use it above in readAsync.\n        globalThis.setTimeout = (f) => (typeof f == \"function\" ? f() : abort());\n      }\n\n      if (typeof scriptArgs != \"undefined\") {\n        arguments_ = scriptArgs;\n      } else if (typeof arguments != \"undefined\") {\n        arguments_ = arguments;\n      }\n\n      if (typeof quit == \"function\") {\n        quit_ = (status, toThrow) => {\n          // Unlike node which has process.exitCode, d8 has no such mechanism. So we\n          // have no way to set the exit code and then let the program exit with\n          // that code when it naturally stops running (say, when all setTimeouts\n          // have completed). For that reason, we must call `quit` - the only way to\n          // set the exit code - but quit also halts immediately.  To increase\n          // consistency with node (and the web) we schedule the actual quit call\n          // using a setTimeout to give the current stack and any exception handlers\n          // a chance to run.  This enables features such as addOnPostRun (which\n          // expected to be able to run code after main returns).\n          setTimeout(() => {\n            if (!(toThrow instanceof ExitStatus)) {\n              let toLog = toThrow;\n              if (toThrow && typeof toThrow == \"object\" && toThrow.stack) {\n                toLog = [toThrow, toThrow.stack];\n              }\n              err(`exiting due to exception: ${toLog}`);\n            }\n            quit(status);\n          });\n          throw toThrow;\n        };\n      }\n\n      if (typeof print != \"undefined\") {\n        // Prefer to use print/printErr where they exist, as they usually work better.\n        if (typeof console == \"undefined\")\n          console = /** @type{!Console} */ ({});\n        console.log = /** @type{!function(this:Console, ...*): undefined} */ (\n          print\n        );\n        console.warn = console.error =\n          /** @type{!function(this:Console, ...*): undefined} */ (\n            typeof printErr != \"undefined\" ? printErr : print\n          );\n      }\n    }\n\n    // Note that this includes Node.js workers when relevant (pthreads is enabled).\n    // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n    // ENVIRONMENT_IS_NODE.\n    else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (typeof document != \"undefined\" && document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      }\n      // When MODULARIZE, this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      }\n      // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n      // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n      // they are removed because they could contain a slash.\n      if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n        scriptDirectory = scriptDirectory.substr(\n          0,\n          scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1,\n        );\n      } else {\n        scriptDirectory = \"\";\n      }\n\n      if (!(typeof window == \"object\" || typeof importScripts == \"function\"))\n        throw new Error(\n          \"not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)\",\n        );\n\n      // Differentiate the Web Worker from the Node Worker case, as reading must\n      // be done differently.\n      {\n        // include: web_or_worker_shell_read.js\n        read_ = (url) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = (url) => {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, false);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send(null);\n            return new Uint8Array(/** @type{!ArrayBuffer} */ (xhr.response));\n          };\n        }\n\n        readAsync = (url, onload, onerror) => {\n          var xhr = new XMLHttpRequest();\n          xhr.open(\"GET\", url, true);\n          xhr.responseType = \"arraybuffer\";\n          xhr.onload = () => {\n            if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {\n              // file URLs can return 0\n              onload(xhr.response);\n              return;\n            }\n            onerror();\n          };\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n\n        // end include: web_or_worker_shell_read.js\n      }\n\n      setWindowTitle = (title) => (document.title = title);\n    } else {\n      throw new Error(\"environment detection error\");\n    }\n\n    var out = Module[\"print\"] || console.log.bind(console);\n    var err = Module[\"printErr\"] || console.error.bind(console);\n\n    // Merge back in the overrides\n    Object.assign(Module, moduleOverrides);\n    // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n    moduleOverrides = null;\n    checkIncomingModuleAPI();\n\n    // Emit code to handle expected values on the Module object. This applies Module.x\n    // to the proper local x. This has two benefits: first, we only emit it if it is\n    // expected to arrive, and second, by using a local everywhere else that can be\n    // minified.\n\n    if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n    legacyModuleProp(\"arguments\", \"arguments_\");\n\n    if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n    legacyModuleProp(\"thisProgram\", \"thisProgram\");\n\n    if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n    legacyModuleProp(\"quit\", \"quit_\");\n\n    // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n    // Assertions on removed incoming Module JS APIs.\n    assert(\n      typeof Module[\"memoryInitializerPrefixURL\"] == \"undefined\",\n      \"Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"pthreadMainPrefixURL\"] == \"undefined\",\n      \"Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"cdInitializerPrefixURL\"] == \"undefined\",\n      \"Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"filePackagePrefixURL\"] == \"undefined\",\n      \"Module.filePackagePrefixURL option was removed, use Module.locateFile instead\",\n    );\n    assert(\n      typeof Module[\"read\"] == \"undefined\",\n      \"Module.read option was removed (modify read_ in JS)\",\n    );\n    assert(\n      typeof Module[\"readAsync\"] == \"undefined\",\n      \"Module.readAsync option was removed (modify readAsync in JS)\",\n    );\n    assert(\n      typeof Module[\"readBinary\"] == \"undefined\",\n      \"Module.readBinary option was removed (modify readBinary in JS)\",\n    );\n    assert(\n      typeof Module[\"setWindowTitle\"] == \"undefined\",\n      \"Module.setWindowTitle option was removed (modify setWindowTitle in JS)\",\n    );\n    assert(\n      typeof Module[\"TOTAL_MEMORY\"] == \"undefined\",\n      \"Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY\",\n    );\n    legacyModuleProp(\"asm\", \"wasmExports\");\n    legacyModuleProp(\"read\", \"read_\");\n    legacyModuleProp(\"readAsync\", \"readAsync\");\n    legacyModuleProp(\"readBinary\", \"readBinary\");\n    legacyModuleProp(\"setWindowTitle\", \"setWindowTitle\");\n    var IDBFS = \"IDBFS is no longer included by default; build with -lidbfs.js\";\n    var PROXYFS =\n      \"PROXYFS is no longer included by default; build with -lproxyfs.js\";\n    var WORKERFS =\n      \"WORKERFS is no longer included by default; build with -lworkerfs.js\";\n    var FETCHFS =\n      \"FETCHFS is no longer included by default; build with -lfetchfs.js\";\n    var ICASEFS =\n      \"ICASEFS is no longer included by default; build with -licasefs.js\";\n    var JSFILEFS =\n      \"JSFILEFS is no longer included by default; build with -ljsfilefs.js\";\n    var OPFS = \"OPFS is no longer included by default; build with -lopfs.js\";\n\n    var NODEFS =\n      \"NODEFS is no longer included by default; build with -lnodefs.js\";\n\n    assert(\n      !ENVIRONMENT_IS_WORKER,\n      \"worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.\",\n    );\n\n    assert(\n      !ENVIRONMENT_IS_NODE,\n      \"node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.\",\n    );\n\n    assert(\n      !ENVIRONMENT_IS_SHELL,\n      \"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.\",\n    );\n\n    // end include: shell.js\n    // include: preamble.js\n    // === Preamble library stuff ===\n\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    var wasmBinary;\n    if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n    legacyModuleProp(\"wasmBinary\", \"wasmBinary\");\n    var noExitRuntime = Module[\"noExitRuntime\"] || true;\n    legacyModuleProp(\"noExitRuntime\", \"noExitRuntime\");\n\n    if (typeof WebAssembly != \"object\") {\n      abort(\"no native wasm support detected\");\n    }\n\n    // Wasm globals\n\n    var wasmMemory;\n\n    //========================================\n    // Runtime essentials\n    //========================================\n\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n    var ABORT = false;\n\n    // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n    var EXITSTATUS;\n\n    /** @type {function(*, string=)} */\n    function assert(condition, text) {\n      if (!condition) {\n        abort(\"Assertion failed\" + (text ? \": \" + text : \"\"));\n      }\n    }\n\n    // We used to include malloc/free by default in the past. Show a helpful error in\n    // builds with assertions.\n\n    // Memory management\n\n    var HEAP,\n      /** @type {!Int8Array} */\n      HEAP8,\n      /** @type {!Uint8Array} */\n      HEAPU8,\n      /** @type {!Int16Array} */\n      HEAP16,\n      /** @type {!Uint16Array} */\n      HEAPU16,\n      /** @type {!Int32Array} */\n      HEAP32,\n      /** @type {!Uint32Array} */\n      HEAPU32,\n      /** @type {!Float32Array} */\n      HEAPF32,\n      /** @type {!Float64Array} */\n      HEAPF64;\n\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n      Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n      Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n      Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n      Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n      Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n      Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n      Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n    }\n\n    assert(\n      !Module[\"STACK_SIZE\"],\n      \"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time\",\n    );\n\n    assert(\n      typeof Int32Array != \"undefined\" &&\n        typeof Float64Array !== \"undefined\" &&\n        Int32Array.prototype.subarray != undefined &&\n        Int32Array.prototype.set != undefined,\n      \"JS engine does not provide full typed array support\",\n    );\n\n    // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n    assert(\n      !Module[\"wasmMemory\"],\n      \"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally\",\n    );\n    assert(\n      !Module[\"INITIAL_MEMORY\"],\n      \"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically\",\n    );\n\n    // include: runtime_init_table.js\n    // In regular non-RELOCATABLE mode the table is exported\n    // from the wasm module and this will be assigned once\n    // the exports are available.\n    var wasmTable;\n    // end include: runtime_init_table.js\n    // include: runtime_stack_check.js\n    // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n    function writeStackCookie() {\n      var max = _emscripten_stack_get_end();\n      assert((max & 3) == 0);\n      // If the stack ends at address zero we write our cookies 4 bytes into the\n      // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n      // monitor writes to address zero.\n      if (max == 0) {\n        max += 4;\n      }\n      // The stack grow downwards towards _emscripten_stack_get_end.\n      // We write cookies to the final two words in the stack and detect if they are\n      // ever overwritten.\n      HEAPU32[max >> 2] = 0x02135467;\n      HEAPU32[(max + 4) >> 2] = 0x89bacdfe;\n      // Also test the global address 0 for integrity.\n      HEAPU32[0 >> 2] = 1668509029;\n    }\n\n    function checkStackCookie() {\n      if (ABORT) return;\n      var max = _emscripten_stack_get_end();\n      // See writeStackCookie().\n      if (max == 0) {\n        max += 4;\n      }\n      var cookie1 = HEAPU32[max >> 2];\n      var cookie2 = HEAPU32[(max + 4) >> 2];\n      if (cookie1 != 0x02135467 || cookie2 != 0x89bacdfe) {\n        abort(\n          `Stack overflow! Stack cookie has been overwritten at ${ptrToString(\n            max,\n          )}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(\n            cookie2,\n          )} ${ptrToString(cookie1)}`,\n        );\n      }\n      // Also test the global address 0 for integrity.\n      if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */) {\n        abort(\n          \"Runtime error: The application has corrupted its heap memory area (address zero)!\",\n        );\n      }\n    }\n    // end include: runtime_stack_check.js\n    // include: runtime_assertions.js\n    // Endianness check\n    (function () {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 0x6373;\n      if (h8[0] !== 0x73 || h8[1] !== 0x63)\n        throw \"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)\";\n    })();\n\n    // end include: runtime_assertions.js\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n    var __ATINIT__ = []; // functions called during startup\n    var __ATEXIT__ = []; // functions called during shutdown\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n\n    var runtimeKeepaliveCounter = 0;\n\n    function keepRuntimeAlive() {\n      return noExitRuntime || runtimeKeepaliveCounter > 0;\n    }\n\n    function preRun() {\n      if (Module[\"preRun\"]) {\n        if (typeof Module[\"preRun\"] == \"function\")\n          Module[\"preRun\"] = [Module[\"preRun\"]];\n        while (Module[\"preRun\"].length) {\n          addOnPreRun(Module[\"preRun\"].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n\n      checkStackCookie();\n\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function postRun() {\n      checkStackCookie();\n\n      if (Module[\"postRun\"]) {\n        if (typeof Module[\"postRun\"] == \"function\")\n          Module[\"postRun\"] = [Module[\"postRun\"]];\n        while (Module[\"postRun\"].length) {\n          addOnPostRun(Module[\"postRun\"].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    // include: runtime_math.js\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n    assert(\n      Math.imul,\n      \"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    assert(\n      Math.fround,\n      \"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    assert(\n      Math.clz32,\n      \"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    assert(\n      Math.trunc,\n      \"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill\",\n    );\n    // end include: runtime_math.js\n    // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n        if (\n          runDependencyWatcher === null &&\n          typeof setInterval != \"undefined\"\n        ) {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(() => {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n            var shown = false;\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err(\"still waiting on run dependencies:\");\n              }\n              err(`dependency: ${dep}`);\n            }\n            if (shown) {\n              err(\"(end of list)\");\n            }\n          }, 10000);\n        }\n      } else {\n        err(\"warning: run dependency added without ID\");\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module[\"monitorRunDependencies\"]) {\n        Module[\"monitorRunDependencies\"](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err(\"warning: run dependency removed without ID\");\n      }\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    /** @param {string|number=} what */\n    function abort(what) {\n      if (Module[\"onAbort\"]) {\n        Module[\"onAbort\"](what);\n      }\n\n      what = \"Aborted(\" + what + \")\";\n      // TODO(sbc): Should we remove printing and leave it up to whoever\n      // catches the exception?\n      err(what);\n\n      ABORT = true;\n      EXITSTATUS = 1;\n\n      // Use a wasm runtime error, because a JS error might be seen as a foreign\n      // exception, which means we'd run destructors on it. We need the error to\n      // simply make the program stop.\n      // FIXME This approach does not work in Wasm EH because it currently does not assume\n      // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n      // a trap or not based on a hidden field within the object. So at the moment\n      // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n      // allows this in the wasm spec.\n\n      // Suppress closure compiler warning here. Closure compiler's builtin extern\n      // defintion for WebAssembly.RuntimeError claims it takes no arguments even\n      // though it can.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n      /** @suppress {checkTypes} */\n      var e = new WebAssembly.RuntimeError(what);\n\n      readyPromiseReject(e);\n      // Throw the error whether or not MODULARIZE is set because abort is used\n      // in code paths apart from instantiation where an exception is expected\n      // to be thrown when abort is called.\n      throw e;\n    }\n\n    // include: memoryprofiler.js\n    // end include: memoryprofiler.js\n    // show errors on likely calls to FS when it was not included\n    var FS = {\n      error() {\n        abort(\n          \"Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM\",\n        );\n      },\n      init() {\n        FS.error();\n      },\n      createDataFile() {\n        FS.error();\n      },\n      createPreloadedFile() {\n        FS.error();\n      },\n      createLazyFile() {\n        FS.error();\n      },\n      open() {\n        FS.error();\n      },\n      mkdev() {\n        FS.error();\n      },\n      registerDevice() {\n        FS.error();\n      },\n      analyzePath() {\n        FS.error();\n      },\n\n      ErrnoError() {\n        FS.error();\n      },\n    };\n    Module[\"FS_createDataFile\"] = FS.createDataFile;\n    Module[\"FS_createPreloadedFile\"] = FS.createPreloadedFile;\n\n    // include: URIUtils.js\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n    var dataURIPrefix = \"data:application/octet-stream;base64,\";\n\n    // Indicates whether filename is a base64 data URI.\n    function isDataURI(filename) {\n      // Prefix of data URIs emitted by SINGLE_FILE and related options.\n      return filename.startsWith(dataURIPrefix);\n    }\n\n    // Indicates whether filename is delivered via file protocol (as opposed to http/https)\n    function isFileURI(filename) {\n      return filename.startsWith(\"file://\");\n    }\n    // end include: URIUtils.js\n    function createExportWrapper(name) {\n      return function () {\n        assert(\n          runtimeInitialized,\n          `native function \\`${name}\\` called before runtime initialization`,\n        );\n        var f = wasmExports[name];\n        assert(f, `exported native function \\`${name}\\` not found`);\n        return f.apply(null, arguments);\n      };\n    }\n\n    // include: runtime_exceptions.js\n    // end include: runtime_exceptions.js\n    var wasmBinaryFile;\n    wasmBinaryFile =\n      \"data:application/octet-stream;base64,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WQ0BCyAAECwiAkF/Sg0BIAAoAgQhASAAKAIsIQILIABCfzcDcCAAIAE2AmggACAEIAIgAWusfDcDeEF/DwsgBEIBfCEEIAAoAgQhASAAKAIIIQMCQCAAKQNwIgVCAFENACAFIAR9IgUgAyABa6xZDQAgASAFp2ohAwsgACADNgJoIAAgBCAAKAIsIgMgAWusfDcDeAJAIAEgA0sNACABQX9qIAI6AAALIAILEAAgAEEgRiAAQXdqQQVJcgvgAQIDfwJ+IwBBEGsiAiQAAkACQCABvCIDQf////8HcSIEQYCAgHxqQf////cHSw0AIAStQhmGQoCAgICAgIDAP3whBUIAIQYMAQsCQCAEQYCAgPwHSQ0AIAOtQhmGQoCAgICAgMD//wCEIQVCACEGDAELAkAgBA0AQgAhBkIAIQUMAQsgAiAErUIAIARnIgRB0QBqECMgAkEIaikDAEKAgICAgIDAAIVBif8AIARrrUIwhoQhBSACKQMAIQYLIAAgBjcDACAAIAUgA0GAgICAeHGtQiCGhDcDCCACQRBqJAALjAECAn8CfiMAQRBrIgIkAAJAAkAgAQ0AQgAhBEIAIQUMAQsgAiABIAFBH3UiA3MgA2siA61CACADZyIDQdEAahAjIAJBCGopAwBCgICAgICAwACFQZ6AASADa61CMIZ8IAFBgICAgHhxrUIghoQhBSACKQMAIQQLIAAgBDcDACAAIAU3AwggAkEQaiQAC5QLAgV/D34jAEHgAGsiBSQAIARC////////P4MhCiAEIAKFQoCAgICAgICAgH+DIQsgAkL///////8/gyIMQiCIIQ0gBEIwiKdB//8BcSEGAkACQAJAIAJCMIinQf//AXEiB0GBgH5qQYKAfkkNAEEAIQggBkGBgH5qQYGAfksNAQsCQCABUCACQv///////////wCDIg5CgICAgICAwP//AFQgDkKAgICAgIDA//8AURsNACACQoCAgICAgCCEIQsMAgsCQCADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQsgAyEBDAILAkAgASAOQoCAgICAgMD//wCFhEIAUg0AAkAgAyAChFBFDQBCgICAgICA4P//ACELQgAhAQwDCyALQoCAgICAgMD//wCEIQtCACEBDAILAkAgAyACQoCAgICAgMD//wCFhEIAUg0AIAEgDoQhAkIAIQECQCACUEUNAEKAgICAgIDg//8AIQsMAwsgC0KAgICAgIDA//8AhCELDAILAkAgASAOhEIAUg0AQgAhAQwCCwJAIAMgAoRCAFINAEIAIQEMAgtBACEIAkAgDkL///////8/Vg0AIAVB0ABqIAEgDCABIAwgDFAiCBt5IAhBBnStfKciCEFxahAjQRAgCGshCCAFQdgAaikDACIMQiCIIQ0gBSkDUCEBCyACQv///////z9WDQAgBUHAAGogAyAKIAMgCiAKUCIJG3kgCUEGdK18pyIJQXFqECMgCCAJa0EQaiEIIAVByABqKQMAIQogBSkDQCEDCyADQg+GIg5CgID+/w+DIgIgAUIgiCIEfiIPIA5CIIgiDiABQv////8PgyIBfnwiEEIghiIRIAIgAX58IhIgEVStIAIgDEL/////D4MiDH4iEyAOIAR+fCIRIANCMYggCkIPhiIUhEL/////D4MiAyABfnwiCiAQQiCIIBAgD1StQiCGhHwiDyACIA1CgIAEhCIQfiIVIA4gDH58Ig0gFEIgiEKAgICACIQiAiABfnwiFCADIAR+fCIWQiCGfCIXfCEBIAcgBmogCGpBgYB/aiEGAkACQCACIAR+IhggDiAQfnwiBCAYVK0gBCADIAx+fCIOIARUrXwgAiAQfnwgDiARIBNUrSAKIBFUrXx8IgQgDlStfCADIBB+IgMgAiAMfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgFkIgiCANIBVUrSAUIA1UrXwgFiAUVK18QiCGhHwiBCACVK18IAQgDyAKVK0gFyAPVK18fCICIARUrXwiBEKAgICAgIDAAINQDQAgBkEBaiEGDAELIBJCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIBJCAYYhEiADIAFCAYaEIQELAkAgBkH//wFIDQAgC0KAgICAgIDA//8AhCELQgAhAQwBCwJAAkAgBkEASg0AAkBBASAGayIHQf8ASw0AIAVBMGogEiABIAZB/wBqIgYQIyAFQSBqIAIgBCAGECMgBUEQaiASIAEgBxAkIAUgAiAEIAcQJCAFKQMgIAUpAxCEIAUpAzAgBUEwakEIaikDAIRCAFKthCESIAVBIGpBCGopAwAgBUEQakEIaikDAIQhASAFQQhqKQMAIQQgBSkDACECDAILQgAhAQwCCyAGrUIwhiAEQv///////z+DhCEECyAEIAuEIQsCQCASUCABQn9VIAFCgICAgICAgICAf1EbDQAgCyACQgF8IgFQrXwhCwwBCwJAIBIgAUKAgICAgICAgIB/hYRCAFENACACIQEMAQsgCyACIAJCAYN8IgEgAlStfCELCyAAIAE3AwAgACALNwMIIAVB4ABqJAALBABBAAsEAEEAC98KAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCQJAAkACQCABUCIGIAJC////////////AIMiCkKAgICAgIDAgIB/fEKAgICAgIDAgIB/VCAKUBsNACADQgBSIAlCgICAgICAwICAf3wiC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCwJAIAYgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhBCABIQMMAgsCQCADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEEDAILAkAgASAKQoCAgICAgMD//wCFhEIAUg0AQoCAgICAgOD//wAgAiADIAGFIAQgAoVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQECQCABIAqEQgBSDQAgAyAJhEIAUg0CIAMgAYMhAyAEIAKDIQQMAgsgAyAJhFBFDQAgASEDIAIhBAwBCyADIAEgAyABViAJIApWIAkgClEbIgcbIQkgBCACIAcbIgtC////////P4MhCiACIAQgBxsiAkIwiKdB//8BcSEIAkAgC0IwiKdB//8BcSIGDQAgBUHgAGogCSAKIAkgCiAKUCIGG3kgBkEGdK18pyIGQXFqECNBECAGayEGIAVB6ABqKQMAIQogBSkDYCEJCyABIAMgBxshAyACQv///////z+DIQQCQCAIDQAgBUHQAGogAyAEIAMgBCAEUCIHG3kgB0EGdK18pyIHQXFqECNBECAHayEIIAVB2ABqKQMAIQQgBSkDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEBIApCA4YgCUI9iIQhBCADQgOGIQogCyAChSEDAkAgBiAIRg0AAkAgBiAIayIHQf8ATQ0AQgAhAUIBIQoMAQsgBUHAAGogCiABQYABIAdrECMgBUEwaiAKIAEgBxAkIAUpAzAgBSkDQCAFQcAAakEIaikDAIRCAFKthCEKIAVBMGpBCGopAwAhAQsgBEKAgICAgICABIQhDCAJQgOGIQkCQAJAIANCf1UNAEIAIQNCACEEIAkgCoUgDCABhYRQDQIgCSAKfSECIAwgAX0gCSAKVK19IgRC/////////wNWDQEgBUEgaiACIAQgAiAEIARQIgcbeSAHQQZ0rXynQXRqIgcQIyAGIAdrIQYgBUEoaikDACEEIAUpAyAhAgwBCyABIAx8IAogCXwiAiAKVK18IgRCgICAgICAgAiDUA0AIAJCAYggBEI/hoQgCkIBg4QhAiAGQQFqIQYgBEIBiCEECyALQoCAgICAgICAgH+DIQoCQCAGQf//AUgNACAKQoCAgICAgMD//wCEIQRCACEDDAELQQAhBwJAAkAgBkEATA0AIAYhBwwBCyAFQRBqIAIgBCAGQf8AahAjIAUgAiAEQQEgBmsQJCAFKQMAIAUpAxAgBUEQakEIaikDAIRCAFKthCECIAVBCGopAwAhBAsgAkIDiCAEQj2GhCEDIAetQjCGIARCA4hC////////P4OEIAqEIQQgAqdBB3EhBgJAAkACQAJAAkAQMw4DAAECAwsgBCADIAZBBEutfCIKIANUrXwhBAJAIAZBBEYNACAKIQMMAwsgBCAKQgGDIgEgCnwiAyABVK18IQQMAwsgBCADIApCAFIgBkEAR3GtfCIKIANUrXwhBCAKIQMMAQsgBCADIApQIAZBAEdxrXwiCiADVK18IQQgCiEDCyAGRQ0BCxA0GgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC40CAgJ/A34jAEEQayICJAACQAJAIAG9IgRC////////////AIMiBUKAgICAgICAeHxC/////////+//AFYNACAFQjyGIQYgBUIEiEKAgICAgICAgDx8IQUMAQsCQCAFQoCAgICAgID4/wBUDQAgBEI8hiEGIARCBIhCgICAgICAwP//AIQhBQwBCwJAIAVQRQ0AQgAhBkIAIQUMAQsgAiAFQgAgBKdnQSBqIAVCIIinZyAFQoCAgIAQVBsiA0ExahAjIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvgAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNAEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQL2AECAX8CfkF/IQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQACQCACIACEIAYgBYSEUEUNAEEADwsCQCADIAGDQgBTDQAgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAuuAQACQAJAIAFBgAhIDQAgAEQAAAAAAADgf6IhAAJAIAFB/w9PDQAgAUGBeGohAQwCCyAARAAAAAAAAOB/oiEAIAFB/RcgAUH9F0gbQYJwaiEBDAELIAFBgXhKDQAgAEQAAAAAAABgA6IhAAJAIAFBuHBNDQAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEobQZIPaiEBCyAAIAFB/wdqrUI0hr+iCzUAIAAgATcDACAAIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGIAJC////////P4OENwMIC3ECAX8CfiMAQRBrIgIkAAJAAkAgAQ0AQgAhA0IAIQQMAQsgAiABrUIAIAFnIgFB0QBqECMgAkEIaikDAEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiQAC0cBAX8jAEEQayIFJAAgBSABIAIgAyAEQoCAgICAgICAgH+FEDUgBSkDACEEIAAgBUEIaikDADcDCCAAIAQ3AwAgBUEQaiQAC+ICAQF/IwBB0ABrIgQkAAJAAkAgA0GAgAFIDQAgBEEgaiABIAJCAEKAgICAgICA//8AEDIgBEEgakEIaikDACECIAQpAyAhAQJAIANB//8BTw0AIANBgYB/aiEDDAILIARBEGogASACQgBCgICAgICAgP//ABAyIANB/f8CIANB/f8CSBtBgoB+aiEDIARBEGpBCGopAwAhAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEHAAGogASACQgBCgICAgICAgDkQMiAEQcAAakEIaikDACECIAQpA0AhAQJAIANB9IB+TQ0AIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQMiADQeiBfSADQeiBfUobQZr+AWohAyAEQTBqQQhqKQMAIQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQMiAAIARBCGopAwA3AwggACAEKQMANwMAIARB0ABqJAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCADQv////8PgyACIAF+fCIBQiCIfDcDCCAAIAFCIIYgBUL/////D4OENwMAC9IQAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEMDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEMIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAkKAgICAgIDA//8AhYRQRQ0AQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINAEIAIQEMAgsCQCABIA2EQgBSDQBCgICAgICA4P//ACAMIAMgAoRQGyEMQgAhAQwCCwJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQcACaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQI0EQIAhrIQggBUHIAmopAwAhCyAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAKIAMgCiAKUCIJG3kgCUEGdK18pyIJQXFqECMgCSAIakFwaiEIIAVBuAJqKQMAIQogBSkDsAIhAwsgBUGgAmogA0IxiCAKQoCAgICAgMAAhCIOQg+GhCICQgBCgICAgLDmvIL1ACACfSIEQgAQPiAFQZACakIAIAVBoAJqQQhqKQMAfUIAIARCABA+IAVBgAJqIAUpA5ACQj+IIAVBkAJqQQhqKQMAQgGGhCIEQgAgAkIAED4gBUHwAWogBEIAQgAgBUGAAmpBCGopAwB9QgAQPiAFQeABaiAFKQPwAUI/iCAFQfABakEIaikDAEIBhoQiBEIAIAJCABA+IAVB0AFqIARCAEIAIAVB4AFqQQhqKQMAfUIAED4gBUHAAWogBSkD0AFCP4ggBUHQAWpBCGopAwBCAYaEIgRCACACQgAQPiAFQbABaiAEQgBCACAFQcABakEIaikDAH1CABA+IAVBoAFqIAJCACAFKQOwAUI/iCAFQbABakEIaikDAEIBhoRCf3wiBEIAED4gBUGQAWogA0IPhkIAIARCABA+IAVB8ABqIARCAEIAIAVBoAFqQQhqKQMAIAUpA6ABIgogBUGQAWpBCGopAwB8IgIgClStfCACQgFWrXx9QgAQPiAFQYABakIBIAJ9QgAgBEIAED4gCCAHIAZraiEGAkACQCAFKQNwIg9CAYYiECAFKQOAAUI/iCAFQYABakEIaikDACIRQgGGhHwiDUKZk398IhJCIIgiAiALQoCAgICAgMAAhCITQgGGIhRCIIgiBH4iFSABQgGGIhZCIIgiCiAFQfAAakEIaikDAEIBhiAPQj+IhCARQj+IfCANIBBUrXwgEiANVK18Qn98Ig9CIIgiDX58IhAgFVStIBAgD0L/////D4MiDyABQj+IIhcgC0IBhoRC/////w+DIgt+fCIRIBBUrXwgDSAEfnwgDyAEfiIVIAsgDX58IhAgFVStQiCGIBBCIIiEfCARIBBCIIZ8IhAgEVStfCAQIBJC/////w+DIhIgC34iFSACIAp+fCIRIBVUrSARIA8gFkL+////D4MiFX58IhggEVStfHwiESAQVK18IBEgEiAEfiIQIBUgDX58IgQgAiALfnwiDSAPIAp+fCIPQiCIIAQgEFStIA0gBFStfCAPIA1UrXxCIIaEfCIEIBFUrXwgBCAYIAIgFX4iAiASIAp+fCIKQiCIIAogAlStQiCGhHwiAiAYVK0gAiAPQiCGfCACVK18fCICIARUrXwiBEL/////////AFYNACAUIBeEIRMgBUHQAGogAiAEIAMgDhA+IAFCMYYgBUHQAGpBCGopAwB9IAUpA1AiAUIAUq19IQ0gBkH+/wBqIQZCACABfSEKDAELIAVB4ABqIAJCAYggBEI/hoQiAiAEQgGIIgQgAyAOED4gAUIwhiAFQeAAakEIaikDAH0gBSkDYCIKQgBSrX0hDSAGQf//AGohBkIAIAp9IQogASEWCwJAIAZB//8BSA0AIAxCgICAgICAwP//AIQhDEIAIQEMAQsCQAJAIAZBAUgNACANQgGGIApCP4iEIQ0gBq1CMIYgBEL///////8/g4QhDyAKQgGGIQQMAQsCQCAGQY9/Sg0AQgAhAQwCCyAFQcAAaiACIARBASAGaxAkIAVBMGogFiATIAZB8ABqECMgBUEgaiADIA4gBSkDQCICIAVBwABqQQhqKQMAIg8QPiAFQTBqQQhqKQMAIAVBIGpBCGopAwBCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSENIAQgAX0hBAsgBUEQaiADIA5CA0IAED4gBSADIA5CBUIAED4gDyACIAJCAYMiASAEfCIEIANWIA0gBCABVK18IgEgDlYgASAOURutfCIDIAJUrXwiAiADIAJCgICAgICAwP//AFQgBCAFKQMQViABIAVBEGpBCGopAwAiAlYgASACURtxrXwiAiADVK18IgMgAiADQoCAgICAgMD//wBUIAQgBSkDAFYgASAFQQhqKQMAIgRWIAEgBFEbca18IgEgAlStfCAMhCEMCyAAIAE3AwAgACAMNwMIIAVB0AJqJAALSwIBfgJ/IAFC////////P4MhAgJAAkAgAUIwiKdB//8BcSIDQf//AUYNAEEEIQQgAw0BQQJBAyACIACEUBsPCyACIACEUCEECyAEC8kGAgR/A34jAEGAAWsiBSQAAkACQAJAIAMgBEIAQgAQN0UNACADIAQQQCEGIAJCMIinIgdB//8BcSIIQf//AUYNACAGDQELIAVBEGogASACIAMgBBAyIAUgBSkDECIEIAVBEGpBCGopAwAiAyAEIAMQPyAFQQhqKQMAIQIgBSkDACEEDAELAkAgASACQv///////////wCDIgkgAyAEQv///////////wCDIgoQN0EASg0AAkAgASAJIAMgChA3RQ0AIAEhBAwCCyAFQfAAaiABIAJCAEIAEDIgBUH4AGopAwAhAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGAkACQCAIRQ0AIAEhBAwBCyAFQeAAaiABIAlCAEKAgICAgIDAu8AAEDIgBUHoAGopAwAiCUIwiKdBiH9qIQggBSkDYCEECwJAIAYNACAFQdAAaiADIApCAEKAgICAgIDAu8AAEDIgBUHYAGopAwAiCkIwiKdBiH9qIQYgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCELIAlC////////P4NCgICAgICAwACEIQkCQCAIIAZMDQADQAJAAkAgCSALfSAEIANUrX0iCkIAUw0AAkAgCiAEIAN9IgSEQgBSDQAgBUEgaiABIAJCAEIAEDIgBUEoaikDACECIAUpAyAhBAwFCyAKQgGGIARCP4iEIQkMAQsgCUIBhiAEQj+IhCEJCyAEQgGGIQQgCEF/aiIIIAZKDQALIAYhCAsCQAJAIAkgC30gBCADVK19IgpCAFkNACAJIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEDIgBUE4aikDACECIAUpAzAhBAwBCwJAIApC////////P1YNAANAIARCP4ghAyAIQX9qIQggBEIBhiEEIAMgCkIBhoQiCkKAgICAgIDAAFQNAAsLIAdBgIACcSEGAkAgCEEASg0AIAVBwABqIAQgCkL///////8/gyAIQfgAaiAGcq1CMIaEQgBCgICAgICAwMM/EDIgBUHIAGopAwAhAiAFKQNAIQQMAQsgCkL///////8/gyAIIAZyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQACxwAIAAgAkL///////////8AgzcDCCAAIAE3AwAL+QgCBX8DfiMAQTBrIgQkAEIAIQkCQAJAIAJBAksNACACQQJ0IgJBzIAE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A0EtRiEEIAJBRmohBSABRQ0BIAVBdUsNASAAKQNwQgBTDQIgACAAKAIEQX9qNgIEDAILIANBRmohBUEAIQQgAyECCyAFQXZJDQBCACEGAkAgAkFQakEKTw0AQQAhAwNAIAIgA0EKbGohAwJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgA0FQaiEDAkAgAkFQaiIFQQlLDQAgA0HMmbPmAEgNAQsLIAOsIQYgBUEKTw0AA0AgAq0gBkIKfnwhBgJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgBkJQfCEGAkAgAkFQaiIDQQlLDQAgBkKuj4XXx8LrowFTDQELCyADQQpPDQADQAJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgAkFQakEKSQ0ACwsCQCAAKQNwQgBTDQAgACAAKAIEQX9qNgIEC0IAIAZ9IAYgBBshBgwBC0KAgICAgICAgIB/IQYgACkDcEIAUw0AIAAgACgCBEF/ajYCBEKAgICAgICAgIB/DwsgBgviAwICfwJ+IwBBIGsiAiQAAkACQCABQv///////////wCDIgRCgICAgICAwP9DfCAEQoCAgICAgMCAvH98Wg0AIABCPIggAUIEhoQhBAJAIABC//////////8PgyIAQoGAgICAgICACFQNACAEQoGAgICAgICAwAB8IQUMAgsgBEKAgICAgICAgMAAfCEFIABCgICAgICAgIAIUg0BIAUgBEIBg3whBQwBCwJAIABQIARCgICAgICAwP//AFQgBEKAgICAgIDA//8AURsNACAAQjyIIAFCBIaEQv////////8Dg0KAgICAgICA/P8AhCEFDAELQoCAgICAgID4/wAhBSAEQv///////7//wwBWDQBCACEFIARCMIinIgNBkfcASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIEIANB/4h/ahAjIAIgACAEQYH4ACADaxAkIAIpAwAiBEI8iCACQQhqKQMAQgSGhCEFAkAgBEL//////////w+DIAIpAxAgAkEQakEIaikDAIRCAFKthCIEQoGAgICAgICACFQNACAFQgF8IQUMAQsgBEKAgICAgICAgAhSDQAgBUIBgyAFfCEFCyACQSBqJAAgBSABQoCAgICAgICAgH+DhL8LhAECAX8CfiMAQaABayIEJAAgBCABNgI8IAQgATYCFCAEQX82AhggBEEQakIAEC0gBCAEQRBqIANBARBDIARBCGopAwAhBSAEKQMAIQYCQCACRQ0AIAIgASAEKAIUIAQoAogBaiAEKAI8a2o2AgALIAAgBTcDCCAAIAY3AwAgBEGgAWokAAszAgF/AXwjAEEQayICJAAgAiAAIAFBARBIIAIpAwAgAkEIaikDABBHIQMgAkEQaiQAIAMLCAAgAEEAEEkLtAIBA38CQCAADQBBACEBAkBBACgC5IQERQ0AQQAoAuSEBBBLIQELAkBBACgC5IQERQ0AQQAoAuSEBBBLIAFyIQELAkAQJygCACIARQ0AA0BBACECAkAgACgCTEEASA0AIAAQKSECCwJAIAAoAhQgACgCHEYNACAAEEsgAXIhAQsCQCACRQ0AIAAQKgsgACgCOCIADQALCxAoIAEPC0EAIQICQCAAKAJMQQBIDQAgABApIQILAkACQAJAIAAoAhQgACgCHEYNACAAQQBBACAAKAIkEQIAGiAAKAIUDQBBfyEBIAINAQwCCwJAIAAoAgQiASAAKAIIIgNGDQAgACABIANrrEEBIAAoAigRGwAaC0EAIQEgAEEANgIcIABCADcDECAAQgA3AgQgAkUNAQsgABAqCyABCwoAIABBUGpBCkkLjAEBBX8DQCAAIgFBAWohACABLAAAEC8NAAtBACECQQAhA0EAIQQCQAJAAkAgASwAACIFQVVqDgMBAgACC0EBIQMLIAAsAAAhBSAAIQEgAyEECwJAIAUQTEUNAANAIAJBCmwgASwAAGtBMGohAiABLAABIQAgAUEBaiEBIAAQTA0ACwsgAkEAIAJrIAQbCwtrAgBBgIAEC1hpbmZpbml0eQBuYW4AAAAA0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AEHYgAQLBHACAQA=\";\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      var binary = tryParseAsDataURI(file);\n      if (binary) {\n        return binary;\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n\n    function getBinaryPromise(binaryFile) {\n      // Otherwise, getBinarySync should be able to get it synchronously\n      return Promise.resolve().then(() => getBinarySync(binaryFile));\n    }\n\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile)\n        .then((binary) => {\n          return WebAssembly.instantiate(binary, imports);\n        })\n        .then((instance) => {\n          return instance;\n        })\n        .then(receiver, (reason) => {\n          err(`failed to asynchronously prepare wasm: ${reason}`);\n\n          // Warn on some common problems.\n          if (isFileURI(wasmBinaryFile)) {\n            err(\n              `warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`,\n            );\n          }\n          abort(reason);\n        });\n    }\n\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n\n    // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n    function createWasm() {\n      // prepare imports\n      var info = {\n        env: wasmImports,\n        wasi_snapshot_preview1: wasmImports,\n      };\n      // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n      /** @param {WebAssembly.Module=} module*/\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n\n        wasmExports = exports;\n\n        wasmMemory = wasmExports[\"memory\"];\n        Module[\"wasmMemory\"] = wasmMemory;\n        assert(wasmMemory, \"memory not found in wasm exports\");\n        // This assertion doesn't hold when emscripten is run in --post-link\n        // mode.\n        // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.\n        //assert(wasmMemory.buffer.byteLength === 16777216);\n        updateMemoryViews();\n\n        wasmTable = wasmExports[\"__indirect_function_table\"];\n\n        assert(wasmTable, \"table not found in wasm exports\");\n\n        addOnInit(wasmExports[\"__wasm_call_ctors\"]);\n\n        removeRunDependency(\"wasm-instantiate\");\n        return exports;\n      }\n      // wait for the pthread pool (if any)\n      addRunDependency(\"wasm-instantiate\");\n\n      // Prefer streaming instantiation if available.\n      // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n      var trueModule = Module;\n      function receiveInstantiationResult(result) {\n        // 'result' is a ResultObject object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(\n          Module === trueModule,\n          \"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?\",\n        );\n        trueModule = null;\n        // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above PTHREADS-enabled path.\n        receiveInstance(result[\"instance\"]);\n      }\n\n      // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to\n      // run the instantiation parallel to any other async startup actions they are\n      // performing.\n      // Also pthreads and wasm workers initialize the wasm instance through this\n      // path.\n      if (Module[\"instantiateWasm\"]) {\n        try {\n          return Module[\"instantiateWasm\"](info, receiveInstance);\n        } catch (e) {\n          err(`Module.instantiateWasm callback failed with error: ${e}`);\n          // If instantiation fails, reject the module ready promise.\n          readyPromiseReject(e);\n        }\n      }\n\n      // If instantiation fails, reject the module ready promise.\n      instantiateAsync(\n        wasmBinary,\n        wasmBinaryFile,\n        info,\n        receiveInstantiationResult,\n      ).catch(readyPromiseReject);\n      return {}; // no exports yet; we'll fill them in later\n    }\n\n    // Globals used by JS i64 conversions (see makeSetValue)\n    var tempDouble;\n    var tempI64;\n\n    // include: runtime_debug.js\n    function legacyModuleProp(prop, newName, incomming = true) {\n      if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n        Object.defineProperty(Module, prop, {\n          configurable: true,\n          get() {\n            let extra = incomming\n              ? \" (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)\"\n              : \"\";\n            abort(\n              `\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra,\n            );\n          },\n        });\n      }\n    }\n\n    function ignoredModuleProp(prop) {\n      if (Object.getOwnPropertyDescriptor(Module, prop)) {\n        abort(\n          `\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`,\n        );\n      }\n    }\n\n    // forcing the filesystem exports a few things by default\n    function isExportedByForceFilesystem(name) {\n      return (\n        name === \"FS_createPath\" ||\n        name === \"FS_createDataFile\" ||\n        name === \"FS_createPreloadedFile\" ||\n        name === \"FS_unlink\" ||\n        name === \"addRunDependency\" ||\n        // The old FS has some functionality that WasmFS lacks.\n        name === \"FS_createLazyFile\" ||\n        name === \"FS_createDevice\" ||\n        name === \"removeRunDependency\"\n      );\n    }\n\n    function missingGlobal(sym, msg) {\n      if (typeof globalThis !== \"undefined\") {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            warnOnce(\n              \"`\" + sym + \"` is not longer defined by emscripten. \" + msg,\n            );\n            return undefined;\n          },\n        });\n      }\n    }\n\n    missingGlobal(\"buffer\", \"Please use HEAP8.buffer or wasmMemory.buffer\");\n    missingGlobal(\"asm\", \"Please use wasmExports instead\");\n\n    function missingLibrarySymbol(sym) {\n      if (\n        typeof globalThis !== \"undefined\" &&\n        !Object.getOwnPropertyDescriptor(globalThis, sym)\n      ) {\n        Object.defineProperty(globalThis, sym, {\n          configurable: true,\n          get() {\n            // Can't `abort()` here because it would break code that does runtime\n            // checks.  e.g. `if (typeof SDL === 'undefined')`.\n            var msg =\n              \"`\" +\n              sym +\n              \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\";\n            // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n            // library.js, which means $name for a JS name with no prefix, or name\n            // for a JS name like _name.\n            var librarySymbol = sym;\n            if (!librarySymbol.startsWith(\"_\")) {\n              librarySymbol = \"$\" + sym;\n            }\n            msg +=\n              \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\" +\n              librarySymbol +\n              \"')\";\n            if (isExportedByForceFilesystem(sym)) {\n              msg +=\n                \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n            }\n            warnOnce(msg);\n            return undefined;\n          },\n        });\n      }\n      // Any symbol that is not included from the JS libary is also (by definition)\n      // not exported on the Module object.\n      unexportedRuntimeSymbol(sym);\n    }\n\n    function unexportedRuntimeSymbol(sym) {\n      if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n        Object.defineProperty(Module, sym, {\n          configurable: true,\n          get() {\n            var msg =\n              \"'\" +\n              sym +\n              \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\";\n            if (isExportedByForceFilesystem(sym)) {\n              msg +=\n                \". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you\";\n            }\n            abort(msg);\n          },\n        });\n      }\n    }\n\n    // Used by XXXXX_DEBUG settings to output debug messages.\n    function dbg(text) {\n      // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n      // logging to show up as warnings.\n      console.warn.apply(console, arguments);\n    }\n    // end include: runtime_debug.js\n    // === Body ===\n\n    // end include: preamble.js\n\n    /** @constructor */\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = `Program terminated with exit(${status})`;\n      this.status = status;\n    }\n\n    var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n    function getValue(ptr, type = \"i8\") {\n      if (type.endsWith(\"*\")) type = \"*\";\n      switch (type) {\n        case \"i1\":\n          return HEAP8[ptr >> 0];\n        case \"i8\":\n          return HEAP8[ptr >> 0];\n        case \"i16\":\n          return HEAP16[ptr >> 1];\n        case \"i32\":\n          return HEAP32[ptr >> 2];\n        case \"i64\":\n          abort(\"to do getValue(i64) use WASM_BIGINT\");\n        case \"float\":\n          return HEAPF32[ptr >> 2];\n        case \"double\":\n          return HEAPF64[ptr >> 3];\n        case \"*\":\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(`invalid type for getValue: ${type}`);\n      }\n    }\n\n    var ptrToString = (ptr) => {\n      assert(typeof ptr === \"number\");\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      ptr >>>= 0;\n      return \"0x\" + ptr.toString(16).padStart(8, \"0\");\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n    function setValue(ptr, value, type = \"i8\") {\n      if (type.endsWith(\"*\")) type = \"*\";\n      switch (type) {\n        case \"i1\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i8\":\n          HEAP8[ptr >> 0] = value;\n          break;\n        case \"i16\":\n          HEAP16[ptr >> 1] = value;\n          break;\n        case \"i32\":\n          HEAP32[ptr >> 2] = value;\n          break;\n        case \"i64\":\n          abort(\"to do setValue(i64) use WASM_BIGINT\");\n        case \"float\":\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case \"double\":\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case \"*\":\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(`invalid type for setValue: ${type}`);\n      }\n    }\n\n    var warnOnce = (text) => {\n      if (!warnOnce.shown) warnOnce.shown = {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    };\n\n    var _emscripten_memcpy_big = (dest, src, num) =>\n      HEAPU8.copyWithin(dest, src, src + num);\n\n    var getHeapMax = () => HEAPU8.length;\n\n    var abortOnCannotGrowMemory = (requestedSize) => {\n      abort(\n        `Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`,\n      );\n    };\n    var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      abortOnCannotGrowMemory(requestedSize);\n    };\n\n    var getCFunc = (ident) => {\n      var func = Module[\"_\" + ident]; // closure exported function\n      assert(\n        func,\n        \"Cannot call unknown function \" + ident + \", make sure it is exported\",\n      );\n      return func;\n    };\n\n    var writeArrayToMemory = (array, buffer) => {\n      assert(\n        array.length >= 0,\n        \"writeArrayToMemory array must have a length (should be an array or typed array)\",\n      );\n      HEAP8.set(array, buffer);\n    };\n\n    var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7f) {\n          len++;\n        } else if (c <= 0x7ff) {\n          len += 2;\n        } else if (c >= 0xd800 && c <= 0xdfff) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n\n    var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === \"string\");\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0)) return 0;\n\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xd800 && u <= 0xdfff) {\n          var u1 = str.charCodeAt(++i);\n          u = (0x10000 + ((u & 0x3ff) << 10)) | (u1 & 0x3ff);\n        }\n        if (u <= 0x7f) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7ff) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xc0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xffff) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xe0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10ffff)\n            warnOnce(\n              \"Invalid Unicode code point \" +\n                ptrToString(u) +\n                \" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).\",\n            );\n          heap[outIdx++] = 0xf0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(\n        typeof maxBytesToWrite == \"number\",\n        \"stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!\",\n      );\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n\n    var UTF8Decoder =\n      typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n\n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n    var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = \"\";\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xe0) == 0xc0) {\n          str += String.fromCharCode(((u0 & 31) << 6) | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xf0) == 0xe0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xf8) != 0xf0)\n            warnOnce(\n              \"Invalid UTF-8 leading byte \" +\n                ptrToString(u0) +\n                \" encountered when deserializing a UTF-8 string in wasm memory to a JS string!\",\n            );\n          u0 =\n            ((u0 & 7) << 18) |\n            (u1 << 12) |\n            (u2 << 6) |\n            (heapOrArray[idx++] & 63);\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(\n            0xd800 | (ch >> 10),\n            0xdc00 | (ch & 0x3ff),\n          );\n        }\n      }\n      return str;\n    };\n\n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n    var UTF8ToString = (ptr, maxBytesToRead) => {\n      assert(typeof ptr == \"number\");\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n    };\n\n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n    var ccall = (ident, returnType, argTypes, args, opts) => {\n      // For fast lookup of conversion functions\n      var toC = {\n        string: (str) => {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        array: (arr) => {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        },\n      };\n\n      function convertReturnValue(ret) {\n        if (returnType === \"string\") {\n          return UTF8ToString(ret);\n        }\n        if (returnType === \"boolean\") return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== \"array\", 'Return type should not be \"array\".');\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(null, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n\n      ret = onDone(ret);\n      return ret;\n    };\n\n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n    var cwrap = (ident, returnType, argTypes, opts) => {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    };\n\n    var stringToNewUTF8 = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = _malloc(size);\n      if (ret) stringToUTF8(str, ret, size);\n      return ret;\n    };\n\n    var uleb128Encode = (n, target) => {\n      assert(n < 16384);\n      if (n < 128) {\n        target.push(n);\n      } else {\n        target.push(n % 128 | 128, n >> 7);\n      }\n    };\n\n    var sigToWasmTypes = (sig) => {\n      assert(\n        !sig.includes(\"j\"),\n        \"i64 not permitted in function signatures when WASM_BIGINT is disabled\",\n      );\n      var typeNames = {\n        i: \"i32\",\n        j: \"i64\",\n        f: \"f32\",\n        d: \"f64\",\n        p: \"i32\",\n      };\n      var type = {\n        parameters: [],\n        results: sig[0] == \"v\" ? [] : [typeNames[sig[0]]],\n      };\n      for (var i = 1; i < sig.length; ++i) {\n        assert(sig[i] in typeNames, \"invalid signature char: \" + sig[i]);\n        type.parameters.push(typeNames[sig[i]]);\n      }\n      return type;\n    };\n\n    var generateFuncType = (sig, target) => {\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        i: 0x7f, // i32\n        p: 0x7f, // i32\n        j: 0x7e, // i64\n        f: 0x7d, // f32\n        d: 0x7c, // f64\n      };\n\n      // Parameters, length + signatures\n      target.push(0x60 /* form: func */);\n      uleb128Encode(sigParam.length, target);\n      for (var i = 0; i < sigParam.length; ++i) {\n        assert(\n          sigParam[i] in typeCodes,\n          \"invalid signature char: \" + sigParam[i],\n        );\n        target.push(typeCodes[sigParam[i]]);\n      }\n\n      // Return values, length + signatures\n      // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n      if (sigRet == \"v\") {\n        target.push(0x00);\n      } else {\n        target.push(0x01, typeCodes[sigRet]);\n      }\n    };\n    var convertJsFunctionToWasm = (func, sig) => {\n      assert(\n        !sig.includes(\"j\"),\n        \"i64 not permitted in function signatures when WASM_BIGINT is disabled\",\n      );\n\n      // If the type reflection proposal is available, use the new\n      // \"WebAssembly.Function\" constructor.\n      // Otherwise, construct a minimal wasm module importing the JS function and\n      // re-exporting it.\n      if (typeof WebAssembly.Function == \"function\") {\n        return new WebAssembly.Function(sigToWasmTypes(sig), func);\n      }\n\n      // The module is static, with the exception of the type section, which is\n      // generated based on the signature passed in.\n      var typeSectionBody = [\n        0x01, // count: 1\n      ];\n      generateFuncType(sig, typeSectionBody);\n\n      // Rest of the module is static\n      var bytes = [\n        0x00,\n        0x61,\n        0x73,\n        0x6d, // magic (\"\\0asm\")\n        0x01,\n        0x00,\n        0x00,\n        0x00, // version: 1\n        0x01, // Type section code\n      ];\n      // Write the overall length of the type section followed by the body\n      uleb128Encode(typeSectionBody.length, bytes);\n      bytes.push.apply(bytes, typeSectionBody);\n\n      // The rest of the module is static\n      bytes.push(\n        0x02,\n        0x07, // import section\n        // (import \"e\" \"f\" (func 0 (type 0)))\n        0x01,\n        0x01,\n        0x65,\n        0x01,\n        0x66,\n        0x00,\n        0x00,\n        0x07,\n        0x05, // export section\n        // (export \"f\" (func 0 (type 0)))\n        0x01,\n        0x01,\n        0x66,\n        0x00,\n        0x00,\n      );\n\n      // We can compile this wasm module synchronously because it is very small.\n      // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n      var module = new WebAssembly.Module(new Uint8Array(bytes));\n      var instance = new WebAssembly.Instance(module, { e: { f: func } });\n      var wrappedFunc = instance.exports[\"f\"];\n      return wrappedFunc;\n    };\n\n    var wasmTableMirror = [];\n    var getWasmTableEntry = (funcPtr) => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        if (funcPtr >= wasmTableMirror.length)\n          wasmTableMirror.length = funcPtr + 1;\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      assert(\n        wasmTable.get(funcPtr) == func,\n        \"JavaScript-side Wasm function table mirror is out of date!\",\n      );\n      return func;\n    };\n\n    var updateTableMap = (offset, count) => {\n      if (functionsInTableMap) {\n        for (var i = offset; i < offset + count; i++) {\n          var item = getWasmTableEntry(i);\n          // Ignore null values.\n          if (item) {\n            functionsInTableMap.set(item, i);\n          }\n        }\n      }\n    };\n\n    var functionsInTableMap = undefined;\n    var getFunctionAddress = (func) => {\n      // First, create the map if this is the first use.\n      if (!functionsInTableMap) {\n        functionsInTableMap = new WeakMap();\n        updateTableMap(0, wasmTable.length);\n      }\n      return functionsInTableMap.get(func) || 0;\n    };\n\n    var freeTableIndexes = [];\n    var getEmptyTableSlot = () => {\n      // Reuse a free index if there is one, otherwise grow.\n      if (freeTableIndexes.length) {\n        return freeTableIndexes.pop();\n      }\n      // Grow the table\n      try {\n        wasmTable.grow(1);\n      } catch (err) {\n        if (!(err instanceof RangeError)) {\n          throw err;\n        }\n        throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n      }\n      return wasmTable.length - 1;\n    };\n\n    var setWasmTableEntry = (idx, func) => {\n      wasmTable.set(idx, func);\n      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped\n      // functions so we need to call it here to retrieve the potential wrapper correctly\n      // instead of just storing 'func' directly into wasmTableMirror\n      wasmTableMirror[idx] = wasmTable.get(idx);\n    };\n    /** @param {string=} sig */\n    var addFunction = (func, sig) => {\n      assert(typeof func != \"undefined\");\n      // Check if the function is already in the table, to ensure each function\n      // gets a unique index.\n      var rtn = getFunctionAddress(func);\n      if (rtn) {\n        return rtn;\n      }\n\n      // It's not in the table, add it now.\n\n      var ret = getEmptyTableSlot();\n\n      // Set the new value.\n      try {\n        // Attempting to call this with JS function will cause of table.set() to fail\n        setWasmTableEntry(ret, func);\n      } catch (err) {\n        if (!(err instanceof TypeError)) {\n          throw err;\n        }\n        assert(\n          typeof sig != \"undefined\",\n          \"Missing signature argument to addFunction: \" + func,\n        );\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        setWasmTableEntry(ret, wrapped);\n      }\n\n      functionsInTableMap.set(func, ret);\n\n      return ret;\n    };\n    function checkIncomingModuleAPI() {\n      ignoredModuleProp(\"fetchSettings\");\n    }\n    var wasmImports = {\n      emscripten_memcpy_big: _emscripten_memcpy_big,\n      emscripten_resize_heap: _emscripten_resize_heap,\n    };\n    var wasmExports = createWasm();\n    var ___wasm_call_ctors = createExportWrapper(\"__wasm_call_ctors\");\n    var ___errno_location = createExportWrapper(\"__errno_location\");\n    var _abs = (Module[\"_abs\"] = createExportWrapper(\"abs\"));\n    var _atof = (Module[\"_atof\"] = createExportWrapper(\"atof\"));\n    var _atoi = (Module[\"_atoi\"] = createExportWrapper(\"atoi\"));\n    var _bsearch = (Module[\"_bsearch\"] = createExportWrapper(\"bsearch\"));\n    var _fflush = (Module[\"_fflush\"] = createExportWrapper(\"fflush\"));\n    var _labs = (Module[\"_labs\"] = createExportWrapper(\"labs\"));\n    var _qsort = (Module[\"_qsort\"] = createExportWrapper(\"qsort\"));\n    var _srand = (Module[\"_srand\"] = createExportWrapper(\"srand\"));\n    var _rand = (Module[\"_rand\"] = createExportWrapper(\"rand\"));\n    var _malloc = (Module[\"_malloc\"] = createExportWrapper(\"malloc\"));\n    var _free = (Module[\"_free\"] = createExportWrapper(\"free\"));\n    var _emscripten_stack_init = () =>\n      (_emscripten_stack_init = wasmExports[\"emscripten_stack_init\"])();\n    var _emscripten_stack_get_free = () =>\n      (_emscripten_stack_get_free = wasmExports[\"emscripten_stack_get_free\"])();\n    var _emscripten_stack_get_base = () =>\n      (_emscripten_stack_get_base = wasmExports[\"emscripten_stack_get_base\"])();\n    var _emscripten_stack_get_end = () =>\n      (_emscripten_stack_get_end = wasmExports[\"emscripten_stack_get_end\"])();\n    var stackSave = createExportWrapper(\"stackSave\");\n    var stackRestore = createExportWrapper(\"stackRestore\");\n    var stackAlloc = createExportWrapper(\"stackAlloc\");\n    var _emscripten_stack_get_current = () =>\n      (_emscripten_stack_get_current =\n        wasmExports[\"emscripten_stack_get_current\"])();\n\n    // include: postamble.js\n    // === Auto-generated postamble setup entry stuff ===\n\n    // include: base64Utils.js\n    // Converts a string of base64 into a byte array.\n    // Throws error on invalid input.\n    function intArrayFromBase64(s) {\n      try {\n        var decoded = atob(s);\n        var bytes = new Uint8Array(decoded.length);\n        for (var i = 0; i < decoded.length; ++i) {\n          bytes[i] = decoded.charCodeAt(i);\n        }\n        return bytes;\n      } catch (_) {\n        throw new Error(\"Converting base64 string to bytes failed.\");\n      }\n    }\n\n    // If filename is a base64 data URI, parses and returns data (Buffer on node,\n    // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\n    function tryParseAsDataURI(filename) {\n      if (!isDataURI(filename)) {\n        return;\n      }\n\n      return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n    }\n    // end include: base64Utils.js\n    Module[\"wasmMemory\"] = wasmMemory;\n    Module[\"ccall\"] = ccall;\n    Module[\"cwrap\"] = cwrap;\n    Module[\"addFunction\"] = addFunction;\n    Module[\"stringToNewUTF8\"] = stringToNewUTF8;\n    var missingLibrarySymbols = [\n      \"writeI53ToI64\",\n      \"writeI53ToI64Clamped\",\n      \"writeI53ToI64Signaling\",\n      \"writeI53ToU64Clamped\",\n      \"writeI53ToU64Signaling\",\n      \"readI53FromI64\",\n      \"readI53FromU64\",\n      \"convertI32PairToI53\",\n      \"convertI32PairToI53Checked\",\n      \"convertU32PairToI53\",\n      \"zeroMemory\",\n      \"exitJS\",\n      \"growMemory\",\n      \"isLeapYear\",\n      \"ydayFromDate\",\n      \"arraySum\",\n      \"addDays\",\n      \"setErrNo\",\n      \"inetPton4\",\n      \"inetNtop4\",\n      \"inetPton6\",\n      \"inetNtop6\",\n      \"readSockaddr\",\n      \"writeSockaddr\",\n      \"getHostByName\",\n      \"initRandomFill\",\n      \"randomFill\",\n      \"getCallstack\",\n      \"emscriptenLog\",\n      \"convertPCtoSourceLocation\",\n      \"readEmAsmArgs\",\n      \"jstoi_q\",\n      \"jstoi_s\",\n      \"getExecutableName\",\n      \"listenOnce\",\n      \"autoResumeAudioContext\",\n      \"dynCallLegacy\",\n      \"getDynCaller\",\n      \"dynCall\",\n      \"handleException\",\n      \"runtimeKeepalivePush\",\n      \"runtimeKeepalivePop\",\n      \"callUserCallback\",\n      \"maybeExit\",\n      \"safeSetTimeout\",\n      \"asmjsMangle\",\n      \"asyncLoad\",\n      \"alignMemory\",\n      \"mmapAlloc\",\n      \"handleAllocatorInit\",\n      \"HandleAllocator\",\n      \"getNativeTypeSize\",\n      \"STACK_SIZE\",\n      \"STACK_ALIGN\",\n      \"POINTER_SIZE\",\n      \"ASSERTIONS\",\n      \"removeFunction\",\n      \"reallyNegative\",\n      \"unSign\",\n      \"strLen\",\n      \"reSign\",\n      \"formatString\",\n      \"intArrayFromString\",\n      \"intArrayToString\",\n      \"AsciiToString\",\n      \"stringToAscii\",\n      \"UTF16ToString\",\n      \"stringToUTF16\",\n      \"lengthBytesUTF16\",\n      \"UTF32ToString\",\n      \"stringToUTF32\",\n      \"lengthBytesUTF32\",\n      \"registerKeyEventCallback\",\n      \"maybeCStringToJsString\",\n      \"findEventTarget\",\n      \"findCanvasEventTarget\",\n      \"getBoundingClientRect\",\n      \"fillMouseEventData\",\n      \"registerMouseEventCallback\",\n      \"registerWheelEventCallback\",\n      \"registerUiEventCallback\",\n      \"registerFocusEventCallback\",\n      \"fillDeviceOrientationEventData\",\n      \"registerDeviceOrientationEventCallback\",\n      \"fillDeviceMotionEventData\",\n      \"registerDeviceMotionEventCallback\",\n      \"screenOrientation\",\n      \"fillOrientationChangeEventData\",\n      \"registerOrientationChangeEventCallback\",\n      \"fillFullscreenChangeEventData\",\n      \"registerFullscreenChangeEventCallback\",\n      \"JSEvents_requestFullscreen\",\n      \"JSEvents_resizeCanvasForFullscreen\",\n      \"registerRestoreOldStyle\",\n      \"hideEverythingExceptGivenElement\",\n      \"restoreHiddenElements\",\n      \"setLetterbox\",\n      \"softFullscreenResizeWebGLRenderTarget\",\n      \"doRequestFullscreen\",\n      \"fillPointerlockChangeEventData\",\n      \"registerPointerlockChangeEventCallback\",\n      \"registerPointerlockErrorEventCallback\",\n      \"requestPointerLock\",\n      \"fillVisibilityChangeEventData\",\n      \"registerVisibilityChangeEventCallback\",\n      \"registerTouchEventCallback\",\n      \"fillGamepadEventData\",\n      \"registerGamepadEventCallback\",\n      \"registerBeforeUnloadEventCallback\",\n      \"fillBatteryEventData\",\n      \"battery\",\n      \"registerBatteryEventCallback\",\n      \"setCanvasElementSize\",\n      \"getCanvasElementSize\",\n      \"demangle\",\n      \"demangleAll\",\n      \"jsStackTrace\",\n      \"stackTrace\",\n      \"getEnvStrings\",\n      \"checkWasiClock\",\n      \"flush_NO_FILESYSTEM\",\n      \"wasiRightsToMuslOFlags\",\n      \"wasiOFlagsToMuslOFlags\",\n      \"createDyncallWrapper\",\n      \"setImmediateWrapped\",\n      \"clearImmediateWrapped\",\n      \"polyfillSetImmediate\",\n      \"getPromise\",\n      \"makePromise\",\n      \"idsToPromises\",\n      \"makePromiseCallback\",\n      \"ExceptionInfo\",\n      \"findMatchingCatch\",\n      \"setMainLoop\",\n      \"getSocketFromFD\",\n      \"getSocketAddress\",\n      \"FS_createPreloadedFile\",\n      \"FS_modeStringToFlags\",\n      \"FS_getMode\",\n      \"FS_stdin_getChar\",\n      \"_setNetworkCallback\",\n      \"heapObjectForWebGLType\",\n      \"heapAccessShiftForWebGLHeap\",\n      \"webgl_enable_ANGLE_instanced_arrays\",\n      \"webgl_enable_OES_vertex_array_object\",\n      \"webgl_enable_WEBGL_draw_buffers\",\n      \"webgl_enable_WEBGL_multi_draw\",\n      \"emscriptenWebGLGet\",\n      \"computeUnpackAlignedImageSize\",\n      \"colorChannelsInGlTextureFormat\",\n      \"emscriptenWebGLGetTexPixelData\",\n      \"__glGenObject\",\n      \"emscriptenWebGLGetUniform\",\n      \"webglGetUniformLocation\",\n      \"webglPrepareUniformLocationsBeforeFirstUse\",\n      \"webglGetLeftBracePos\",\n      \"emscriptenWebGLGetVertexAttrib\",\n      \"__glGetActiveAttribOrUniform\",\n      \"writeGLArray\",\n      \"registerWebGlEventCallback\",\n      \"runAndAbortIfError\",\n      \"SDL_unicode\",\n      \"SDL_ttfContext\",\n      \"SDL_audio\",\n      \"GLFW_Window\",\n      \"ALLOC_NORMAL\",\n      \"ALLOC_STACK\",\n      \"allocate\",\n      \"writeStringToMemory\",\n      \"writeAsciiToMemory\",\n    ];\n    missingLibrarySymbols.forEach(missingLibrarySymbol);\n\n    var unexportedSymbols = [\n      \"run\",\n      \"addOnPreRun\",\n      \"addOnInit\",\n      \"addOnPreMain\",\n      \"addOnExit\",\n      \"addOnPostRun\",\n      \"addRunDependency\",\n      \"removeRunDependency\",\n      \"FS_createFolder\",\n      \"FS_createPath\",\n      \"FS_createDataFile\",\n      \"FS_createLazyFile\",\n      \"FS_createLink\",\n      \"FS_createDevice\",\n      \"FS_readFile\",\n      \"FS_unlink\",\n      \"out\",\n      \"err\",\n      \"callMain\",\n      \"abort\",\n      \"keepRuntimeAlive\",\n      \"wasmTable\",\n      \"wasmExports\",\n      \"stackAlloc\",\n      \"stackSave\",\n      \"stackRestore\",\n      \"getTempRet0\",\n      \"setTempRet0\",\n      \"writeStackCookie\",\n      \"checkStackCookie\",\n      \"intArrayFromBase64\",\n      \"tryParseAsDataURI\",\n      \"ptrToString\",\n      \"getHeapMax\",\n      \"abortOnCannotGrowMemory\",\n      \"ENV\",\n      \"MONTH_DAYS_REGULAR\",\n      \"MONTH_DAYS_LEAP\",\n      \"MONTH_DAYS_REGULAR_CUMULATIVE\",\n      \"MONTH_DAYS_LEAP_CUMULATIVE\",\n      \"ERRNO_CODES\",\n      \"ERRNO_MESSAGES\",\n      \"DNS\",\n      \"Protocols\",\n      \"Sockets\",\n      \"timers\",\n      \"warnOnce\",\n      \"UNWIND_CACHE\",\n      \"readEmAsmArgsArray\",\n      \"getCFunc\",\n      \"uleb128Encode\",\n      \"sigToWasmTypes\",\n      \"generateFuncType\",\n      \"convertJsFunctionToWasm\",\n      \"freeTableIndexes\",\n      \"functionsInTableMap\",\n      \"getEmptyTableSlot\",\n      \"updateTableMap\",\n      \"getFunctionAddress\",\n      \"setValue\",\n      \"getValue\",\n      \"PATH\",\n      \"PATH_FS\",\n      \"UTF8Decoder\",\n      \"UTF8ArrayToString\",\n      \"UTF8ToString\",\n      \"stringToUTF8Array\",\n      \"stringToUTF8\",\n      \"lengthBytesUTF8\",\n      \"UTF16Decoder\",\n      \"stringToUTF8OnStack\",\n      \"writeArrayToMemory\",\n      \"JSEvents\",\n      \"specialHTMLTargets\",\n      \"currentFullscreenStrategy\",\n      \"restoreOldWindowedStyle\",\n      \"ExitStatus\",\n      \"promiseMap\",\n      \"uncaughtExceptionCount\",\n      \"exceptionLast\",\n      \"exceptionCaught\",\n      \"Browser\",\n      \"wget\",\n      \"SYSCALLS\",\n      \"preloadPlugins\",\n      \"FS_stdin_getChar_buffer\",\n      \"FS\",\n      \"MEMFS\",\n      \"TTY\",\n      \"PIPEFS\",\n      \"SOCKFS\",\n      \"tempFixedLengthArray\",\n      \"miniTempWebGLFloatBuffers\",\n      \"miniTempWebGLIntBuffers\",\n      \"GL\",\n      \"emscripten_webgl_power_preferences\",\n      \"AL\",\n      \"GLUT\",\n      \"EGL\",\n      \"GLEW\",\n      \"IDBStore\",\n      \"SDL\",\n      \"SDL_gfx\",\n      \"GLFW\",\n      \"allocateUTF8\",\n      \"allocateUTF8OnStack\",\n    ];\n    unexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n    var calledRun;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n\n    function stackCheckInit() {\n      // This is normally called automatically during __wasm_call_ctors but need to\n      // get these values before even running any of the ctors so we call it redundantly\n      // here.\n      _emscripten_stack_init();\n      // TODO(sbc): Move writeStackCookie to native to to avoid this.\n      writeStackCookie();\n    }\n\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n\n      stackCheckInit();\n\n      preRun();\n\n      // a preRun added a dependency, run will be called later\n      if (runDependencies > 0) {\n        return;\n      }\n\n      function doRun() {\n        // run may have just been called through dependencies being fulfilled just in this very frame,\n        // or while the async setStatus time below was happening\n        if (calledRun) return;\n        calledRun = true;\n        Module[\"calledRun\"] = true;\n\n        if (ABORT) return;\n\n        initRuntime();\n\n        readyPromiseResolve(Module);\n        if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n\n        assert(\n          !Module[\"_main\"],\n          'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]',\n        );\n\n        postRun();\n      }\n\n      if (Module[\"setStatus\"]) {\n        Module[\"setStatus\"](\"Running...\");\n        setTimeout(function () {\n          setTimeout(function () {\n            Module[\"setStatus\"](\"\");\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n      checkStackCookie();\n    }\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var oldOut = out;\n      var oldErr = err;\n      var has = false;\n      out = err = (x) => {\n        has = true;\n      };\n      try {\n        // it doesn't matter if it fails\n        _fflush(0);\n      } catch (e) {}\n      out = oldOut;\n      err = oldErr;\n      if (has) {\n        warnOnce(\n          \"stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.\",\n        );\n        warnOnce(\n          \"(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)\",\n        );\n      }\n    }\n\n    if (Module[\"preInit\"]) {\n      if (typeof Module[\"preInit\"] == \"function\")\n        Module[\"preInit\"] = [Module[\"preInit\"]];\n      while (Module[\"preInit\"].length > 0) {\n        Module[\"preInit\"].pop()();\n      }\n    }\n\n    run();\n\n    // end include: postamble.js\n\n    return moduleArg.ready;\n  };\n})();\nif (typeof exports === \"object\" && typeof module === \"object\")\n  module.exports = Module;\nelse if (typeof define === \"function\" && define[\"amd\"])\n  define([], () => Module);\n","/**\n * Compiler for C to webassembly\n */\nimport parse from \"./parser\";\nimport process from \"./processor\";\nimport { generateWat } from \"./wat-generator\";\nimport { compileWatToWasm } from \"./wat-to-wasm\";\nimport translate from \"~src/translator\";\nimport {\n  ParserCompilationErrors,\n  SourceCodeError,\n  generateCompilationWarningMessage,\n  toJson,\n} from \"~src/errors\";\nimport ModuleRepository, {\n  ModuleName,\n  ModulesGlobalConfig,\n} from \"~src/modules\";\nimport { interpret, evaluateTillStep } from \"~src/interpreter/index\";\nimport { CContext } from \"~src/interpreter/interpret\";\n\nexport interface SuccessfulCompilationResult {\n  status: \"success\";\n  wasm: Uint8Array;\n  dataSegmentSize: number;\n  functionTableSize: number; // size of function table = to number of defined functions in program\n  importedModules: ModuleName[]; // all the modules imported into this C program\n  warnings: string[];\n}\n\ninterface FailedCompilationResult {\n  status: \"failure\";\n  errorMessage: string;\n}\n\nexport type CompilationResult =\n  | SuccessfulCompilationResult\n  | FailedCompilationResult;\n\nexport interface SuccessfulEvaluationResult {\n  status: \"success\";\n  context: CContext;\n  importedModules: ModuleName[];\n}\n\ninterface FailedEvaluationResult {\n  status: \"failure\";\n  errorMessage: string;\n}\n\nexport type EvaluationResult =\n  | SuccessfulEvaluationResult\n  | FailedEvaluationResult;\n\nexport async function compile(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n): Promise<CompilationResult> {\n  try {\n    const { cAstRoot, warnings } = parse(cSourceCode, moduleRepository);\n    const {\n      astRootNode,\n      includedModules,\n      warnings: processorWarnings,\n    } = process(cAstRoot, moduleRepository);\n    warnings.push(\n      ...processorWarnings.map((w) =>\n        generateCompilationWarningMessage(w.message, cSourceCode, w.position),\n      ),\n    );\n\n    // interpret(astRootNode, cAstRoot.includedModules, moduleRepository.config); // here\n\n    const wasmModule = translate(astRootNode, moduleRepository);\n    const output = await compileWatToWasm(generateWat(wasmModule));\n    return {\n      status: \"success\",\n      wasm: output,\n      dataSegmentSize: wasmModule.dataSegmentSize,\n      functionTableSize: wasmModule.functionTable.size,\n      importedModules: includedModules,\n      warnings,\n    };\n  } catch (e) {\n    if (e instanceof SourceCodeError) {\n      return {\n        status: \"failure\",\n        errorMessage: e.generateCompilationErrorMessage(cSourceCode),\n      };\n    }\n    if (e instanceof ParserCompilationErrors) {\n      return {\n        status: \"failure\",\n        errorMessage: e.message,\n      };\n    }\n    throw e;\n  }\n}\n\nexport async function evaluate(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n  targetStep: number,\n): Promise<EvaluationResult> {\n  try {\n    const { cAstRoot, warnings } = parse(cSourceCode, moduleRepository);\n    const {\n      astRootNode,\n      includedModules,\n      warnings: processorWarnings,\n    } = process(cAstRoot, moduleRepository);\n    warnings.push(\n      ...processorWarnings.map((w) =>\n        generateCompilationWarningMessage(w.message, cSourceCode, w.position),\n      ),\n    );\n\n    const outputContext = await evaluateTillStep(\n      astRootNode,\n      cAstRoot.includedModules,\n      moduleRepository.config,\n      targetStep,\n      cSourceCode,\n    );\n\n    return {\n      status: \"success\",\n      context: outputContext,\n      importedModules: includedModules,\n    };\n  } catch (e) {\n    if (e instanceof SourceCodeError) {\n      return {\n        status: \"failure\",\n        errorMessage: e.generateCompilationErrorMessage(cSourceCode),\n      };\n    }\n    if (e instanceof ParserCompilationErrors) {\n      return {\n        status: \"failure\",\n        errorMessage: e.message,\n      };\n    }\n    throw e;\n  }\n}\n\ninterface SuccessfulWatCompilationResult {\n  status: \"success\";\n  watOutput: string;\n  warnings: string[];\n}\n\ninterface FailedWatCompilationResult {\n  status: \"failure\";\n  errorMessage: string;\n}\n\nexport type WatCompilationResult =\n  | SuccessfulWatCompilationResult\n  | FailedWatCompilationResult;\n\nexport function compileToWat(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n): WatCompilationResult {\n  try {\n    const { cAstRoot, warnings } = parse(cSourceCode, moduleRepository);\n    const { astRootNode, warnings: processorWarnings } = process(\n      cAstRoot,\n      moduleRepository,\n    );\n    warnings.push(\n      ...processorWarnings.map((w) =>\n        generateCompilationWarningMessage(w.message, cSourceCode, w.position),\n      ),\n    );\n    const wasmModule = translate(astRootNode, moduleRepository);\n    const output = generateWat(wasmModule);\n    return {\n      status: \"success\",\n      watOutput: output,\n      warnings,\n    };\n  } catch (e) {\n    if (e instanceof SourceCodeError) {\n      return {\n        status: \"failure\",\n        errorMessage: e.generateCompilationErrorMessage(cSourceCode),\n      };\n    }\n    if (e instanceof ParserCompilationErrors) {\n      return {\n        status: \"failure\",\n        errorMessage: e.message,\n      };\n    }\n    throw e;\n  }\n}\n\nexport function generate_C_AST(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n) {\n  try {\n    const parsedResult = parse(cSourceCode, moduleRepository);\n    return toJson(parsedResult);\n  } catch (e) {\n    if (e instanceof SourceCodeError) {\n      e.generateCompilationErrorMessage(cSourceCode);\n    }\n    throw e;\n  }\n}\n\nexport function generate_processed_C_AST(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n) {\n  try {\n    const { cAstRoot } = parse(cSourceCode, moduleRepository);\n    const { astRootNode } = process(cAstRoot, moduleRepository);\n    return toJson(astRootNode);\n  } catch (e) {\n    if (e instanceof SourceCodeError) {\n      e.generateCompilationErrorMessage(cSourceCode);\n    }\n    throw e;\n  }\n}\n\nexport function generate_WAT_AST(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n) {\n  const { cAstRoot } = parse(cSourceCode, moduleRepository);\n  const { astRootNode } = process(cAstRoot, moduleRepository);\n  //checkForErrors(cSourceCode, CAst, Object.keys(wasmModuleImports)); // use semantic analyzer to check for semantic errors\n  const wasmAst = translate(astRootNode, moduleRepository);\n  return toJson(wasmAst);\n}\n\nexport function interpret_C_AST(\n  cSourceCode: string,\n  moduleRepository: ModuleRepository,\n  moduleConfig: ModulesGlobalConfig,\n) {\n  const { cAstRoot } = parse(cSourceCode, moduleRepository);\n  const { astRootNode } = process(cAstRoot, moduleRepository);\n  interpret(astRootNode, cAstRoot.includedModules, moduleConfig, cSourceCode);\n}\n","import ModuleRepository from \"~src/modules\";\nimport { CAstRoot } from \"~src/parser/c-ast/core\";\nimport {\n  ParserCompilationErrors,\n  generateCompilationWarningMessage,\n} from \"~src/errors\";\n\nimport preprocessor from \"~src/parser/peggyjs/preprocessor\";\nimport lexer from \"~src/parser/peggyjs/lexer\";\nimport parser from \"~src/parser/peggyjs/parser\";\nimport { Position } from \"~src/parser/c-ast/misc\";\n\nexport interface ParserOutput {\n  cAstRoot: CAstRoot;\n  warnings: string[];\n}\n\nexport default function parse(\n  sourceCode: string,\n  moduleRepository: ModuleRepository,\n) {\n  try {\n    // eslint-disable-next-line\n    // @ts-ignore\n    parser.moduleRepository = moduleRepository; // make moduleRepository available to parser object\n    const preprocessedOutput = preprocessor.parse(sourceCode);\n    // eslint-disable-next-line\n    // @ts-ignore\n    lexer.falseNewlinePositions = preprocessor.falseNewlinePositions;\n    const lexedOutput = lexer.parse(preprocessedOutput);\n    // eslint-disable-next-line\n    // @ts-ignore\n    parser.tokenPositions = lexer.tokenPositions;\n\n    try {\n      const { rootNode, compilationErrors, warnings } =\n        parser.parse(lexedOutput);\n\n      if (compilationErrors.length > 0) {\n        // this handles any errors that were detected but didnt stop parsing\n        throw new ParserCompilationErrors(\n          sourceCode,\n          compilationErrors as { message: string; position: Position }[],\n        );\n      }\n      return {\n        cAstRoot: rootNode,\n        warnings: warnings.map((w: { message: string; position: Position }) =>\n          generateCompilationWarningMessage(w.message, sourceCode, w.position),\n        ),\n      };\n    } catch (e) {\n      // catch syntax errors detected by peggy js\n      // or any error that required immediately ending of parsing\n      if (\"location\" in (e as object)) {\n        // parser locations from syntax errors (or any thrown immediate errors) need to be adjusted\n        if (\n          !(lexer as any).tokenPositions.has((e as any).location.start.offset)\n        ) {\n          // in case the location was a artificial whitespace separating tokens\n          throw new ParserCompilationErrors(sourceCode, [\n            {\n              message: \"syntax error in program\",\n              position: {\n                start: { offset: 0, line: 0, column: 0 },\n                end: { offset: 0, line: 0, column: 0 },\n              },\n            },\n          ]);\n        }\n        const adjustedLocation = {\n          start: (lexer as any).tokenPositions.get(\n            (e as any).location.start.offset,\n          ).start,\n          end: (lexer as any).tokenPositions.get(\n            Math.max(\n              (e as any).location.start.offset,\n              (e as any).location.end.offset - 1,\n            ),\n          ).end,\n        };\n        throw new ParserCompilationErrors(sourceCode, [\n          { message: (e as any).message, position: adjustedLocation },\n        ]);\n      }\n      throw e;\n    }\n  } catch (e) {\n    // catch any other errors\n    if (\n      !(e instanceof ParserCompilationErrors) &&\n      \"location\" in (e as object)\n    ) {\n      throw new ParserCompilationErrors(sourceCode, [\n        { message: (e as any).message, position: (e as any).location },\n      ]);\n    }\n    throw e;\n  }\n}\n","// Generated by Peggy 3.0.2.\n//\n// https://peggyjs.org/\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { program: peg$parseprogram };\n  var peg$startRuleFunction = peg$parseprogram;\n\n  var peg$c0 = \"\\\\\\n\";\n  var peg$c1 = \"//\";\n  var peg$c2 = \"/*\";\n  var peg$c3 = \"\\\"\";\n  var peg$c4 = \"\\n\";\n  var peg$c5 = \"*/\";\n  var peg$c6 = \"\\\\\\\"\";\n\n  var peg$r0 = /^[ \\t\\n\\v\\f]/;\n\n  var peg$e0 = peg$literalExpectation(\"\\\\\\n\", false);\n  var peg$e1 = peg$literalExpectation(\"//\", false);\n  var peg$e2 = peg$literalExpectation(\"/*\", false);\n  var peg$e3 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e4 = peg$anyExpectation();\n  var peg$e5 = peg$literalExpectation(\"\\n\", false);\n  var peg$e6 = peg$literalExpectation(\"*/\", false);\n  var peg$e7 = peg$literalExpectation(\"\\\\\\\"\", false);\n  var peg$e8 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\v\", \"\\f\"], false, false);\n\n  var peg$f0 = function(matches) { return matches.join(\"\") };\n  var peg$f1 = function(comment) { return \" \".repeat(comment.length); };\n  var peg$f2 = function() { thisParser.falseNewlinePositions.push(location().start.offset); return \"\"; };\n  var peg$f3 = function() { return \"\"; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$resultsCache = {};\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseprogram() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 8 + 0;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsepreprocess_match();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsepreprocess_match();\n    }\n    peg$savedPos = s0;\n    s1 = peg$f0(s1);\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepreprocess_match() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 8 + 1;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsecomment();\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f1(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedouble_quoted_string();\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c0) {\n          s1 = peg$c0;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f2();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = [];\n          s2 = peg$currPos;\n          s3 = peg$currPos;\n          peg$silentFails++;\n          if (input.substr(peg$currPos, 2) === peg$c1) {\n            s4 = peg$c1;\n            peg$currPos += 2;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e1); }\n          }\n          peg$silentFails--;\n          if (s4 === peg$FAILED) {\n            s3 = undefined;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$currPos;\n            peg$silentFails++;\n            if (input.substr(peg$currPos, 2) === peg$c2) {\n              s5 = peg$c2;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e2); }\n            }\n            peg$silentFails--;\n            if (s5 === peg$FAILED) {\n              s4 = undefined;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$currPos;\n              peg$silentFails++;\n              if (input.substr(peg$currPos, 2) === peg$c0) {\n                s6 = peg$c0;\n                peg$currPos += 2;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e0); }\n              }\n              peg$silentFails--;\n              if (s6 === peg$FAILED) {\n                s5 = undefined;\n              } else {\n                peg$currPos = s5;\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                peg$silentFails++;\n                if (input.charCodeAt(peg$currPos) === 34) {\n                  s7 = peg$c3;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                }\n                peg$silentFails--;\n                if (s7 === peg$FAILED) {\n                  s6 = undefined;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s7 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s3 = [s3, s4, s5, s6, s7];\n                    s2 = s3;\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n              s2 = peg$currPos;\n              s3 = peg$currPos;\n              peg$silentFails++;\n              if (input.substr(peg$currPos, 2) === peg$c1) {\n                s4 = peg$c1;\n                peg$currPos += 2;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e1); }\n              }\n              peg$silentFails--;\n              if (s4 === peg$FAILED) {\n                s3 = undefined;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$currPos;\n                peg$silentFails++;\n                if (input.substr(peg$currPos, 2) === peg$c2) {\n                  s5 = peg$c2;\n                  peg$currPos += 2;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e2); }\n                }\n                peg$silentFails--;\n                if (s5 === peg$FAILED) {\n                  s4 = undefined;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$currPos;\n                  peg$silentFails++;\n                  if (input.substr(peg$currPos, 2) === peg$c0) {\n                    s6 = peg$c0;\n                    peg$currPos += 2;\n                  } else {\n                    s6 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e0); }\n                  }\n                  peg$silentFails--;\n                  if (s6 === peg$FAILED) {\n                    s5 = undefined;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$currPos;\n                    peg$silentFails++;\n                    if (input.charCodeAt(peg$currPos) === 34) {\n                      s7 = peg$c3;\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                    }\n                    peg$silentFails--;\n                    if (s7 === peg$FAILED) {\n                      s6 = undefined;\n                    } else {\n                      peg$currPos = s6;\n                      s6 = peg$FAILED;\n                    }\n                    if (s6 !== peg$FAILED) {\n                      if (input.length > peg$currPos) {\n                        s7 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                      } else {\n                        s7 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                      }\n                      if (s7 !== peg$FAILED) {\n                        s3 = [s3, s4, s5, s6, s7];\n                        s2 = s3;\n                      } else {\n                        peg$currPos = s2;\n                        s2 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s2;\n                      s2 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s2;\n                  s2 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n          if (s1 !== peg$FAILED) {\n            s0 = input.substring(s0, peg$currPos);\n          } else {\n            s0 = s1;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0;\n\n    var key = peg$currPos * 8 + 2;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsesingle_line_comment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemulti_line_comment();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsesingle_line_comment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 8 + 3;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c1) {\n      s1 = peg$c1;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 10) {\n        s5 = peg$c4;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e5); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 10) {\n          s5 = peg$c4;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e4); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsemulti_line_comment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 8 + 4;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c2) {\n      s1 = peg$c2;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c5) {\n        s5 = peg$c5;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c5) {\n          s5 = peg$c5;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e6); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e4); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c5) {\n        s3 = peg$c5;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedouble_quoted_string() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 8 + 5;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c3;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s5 = peg$c3;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c6) {\n          s5 = peg$c6;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e7); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e4); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s5 = peg$c3;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c6) {\n            s5 = peg$c6;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e7); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e4); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c3;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsebackslash_newline() {\n    var s0, s1;\n\n    var key = peg$currPos * 8 + 6;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c0) {\n      s1 = peg$c0;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f3();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0, s1;\n\n    var key = peg$currPos * 8 + 7;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e8); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n\n  const thisParser = this;\n  // positions of \"\\\\\\n\" in the program\n  thisParser.falseNewlinePositions = []\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","// Generated by Peggy 3.0.2.\n//\n// https://peggyjs.org/\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { program: peg$parseprogram };\n  var peg$startRuleFunction = peg$parseprogram;\n\n  var peg$c0 = \"@\";\n  var peg$c1 = \"#include <\";\n  var peg$c2 = \">\";\n  var peg$c3 = \"_Static_assert\";\n  var peg$c4 = \"_Thread_local\";\n  var peg$c5 = \"_Imaginary\";\n  var peg$c6 = \"_Noreturn\";\n  var peg$c7 = \"continue\";\n  var peg$c8 = \"register\";\n  var peg$c9 = \"restrict\";\n  var peg$c10 = \"unsigned\";\n  var peg$c11 = \"volatile\";\n  var peg$c12 = \"_Alignas\";\n  var peg$c13 = \"_Alignof\";\n  var peg$c14 = \"_Complex\";\n  var peg$c15 = \"_Generic\";\n  var peg$c16 = \"default\";\n  var peg$c17 = \"typedef\";\n  var peg$c18 = \"_Atomic\";\n  var peg$c19 = \"extern\";\n  var peg$c20 = \"inline\";\n  var peg$c21 = \"double\";\n  var peg$c22 = \"return\";\n  var peg$c23 = \"signed\";\n  var peg$c24 = \"sizeof\";\n  var peg$c25 = \"static\";\n  var peg$c26 = \"struct\";\n  var peg$c27 = \"switch\";\n  var peg$c28 = \"break\";\n  var peg$c29 = \"float\";\n  var peg$c30 = \"const\";\n  var peg$c31 = \"short\";\n  var peg$c32 = \"union\";\n  var peg$c33 = \"while\";\n  var peg$c34 = \"_Bool\";\n  var peg$c35 = \"auto\";\n  var peg$c36 = \"case\";\n  var peg$c37 = \"char\";\n  var peg$c38 = \"goto\";\n  var peg$c39 = \"long\";\n  var peg$c40 = \"else\";\n  var peg$c41 = \"enum\";\n  var peg$c42 = \"void\";\n  var peg$c43 = \"for\";\n  var peg$c44 = \"int\";\n  var peg$c45 = \"if\";\n  var peg$c46 = \"do\";\n  var peg$c47 = \"0\";\n  var peg$c48 = \"0x\";\n  var peg$c49 = \"0X\";\n  var peg$c50 = \"u\";\n  var peg$c51 = \"U\";\n  var peg$c52 = \"l\";\n  var peg$c53 = \"L\";\n  var peg$c54 = \"ll\";\n  var peg$c55 = \"LL\";\n  var peg$c56 = \".\";\n  var peg$c57 = \"e\";\n  var peg$c58 = \"E\";\n  var peg$c59 = \"+\";\n  var peg$c60 = \"-\";\n  var peg$c61 = \"'\";\n  var peg$c62 = \"\\\\'\";\n  var peg$c63 = \"\\\\\\\"\";\n  var peg$c64 = \"\\\\?\";\n  var peg$c65 = \"\\\\\\\\\";\n  var peg$c66 = \"\\\\a\";\n  var peg$c67 = \"\\\\b\";\n  var peg$c68 = \"\\\\f\";\n  var peg$c69 = \"\\\\r\";\n  var peg$c70 = \"\\\\n\";\n  var peg$c71 = \"\\\\t\";\n  var peg$c72 = \"\\\\v\";\n  var peg$c73 = \"\\\\\";\n  var peg$c74 = \"\\\\x\";\n  var peg$c75 = \"\\\"\";\n  var peg$c76 = \"%:%:\";\n  var peg$c77 = \"...\";\n  var peg$c78 = \"<<=\";\n  var peg$c79 = \">>=\";\n  var peg$c80 = \"++\";\n  var peg$c81 = \"--\";\n  var peg$c82 = \"+=\";\n  var peg$c83 = \"-=\";\n  var peg$c84 = \"*=\";\n  var peg$c85 = \"/=\";\n  var peg$c86 = \"%=\";\n  var peg$c87 = \"&=\";\n  var peg$c88 = \"^=\";\n  var peg$c89 = \"|=\";\n  var peg$c90 = \"==\";\n  var peg$c91 = \"!=\";\n  var peg$c92 = \"<=\";\n  var peg$c93 = \">=\";\n  var peg$c94 = \">>\";\n  var peg$c95 = \"<<\";\n  var peg$c96 = \"->\";\n  var peg$c97 = \"&&\";\n  var peg$c98 = \"||\";\n  var peg$c99 = \"##\";\n  var peg$c100 = \"%:\";\n  var peg$c101 = \"<:\";\n  var peg$c102 = \":>\";\n  var peg$c103 = \"<%\";\n  var peg$c104 = \"%>\";\n  var peg$c105 = \"[\";\n  var peg$c106 = \"]\";\n  var peg$c107 = \"(\";\n  var peg$c108 = \")\";\n  var peg$c109 = \"{\";\n  var peg$c110 = \"}\";\n  var peg$c111 = \"&\";\n  var peg$c112 = \"*\";\n  var peg$c113 = \"~\";\n  var peg$c114 = \"!\";\n  var peg$c115 = \"/\";\n  var peg$c116 = \"%\";\n  var peg$c117 = \"<\";\n  var peg$c118 = \"^\";\n  var peg$c119 = \"|\";\n  var peg$c120 = \"?\";\n  var peg$c121 = \":\";\n  var peg$c122 = \";\";\n  var peg$c123 = \"=\";\n  var peg$c124 = \",\";\n  var peg$c125 = \"#\";\n\n  var peg$r0 = /^[ \\t\\n\\v\\f]/;\n  var peg$r1 = /^[a-z0-9!\"#%&()*+,-.\\/: ;<=>?[\\]\\^_{|}~\\t\\v\\f]/i;\n  var peg$r2 = /^[a-z_]/i;\n  var peg$r3 = /^[a-z0-9_]/i;\n  var peg$r4 = /^[1-9]/;\n  var peg$r5 = /^[0-9]/;\n  var peg$r6 = /^[0-7]/;\n  var peg$r7 = /^[0-9A-F]/i;\n  var peg$r8 = /^[fl]/i;\n  var peg$r9 = /^[a-z0-9!'#%&()*+,-.\\/: ;<=>?[\\]\\^_{|}~\\t\\v\\f]/i;\n\n  var peg$e0 = peg$otherExpectation(\"separator\");\n  var peg$e1 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\v\", \"\\f\"], false, false);\n  var peg$e2 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"!\", \"\\\"\", \"#\", \"%\", \"&\", \"(\", \")\", \"*\", \"+\", [\",\", \".\"], \"/\", \":\", \" \", \";\", \"<\", \"=\", \">\", \"?\", \"[\", \"]\", \"^\", \"_\", \"{\", \"|\", \"}\", \"~\", \"\\t\", \"\\v\", \"\\f\"], false, true);\n  var peg$e3 = peg$literalExpectation(\"@\", false);\n  var peg$e4 = peg$classExpectation([[\"a\", \"z\"], \"_\"], false, true);\n  var peg$e5 = peg$literalExpectation(\"#include <\", false);\n  var peg$e6 = peg$literalExpectation(\">\", false);\n  var peg$e7 = peg$literalExpectation(\"_Static_assert\", false);\n  var peg$e8 = peg$literalExpectation(\"_Thread_local\", false);\n  var peg$e9 = peg$literalExpectation(\"_Imaginary\", false);\n  var peg$e10 = peg$literalExpectation(\"_Noreturn\", false);\n  var peg$e11 = peg$literalExpectation(\"continue\", false);\n  var peg$e12 = peg$literalExpectation(\"register\", false);\n  var peg$e13 = peg$literalExpectation(\"restrict\", false);\n  var peg$e14 = peg$literalExpectation(\"unsigned\", false);\n  var peg$e15 = peg$literalExpectation(\"volatile\", false);\n  var peg$e16 = peg$literalExpectation(\"_Alignas\", false);\n  var peg$e17 = peg$literalExpectation(\"_Alignof\", false);\n  var peg$e18 = peg$literalExpectation(\"_Complex\", false);\n  var peg$e19 = peg$literalExpectation(\"_Generic\", false);\n  var peg$e20 = peg$literalExpectation(\"default\", false);\n  var peg$e21 = peg$literalExpectation(\"typedef\", false);\n  var peg$e22 = peg$literalExpectation(\"_Atomic\", false);\n  var peg$e23 = peg$literalExpectation(\"extern\", false);\n  var peg$e24 = peg$literalExpectation(\"inline\", false);\n  var peg$e25 = peg$literalExpectation(\"double\", false);\n  var peg$e26 = peg$literalExpectation(\"return\", false);\n  var peg$e27 = peg$literalExpectation(\"signed\", false);\n  var peg$e28 = peg$literalExpectation(\"sizeof\", false);\n  var peg$e29 = peg$literalExpectation(\"static\", false);\n  var peg$e30 = peg$literalExpectation(\"struct\", false);\n  var peg$e31 = peg$literalExpectation(\"switch\", false);\n  var peg$e32 = peg$literalExpectation(\"break\", false);\n  var peg$e33 = peg$literalExpectation(\"float\", false);\n  var peg$e34 = peg$literalExpectation(\"const\", false);\n  var peg$e35 = peg$literalExpectation(\"short\", false);\n  var peg$e36 = peg$literalExpectation(\"union\", false);\n  var peg$e37 = peg$literalExpectation(\"while\", false);\n  var peg$e38 = peg$literalExpectation(\"_Bool\", false);\n  var peg$e39 = peg$literalExpectation(\"auto\", false);\n  var peg$e40 = peg$literalExpectation(\"case\", false);\n  var peg$e41 = peg$literalExpectation(\"char\", false);\n  var peg$e42 = peg$literalExpectation(\"goto\", false);\n  var peg$e43 = peg$literalExpectation(\"long\", false);\n  var peg$e44 = peg$literalExpectation(\"else\", false);\n  var peg$e45 = peg$literalExpectation(\"enum\", false);\n  var peg$e46 = peg$literalExpectation(\"void\", false);\n  var peg$e47 = peg$literalExpectation(\"for\", false);\n  var peg$e48 = peg$literalExpectation(\"int\", false);\n  var peg$e49 = peg$literalExpectation(\"if\", false);\n  var peg$e50 = peg$literalExpectation(\"do\", false);\n  var peg$e51 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"_\"], false, true);\n  var peg$e52 = peg$literalExpectation(\"0\", false);\n  var peg$e53 = peg$classExpectation([[\"1\", \"9\"]], false, false);\n  var peg$e54 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e55 = peg$classExpectation([[\"0\", \"7\"]], false, false);\n  var peg$e56 = peg$literalExpectation(\"0x\", false);\n  var peg$e57 = peg$literalExpectation(\"0X\", false);\n  var peg$e58 = peg$classExpectation([[\"0\", \"9\"], [\"A\", \"F\"]], false, true);\n  var peg$e59 = peg$literalExpectation(\"u\", false);\n  var peg$e60 = peg$literalExpectation(\"U\", false);\n  var peg$e61 = peg$literalExpectation(\"l\", false);\n  var peg$e62 = peg$literalExpectation(\"L\", false);\n  var peg$e63 = peg$literalExpectation(\"ll\", false);\n  var peg$e64 = peg$literalExpectation(\"LL\", false);\n  var peg$e65 = peg$literalExpectation(\".\", false);\n  var peg$e66 = peg$literalExpectation(\"e\", false);\n  var peg$e67 = peg$literalExpectation(\"E\", false);\n  var peg$e68 = peg$literalExpectation(\"+\", false);\n  var peg$e69 = peg$literalExpectation(\"-\", false);\n  var peg$e70 = peg$classExpectation([\"f\", \"l\"], false, true);\n  var peg$e71 = peg$literalExpectation(\"'\", false);\n  var peg$e72 = peg$literalExpectation(\"\\\\'\", false);\n  var peg$e73 = peg$literalExpectation(\"\\\\\\\"\", false);\n  var peg$e74 = peg$literalExpectation(\"\\\\?\", false);\n  var peg$e75 = peg$literalExpectation(\"\\\\\\\\\", false);\n  var peg$e76 = peg$literalExpectation(\"\\\\a\", false);\n  var peg$e77 = peg$literalExpectation(\"\\\\b\", false);\n  var peg$e78 = peg$literalExpectation(\"\\\\f\", false);\n  var peg$e79 = peg$literalExpectation(\"\\\\r\", false);\n  var peg$e80 = peg$literalExpectation(\"\\\\n\", false);\n  var peg$e81 = peg$literalExpectation(\"\\\\t\", false);\n  var peg$e82 = peg$literalExpectation(\"\\\\v\", false);\n  var peg$e83 = peg$literalExpectation(\"\\\\\", false);\n  var peg$e84 = peg$literalExpectation(\"\\\\x\", false);\n  var peg$e85 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e86 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"!\", \"'\", \"#\", \"%\", \"&\", \"(\", \")\", \"*\", \"+\", [\",\", \".\"], \"/\", \":\", \" \", \";\", \"<\", \"=\", \">\", \"?\", \"[\", \"]\", \"^\", \"_\", \"{\", \"|\", \"}\", \"~\", \"\\t\", \"\\v\", \"\\f\"], false, true);\n  var peg$e87 = peg$literalExpectation(\"%:%:\", false);\n  var peg$e88 = peg$literalExpectation(\"...\", false);\n  var peg$e89 = peg$literalExpectation(\"<<=\", false);\n  var peg$e90 = peg$literalExpectation(\">>=\", false);\n  var peg$e91 = peg$literalExpectation(\"++\", false);\n  var peg$e92 = peg$literalExpectation(\"--\", false);\n  var peg$e93 = peg$literalExpectation(\"+=\", false);\n  var peg$e94 = peg$literalExpectation(\"-=\", false);\n  var peg$e95 = peg$literalExpectation(\"*=\", false);\n  var peg$e96 = peg$literalExpectation(\"/=\", false);\n  var peg$e97 = peg$literalExpectation(\"%=\", false);\n  var peg$e98 = peg$literalExpectation(\"&=\", false);\n  var peg$e99 = peg$literalExpectation(\"^=\", false);\n  var peg$e100 = peg$literalExpectation(\"|=\", false);\n  var peg$e101 = peg$literalExpectation(\"==\", false);\n  var peg$e102 = peg$literalExpectation(\"!=\", false);\n  var peg$e103 = peg$literalExpectation(\"<=\", false);\n  var peg$e104 = peg$literalExpectation(\">=\", false);\n  var peg$e105 = peg$literalExpectation(\">>\", false);\n  var peg$e106 = peg$literalExpectation(\"<<\", false);\n  var peg$e107 = peg$literalExpectation(\"->\", false);\n  var peg$e108 = peg$literalExpectation(\"&&\", false);\n  var peg$e109 = peg$literalExpectation(\"||\", false);\n  var peg$e110 = peg$literalExpectation(\"##\", false);\n  var peg$e111 = peg$literalExpectation(\"%:\", false);\n  var peg$e112 = peg$literalExpectation(\"<:\", false);\n  var peg$e113 = peg$literalExpectation(\":>\", false);\n  var peg$e114 = peg$literalExpectation(\"<%\", false);\n  var peg$e115 = peg$literalExpectation(\"%>\", false);\n  var peg$e116 = peg$literalExpectation(\"[\", false);\n  var peg$e117 = peg$literalExpectation(\"]\", false);\n  var peg$e118 = peg$literalExpectation(\"(\", false);\n  var peg$e119 = peg$literalExpectation(\")\", false);\n  var peg$e120 = peg$literalExpectation(\"{\", false);\n  var peg$e121 = peg$literalExpectation(\"}\", false);\n  var peg$e122 = peg$literalExpectation(\"&\", false);\n  var peg$e123 = peg$literalExpectation(\"*\", false);\n  var peg$e124 = peg$literalExpectation(\"~\", false);\n  var peg$e125 = peg$literalExpectation(\"!\", false);\n  var peg$e126 = peg$literalExpectation(\"/\", false);\n  var peg$e127 = peg$literalExpectation(\"%\", false);\n  var peg$e128 = peg$literalExpectation(\"<\", false);\n  var peg$e129 = peg$literalExpectation(\"^\", false);\n  var peg$e130 = peg$literalExpectation(\"|\", false);\n  var peg$e131 = peg$literalExpectation(\"?\", false);\n  var peg$e132 = peg$literalExpectation(\":\", false);\n  var peg$e133 = peg$literalExpectation(\";\", false);\n  var peg$e134 = peg$literalExpectation(\"=\", false);\n  var peg$e135 = peg$literalExpectation(\",\", false);\n  var peg$e136 = peg$literalExpectation(\"#\", false);\n\n  var peg$f0 = function(matches) { return matches.join(\"\"); };\n  var peg$f1 = function(token) { addTokenPosition(token); return token + \" \"; };\n  var peg$f2 = function() { return \"\"; };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$resultsCache = {};\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseprogram() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 36 + 0;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsepreprocess_match();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsepreprocess_match();\n    }\n    peg$savedPos = s0;\n    s1 = peg$f0(s1);\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepreprocess_match() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 36 + 1;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsetoken();\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f1(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f2();\n      }\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    var key = peg$currPos * 36 + 2;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$r0.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e1); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsesource_character_set() {\n    var s0, s1;\n\n    var key = peg$currPos * 36 + 3;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseextended_source_character_set();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseextended_source_character_set() {\n    var s0;\n\n    var key = peg$currPos * 36 + 4;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 64) {\n      s0 = peg$c0;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 5;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parseinclude();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsekeyword();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n        }\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = undefined;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseconstant();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            peg$silentFails++;\n            if (peg$r2.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e4); }\n            }\n            peg$silentFails--;\n            if (s3 === peg$FAILED) {\n              s2 = undefined;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsestring_literal();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsepunctuator();\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinclude() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 6;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 10) === peg$c1) {\n      s1 = peg$c1;\n      peg$currPos += 10;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseidentifier();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s3 = peg$c2;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e6); }\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsekeyword() {\n    var s0;\n\n    var key = peg$currPos * 36 + 7;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 14) === peg$c3) {\n      s0 = peg$c3;\n      peg$currPos += 14;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 13) === peg$c4) {\n        s0 = peg$c4;\n        peg$currPos += 13;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e8); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 10) === peg$c5) {\n          s0 = peg$c5;\n          peg$currPos += 10;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e9); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 9) === peg$c6) {\n            s0 = peg$c6;\n            peg$currPos += 9;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e10); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c7) {\n              s0 = peg$c7;\n              peg$currPos += 8;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e11); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8) === peg$c8) {\n                s0 = peg$c8;\n                peg$currPos += 8;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e12); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c9) {\n                  s0 = peg$c9;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e13); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8) === peg$c10) {\n                    s0 = peg$c10;\n                    peg$currPos += 8;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e14); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 8) === peg$c11) {\n                      s0 = peg$c11;\n                      peg$currPos += 8;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 8) === peg$c12) {\n                        s0 = peg$c12;\n                        peg$currPos += 8;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e16); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c13) {\n                          s0 = peg$c13;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e17); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c14) {\n                            s0 = peg$c14;\n                            peg$currPos += 8;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e18); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 8) === peg$c15) {\n                              s0 = peg$c15;\n                              peg$currPos += 8;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e19); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 7) === peg$c16) {\n                                s0 = peg$c16;\n                                peg$currPos += 7;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e20); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 7) === peg$c17) {\n                                  s0 = peg$c17;\n                                  peg$currPos += 7;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e21); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 7) === peg$c18) {\n                                    s0 = peg$c18;\n                                    peg$currPos += 7;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$e22); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 6) === peg$c19) {\n                                      s0 = peg$c19;\n                                      peg$currPos += 6;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 6) === peg$c20) {\n                                        s0 = peg$c20;\n                                        peg$currPos += 6;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$e24); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 6) === peg$c21) {\n                                          s0 = peg$c21;\n                                          peg$currPos += 6;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$e25); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 6) === peg$c22) {\n                                            s0 = peg$c22;\n                                            peg$currPos += 6;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$e26); }\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 6) === peg$c23) {\n                                              s0 = peg$c23;\n                                              peg$currPos += 6;\n                                            } else {\n                                              s0 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$e27); }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              if (input.substr(peg$currPos, 6) === peg$c24) {\n                                                s0 = peg$c24;\n                                                peg$currPos += 6;\n                                              } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$e28); }\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 6) === peg$c25) {\n                                                  s0 = peg$c25;\n                                                  peg$currPos += 6;\n                                                } else {\n                                                  s0 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$e29); }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  if (input.substr(peg$currPos, 6) === peg$c26) {\n                                                    s0 = peg$c26;\n                                                    peg$currPos += 6;\n                                                  } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$e30); }\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 6) === peg$c27) {\n                                                      s0 = peg$c27;\n                                                      peg$currPos += 6;\n                                                    } else {\n                                                      s0 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      if (input.substr(peg$currPos, 5) === peg$c28) {\n                                                        s0 = peg$c28;\n                                                        peg$currPos += 5;\n                                                      } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$e32); }\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 5) === peg$c29) {\n                                                          s0 = peg$c29;\n                                                          peg$currPos += 5;\n                                                        } else {\n                                                          s0 = peg$FAILED;\n                                                          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          if (input.substr(peg$currPos, 5) === peg$c30) {\n                                                            s0 = peg$c30;\n                                                            peg$currPos += 5;\n                                                          } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) { peg$fail(peg$e34); }\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 5) === peg$c31) {\n                                                              s0 = peg$c31;\n                                                              peg$currPos += 5;\n                                                            } else {\n                                                              s0 = peg$FAILED;\n                                                              if (peg$silentFails === 0) { peg$fail(peg$e35); }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              if (input.substr(peg$currPos, 5) === peg$c32) {\n                                                                s0 = peg$c32;\n                                                                peg$currPos += 5;\n                                                              } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) { peg$fail(peg$e36); }\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                if (input.substr(peg$currPos, 5) === peg$c33) {\n                                                                  s0 = peg$c33;\n                                                                  peg$currPos += 5;\n                                                                } else {\n                                                                  s0 = peg$FAILED;\n                                                                  if (peg$silentFails === 0) { peg$fail(peg$e37); }\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  if (input.substr(peg$currPos, 5) === peg$c34) {\n                                                                    s0 = peg$c34;\n                                                                    peg$currPos += 5;\n                                                                  } else {\n                                                                    s0 = peg$FAILED;\n                                                                    if (peg$silentFails === 0) { peg$fail(peg$e38); }\n                                                                  }\n                                                                  if (s0 === peg$FAILED) {\n                                                                    if (input.substr(peg$currPos, 4) === peg$c35) {\n                                                                      s0 = peg$c35;\n                                                                      peg$currPos += 4;\n                                                                    } else {\n                                                                      s0 = peg$FAILED;\n                                                                      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n                                                                    }\n                                                                    if (s0 === peg$FAILED) {\n                                                                      if (input.substr(peg$currPos, 4) === peg$c36) {\n                                                                        s0 = peg$c36;\n                                                                        peg$currPos += 4;\n                                                                      } else {\n                                                                        s0 = peg$FAILED;\n                                                                        if (peg$silentFails === 0) { peg$fail(peg$e40); }\n                                                                      }\n                                                                      if (s0 === peg$FAILED) {\n                                                                        if (input.substr(peg$currPos, 4) === peg$c37) {\n                                                                          s0 = peg$c37;\n                                                                          peg$currPos += 4;\n                                                                        } else {\n                                                                          s0 = peg$FAILED;\n                                                                          if (peg$silentFails === 0) { peg$fail(peg$e41); }\n                                                                        }\n                                                                        if (s0 === peg$FAILED) {\n                                                                          if (input.substr(peg$currPos, 4) === peg$c38) {\n                                                                            s0 = peg$c38;\n                                                                            peg$currPos += 4;\n                                                                          } else {\n                                                                            s0 = peg$FAILED;\n                                                                            if (peg$silentFails === 0) { peg$fail(peg$e42); }\n                                                                          }\n                                                                          if (s0 === peg$FAILED) {\n                                                                            if (input.substr(peg$currPos, 4) === peg$c39) {\n                                                                              s0 = peg$c39;\n                                                                              peg$currPos += 4;\n                                                                            } else {\n                                                                              s0 = peg$FAILED;\n                                                                              if (peg$silentFails === 0) { peg$fail(peg$e43); }\n                                                                            }\n                                                                            if (s0 === peg$FAILED) {\n                                                                              if (input.substr(peg$currPos, 4) === peg$c40) {\n                                                                                s0 = peg$c40;\n                                                                                peg$currPos += 4;\n                                                                              } else {\n                                                                                s0 = peg$FAILED;\n                                                                                if (peg$silentFails === 0) { peg$fail(peg$e44); }\n                                                                              }\n                                                                              if (s0 === peg$FAILED) {\n                                                                                if (input.substr(peg$currPos, 4) === peg$c41) {\n                                                                                  s0 = peg$c41;\n                                                                                  peg$currPos += 4;\n                                                                                } else {\n                                                                                  s0 = peg$FAILED;\n                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e45); }\n                                                                                }\n                                                                                if (s0 === peg$FAILED) {\n                                                                                  if (input.substr(peg$currPos, 4) === peg$c42) {\n                                                                                    s0 = peg$c42;\n                                                                                    peg$currPos += 4;\n                                                                                  } else {\n                                                                                    s0 = peg$FAILED;\n                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e46); }\n                                                                                  }\n                                                                                  if (s0 === peg$FAILED) {\n                                                                                    if (input.substr(peg$currPos, 3) === peg$c43) {\n                                                                                      s0 = peg$c43;\n                                                                                      peg$currPos += 3;\n                                                                                    } else {\n                                                                                      s0 = peg$FAILED;\n                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e47); }\n                                                                                    }\n                                                                                    if (s0 === peg$FAILED) {\n                                                                                      if (input.substr(peg$currPos, 3) === peg$c44) {\n                                                                                        s0 = peg$c44;\n                                                                                        peg$currPos += 3;\n                                                                                      } else {\n                                                                                        s0 = peg$FAILED;\n                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e48); }\n                                                                                      }\n                                                                                      if (s0 === peg$FAILED) {\n                                                                                        if (input.substr(peg$currPos, 2) === peg$c45) {\n                                                                                          s0 = peg$c45;\n                                                                                          peg$currPos += 2;\n                                                                                        } else {\n                                                                                          s0 = peg$FAILED;\n                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e49); }\n                                                                                        }\n                                                                                        if (s0 === peg$FAILED) {\n                                                                                          if (input.substr(peg$currPos, 2) === peg$c46) {\n                                                                                            s0 = peg$c46;\n                                                                                            peg$currPos += 2;\n                                                                                          } else {\n                                                                                            s0 = peg$FAILED;\n                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e50); }\n                                                                                          }\n                                                                                        }\n                                                                                      }\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                              }\n                                                                            }\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                    }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 8;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e51); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e51); }\n        }\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseconstant() {\n    var s0;\n\n    var key = peg$currPos * 36 + 9;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsedecimal_floating_constant();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseinteger_constant();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsecharacter_constant();\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinteger_constant() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 36 + 10;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedecimal_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseoctal_constant();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsehexadecimal_constant();\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 48) {\n            s1 = peg$c47;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e52); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseinteger_suffix();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedecimal_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 11;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonzero_digit();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsedigit();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsedigit();\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsenonzero_digit() {\n    var s0, s1;\n\n    var key = peg$currPos * 36 + 12;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e53); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0, s1;\n\n    var key = peg$currPos * 36 + 13;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e54); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseoctal_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 14;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 48) {\n      s1 = peg$c47;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e52); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseoctal_digit();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseoctal_digit();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseoctal_digit() {\n    var s0, s1;\n\n    var key = peg$currPos * 36 + 15;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r6.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e55); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 16;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsehexadecimal_prefix();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsehexadecimal_digit();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsehexadecimal_digit();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_prefix() {\n    var s0;\n\n    var key = peg$currPos * 36 + 17;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c48) {\n      s0 = peg$c48;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e56); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c49) {\n        s0 = peg$c49;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e57); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_digit() {\n    var s0, s1;\n\n    var key = peg$currPos * 36 + 18;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r7.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e58); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinteger_suffix() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 36 + 19;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseunsigned_suffix();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselong_long_suffix();\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseunsigned_suffix();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselong_suffix();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselong_long_suffix();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseunsigned_suffix();\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parselong_suffix();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseunsigned_suffix();\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseunsigned_suffix() {\n    var s0;\n\n    var key = peg$currPos * 36 + 20;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s0 = peg$c50;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e59); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 85) {\n        s0 = peg$c51;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e60); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselong_suffix() {\n    var s0;\n\n    var key = peg$currPos * 36 + 21;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 108) {\n      s0 = peg$c52;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e61); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 76) {\n        s0 = peg$c53;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e62); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselong_long_suffix() {\n    var s0;\n\n    var key = peg$currPos * 36 + 22;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c54) {\n      s0 = peg$c54;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e63); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c55) {\n        s0 = peg$c55;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e64); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedecimal_floating_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 23;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsefractional_constant();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexponent_part();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsefloating_suffix();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s1 = [s1, s2, s3];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsedigit();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsedigit();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexponent_part();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefloating_suffix();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 36 + 24;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsedigit();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsedigit();\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c56;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e65); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsedigit();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsedigit();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsedigit();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsedigit();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c56;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e65); }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseexponent_part() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 36 + 25;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 101) {\n      s1 = peg$c57;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e66); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 69) {\n        s1 = peg$c58;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e67); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s2 = peg$c59;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e68); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c60;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e69); }\n        }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parsedigit();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsedigit();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefloating_suffix() {\n    var s0;\n\n    var key = peg$currPos * 36 + 26;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (peg$r8.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e70); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsecharacter_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 27;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s1 = peg$c61;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e71); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsec_char();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s3 = peg$c61;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e71); }\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsec_char() {\n    var s0;\n\n    var key = peg$currPos * 36 + 28;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseescape_sequence();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseescape_sequence() {\n    var s0;\n\n    var key = peg$currPos * 36 + 29;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsesimple_escape_sequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseoctal_escape_sequence();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehexadecimal_escape_sequence();\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsesimple_escape_sequence() {\n    var s0;\n\n    var key = peg$currPos * 36 + 30;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c62) {\n      s0 = peg$c62;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e72); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c63) {\n        s0 = peg$c63;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e73); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c64) {\n          s0 = peg$c64;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e74); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c65) {\n            s0 = peg$c65;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e75); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c66) {\n              s0 = peg$c66;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e76); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c67) {\n                s0 = peg$c67;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e77); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c68) {\n                  s0 = peg$c68;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e78); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c69) {\n                    s0 = peg$c69;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e79); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c70) {\n                      s0 = peg$c70;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e80); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c71) {\n                        s0 = peg$c71;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e81); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c72) {\n                          s0 = peg$c72;\n                          peg$currPos += 2;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e82); }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseoctal_escape_sequence() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 36 + 31;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c73;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e83); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parseoctal_digit();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (s3.length >= 3) {\n          s4 = peg$FAILED;\n        } else {\n          s4 = peg$parseoctal_digit();\n        }\n      }\n      if (s3.length < 1) {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_escape_sequence() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 36 + 32;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c74) {\n      s1 = peg$c74;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e84); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsehexadecimal_digit();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (s3.length >= 2) {\n          s4 = peg$FAILED;\n        } else {\n          s4 = peg$parsehexadecimal_digit();\n        }\n      }\n      if (s3.length < 1) {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestring_literal() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 36 + 33;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c75;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e85); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parses_char();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parses_char();\n      }\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c75;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e85); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parses_char() {\n    var s0;\n\n    var key = peg$currPos * 36 + 34;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (peg$r9.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e86); }\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseescape_sequence();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepunctuator() {\n    var s0;\n\n    var key = peg$currPos * 36 + 35;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 4) === peg$c76) {\n      s0 = peg$c76;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e87); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c77) {\n        s0 = peg$c77;\n        peg$currPos += 3;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e88); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c78) {\n          s0 = peg$c78;\n          peg$currPos += 3;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e89); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c79) {\n            s0 = peg$c79;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e90); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c80) {\n              s0 = peg$c80;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e91); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c81) {\n                s0 = peg$c81;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e92); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c82) {\n                  s0 = peg$c82;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e93); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c83) {\n                    s0 = peg$c83;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e94); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c84) {\n                      s0 = peg$c84;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e95); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c85) {\n                        s0 = peg$c85;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e96); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c86) {\n                          s0 = peg$c86;\n                          peg$currPos += 2;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e97); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 2) === peg$c87) {\n                            s0 = peg$c87;\n                            peg$currPos += 2;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e98); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c88) {\n                              s0 = peg$c88;\n                              peg$currPos += 2;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e99); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 2) === peg$c89) {\n                                s0 = peg$c89;\n                                peg$currPos += 2;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e100); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 2) === peg$c90) {\n                                  s0 = peg$c90;\n                                  peg$currPos += 2;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e101); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 2) === peg$c91) {\n                                    s0 = peg$c91;\n                                    peg$currPos += 2;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$e102); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 2) === peg$c92) {\n                                      s0 = peg$c92;\n                                      peg$currPos += 2;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$e103); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 2) === peg$c93) {\n                                        s0 = peg$c93;\n                                        peg$currPos += 2;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$e104); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 2) === peg$c94) {\n                                          s0 = peg$c94;\n                                          peg$currPos += 2;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$e105); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 2) === peg$c95) {\n                                            s0 = peg$c95;\n                                            peg$currPos += 2;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$e106); }\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 2) === peg$c96) {\n                                              s0 = peg$c96;\n                                              peg$currPos += 2;\n                                            } else {\n                                              s0 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$e107); }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              if (input.substr(peg$currPos, 2) === peg$c97) {\n                                                s0 = peg$c97;\n                                                peg$currPos += 2;\n                                              } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$e108); }\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 2) === peg$c98) {\n                                                  s0 = peg$c98;\n                                                  peg$currPos += 2;\n                                                } else {\n                                                  s0 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$e109); }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  if (input.substr(peg$currPos, 2) === peg$c99) {\n                                                    s0 = peg$c99;\n                                                    peg$currPos += 2;\n                                                  } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$e110); }\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 2) === peg$c100) {\n                                                      s0 = peg$c100;\n                                                      peg$currPos += 2;\n                                                    } else {\n                                                      s0 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$e111); }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      if (input.substr(peg$currPos, 2) === peg$c101) {\n                                                        s0 = peg$c101;\n                                                        peg$currPos += 2;\n                                                      } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$e112); }\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 2) === peg$c102) {\n                                                          s0 = peg$c102;\n                                                          peg$currPos += 2;\n                                                        } else {\n                                                          s0 = peg$FAILED;\n                                                          if (peg$silentFails === 0) { peg$fail(peg$e113); }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          if (input.substr(peg$currPos, 2) === peg$c103) {\n                                                            s0 = peg$c103;\n                                                            peg$currPos += 2;\n                                                          } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) { peg$fail(peg$e114); }\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 2) === peg$c104) {\n                                                              s0 = peg$c104;\n                                                              peg$currPos += 2;\n                                                            } else {\n                                                              s0 = peg$FAILED;\n                                                              if (peg$silentFails === 0) { peg$fail(peg$e115); }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              if (input.charCodeAt(peg$currPos) === 91) {\n                                                                s0 = peg$c105;\n                                                                peg$currPos++;\n                                                              } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) { peg$fail(peg$e116); }\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                if (input.charCodeAt(peg$currPos) === 93) {\n                                                                  s0 = peg$c106;\n                                                                  peg$currPos++;\n                                                                } else {\n                                                                  s0 = peg$FAILED;\n                                                                  if (peg$silentFails === 0) { peg$fail(peg$e117); }\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  if (input.charCodeAt(peg$currPos) === 40) {\n                                                                    s0 = peg$c107;\n                                                                    peg$currPos++;\n                                                                  } else {\n                                                                    s0 = peg$FAILED;\n                                                                    if (peg$silentFails === 0) { peg$fail(peg$e118); }\n                                                                  }\n                                                                  if (s0 === peg$FAILED) {\n                                                                    if (input.charCodeAt(peg$currPos) === 41) {\n                                                                      s0 = peg$c108;\n                                                                      peg$currPos++;\n                                                                    } else {\n                                                                      s0 = peg$FAILED;\n                                                                      if (peg$silentFails === 0) { peg$fail(peg$e119); }\n                                                                    }\n                                                                    if (s0 === peg$FAILED) {\n                                                                      if (input.charCodeAt(peg$currPos) === 123) {\n                                                                        s0 = peg$c109;\n                                                                        peg$currPos++;\n                                                                      } else {\n                                                                        s0 = peg$FAILED;\n                                                                        if (peg$silentFails === 0) { peg$fail(peg$e120); }\n                                                                      }\n                                                                      if (s0 === peg$FAILED) {\n                                                                        if (input.charCodeAt(peg$currPos) === 125) {\n                                                                          s0 = peg$c110;\n                                                                          peg$currPos++;\n                                                                        } else {\n                                                                          s0 = peg$FAILED;\n                                                                          if (peg$silentFails === 0) { peg$fail(peg$e121); }\n                                                                        }\n                                                                        if (s0 === peg$FAILED) {\n                                                                          if (input.charCodeAt(peg$currPos) === 46) {\n                                                                            s0 = peg$c56;\n                                                                            peg$currPos++;\n                                                                          } else {\n                                                                            s0 = peg$FAILED;\n                                                                            if (peg$silentFails === 0) { peg$fail(peg$e65); }\n                                                                          }\n                                                                          if (s0 === peg$FAILED) {\n                                                                            if (input.charCodeAt(peg$currPos) === 38) {\n                                                                              s0 = peg$c111;\n                                                                              peg$currPos++;\n                                                                            } else {\n                                                                              s0 = peg$FAILED;\n                                                                              if (peg$silentFails === 0) { peg$fail(peg$e122); }\n                                                                            }\n                                                                            if (s0 === peg$FAILED) {\n                                                                              if (input.charCodeAt(peg$currPos) === 42) {\n                                                                                s0 = peg$c112;\n                                                                                peg$currPos++;\n                                                                              } else {\n                                                                                s0 = peg$FAILED;\n                                                                                if (peg$silentFails === 0) { peg$fail(peg$e123); }\n                                                                              }\n                                                                              if (s0 === peg$FAILED) {\n                                                                                if (input.charCodeAt(peg$currPos) === 43) {\n                                                                                  s0 = peg$c59;\n                                                                                  peg$currPos++;\n                                                                                } else {\n                                                                                  s0 = peg$FAILED;\n                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e68); }\n                                                                                }\n                                                                                if (s0 === peg$FAILED) {\n                                                                                  if (input.charCodeAt(peg$currPos) === 45) {\n                                                                                    s0 = peg$c60;\n                                                                                    peg$currPos++;\n                                                                                  } else {\n                                                                                    s0 = peg$FAILED;\n                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e69); }\n                                                                                  }\n                                                                                  if (s0 === peg$FAILED) {\n                                                                                    if (input.charCodeAt(peg$currPos) === 126) {\n                                                                                      s0 = peg$c113;\n                                                                                      peg$currPos++;\n                                                                                    } else {\n                                                                                      s0 = peg$FAILED;\n                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e124); }\n                                                                                    }\n                                                                                    if (s0 === peg$FAILED) {\n                                                                                      if (input.charCodeAt(peg$currPos) === 33) {\n                                                                                        s0 = peg$c114;\n                                                                                        peg$currPos++;\n                                                                                      } else {\n                                                                                        s0 = peg$FAILED;\n                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e125); }\n                                                                                      }\n                                                                                      if (s0 === peg$FAILED) {\n                                                                                        if (input.charCodeAt(peg$currPos) === 47) {\n                                                                                          s0 = peg$c115;\n                                                                                          peg$currPos++;\n                                                                                        } else {\n                                                                                          s0 = peg$FAILED;\n                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e126); }\n                                                                                        }\n                                                                                        if (s0 === peg$FAILED) {\n                                                                                          if (input.charCodeAt(peg$currPos) === 37) {\n                                                                                            s0 = peg$c116;\n                                                                                            peg$currPos++;\n                                                                                          } else {\n                                                                                            s0 = peg$FAILED;\n                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e127); }\n                                                                                          }\n                                                                                          if (s0 === peg$FAILED) {\n                                                                                            if (input.charCodeAt(peg$currPos) === 60) {\n                                                                                              s0 = peg$c117;\n                                                                                              peg$currPos++;\n                                                                                            } else {\n                                                                                              s0 = peg$FAILED;\n                                                                                              if (peg$silentFails === 0) { peg$fail(peg$e128); }\n                                                                                            }\n                                                                                            if (s0 === peg$FAILED) {\n                                                                                              if (input.charCodeAt(peg$currPos) === 62) {\n                                                                                                s0 = peg$c2;\n                                                                                                peg$currPos++;\n                                                                                              } else {\n                                                                                                s0 = peg$FAILED;\n                                                                                                if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                                                                                              }\n                                                                                              if (s0 === peg$FAILED) {\n                                                                                                if (input.charCodeAt(peg$currPos) === 94) {\n                                                                                                  s0 = peg$c118;\n                                                                                                  peg$currPos++;\n                                                                                                } else {\n                                                                                                  s0 = peg$FAILED;\n                                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e129); }\n                                                                                                }\n                                                                                                if (s0 === peg$FAILED) {\n                                                                                                  if (input.charCodeAt(peg$currPos) === 124) {\n                                                                                                    s0 = peg$c119;\n                                                                                                    peg$currPos++;\n                                                                                                  } else {\n                                                                                                    s0 = peg$FAILED;\n                                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e130); }\n                                                                                                  }\n                                                                                                  if (s0 === peg$FAILED) {\n                                                                                                    if (input.charCodeAt(peg$currPos) === 63) {\n                                                                                                      s0 = peg$c120;\n                                                                                                      peg$currPos++;\n                                                                                                    } else {\n                                                                                                      s0 = peg$FAILED;\n                                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e131); }\n                                                                                                    }\n                                                                                                    if (s0 === peg$FAILED) {\n                                                                                                      if (input.charCodeAt(peg$currPos) === 58) {\n                                                                                                        s0 = peg$c121;\n                                                                                                        peg$currPos++;\n                                                                                                      } else {\n                                                                                                        s0 = peg$FAILED;\n                                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e132); }\n                                                                                                      }\n                                                                                                      if (s0 === peg$FAILED) {\n                                                                                                        if (input.charCodeAt(peg$currPos) === 59) {\n                                                                                                          s0 = peg$c122;\n                                                                                                          peg$currPos++;\n                                                                                                        } else {\n                                                                                                          s0 = peg$FAILED;\n                                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e133); }\n                                                                                                        }\n                                                                                                        if (s0 === peg$FAILED) {\n                                                                                                          if (input.charCodeAt(peg$currPos) === 61) {\n                                                                                                            s0 = peg$c123;\n                                                                                                            peg$currPos++;\n                                                                                                          } else {\n                                                                                                            s0 = peg$FAILED;\n                                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e134); }\n                                                                                                          }\n                                                                                                          if (s0 === peg$FAILED) {\n                                                                                                            if (input.charCodeAt(peg$currPos) === 44) {\n                                                                                                              s0 = peg$c124;\n                                                                                                              peg$currPos++;\n                                                                                                            } else {\n                                                                                                              s0 = peg$FAILED;\n                                                                                                              if (peg$silentFails === 0) { peg$fail(peg$e135); }\n                                                                                                            }\n                                                                                                            if (s0 === peg$FAILED) {\n                                                                                                              if (input.charCodeAt(peg$currPos) === 35) {\n                                                                                                                s0 = peg$c125;\n                                                                                                                peg$currPos++;\n                                                                                                              } else {\n                                                                                                                s0 = peg$FAILED;\n                                                                                                                if (peg$silentFails === 0) { peg$fail(peg$e136); }\n                                                                                                              }\n                                                                                                            }\n                                                                                                          }\n                                                                                                        }\n                                                                                                      }\n                                                                                                    }\n                                                                                                  }\n                                                                                                }\n                                                                                              }\n                                                                                            }\n                                                                                          }\n                                                                                        }\n                                                                                      }\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                              }\n                                                                            }\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                    }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n\n  const thisParser = this; \n  thisParser.tokenPositions = new Map();\n  // length of the output string of the lexer\n  let outputLength = 0;\n\n  /**\n   * Returns the location of the token, adjusted for \"\\\\\\n\" that were removed by the preprocessor.\n   */\n  function getAdjustedTokenLocation() {\n    const FALSE_NEWLINE_CHAR_LENGTH = 2;\n    const adjustedLocation = location();\n    let numOfFalseNewlinesBefStart = 0;\n    let numOfFalseNewlinesBefEnd = 0;\n    for (const falseNewlinePosition of thisParser.falseNewlinePositions) {\n      if (falseNewlinePosition > adjustedLocation.end.offset) {\n        break;\n      }\n      numOfFalseNewlinesBefEnd++;\n      if (falseNewlinePosition < adjustedLocation.start.offset) {\n        numOfFalseNewlinesBefStart++;\n      }\n    }\n    adjustedLocation.start.offset += FALSE_NEWLINE_CHAR_LENGTH * numOfFalseNewlinesBefStart;\n    adjustedLocation.start.line += numOfFalseNewlinesBefStart;\n    adjustedLocation.end.offset += FALSE_NEWLINE_CHAR_LENGTH * numOfFalseNewlinesBefEnd;\n    adjustedLocation.end.line += numOfFalseNewlinesBefEnd;\n    return adjustedLocation;\n  }\n\n  function addTokenPosition(token) {\n    const tokenPosition = getAdjustedTokenLocation();\n    for (let i = 0; i < token.length; ++i) {\n      thisParser.tokenPositions.set(outputLength + i, tokenPosition);\n    }\n    outputLength += token.length + 1;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","// Generated by Peggy 3.0.2.\n//\n// https://peggyjs.org/\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { program: peg$parseprogram };\n  var peg$startRuleFunction = peg$parseprogram;\n\n  var peg$c0 = \" \";\n  var peg$c1 = \"{\";\n  var peg$c2 = \"}\";\n  var peg$c3 = \"return\";\n  var peg$c4 = \";\";\n  var peg$c5 = \"break\";\n  var peg$c6 = \"continue\";\n  var peg$c7 = \"do\";\n  var peg$c8 = \"while\";\n  var peg$c9 = \"(\";\n  var peg$c10 = \")\";\n  var peg$c11 = \"for\";\n  var peg$c12 = \"if\";\n  var peg$c13 = \"else\";\n  var peg$c14 = \"switch\";\n  var peg$c15 = \"default\";\n  var peg$c16 = \":\";\n  var peg$c17 = \"case\";\n  var peg$c18 = \"const\";\n  var peg$c19 = \"auto\";\n  var peg$c20 = \"static\";\n  var peg$c21 = \"typedef\";\n  var peg$c22 = \"void\";\n  var peg$c23 = \"char\";\n  var peg$c24 = \"int\";\n  var peg$c25 = \"float\";\n  var peg$c26 = \"double\";\n  var peg$c27 = \"long\";\n  var peg$c28 = \"short\";\n  var peg$c29 = \"signed\";\n  var peg$c30 = \"unsigned\";\n  var peg$c31 = \",\";\n  var peg$c32 = \"=\";\n  var peg$c33 = \"*\";\n  var peg$c34 = \"[\";\n  var peg$c35 = \"]\";\n  var peg$c36 = \"struct\";\n  var peg$c37 = \"enum\";\n  var peg$c38 = \"+=\";\n  var peg$c39 = \"-=\";\n  var peg$c40 = \"*=\";\n  var peg$c41 = \"/=\";\n  var peg$c42 = \"%=\";\n  var peg$c43 = \"<<=\";\n  var peg$c44 = \">>=\";\n  var peg$c45 = \"&=\";\n  var peg$c46 = \"^=\";\n  var peg$c47 = \"|=\";\n  var peg$c48 = \"?\";\n  var peg$c49 = \"||\";\n  var peg$c50 = \"&&\";\n  var peg$c51 = \"|\";\n  var peg$c52 = \"^\";\n  var peg$c53 = \"&\";\n  var peg$c54 = \"!=\";\n  var peg$c55 = \"==\";\n  var peg$c56 = \"<=\";\n  var peg$c57 = \">=\";\n  var peg$c58 = \"<\";\n  var peg$c59 = \">\";\n  var peg$c60 = \"<<\";\n  var peg$c61 = \">>\";\n  var peg$c62 = \"+\";\n  var peg$c63 = \"-\";\n  var peg$c64 = \"/\";\n  var peg$c65 = \"%\";\n  var peg$c66 = \"++\";\n  var peg$c67 = \"--\";\n  var peg$c68 = \"!\";\n  var peg$c69 = \"~\";\n  var peg$c70 = \"sizeof\";\n  var peg$c71 = \".\";\n  var peg$c72 = \"->\";\n  var peg$c73 = \"@\";\n  var peg$c74 = \"#include <\";\n  var peg$c75 = \"_Static_assert\";\n  var peg$c76 = \"_Thread_local\";\n  var peg$c77 = \"_Imaginary\";\n  var peg$c78 = \"_Noreturn\";\n  var peg$c79 = \"register\";\n  var peg$c80 = \"restrict\";\n  var peg$c81 = \"volatile\";\n  var peg$c82 = \"_Alignas\";\n  var peg$c83 = \"_Alignof\";\n  var peg$c84 = \"_Complex\";\n  var peg$c85 = \"_Generic\";\n  var peg$c86 = \"_Atomic\";\n  var peg$c87 = \"extern\";\n  var peg$c88 = \"inline\";\n  var peg$c89 = \"union\";\n  var peg$c90 = \"_Bool\";\n  var peg$c91 = \"goto\";\n  var peg$c92 = \"0\";\n  var peg$c93 = \"0x\";\n  var peg$c94 = \"0X\";\n  var peg$c95 = \"u\";\n  var peg$c96 = \"U\";\n  var peg$c97 = \"l\";\n  var peg$c98 = \"L\";\n  var peg$c99 = \"ll\";\n  var peg$c100 = \"LL\";\n  var peg$c101 = \"e\";\n  var peg$c102 = \"E\";\n  var peg$c103 = \"'\";\n  var peg$c104 = \"\\\\'\";\n  var peg$c105 = \"\\\\\\\"\";\n  var peg$c106 = \"\\\\?\";\n  var peg$c107 = \"\\\\\\\\\";\n  var peg$c108 = \"\\\\a\";\n  var peg$c109 = \"\\\\b\";\n  var peg$c110 = \"\\\\f\";\n  var peg$c111 = \"\\\\r\";\n  var peg$c112 = \"\\\\n\";\n  var peg$c113 = \"\\\\t\";\n  var peg$c114 = \"\\\\v\";\n  var peg$c115 = \"\\\\\";\n  var peg$c116 = \"\\\\x\";\n  var peg$c117 = \"\\\"\";\n  var peg$c118 = \"%:%:\";\n  var peg$c119 = \"...\";\n  var peg$c120 = \"##\";\n  var peg$c121 = \"%:\";\n  var peg$c122 = \"<:\";\n  var peg$c123 = \":>\";\n  var peg$c124 = \"<%\";\n  var peg$c125 = \"%>\";\n  var peg$c126 = \"#\";\n\n  var peg$r0 = /^[a-z0-9!'\"#%&()*+,-.\\/: ;<=>?[\\]\\^_{|}~\\t\\v\\f]/i;\n  var peg$r1 = /^[a-z_]/i;\n  var peg$r2 = /^[a-z0-9_]/i;\n  var peg$r3 = /^[1-9]/;\n  var peg$r4 = /^[0-9]/;\n  var peg$r5 = /^[0-7]/;\n  var peg$r6 = /^[0-9A-F]/i;\n  var peg$r7 = /^[fl]/i;\n  var peg$r8 = /^[a-z0-9!\"#%&()*+,-.\\/: ;<=>?[\\]\\^_{|}~\\t\\v\\f]/i;\n  var peg$r9 = /^[a-z0-9!'#%&()*+,-.\\/: ;<=>?[\\]\\^_{|}~\\t\\v\\f]/i;\n\n  var peg$e0 = peg$otherExpectation(\"token separator\");\n  var peg$e1 = peg$literalExpectation(\" \", false);\n  var peg$e2 = peg$otherExpectation(\"block\");\n  var peg$e3 = peg$literalExpectation(\"{\", false);\n  var peg$e4 = peg$literalExpectation(\"}\", false);\n  var peg$e5 = peg$literalExpectation(\"return\", false);\n  var peg$e6 = peg$literalExpectation(\";\", false);\n  var peg$e7 = peg$literalExpectation(\"break\", false);\n  var peg$e8 = peg$literalExpectation(\"continue\", false);\n  var peg$e9 = peg$literalExpectation(\"do\", false);\n  var peg$e10 = peg$literalExpectation(\"while\", false);\n  var peg$e11 = peg$literalExpectation(\"(\", false);\n  var peg$e12 = peg$literalExpectation(\")\", false);\n  var peg$e13 = peg$literalExpectation(\"for\", false);\n  var peg$e14 = peg$literalExpectation(\"if\", false);\n  var peg$e15 = peg$literalExpectation(\"else\", false);\n  var peg$e16 = peg$literalExpectation(\"switch\", false);\n  var peg$e17 = peg$literalExpectation(\"default\", false);\n  var peg$e18 = peg$literalExpectation(\":\", false);\n  var peg$e19 = peg$literalExpectation(\"case\", false);\n  var peg$e20 = peg$literalExpectation(\"const\", false);\n  var peg$e21 = peg$literalExpectation(\"auto\", false);\n  var peg$e22 = peg$literalExpectation(\"static\", false);\n  var peg$e23 = peg$literalExpectation(\"typedef\", false);\n  var peg$e24 = peg$literalExpectation(\"void\", false);\n  var peg$e25 = peg$literalExpectation(\"char\", false);\n  var peg$e26 = peg$literalExpectation(\"int\", false);\n  var peg$e27 = peg$literalExpectation(\"float\", false);\n  var peg$e28 = peg$literalExpectation(\"double\", false);\n  var peg$e29 = peg$literalExpectation(\"long\", false);\n  var peg$e30 = peg$literalExpectation(\"short\", false);\n  var peg$e31 = peg$literalExpectation(\"signed\", false);\n  var peg$e32 = peg$literalExpectation(\"unsigned\", false);\n  var peg$e33 = peg$literalExpectation(\",\", false);\n  var peg$e34 = peg$literalExpectation(\"=\", false);\n  var peg$e35 = peg$literalExpectation(\"*\", false);\n  var peg$e36 = peg$literalExpectation(\"[\", false);\n  var peg$e37 = peg$literalExpectation(\"]\", false);\n  var peg$e38 = peg$literalExpectation(\"struct\", false);\n  var peg$e39 = peg$literalExpectation(\"enum\", false);\n  var peg$e40 = peg$literalExpectation(\"+=\", false);\n  var peg$e41 = peg$literalExpectation(\"-=\", false);\n  var peg$e42 = peg$literalExpectation(\"*=\", false);\n  var peg$e43 = peg$literalExpectation(\"/=\", false);\n  var peg$e44 = peg$literalExpectation(\"%=\", false);\n  var peg$e45 = peg$literalExpectation(\"<<=\", false);\n  var peg$e46 = peg$literalExpectation(\">>=\", false);\n  var peg$e47 = peg$literalExpectation(\"&=\", false);\n  var peg$e48 = peg$literalExpectation(\"^=\", false);\n  var peg$e49 = peg$literalExpectation(\"|=\", false);\n  var peg$e50 = peg$literalExpectation(\"?\", false);\n  var peg$e51 = peg$literalExpectation(\"||\", false);\n  var peg$e52 = peg$literalExpectation(\"&&\", false);\n  var peg$e53 = peg$literalExpectation(\"|\", false);\n  var peg$e54 = peg$literalExpectation(\"^\", false);\n  var peg$e55 = peg$literalExpectation(\"&\", false);\n  var peg$e56 = peg$literalExpectation(\"!=\", false);\n  var peg$e57 = peg$literalExpectation(\"==\", false);\n  var peg$e58 = peg$literalExpectation(\"<=\", false);\n  var peg$e59 = peg$literalExpectation(\">=\", false);\n  var peg$e60 = peg$literalExpectation(\"<\", false);\n  var peg$e61 = peg$literalExpectation(\">\", false);\n  var peg$e62 = peg$literalExpectation(\"<<\", false);\n  var peg$e63 = peg$literalExpectation(\">>\", false);\n  var peg$e64 = peg$literalExpectation(\"+\", false);\n  var peg$e65 = peg$literalExpectation(\"-\", false);\n  var peg$e66 = peg$literalExpectation(\"/\", false);\n  var peg$e67 = peg$literalExpectation(\"%\", false);\n  var peg$e68 = peg$literalExpectation(\"++\", false);\n  var peg$e69 = peg$literalExpectation(\"--\", false);\n  var peg$e70 = peg$literalExpectation(\"!\", false);\n  var peg$e71 = peg$literalExpectation(\"~\", false);\n  var peg$e72 = peg$literalExpectation(\"sizeof\", false);\n  var peg$e73 = peg$literalExpectation(\".\", false);\n  var peg$e74 = peg$literalExpectation(\"->\", false);\n  var peg$e75 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"!\", \"'\", \"\\\"\", \"#\", \"%\", \"&\", \"(\", \")\", \"*\", \"+\", [\",\", \".\"], \"/\", \":\", \" \", \";\", \"<\", \"=\", \">\", \"?\", \"[\", \"]\", \"^\", \"_\", \"{\", \"|\", \"}\", \"~\", \"\\t\", \"\\v\", \"\\f\"], false, true);\n  var peg$e76 = peg$literalExpectation(\"@\", false);\n  var peg$e77 = peg$literalExpectation(\"#include <\", false);\n  var peg$e78 = peg$literalExpectation(\"_Static_assert\", false);\n  var peg$e79 = peg$literalExpectation(\"_Thread_local\", false);\n  var peg$e80 = peg$literalExpectation(\"_Imaginary\", false);\n  var peg$e81 = peg$literalExpectation(\"_Noreturn\", false);\n  var peg$e82 = peg$literalExpectation(\"register\", false);\n  var peg$e83 = peg$literalExpectation(\"restrict\", false);\n  var peg$e84 = peg$literalExpectation(\"volatile\", false);\n  var peg$e85 = peg$literalExpectation(\"_Alignas\", false);\n  var peg$e86 = peg$literalExpectation(\"_Alignof\", false);\n  var peg$e87 = peg$literalExpectation(\"_Complex\", false);\n  var peg$e88 = peg$literalExpectation(\"_Generic\", false);\n  var peg$e89 = peg$literalExpectation(\"_Atomic\", false);\n  var peg$e90 = peg$literalExpectation(\"extern\", false);\n  var peg$e91 = peg$literalExpectation(\"inline\", false);\n  var peg$e92 = peg$literalExpectation(\"union\", false);\n  var peg$e93 = peg$literalExpectation(\"_Bool\", false);\n  var peg$e94 = peg$literalExpectation(\"goto\", false);\n  var peg$e95 = peg$classExpectation([[\"a\", \"z\"], \"_\"], false, true);\n  var peg$e96 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"_\"], false, true);\n  var peg$e97 = peg$literalExpectation(\"0\", false);\n  var peg$e98 = peg$classExpectation([[\"1\", \"9\"]], false, false);\n  var peg$e99 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e100 = peg$classExpectation([[\"0\", \"7\"]], false, false);\n  var peg$e101 = peg$literalExpectation(\"0x\", false);\n  var peg$e102 = peg$literalExpectation(\"0X\", false);\n  var peg$e103 = peg$classExpectation([[\"0\", \"9\"], [\"A\", \"F\"]], false, true);\n  var peg$e104 = peg$literalExpectation(\"u\", false);\n  var peg$e105 = peg$literalExpectation(\"U\", false);\n  var peg$e106 = peg$literalExpectation(\"l\", false);\n  var peg$e107 = peg$literalExpectation(\"L\", false);\n  var peg$e108 = peg$literalExpectation(\"ll\", false);\n  var peg$e109 = peg$literalExpectation(\"LL\", false);\n  var peg$e110 = peg$literalExpectation(\"e\", false);\n  var peg$e111 = peg$literalExpectation(\"E\", false);\n  var peg$e112 = peg$classExpectation([\"f\", \"l\"], false, true);\n  var peg$e113 = peg$literalExpectation(\"'\", false);\n  var peg$e114 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"!\", \"\\\"\", \"#\", \"%\", \"&\", \"(\", \")\", \"*\", \"+\", [\",\", \".\"], \"/\", \":\", \" \", \";\", \"<\", \"=\", \">\", \"?\", \"[\", \"]\", \"^\", \"_\", \"{\", \"|\", \"}\", \"~\", \"\\t\", \"\\v\", \"\\f\"], false, true);\n  var peg$e115 = peg$literalExpectation(\"\\\\'\", false);\n  var peg$e116 = peg$literalExpectation(\"\\\\\\\"\", false);\n  var peg$e117 = peg$literalExpectation(\"\\\\?\", false);\n  var peg$e118 = peg$literalExpectation(\"\\\\\\\\\", false);\n  var peg$e119 = peg$literalExpectation(\"\\\\a\", false);\n  var peg$e120 = peg$literalExpectation(\"\\\\b\", false);\n  var peg$e121 = peg$literalExpectation(\"\\\\f\", false);\n  var peg$e122 = peg$literalExpectation(\"\\\\r\", false);\n  var peg$e123 = peg$literalExpectation(\"\\\\n\", false);\n  var peg$e124 = peg$literalExpectation(\"\\\\t\", false);\n  var peg$e125 = peg$literalExpectation(\"\\\\v\", false);\n  var peg$e126 = peg$literalExpectation(\"\\\\\", false);\n  var peg$e127 = peg$literalExpectation(\"\\\\x\", false);\n  var peg$e128 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e129 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"!\", \"'\", \"#\", \"%\", \"&\", \"(\", \")\", \"*\", \"+\", [\",\", \".\"], \"/\", \":\", \" \", \";\", \"<\", \"=\", \">\", \"?\", \"[\", \"]\", \"^\", \"_\", \"{\", \"|\", \"}\", \"~\", \"\\t\", \"\\v\", \"\\f\"], false, true);\n  var peg$e130 = peg$literalExpectation(\"%:%:\", false);\n  var peg$e131 = peg$literalExpectation(\"...\", false);\n  var peg$e132 = peg$literalExpectation(\"##\", false);\n  var peg$e133 = peg$literalExpectation(\"%:\", false);\n  var peg$e134 = peg$literalExpectation(\"<:\", false);\n  var peg$e135 = peg$literalExpectation(\":>\", false);\n  var peg$e136 = peg$literalExpectation(\"<%\", false);\n  var peg$e137 = peg$literalExpectation(\"%>\", false);\n  var peg$e138 = peg$literalExpectation(\"#\", false);\n\n  var peg$f0 = function(includedModules, rootNode) { rootNode.includedModules = includedModules; return { compilationErrors, warnings, rootNode };};\n  var peg$f1 = function(rootNode) { rootNode.includedModules = []; return { compilationErrors, warnings, rootNode };};\n  var peg$f2 = function(items) { return createRootNode(items); };\n  var peg$f3 = function(declarationSpecifier, declarator, body) { return generateFunctionDefinitionNode([declarationSpecifier], declarator, body); };\n  var peg$f4 = function(declarationSpecifiers, declarator, body) { return generateFunctionDefinitionNode(declarationSpecifiers, declarator, body); };\n  var peg$f5 = function(statements) { return createBlockNode(statements); };\n  var peg$f6 = function() { return createBlockNode([]); };\n  var peg$f7 = function(expr) { return generateNode(\"ReturnStatement\", { value: expr === null ? undefined : expr } ); };\n  var peg$f8 = function() { return generateNode(\"BreakStatement\"); };\n  var peg$f9 = function() { return generateNode(\"ContinueStatement\"); };\n  var peg$f10 = function(body, condition) { return generateNode(\"DoWhileLoop\", { condition, body }); };\n  var peg$f11 = function(condition, body) { return generateNode(\"WhileLoop\", { condition, body }); };\n  var peg$f12 = function(clause, condition, update, body) { return generateNode(\"ForLoop\", { clause: clause === null ? null : { type: \"Expression\", value: clause }, condition, update, body }); };\n  var peg$f13 = function(clause, condition, update, body) { return createDeclarationForLoopNode(clause, condition, update, body);  };\n  var peg$f14 = function(condition, ifStatement, elseStatement) { return generateNode(\"SelectionStatement\", { condition, ifStatement, elseStatement }); };\n  var peg$f15 = function(condition, ifStatement) { return generateNode( \"SelectionStatement\", { condition, ifStatement }); };\n  var peg$f16 = function(targetExpression, cases, defaultStatements) { return createSwitchStatementNode(targetExpression, cases, defaultStatements ?? []); };\n  var peg$f17 = function(targetExpression, defaultStatements) { return createSwitchStatementNode(targetExpression, [], defaultStatements); };\n  var peg$f18 = function(targetExpression) { return createSwitchStatementNode(targetExpression, [], []); };\n  var peg$f19 = function(targetExpression) { warn(\"Statement will never be executed\"); return createSwitchStatementNode(targetExpression, [], []); };\n  var peg$f20 = function() { return []; };\n  var peg$f21 = function(conditionMatch, statements) { return generateNode(\"SwitchStatementCase\", { conditionMatch, statements }); };\n  var peg$f22 = function(conditionMatch) { return generateNode(\"SwitchStatementCase\", { conditionMatch, statements: [] }); };\n  var peg$f23 = function(declarationSpecifier, initDeclarators) { return processDeclaration([declarationSpecifier], initDeclarators); };\n  var peg$f24 = function(declarationSpecifiers, initDeclarators) { return processDeclaration(declarationSpecifiers, initDeclarators); };\n  var peg$f25 = function(declarationSpecifiers, initDeclarators) { return processDeclaration(declarationSpecifiers, initDeclarators); };\n  var peg$f26 = function(declarationSpecifiers) { return processDeclarationWithoutDeclarator(declarationSpecifiers); };\n  var peg$f27 = function(specifier) { return generateNode(\"TypeSpecifier\", { specifier } ); };\n  var peg$f28 = function() { return generateNode(\"TypeQualifier\", { qualifier: \"const\"}); };\n  var peg$f29 = function(specifier) { return generateNode(\"StorageClassSpecifier\", { specifier }); };\n  var peg$f30 = function() { return { type: \"TypeDefSpecifier\" }; };\n  var peg$f31 = function(specifier) { return generateNode(\"PrimaryTypeSpecifier\", { specifier }); };\n  var peg$f32 = function(specifier) { return generateNode(\"StructTypeSpecifier\", { specifier }); };\n  var peg$f33 = function(specifier) { return generateNode(\"PrimaryDataTypeLengthSpecifier\", { specifier }); };\n  var peg$f34 = function(specifier) { return generateNode(\"IntegerSignSpecifier\", { specifier }); };\n  var peg$f35 = function() { return generateNode(\"VoidTypeSpecifier\"); };\n  var peg$f36 = function(specifier) { return generateNode(\"EnumTypeSpecifier\", { specifier }); };\n  var peg$f37 = function(typeName) { return generateNode(\"UserNamedTypeSpecifier\", { typeName }); };\n  var peg$f38 = function(name) { return isIdentifierAType(name); };\n  var peg$f39 = function(name) { return name; };\n  var peg$f40 = function(declarator, initializer) { return { ...declarator, initializer  }; };\n  var peg$f41 = function(pointers, directDeclarator) { return createPointerDeclaratorNode(pointers, directDeclarator); };\n  var peg$f42 = function(directDeclarator) { return directDeclarator; };\n  var peg$f43 = function(qualifier) { return { type: \"pointer\", isConst: qualifier !== null}; };\n  var peg$f44 = function(value) { return createInitializerSingle(value); };\n  var peg$f45 = function(list) { return createInitializerList(list); };\n  var peg$f46 = function(directDeclarator, declaratorSuffixes) { return evaluateDeclaratorSuffixes(directDeclarator, declaratorSuffixes); };\n  var peg$f47 = function(directDeclarator) { return evaluateDeclaratorSuffixes(directDeclarator, []); };\n  var peg$f48 = function(symbolName) { return { type: \"SymbolDeclarator\", symbolName }; };\n  var peg$f49 = function(parameters) { return createFunctionDeclarator(parameters); };\n  var peg$f50 = function() { return createFunctionDeclarator(); };\n  var peg$f51 = function(numElements) { return { type: \"ArrayDeclarator\", numElements: numElements !== null ? numElements : undefined }; };\n  var peg$f52 = function(tag, fieldDeclarations) { return generateNode(tag === null ? \"AnonymousStruct\" : \"NamedStructDefinition\", createStructSpecifier(fieldDeclarations, tag)); };\n  var peg$f53 = function(tag) { return generateNode(tag === null ? \"AnonymousStruct\" : \"NamedStructDefinition\", createEmptyStructSpecifier(tag)); };\n  var peg$f54 = function(tag) { return generateNode(\"NamedStructReference\", { tag } ); };\n  var peg$f55 = function(declarations) { return unpackStructDeclarations(declarations); };\n  var peg$f56 = function(specifier, declarators) { return processStructDeclaration([specifier], declarators); };\n  var peg$f57 = function(specifiers, declarators) { return processStructDeclaration(specifiers, declarators); };\n  var peg$f58 = function(specifier) { return { type: \"TypeSpecifier\", specifier }; };\n  var peg$f59 = function(tag, enumerators) { return generateNode(\"NamedDefinedEnum\", { tag, enumerators } ); };\n  var peg$f60 = function(enumerators) { return generateNode(\"AnonymousEnum\", { enumerators }); };\n  var peg$f61 = function(tag) { return generateNode(\"NamedEnumReference\", { tag }); };\n  var peg$f62 = function(name, value) { return { name, value }; };\n  var peg$f63 = function(name) { return { name }; };\n  var peg$f64 = function(parameters) { return unpackParameters(parameters); };\n  var peg$f65 = function(declarationSpecifier, declarator) { return processParameterDeclaration([declarationSpecifier], declarator); };\n  var peg$f66 = function(declarationSpecifiers, declarator) { return processParameterDeclaration(declarationSpecifiers, declarator); };\n  var peg$f67 = function(declarationSpecifiers, abstractDeclarator) { return processParameterDeclaration(declarationSpecifiers, abstractDeclarator); };\n  var peg$f68 = function(declarationSpecifiers) { return processParameterDeclaration(declarationSpecifiers, null); };\n  var peg$f69 = function(pointers, directAbstractDeclarator) { return createPointerDeclaratorNode(pointers, directAbstractDeclarator); };\n  var peg$f70 = function(pointers) { return createPointerDeclaratorNode(pointers, { type: \"AbstractDeclarator\" }); };\n  var peg$f71 = function(directAbstractDeclarator) { return directAbstractDeclarator; };\n  var peg$f72 = function(directAbstractDeclarator, declaratorSuffixes) { return evaluateDeclaratorSuffixes(directAbstractDeclarator, declaratorSuffixes); };\n  var peg$f73 = function(declaratorSuffixes) { return evaluateDeclaratorSuffixes({ type: \"AbstractDeclarator\" }, declaratorSuffixes); };\n  var peg$f74 = function(expressions) { return generateNode(\"CommaSeparatedExpressions\", { expressions }); };\n  var peg$f75 = function(lvalue, assignmentOperator, assignedExpression) { return createAssignmentNode(lvalue, assignedExpression, assignmentOperator); };\n  var peg$f76 = function(condition, trueExpression, falseExpression) { return generateNode(\"ConditionalExpression\", { condition, trueExpression, falseExpression }); };\n  var peg$f77 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f78 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f79 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f80 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f81 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f82 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f83 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f84 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f85 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f86 = function(firstExpr, tail) { return createLeftToRightBinaryExpressionTree(firstExpr, tail); };\n  var peg$f87 = function(operations, firstExpr) { return createPrefixExpressionNode(firstExpr, operations); };\n  var peg$f88 = function(operator) { return { type: \"PrefixExpression\", operator }; };\n  var peg$f89 = function(operator) { return { type: \"PrefixExpression\", operator }; };\n  var peg$f90 = function(operator) { return { type: \"PointerDereference\" }; };\n  var peg$f91 = function() { return { type: \"AddressOfExpression\" }; };\n  var peg$f92 = function() { return { type: \"SizeOfExpression\", subtype: \"expression\" }; };\n  var peg$f93 = function(firstExpr, operations) { return createPostfixExpressionNode(firstExpr, operations); };\n  var peg$f94 = function(operator) { return generateNode(\"PostfixExpression\", { operator }); };\n  var peg$f95 = function(args) { return generateNode(\"FunctionCall\", { args }); };\n  var peg$f96 = function() { return generateNode(\"FunctionCall\", { args: [] } ); };\n  var peg$f97 = function(index) { return generateNode(\"ArrayElementExpr\", { index }); };\n  var peg$f98 = function(fieldTag) { return generateNode(\"StructMemberAccess\", { fieldTag }); };\n  var peg$f99 = function(fieldTag) { return generateNode(\"StructPointerMemberAccess\", { fieldTag }); };\n  var peg$f100 = function(dataType) { return createSizeOfDataTypeExpression(dataType); };\n  var peg$f101 = function(name) { return isIdentifierAType(name); };\n  var peg$f102 = function(name) { return generateNode(\"IdentifierExpression\", { name }); };\n  var peg$f103 = function(specifiers, declarator) { return generateDataTypeFromSpecifierAndAbstractDeclarators(specifiers, declarator); };\n  var peg$f104 = function(identifier) { addIncludedModuleDefinitions(identifier); return identifier; };\n  var peg$f105 = function(str) { return isStringAKeyword(str) ? false : true; };\n  var peg$f106 = function(str) { return str; };\n  var peg$f107 = function(value, suffix) { return generateIntegerConstant(value, suffix); };\n  var peg$f108 = function(value) { return \"0o\" + value; };\n  var peg$f109 = function(value, suffix) { return generateFloatConstant(value, suffix); };\n  var peg$f110 = function(value, suffix) { return generateFloatConstant(value, suffix); };\n  var peg$f111 = function(name) { return isIdentifierAType(name); };\n  var peg$f112 = function(name) { return name; };\n  var peg$f113 = function(value) { return generateNode(\"IntegerConstant\", { value: BigInt(value) }); };\n  var peg$f114 = function(char) { return char.charCodeAt(0); };\n  var peg$f115 = function(char) { return char.charCodeAt(0); };\n  var peg$f116 = function() { return 39; };\n  var peg$f117 = function() { return 34; };\n  var peg$f118 = function() { return 63; };\n  var peg$f119 = function() { return 92; };\n  var peg$f120 = function() { return 7; };\n  var peg$f121 = function() { return 8; };\n  var peg$f122 = function() { return 12; };\n  var peg$f123 = function() { return 13; };\n  var peg$f124 = function() { return 10; };\n  var peg$f125 = function() { return 9; };\n  var peg$f126 = function() { return 11; };\n  var peg$f127 = function(value) { return parseInt(value, 8); };\n  var peg$f128 = function(value) { return parseInt(value, 16); };\n  var peg$f129 = function(chars) { chars.push(0); return generateNode(\"StringLiteral\", { chars }); };\n  var peg$f130 = function(char) { return char.charCodeAt(0); };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$resultsCache = {};\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseprogram() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 0;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseinclude();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s4 = peg$parseinclude();\n        if (s4 === peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        } else {\n          s3 = s4;\n        }\n      } else {\n        s3 = s4;\n      }\n    }\n    if (s2.length < 1) {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetranslation_unit();\n        s4 = peg$parse_();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f0(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsetranslation_unit();\n      s2 = peg$parse_();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1);\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 1;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s0 = peg$c0;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetranslation_unit() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 2;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsefunction_definition();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parsedeclaration();\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parsefunction_definition();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsedeclaration();\n        }\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    peg$savedPos = s0;\n    s1 = peg$f2(s1);\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefunction_definition() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 3;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedeclaration_specifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedeclarator();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecompound_statement();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f3(s1, s3, s5);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedeclaration_specifiers();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsedeclarator();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecompound_statement();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f4(s1, s3, s5);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestatement() {\n    var s0;\n\n    var key = peg$currPos * 105 + 4;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parseiteration_statement();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsecompound_statement();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsejump_statement();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseexpression_statement();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseselection_statement();\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsecompound_statement() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 5;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c1;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseblock_item_list();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s5 = peg$c2;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e4); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f5(s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c1;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s3 = peg$c2;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e4); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e2); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseblock_item_list() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 6;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseblock_item();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parseblock_item();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseblock_item() {\n    var s0;\n\n    var key = peg$currPos * 105 + 7;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsestatement();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsedeclaration();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsejump_statement() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 8;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c3) {\n      s1 = peg$c3;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseexpression();\n        if (s4 !== peg$FAILED) {\n          s2 = s4;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 59) {\n          s4 = peg$c4;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e6); }\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f7(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c5) {\n        s1 = peg$c5;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 59) {\n            s3 = peg$c4;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e6); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f8();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 8) === peg$c6) {\n          s1 = peg$c6;\n          peg$currPos += 8;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e8); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s3 = peg$c4;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e6); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f9();\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseexpression_statement() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 9;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseexpression();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s2 = peg$c4;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s2 !== peg$FAILED) {\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseiteration_statement() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;\n\n    var key = peg$currPos * 105 + 10;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestatement();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c8) {\n              s5 = peg$c8;\n              peg$currPos += 5;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e10); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 40) {\n                  s7 = peg$c9;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e11); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseexpression();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s11 = peg$c10;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parse_();\n                          if (s12 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 59) {\n                              s13 = peg$c4;\n                              peg$currPos++;\n                            } else {\n                              s13 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                            }\n                            if (s13 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s0 = peg$f10(s3, s9);\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c8) {\n        s1 = peg$c8;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s3 = peg$c9;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e11); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseexpression();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c10;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parsestatement();\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f11(s5, s9);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c11) {\n          s1 = peg$c11;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e13); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e11); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$currPos;\n                s6 = peg$parseexpression();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    s5 = s6;\n                  } else {\n                    peg$currPos = s5;\n                    s5 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s5;\n                  s5 = peg$FAILED;\n                }\n                if (s5 === peg$FAILED) {\n                  s5 = null;\n                }\n                if (input.charCodeAt(peg$currPos) === 59) {\n                  s6 = peg$c4;\n                  peg$currPos++;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                }\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parse_();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$currPos;\n                    s9 = peg$parseexpression();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        s8 = s9;\n                      } else {\n                        peg$currPos = s8;\n                        s8 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s8;\n                      s8 = peg$FAILED;\n                    }\n                    if (s8 === peg$FAILED) {\n                      s8 = null;\n                    }\n                    if (input.charCodeAt(peg$currPos) === 59) {\n                      s9 = peg$c4;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$currPos;\n                        s12 = peg$parseexpression();\n                        if (s12 !== peg$FAILED) {\n                          s13 = peg$parse_();\n                          if (s13 !== peg$FAILED) {\n                            s11 = s12;\n                          } else {\n                            peg$currPos = s11;\n                            s11 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s11;\n                          s11 = peg$FAILED;\n                        }\n                        if (s11 === peg$FAILED) {\n                          s11 = null;\n                        }\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s12 = peg$c10;\n                          peg$currPos++;\n                        } else {\n                          s12 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                        }\n                        if (s12 !== peg$FAILED) {\n                          s13 = peg$parse_();\n                          if (s13 !== peg$FAILED) {\n                            s14 = peg$parsestatement();\n                            if (s14 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s0 = peg$f12(s5, s8, s11, s14);\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 3) === peg$c11) {\n            s1 = peg$c11;\n            peg$currPos += 3;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e13); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s3 = peg$c9;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e11); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsedeclaration();\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parse_();\n                    if (s6 !== peg$FAILED) {\n                      s7 = peg$currPos;\n                      s8 = peg$parseexpression();\n                      if (s8 !== peg$FAILED) {\n                        s9 = peg$parse_();\n                        if (s9 !== peg$FAILED) {\n                          s7 = s8;\n                        } else {\n                          peg$currPos = s7;\n                          s7 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s7;\n                        s7 = peg$FAILED;\n                      }\n                      if (s7 === peg$FAILED) {\n                        s7 = null;\n                      }\n                      if (input.charCodeAt(peg$currPos) === 59) {\n                        s8 = peg$c4;\n                        peg$currPos++;\n                      } else {\n                        s8 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                      }\n                      if (s8 !== peg$FAILED) {\n                        s9 = peg$parse_();\n                        if (s9 !== peg$FAILED) {\n                          s10 = peg$currPos;\n                          s11 = peg$parseexpression();\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parse_();\n                            if (s12 !== peg$FAILED) {\n                              s10 = s11;\n                            } else {\n                              peg$currPos = s10;\n                              s10 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s10;\n                            s10 = peg$FAILED;\n                          }\n                          if (s10 === peg$FAILED) {\n                            s10 = null;\n                          }\n                          if (input.charCodeAt(peg$currPos) === 41) {\n                            s11 = peg$c10;\n                            peg$currPos++;\n                          } else {\n                            s11 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                          }\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parse_();\n                            if (s12 !== peg$FAILED) {\n                              s13 = peg$parsestatement();\n                              if (s13 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f13(s5, s7, s10, s13);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseselection_statement() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;\n\n    var key = peg$currPos * 105 + 11;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c12) {\n      s1 = peg$c12;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s3 = peg$c9;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseexpression();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s7 = peg$c10;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsestatement();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        if (input.substr(peg$currPos, 4) === peg$c13) {\n                          s11 = peg$c13;\n                          peg$currPos += 4;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e15); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parse_();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parsestatement();\n                            if (s13 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s0 = peg$f14(s5, s9, s13);\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c12) {\n        s1 = peg$c12;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s3 = peg$c9;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e11); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseexpression();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c10;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_();\n                    if (s8 !== peg$FAILED) {\n                      s9 = peg$parsestatement();\n                      if (s9 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s0 = peg$f15(s5, s9);\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 6) === peg$c14) {\n          s1 = peg$c14;\n          peg$currPos += 6;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e16); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e11); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseexpression();\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n                  if (s6 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s7 = peg$c10;\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      s8 = peg$parse_();\n                      if (s8 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 123) {\n                          s9 = peg$c1;\n                          peg$currPos++;\n                        } else {\n                          s9 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                        }\n                        if (s9 !== peg$FAILED) {\n                          s10 = peg$parse_();\n                          if (s10 !== peg$FAILED) {\n                            s11 = peg$currPos;\n                            s12 = [];\n                            s13 = peg$parseswitch_statement_case();\n                            while (s13 !== peg$FAILED) {\n                              s12.push(s13);\n                              s13 = peg$currPos;\n                              s14 = peg$parse_();\n                              if (s14 !== peg$FAILED) {\n                                s14 = peg$parseswitch_statement_case();\n                                if (s14 === peg$FAILED) {\n                                  peg$currPos = s13;\n                                  s13 = peg$FAILED;\n                                } else {\n                                  s13 = s14;\n                                }\n                              } else {\n                                s13 = s14;\n                              }\n                            }\n                            if (s12.length < 1) {\n                              peg$currPos = s11;\n                              s11 = peg$FAILED;\n                            } else {\n                              s11 = s12;\n                            }\n                            if (s11 !== peg$FAILED) {\n                              s12 = peg$currPos;\n                              s13 = peg$parse_();\n                              if (s13 !== peg$FAILED) {\n                                s14 = peg$parseswitch_default_case();\n                                if (s14 !== peg$FAILED) {\n                                  s12 = s14;\n                                } else {\n                                  peg$currPos = s12;\n                                  s12 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s12;\n                                s12 = peg$FAILED;\n                              }\n                              if (s12 === peg$FAILED) {\n                                s12 = null;\n                              }\n                              s13 = peg$parse_();\n                              if (s13 !== peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 125) {\n                                  s14 = peg$c2;\n                                  peg$currPos++;\n                                } else {\n                                  s14 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                                }\n                                if (s14 !== peg$FAILED) {\n                                  peg$savedPos = s0;\n                                  s0 = peg$f16(s5, s11, s12);\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 6) === peg$c14) {\n            s1 = peg$c14;\n            peg$currPos += 6;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e16); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s3 = peg$c9;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e11); }\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parseexpression();\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parse_();\n                    if (s6 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 41) {\n                        s7 = peg$c10;\n                        peg$currPos++;\n                      } else {\n                        s7 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                      }\n                      if (s7 !== peg$FAILED) {\n                        s8 = peg$parse_();\n                        if (s8 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 123) {\n                            s9 = peg$c1;\n                            peg$currPos++;\n                          } else {\n                            s9 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                          }\n                          if (s9 !== peg$FAILED) {\n                            s10 = peg$parse_();\n                            if (s10 !== peg$FAILED) {\n                              s11 = peg$parseswitch_default_case();\n                              if (s11 !== peg$FAILED) {\n                                s12 = peg$parse_();\n                                if (s12 !== peg$FAILED) {\n                                  if (input.charCodeAt(peg$currPos) === 125) {\n                                    s13 = peg$c2;\n                                    peg$currPos++;\n                                  } else {\n                                    s13 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                                  }\n                                  if (s13 !== peg$FAILED) {\n                                    peg$savedPos = s0;\n                                    s0 = peg$f17(s5, s11);\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 6) === peg$c14) {\n              s1 = peg$c14;\n              peg$currPos += 6;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e16); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 40) {\n                  s3 = peg$c9;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e11); }\n                }\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parseexpression();\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parse_();\n                      if (s6 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 41) {\n                          s7 = peg$c10;\n                          peg$currPos++;\n                        } else {\n                          s7 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                        }\n                        if (s7 !== peg$FAILED) {\n                          s8 = peg$parse_();\n                          if (s8 !== peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 123) {\n                              s9 = peg$c1;\n                              peg$currPos++;\n                            } else {\n                              s9 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                            }\n                            if (s9 !== peg$FAILED) {\n                              s10 = peg$parse_();\n                              if (s10 !== peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 125) {\n                                  s11 = peg$c2;\n                                  peg$currPos++;\n                                } else {\n                                  s11 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                                }\n                                if (s11 !== peg$FAILED) {\n                                  peg$savedPos = s0;\n                                  s0 = peg$f18(s5);\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 6) === peg$c14) {\n                s1 = peg$c14;\n                peg$currPos += 6;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e16); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 40) {\n                    s3 = peg$c9;\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e11); }\n                  }\n                  if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                      s5 = peg$parseexpression();\n                      if (s5 !== peg$FAILED) {\n                        s6 = peg$parse_();\n                        if (s6 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 41) {\n                            s7 = peg$c10;\n                            peg$currPos++;\n                          } else {\n                            s7 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                          }\n                          if (s7 !== peg$FAILED) {\n                            s8 = peg$parse_();\n                            if (s8 !== peg$FAILED) {\n                              s9 = peg$parsestatement();\n                              if (s9 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f19(s5);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseswitch_default_case() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 12;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c15) {\n      s1 = peg$c15;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e17); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c16;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e18); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseblock_item_list();\n            if (s5 !== peg$FAILED) {\n              s0 = s5;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 7) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 7;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e17); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s3 = peg$c16;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e18); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f20();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseswitch_statement_case() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 13;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c17) {\n      s1 = peg$c17;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseconditional_expression();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s5 = peg$c16;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e18); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseblock_item_list();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f21(s3, s7);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c17) {\n        s1 = peg$c17;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseconditional_expression();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s5 = peg$c16;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e18); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f22(s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedeclaration() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 14;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedeclaration_specifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseinit_declarator_list();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s5 = peg$c4;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e6); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f23(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsedeclaration_specifier();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (s2.length >= 2) {\n          s3 = peg$FAILED;\n        } else {\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s4 = peg$parsedeclaration_specifier();\n            if (s4 === peg$FAILED) {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            } else {\n              s3 = s4;\n            }\n          } else {\n            s3 = s4;\n          }\n        }\n      }\n      if (s2.length < 2) {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseinit_declarator_list();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 59) {\n                s5 = peg$c4;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e6); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f24(s1, s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsedeclaration_specifiers();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseinit_declarator_list();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parse_();\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 59) {\n                  s5 = peg$c4;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f25(s1, s3);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsedeclaration_specifiers();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 59) {\n                s3 = peg$c4;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e6); }\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f26(s1);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedeclaration_specifiers() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 15;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsedeclaration_specifier();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parsedeclaration_specifier();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedeclaration_specifier() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 16;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsetype_qualifier();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsestorage_class_specifier();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsetype_specifier();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f27(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsetypedef_specifier();\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetype_qualifier() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 17;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c18) {\n      s1 = peg$c18;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f28();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestorage_class_specifier() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 18;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c19) {\n      s1 = peg$c19;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 6) === peg$c20) {\n        s1 = peg$c20;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e22); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f29(s1);\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetypedef_specifier() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 19;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c21) {\n      s1 = peg$c21;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f30();\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetype_specifier() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 20;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseprimary_data_type_specifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f31(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestruct_specifier();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f32(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseprimary_data_type_length_specifier();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f33(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseinteger_sign_type_specifier();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f34(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 4) === peg$c22) {\n              s1 = peg$c22;\n              peg$currPos += 4;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e24); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f35();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseenum_specifier();\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f36(s1);\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsetypedef_name();\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$f37(s1);\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseprimary_data_type_specifier() {\n    var s0;\n\n    var key = peg$currPos * 105 + 21;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 4) === peg$c23) {\n      s0 = peg$c23;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e25); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c24) {\n        s0 = peg$c24;\n        peg$currPos += 3;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c25) {\n          s0 = peg$c25;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e27); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 6) === peg$c26) {\n            s0 = peg$c26;\n            peg$currPos += 6;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e28); }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseprimary_data_type_length_specifier() {\n    var s0;\n\n    var key = peg$currPos * 105 + 22;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 4) === peg$c27) {\n      s0 = peg$c27;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e29); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 5) === peg$c28) {\n        s0 = peg$c28;\n        peg$currPos += 5;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e30); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinteger_sign_type_specifier() {\n    var s0;\n\n    var key = peg$currPos * 105 + 23;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 6) === peg$c29) {\n      s0 = peg$c29;\n      peg$currPos += 6;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 8) === peg$c30) {\n        s0 = peg$c30;\n        peg$currPos += 8;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e32); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetypedef_name() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 105 + 24;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f38(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f39(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinit_declarator_list() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key = peg$currPos * 105 + 25;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseinit_declarator();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c31;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parseinit_declarator();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinit_declarator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 26;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedeclarator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s3 = peg$c32;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e34); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseinitializer();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f40(s1, s5);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsedeclarator();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedeclarator() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 27;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsepointer();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedirect_declarator();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f41(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedirect_declarator();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f42(s1);\n      }\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepointer() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 28;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsepointer_with_qualifier();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parsepointer_with_qualifier();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepointer_with_qualifier() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 29;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 42) {\n      s1 = peg$c33;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e35); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        s5 = [];\n        s6 = peg$parsetype_qualifier();\n        while (s6 !== peg$FAILED) {\n          s5.push(s6);\n          s6 = peg$currPos;\n          s7 = peg$parse_();\n          if (s7 !== peg$FAILED) {\n            s7 = peg$parsetype_qualifier();\n            if (s7 === peg$FAILED) {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            } else {\n              s6 = s7;\n            }\n          } else {\n            s6 = s7;\n          }\n        }\n        if (s5.length < 1) {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        } else {\n          s4 = s5;\n        }\n        if (s4 !== peg$FAILED) {\n          s2 = s4;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f43(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinitializer() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 30;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parselist_initializer();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseassignment_expression();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f44(s1);\n      }\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselist_initializer() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    var key = peg$currPos * 105 + 31;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c1;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parseinitializer();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          s7 = peg$parse_();\n          if (s7 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s8 = peg$c31;\n              peg$currPos++;\n            } else {\n              s8 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e33); }\n            }\n            if (s8 !== peg$FAILED) {\n              s9 = peg$parse_();\n              if (s9 !== peg$FAILED) {\n                s7 = [s7, s8, s9];\n                s6 = s7;\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s6;\n              s6 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s6 = peg$parseinitializer();\n            if (s6 === peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            } else {\n              s5 = s6;\n            }\n          } else {\n            s5 = s6;\n          }\n        }\n        s5 = peg$parse_();\n        if (s5 !== peg$FAILED) {\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c31;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s5 = peg$c2;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f45(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedirect_declarator() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key = peg$currPos * 105 + 32;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedirect_declarator_helper();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsefunction_declarator_suffix();\n        if (s5 === peg$FAILED) {\n          s5 = peg$parsearray_declarator_suffix();\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s6 = peg$parsefunction_declarator_suffix();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parsearray_declarator_suffix();\n            }\n            if (s6 === peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            } else {\n              s5 = s6;\n            }\n          } else {\n            s5 = s6;\n          }\n        }\n        if (s4.length < 1) {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        } else {\n          s3 = s4;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f46(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedirect_declarator_helper();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f47(s1);\n      }\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedirect_declarator_helper() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 33;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f48(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsedeclarator();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c10;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e12); }\n              }\n              if (s5 !== peg$FAILED) {\n                s0 = s3;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefunction_declarator_suffix() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 34;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseparameter_list();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c10;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e12); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f49(s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c10;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e12); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f50();\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsearray_declarator_suffix() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 35;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c34;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e36); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseassignment_expression();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s4 = peg$c35;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e37); }\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f51(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestruct_specifier() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var key = peg$currPos * 105 + 36;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c36) {\n      s1 = peg$c36;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e38); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseidentifier();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s4 = peg$c1;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsestruct_declaration_list();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parse_();\n              if (s7 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 125) {\n                  s8 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                }\n                if (s8 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f52(s3, s6);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 6) === peg$c36) {\n        s1 = peg$c36;\n        peg$currPos += 6;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e38); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$parseidentifier();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s4 = peg$c1;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s6 = peg$c2;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e4); }\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f53(s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 6) === peg$c36) {\n          s1 = peg$c36;\n          peg$currPos += 6;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e38); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseidentifier();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f54(s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestruct_declaration_list() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 37;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parsestruct_declaration();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s4 = peg$parsestruct_declaration();\n        if (s4 === peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        } else {\n          s3 = s4;\n        }\n      } else {\n        s3 = s4;\n      }\n    }\n    if (s2.length < 1) {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f55(s1);\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestruct_declaration() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 38;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsespecifier_qualifier_list_item();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestruct_declarator_list();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 59) {\n              s5 = peg$c4;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e6); }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f56(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsespecifier_qualifier_list();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsestruct_declarator_list();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 59) {\n                s5 = peg$c4;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e6); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f57(s1, s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsespecifier_qualifier_list() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 39;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsespecifier_qualifier_list_item();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parsespecifier_qualifier_list_item();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsespecifier_qualifier_list_item() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 40;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsetype_specifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f58(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetype_qualifier();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestruct_declarator_list() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key = peg$currPos * 105 + 41;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsedeclarator();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c31;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parsedeclarator();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseenum_specifier() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    var key = peg$currPos * 105 + 42;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c37) {\n      s1 = peg$c37;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseidentifier();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseenumerator_list();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 44) {\n                      s10 = peg$c31;\n                      peg$currPos++;\n                    } else {\n                      s10 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n                    }\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parse_();\n                      if (s11 !== peg$FAILED) {\n                        s10 = [s10, s11];\n                        s9 = s10;\n                      } else {\n                        peg$currPos = s9;\n                        s9 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s9;\n                      s9 = peg$FAILED;\n                    }\n                    if (s9 === peg$FAILED) {\n                      s9 = null;\n                    }\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s10 = peg$c2;\n                      peg$currPos++;\n                    } else {\n                      s10 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                    }\n                    if (s10 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f59(s3, s7);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c37) {\n        s1 = peg$c37;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s3 = peg$c1;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e3); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseenumerator_list();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 44) {\n                    s8 = peg$c31;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e33); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parse_();\n                    if (s9 !== peg$FAILED) {\n                      s8 = [s8, s9];\n                      s7 = s8;\n                    } else {\n                      peg$currPos = s7;\n                      s7 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s8 = peg$c2;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f60(s5);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 4) === peg$c37) {\n          s1 = peg$c37;\n          peg$currPos += 4;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e39); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseidentifier();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f61(s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseenumerator_list() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key = peg$currPos * 105 + 43;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseenumerator();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c31;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parseenumerator();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseenumerator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 44;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseenumeration_constant();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s3 = peg$c32;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e34); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseconditional_expression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f62(s1, s5);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseenumeration_constant();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f63(s1);\n      }\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseparameter_list() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 45;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseparameter_declaration();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      s5 = peg$parse_();\n      if (s5 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s6 = peg$c31;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parse_();\n          if (s7 !== peg$FAILED) {\n            s5 = [s5, s6, s7];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s4 = peg$parseparameter_declaration();\n        if (s4 === peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        } else {\n          s3 = s4;\n        }\n      } else {\n        s3 = s4;\n      }\n    }\n    if (s2.length < 1) {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f64(s1);\n    }\n    s0 = s1;\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseparameter_declaration() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 46;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedeclaration_specifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedeclarator();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f65(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedeclaration_specifiers();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsedeclarator();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f66(s1, s3);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsedeclaration_specifiers();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseabstract_declarator();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f67(s1, s3);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsedeclaration_specifiers();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f68(s1);\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseabstract_declarator() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 47;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsepointer();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedirect_abstract_declarator();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f69(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsepointer();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f70(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsedirect_abstract_declarator();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f71(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedirect_abstract_declarator() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key = peg$currPos * 105 + 48;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedirect_abstract_declarator_helper();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsefunction_declarator_suffix();\n        if (s5 === peg$FAILED) {\n          s5 = peg$parsearray_declarator_suffix();\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s6 = peg$parsefunction_declarator_suffix();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parsearray_declarator_suffix();\n            }\n            if (s6 === peg$FAILED) {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            } else {\n              s5 = s6;\n            }\n          } else {\n            s5 = s6;\n          }\n        }\n        if (s4.length < 1) {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        } else {\n          s3 = s4;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f72(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$parsefunction_declarator_suffix();\n      if (s3 === peg$FAILED) {\n        s3 = peg$parsearray_declarator_suffix();\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          s4 = peg$parsefunction_declarator_suffix();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsearray_declarator_suffix();\n          }\n          if (s4 === peg$FAILED) {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          } else {\n            s3 = s4;\n          }\n        } else {\n          s3 = s4;\n        }\n      }\n      if (s2.length < 1) {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f73(s1);\n      }\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedirect_abstract_declarator_helper() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 49;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e11); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseabstract_declarator();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c10;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e12); }\n            }\n            if (s5 !== peg$FAILED) {\n              s0 = s3;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseexpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 50;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseassignment_expression();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      s5 = peg$parse_();\n      if (s5 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s6 = peg$c31;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parse_();\n          if (s7 !== peg$FAILED) {\n            s5 = [s5, s6, s7];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s4 = peg$parseassignment_expression();\n        if (s4 === peg$FAILED) {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        } else {\n          s3 = s4;\n        }\n      } else {\n        s3 = s4;\n      }\n    }\n    if (s2.length < 2) {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f74(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseassignment_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseassignment_expression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 51;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseunary_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseassignment_operator();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseassignment_expression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f75(s1, s3, s5);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseconditional_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseassignment_operator() {\n    var s0;\n\n    var key = peg$currPos * 105 + 52;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c38) {\n      s0 = peg$c38;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e40); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c39) {\n        s0 = peg$c39;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e41); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c40) {\n          s0 = peg$c40;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e42); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c41) {\n            s0 = peg$c41;\n            peg$currPos += 2;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e43); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c42) {\n              s0 = peg$c42;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e44); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 3) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 3;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e45); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c44) {\n                  s0 = peg$c44;\n                  peg$currPos += 3;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c45) {\n                    s0 = peg$c45;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e47); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c46) {\n                      s0 = peg$c46;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e48); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c47) {\n                        s0 = peg$c47;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e49); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 61) {\n                          s0 = peg$c32;\n                          peg$currPos++;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e34); }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseconditional_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n    var key = peg$currPos * 105 + 53;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parselogical_or_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 63) {\n          s3 = peg$c48;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e50); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseexpression();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s7 = peg$c16;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e18); }\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse_();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseconditional_expression();\n                    if (s9 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s0 = peg$f76(s1, s5, s9);\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselogical_or_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselogical_or_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 54;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parselogical_and_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c49) {\n          s5 = peg$c49;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e51); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parselogical_and_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c49) {\n              s5 = peg$c49;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e51); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parselogical_and_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f77(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselogical_and_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselogical_and_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 55;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsebitwise_or_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c50) {\n          s5 = peg$c50;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e52); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsebitwise_or_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c50) {\n              s5 = peg$c50;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e52); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebitwise_or_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f78(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsebitwise_or_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsebitwise_or_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 56;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsebitwise_xor_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s5 = peg$c51;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e53); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsebitwise_xor_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 124) {\n              s5 = peg$c51;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e53); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebitwise_xor_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f79(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsebitwise_xor_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsebitwise_xor_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 57;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsebitwise_and_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 94) {\n          s5 = peg$c52;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e54); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsebitwise_and_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 94) {\n              s5 = peg$c52;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e54); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebitwise_and_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f80(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsebitwise_and_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsebitwise_and_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 58;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseequality_relational_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 38) {\n          s5 = peg$c53;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e55); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseequality_relational_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 38) {\n              s5 = peg$c53;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e55); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseequality_relational_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f81(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseequality_relational_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseequality_relational_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 59;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parserelative_relational_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c54) {\n          s5 = peg$c54;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e56); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c55) {\n            s5 = peg$c55;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e57); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parserelative_relational_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c54) {\n              s5 = peg$c54;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e56); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c55) {\n                s5 = peg$c55;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e57); }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parserelative_relational_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f82(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parserelative_relational_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parserelative_relational_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 60;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsebitwise_shift_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c56) {\n          s5 = peg$c56;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e58); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c57) {\n            s5 = peg$c57;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e59); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 60) {\n              s5 = peg$c58;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e60); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 62) {\n                s5 = peg$c59;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e61); }\n              }\n            }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsebitwise_shift_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c56) {\n              s5 = peg$c56;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e58); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c57) {\n                s5 = peg$c57;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e59); }\n              }\n              if (s5 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 60) {\n                  s5 = peg$c58;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e60); }\n                }\n                if (s5 === peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 62) {\n                    s5 = peg$c59;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e61); }\n                  }\n                }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebitwise_shift_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f83(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsebitwise_shift_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsebitwise_shift_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 61;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseadd_subtract_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c60) {\n          s5 = peg$c60;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e62); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.substr(peg$currPos, 2) === peg$c61) {\n            s5 = peg$c61;\n            peg$currPos += 2;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e63); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseadd_subtract_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c60) {\n              s5 = peg$c60;\n              peg$currPos += 2;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e62); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c61) {\n                s5 = peg$c61;\n                peg$currPos += 2;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e63); }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseadd_subtract_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f84(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseadd_subtract_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseadd_subtract_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 62;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsemultiply_divide_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s5 = peg$c62;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e64); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s5 = peg$c63;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e65); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsemultiply_divide_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 43) {\n              s5 = peg$c62;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e64); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 45) {\n                s5 = peg$c63;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e65); }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsemultiply_divide_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f85(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsemultiply_divide_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsemultiply_divide_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 63;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseunary_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s5 = peg$c33;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e35); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s5 = peg$c64;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e66); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 37) {\n              s5 = peg$c65;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e67); }\n            }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseunary_expression();\n            if (s7 !== peg$FAILED) {\n              s3 = [ s5, s7 ];\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 42) {\n              s5 = peg$c33;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e35); }\n            }\n            if (s5 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s5 = peg$c64;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e66); }\n              }\n              if (s5 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 37) {\n                  s5 = peg$c65;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e67); }\n                }\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseunary_expression();\n                if (s7 !== peg$FAILED) {\n                  s3 = [ s5, s7 ];\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f86(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseunary_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseunary_expression() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 64;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parseprefix_operation();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s2 = s3;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseprefix_operation();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepostfix_expression();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f87(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsepostfix_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseprefix_operation() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 65;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c66) {\n      s1 = peg$c66;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e68); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c67) {\n        s1 = peg$c67;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e69); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f88(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s1 = peg$c62;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e64); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c63;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e65); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c68;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e70); }\n          }\n          if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 126) {\n              s1 = peg$c69;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e71); }\n            }\n          }\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f89(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c33;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e35); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f90(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 38) {\n            s1 = peg$c53;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e55); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f91();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 6) === peg$c70) {\n              s1 = peg$c70;\n              peg$currPos += 6;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e72); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f92();\n            }\n            s0 = s1;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepostfix_expression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 66;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseprimary_expression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsepostfix_operation();\n        if (s5 !== peg$FAILED) {\n          s3 = s5;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsepostfix_operation();\n            if (s5 !== peg$FAILED) {\n              s3 = s5;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f93(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseprimary_expression();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepostfix_operation() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 67;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c66) {\n      s1 = peg$c66;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e68); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c67) {\n        s1 = peg$c67;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e69); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f94(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefunction_argument_list();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s5 = peg$c10;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e12); }\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s0 = peg$f95(s3);\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c9;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parse_();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c10;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e12); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f96();\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c34;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e36); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseexpression();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s5 = peg$c35;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e37); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f97(s3);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s1 = peg$c71;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e73); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseidentifier();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f98(s3);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c72) {\n                s1 = peg$c72;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e74); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse_();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseidentifier();\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f99(s3);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefunction_argument_list() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    var key = peg$currPos * 105 + 68;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseassignment_expression();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c31;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e33); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s3 = peg$parseassignment_expression();\n        if (s3 === peg$FAILED) {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        } else {\n          s2 = s3;\n        }\n      } else {\n        s2 = s3;\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseprimary_expression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var key = peg$currPos * 105 + 69;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c70) {\n      s1 = peg$c70;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e72); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s3 = peg$c9;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsetype_name();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s7 = peg$c10;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f100(s5);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseidentifier();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = peg$currPos;\n        s2 = peg$f101(s1);\n        if (s2) {\n          s2 = peg$FAILED;\n        } else {\n          s2 = undefined;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f102(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseconstant();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsestring_literal();\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s1 = peg$c9;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e11); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseexpression();\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n                  if (s4 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s5 = peg$c10;\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s0 = s3;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetype_name() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 70;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsespecifier_qualifier_list();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseabstract_declarator();\n        if (s4 !== peg$FAILED) {\n          s2 = s4;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f103(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsesource_character_set() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 71;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e75); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseextended_source_character_set();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseextended_source_character_set() {\n    var s0;\n\n    var key = peg$currPos * 105 + 72;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 64) {\n      s0 = peg$c73;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e76); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsetoken() {\n    var s0;\n\n    var key = peg$currPos * 105 + 73;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parseinclude();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsekeyword();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseidentifier();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseconstant();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsestring_literal();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsepunctuator();\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinclude() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 74;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 10) === peg$c74) {\n      s1 = peg$c74;\n      peg$currPos += 10;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e77); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseidentifier();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 62) {\n          s3 = peg$c59;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e61); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f104(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsekeyword() {\n    var s0;\n\n    var key = peg$currPos * 105 + 75;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 14) === peg$c75) {\n      s0 = peg$c75;\n      peg$currPos += 14;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e78); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 13) === peg$c76) {\n        s0 = peg$c76;\n        peg$currPos += 13;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e79); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 10) === peg$c77) {\n          s0 = peg$c77;\n          peg$currPos += 10;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e80); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 9) === peg$c78) {\n            s0 = peg$c78;\n            peg$currPos += 9;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e81); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c6) {\n              s0 = peg$c6;\n              peg$currPos += 8;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e8); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 8) === peg$c79) {\n                s0 = peg$c79;\n                peg$currPos += 8;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e82); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c80) {\n                  s0 = peg$c80;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e83); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8) === peg$c30) {\n                    s0 = peg$c30;\n                    peg$currPos += 8;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e32); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 8) === peg$c81) {\n                      s0 = peg$c81;\n                      peg$currPos += 8;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e84); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 8) === peg$c82) {\n                        s0 = peg$c82;\n                        peg$currPos += 8;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e85); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c83) {\n                          s0 = peg$c83;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e86); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c84) {\n                            s0 = peg$c84;\n                            peg$currPos += 8;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e87); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 8) === peg$c85) {\n                              s0 = peg$c85;\n                              peg$currPos += 8;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e88); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 7) === peg$c15) {\n                                s0 = peg$c15;\n                                peg$currPos += 7;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e17); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 7) === peg$c21) {\n                                  s0 = peg$c21;\n                                  peg$currPos += 7;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e23); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 7) === peg$c86) {\n                                    s0 = peg$c86;\n                                    peg$currPos += 7;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$e89); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 6) === peg$c87) {\n                                      s0 = peg$c87;\n                                      peg$currPos += 6;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$e90); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 6) === peg$c88) {\n                                        s0 = peg$c88;\n                                        peg$currPos += 6;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$e91); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 6) === peg$c26) {\n                                          s0 = peg$c26;\n                                          peg$currPos += 6;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$e28); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 6) === peg$c3) {\n                                            s0 = peg$c3;\n                                            peg$currPos += 6;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$e5); }\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 6) === peg$c29) {\n                                              s0 = peg$c29;\n                                              peg$currPos += 6;\n                                            } else {\n                                              s0 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$e31); }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              if (input.substr(peg$currPos, 6) === peg$c70) {\n                                                s0 = peg$c70;\n                                                peg$currPos += 6;\n                                              } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$e72); }\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 6) === peg$c20) {\n                                                  s0 = peg$c20;\n                                                  peg$currPos += 6;\n                                                } else {\n                                                  s0 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$e22); }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  if (input.substr(peg$currPos, 6) === peg$c36) {\n                                                    s0 = peg$c36;\n                                                    peg$currPos += 6;\n                                                  } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$e38); }\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 6) === peg$c14) {\n                                                      s0 = peg$c14;\n                                                      peg$currPos += 6;\n                                                    } else {\n                                                      s0 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      if (input.substr(peg$currPos, 5) === peg$c5) {\n                                                        s0 = peg$c5;\n                                                        peg$currPos += 5;\n                                                      } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 5) === peg$c25) {\n                                                          s0 = peg$c25;\n                                                          peg$currPos += 5;\n                                                        } else {\n                                                          s0 = peg$FAILED;\n                                                          if (peg$silentFails === 0) { peg$fail(peg$e27); }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          if (input.substr(peg$currPos, 5) === peg$c18) {\n                                                            s0 = peg$c18;\n                                                            peg$currPos += 5;\n                                                          } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) { peg$fail(peg$e20); }\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 5) === peg$c28) {\n                                                              s0 = peg$c28;\n                                                              peg$currPos += 5;\n                                                            } else {\n                                                              s0 = peg$FAILED;\n                                                              if (peg$silentFails === 0) { peg$fail(peg$e30); }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              if (input.substr(peg$currPos, 5) === peg$c89) {\n                                                                s0 = peg$c89;\n                                                                peg$currPos += 5;\n                                                              } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) { peg$fail(peg$e92); }\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                if (input.substr(peg$currPos, 5) === peg$c8) {\n                                                                  s0 = peg$c8;\n                                                                  peg$currPos += 5;\n                                                                } else {\n                                                                  s0 = peg$FAILED;\n                                                                  if (peg$silentFails === 0) { peg$fail(peg$e10); }\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  if (input.substr(peg$currPos, 5) === peg$c90) {\n                                                                    s0 = peg$c90;\n                                                                    peg$currPos += 5;\n                                                                  } else {\n                                                                    s0 = peg$FAILED;\n                                                                    if (peg$silentFails === 0) { peg$fail(peg$e93); }\n                                                                  }\n                                                                  if (s0 === peg$FAILED) {\n                                                                    if (input.substr(peg$currPos, 4) === peg$c19) {\n                                                                      s0 = peg$c19;\n                                                                      peg$currPos += 4;\n                                                                    } else {\n                                                                      s0 = peg$FAILED;\n                                                                      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n                                                                    }\n                                                                    if (s0 === peg$FAILED) {\n                                                                      if (input.substr(peg$currPos, 4) === peg$c17) {\n                                                                        s0 = peg$c17;\n                                                                        peg$currPos += 4;\n                                                                      } else {\n                                                                        s0 = peg$FAILED;\n                                                                        if (peg$silentFails === 0) { peg$fail(peg$e19); }\n                                                                      }\n                                                                      if (s0 === peg$FAILED) {\n                                                                        if (input.substr(peg$currPos, 4) === peg$c23) {\n                                                                          s0 = peg$c23;\n                                                                          peg$currPos += 4;\n                                                                        } else {\n                                                                          s0 = peg$FAILED;\n                                                                          if (peg$silentFails === 0) { peg$fail(peg$e25); }\n                                                                        }\n                                                                        if (s0 === peg$FAILED) {\n                                                                          if (input.substr(peg$currPos, 4) === peg$c91) {\n                                                                            s0 = peg$c91;\n                                                                            peg$currPos += 4;\n                                                                          } else {\n                                                                            s0 = peg$FAILED;\n                                                                            if (peg$silentFails === 0) { peg$fail(peg$e94); }\n                                                                          }\n                                                                          if (s0 === peg$FAILED) {\n                                                                            if (input.substr(peg$currPos, 4) === peg$c27) {\n                                                                              s0 = peg$c27;\n                                                                              peg$currPos += 4;\n                                                                            } else {\n                                                                              s0 = peg$FAILED;\n                                                                              if (peg$silentFails === 0) { peg$fail(peg$e29); }\n                                                                            }\n                                                                            if (s0 === peg$FAILED) {\n                                                                              if (input.substr(peg$currPos, 4) === peg$c13) {\n                                                                                s0 = peg$c13;\n                                                                                peg$currPos += 4;\n                                                                              } else {\n                                                                                s0 = peg$FAILED;\n                                                                                if (peg$silentFails === 0) { peg$fail(peg$e15); }\n                                                                              }\n                                                                              if (s0 === peg$FAILED) {\n                                                                                if (input.substr(peg$currPos, 4) === peg$c37) {\n                                                                                  s0 = peg$c37;\n                                                                                  peg$currPos += 4;\n                                                                                } else {\n                                                                                  s0 = peg$FAILED;\n                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e39); }\n                                                                                }\n                                                                                if (s0 === peg$FAILED) {\n                                                                                  if (input.substr(peg$currPos, 4) === peg$c22) {\n                                                                                    s0 = peg$c22;\n                                                                                    peg$currPos += 4;\n                                                                                  } else {\n                                                                                    s0 = peg$FAILED;\n                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e24); }\n                                                                                  }\n                                                                                  if (s0 === peg$FAILED) {\n                                                                                    if (input.substr(peg$currPos, 3) === peg$c11) {\n                                                                                      s0 = peg$c11;\n                                                                                      peg$currPos += 3;\n                                                                                    } else {\n                                                                                      s0 = peg$FAILED;\n                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n                                                                                    }\n                                                                                    if (s0 === peg$FAILED) {\n                                                                                      if (input.substr(peg$currPos, 3) === peg$c24) {\n                                                                                        s0 = peg$c24;\n                                                                                        peg$currPos += 3;\n                                                                                      } else {\n                                                                                        s0 = peg$FAILED;\n                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n                                                                                      }\n                                                                                      if (s0 === peg$FAILED) {\n                                                                                        if (input.substr(peg$currPos, 2) === peg$c12) {\n                                                                                          s0 = peg$c12;\n                                                                                          peg$currPos += 2;\n                                                                                        } else {\n                                                                                          s0 = peg$FAILED;\n                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e14); }\n                                                                                        }\n                                                                                        if (s0 === peg$FAILED) {\n                                                                                          if (input.substr(peg$currPos, 2) === peg$c7) {\n                                                                                            s0 = peg$c7;\n                                                                                            peg$currPos += 2;\n                                                                                          } else {\n                                                                                            s0 = peg$FAILED;\n                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e9); }\n                                                                                          }\n                                                                                        }\n                                                                                      }\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                              }\n                                                                            }\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                    }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseidentifier() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 76;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e95); }\n    }\n    if (s3 !== peg$FAILED) {\n      s4 = [];\n      if (peg$r2.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e96); }\n      }\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        if (peg$r2.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e96); }\n        }\n      }\n      s3 = [s3, s4];\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f105(s1);\n      if (s2) {\n        s2 = undefined;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f106(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseconstant() {\n    var s0;\n\n    var key = peg$currPos * 105 + 77;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsedecimal_floating_constant();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseinteger_constant();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseenumeration_constant();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsecharacter_constant();\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinteger_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 78;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedecimal_constant();\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseoctal_constant();\n      if (s1 === peg$FAILED) {\n        s1 = peg$currPos;\n        s2 = peg$parsehexadecimal_constant();\n        if (s2 !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 48) {\n            s1 = peg$c92;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e97); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parseinteger_suffix();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = input.substring(s2, peg$currPos);\n      peg$savedPos = s0;\n      s0 = peg$f107(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedecimal_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 79;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonzero_digit();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsedigit();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsedigit();\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsenonzero_digit() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 80;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e98); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 81;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e99); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseoctal_constant() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 82;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 48) {\n      s1 = peg$c92;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e97); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parseoctal_digit();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseoctal_digit();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f108(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseoctal_digit() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 83;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e100); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 84;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsehexadecimal_prefix();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsehexadecimal_digit();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsehexadecimal_digit();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_prefix() {\n    var s0;\n\n    var key = peg$currPos * 105 + 85;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c93) {\n      s0 = peg$c93;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e101); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c94) {\n        s0 = peg$c94;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e102); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_digit() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 86;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r6.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e103); }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseinteger_suffix() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 105 + 87;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseunsigned_suffix();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parselong_long_suffix();\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseunsigned_suffix();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parselong_suffix();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parselong_long_suffix();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseunsigned_suffix();\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parselong_suffix();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseunsigned_suffix();\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseunsigned_suffix() {\n    var s0;\n\n    var key = peg$currPos * 105 + 88;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s0 = peg$c95;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e104); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 85) {\n        s0 = peg$c96;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e105); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselong_suffix() {\n    var s0;\n\n    var key = peg$currPos * 105 + 89;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 108) {\n      s0 = peg$c97;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e106); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 76) {\n        s0 = peg$c98;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e107); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parselong_long_suffix() {\n    var s0;\n\n    var key = peg$currPos * 105 + 90;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 2) === peg$c99) {\n      s0 = peg$c99;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e108); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c100) {\n        s0 = peg$c100;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e109); }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsedecimal_floating_constant() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 91;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parsefractional_constant();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parseexponent_part();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      s3 = [s3, s4];\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parsefloating_suffix();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = input.substring(s2, peg$currPos);\n      peg$savedPos = s0;\n      s0 = peg$f109(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parsedigit();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsedigit();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseexponent_part();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsefloating_suffix();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f110(s1, s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 92;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsedigit();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsedigit();\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c71;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e73); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      s4 = peg$parsedigit();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsedigit();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parsedigit();\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parsedigit();\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c71;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e73); }\n        }\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseexponent_part() {\n    var s0, s1, s2, s3, s4;\n\n    var key = peg$currPos * 105 + 93;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 101) {\n      s1 = peg$c101;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e110); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 69) {\n        s1 = peg$c102;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e111); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s2 = peg$c62;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e64); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c63;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e65); }\n        }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parsedigit();\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsedigit();\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsefloating_suffix() {\n    var s0;\n\n    var key = peg$currPos * 105 + 94;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (peg$r7.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e112); }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseenumeration_constant() {\n    var s0, s1, s2;\n\n    var key = peg$currPos * 105 + 95;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parseidentifier();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = peg$currPos;\n      s2 = peg$f111(s1);\n      if (s2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = undefined;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f112(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsecharacter_constant() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 96;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s1 = peg$c103;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e113); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsec_char();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s3 = peg$c103;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e113); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f113(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsec_char() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 97;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e114); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f114(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseextended_source_character_set();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f115(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseescape_sequence();\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseescape_sequence() {\n    var s0;\n\n    var key = peg$currPos * 105 + 98;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$parsesimple_escape_sequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseoctal_escape_sequence();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehexadecimal_escape_sequence();\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsesimple_escape_sequence() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 99;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c104) {\n      s1 = peg$c104;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e115); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f116();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c105) {\n        s1 = peg$c105;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e116); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f117();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c106) {\n          s1 = peg$c106;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e117); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$f118();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c107) {\n            s1 = peg$c107;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e118); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f119();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c108) {\n              s1 = peg$c108;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e119); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f120();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c109) {\n                s1 = peg$c109;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e120); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f121();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.substr(peg$currPos, 2) === peg$c110) {\n                  s1 = peg$c110;\n                  peg$currPos += 2;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e121); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$f122();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.substr(peg$currPos, 2) === peg$c111) {\n                    s1 = peg$c111;\n                    peg$currPos += 2;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e122); }\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$f123();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.substr(peg$currPos, 2) === peg$c112) {\n                      s1 = peg$c112;\n                      peg$currPos += 2;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e123); }\n                    }\n                    if (s1 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$f124();\n                    }\n                    s0 = s1;\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$currPos;\n                      if (input.substr(peg$currPos, 2) === peg$c113) {\n                        s1 = peg$c113;\n                        peg$currPos += 2;\n                      } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e124); }\n                      }\n                      if (s1 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$f125();\n                      }\n                      s0 = s1;\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$currPos;\n                        if (input.substr(peg$currPos, 2) === peg$c114) {\n                          s1 = peg$c114;\n                          peg$currPos += 2;\n                        } else {\n                          s1 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e125); }\n                        }\n                        if (s1 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$f126();\n                        }\n                        s0 = s1;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parseoctal_escape_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 100;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c115;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e126); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parseoctal_digit();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        if (s4.length >= 3) {\n          s5 = peg$FAILED;\n        } else {\n          s5 = peg$parseoctal_digit();\n        }\n      }\n      if (s4.length < 1) {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f127(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsehexadecimal_escape_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    var key = peg$currPos * 105 + 101;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c116) {\n      s1 = peg$c116;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e127); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsehexadecimal_digit();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        if (s4.length >= 2) {\n          s5 = peg$FAILED;\n        } else {\n          s5 = peg$parsehexadecimal_digit();\n        }\n      }\n      if (s4.length < 1) {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f128(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsestring_literal() {\n    var s0, s1, s2, s3;\n\n    var key = peg$currPos * 105 + 102;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c117;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e128); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parses_char();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parses_char();\n      }\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c117;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e128); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f129(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parses_char() {\n    var s0, s1;\n\n    var key = peg$currPos * 105 + 103;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    s0 = peg$currPos;\n    if (peg$r9.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e129); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f130(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseescape_sequence();\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n  function peg$parsepunctuator() {\n    var s0;\n\n    var key = peg$currPos * 105 + 104;\n    var cached = peg$resultsCache[key];\n\n    if (cached) {\n      peg$currPos = cached.nextPos;\n\n      return cached.result;\n    }\n\n    if (input.substr(peg$currPos, 4) === peg$c118) {\n      s0 = peg$c118;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e130); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c119) {\n        s0 = peg$c119;\n        peg$currPos += 3;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e131); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c43) {\n          s0 = peg$c43;\n          peg$currPos += 3;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e45); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c44) {\n            s0 = peg$c44;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e46); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c66) {\n              s0 = peg$c66;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e68); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c67) {\n                s0 = peg$c67;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e69); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c38) {\n                  s0 = peg$c38;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e40); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c39) {\n                    s0 = peg$c39;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e41); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c40) {\n                      s0 = peg$c40;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e42); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c41) {\n                        s0 = peg$c41;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$e43); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c42) {\n                          s0 = peg$c42;\n                          peg$currPos += 2;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$e44); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 2) === peg$c45) {\n                            s0 = peg$c45;\n                            peg$currPos += 2;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$e47); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c46) {\n                              s0 = peg$c46;\n                              peg$currPos += 2;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$e48); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 2) === peg$c47) {\n                                s0 = peg$c47;\n                                peg$currPos += 2;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$e49); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 2) === peg$c55) {\n                                  s0 = peg$c55;\n                                  peg$currPos += 2;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$e57); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 2) === peg$c54) {\n                                    s0 = peg$c54;\n                                    peg$currPos += 2;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$e56); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 2) === peg$c56) {\n                                      s0 = peg$c56;\n                                      peg$currPos += 2;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$e58); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 2) === peg$c57) {\n                                        s0 = peg$c57;\n                                        peg$currPos += 2;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$e59); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 2) === peg$c61) {\n                                          s0 = peg$c61;\n                                          peg$currPos += 2;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$e63); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 2) === peg$c60) {\n                                            s0 = peg$c60;\n                                            peg$currPos += 2;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$e62); }\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 2) === peg$c72) {\n                                              s0 = peg$c72;\n                                              peg$currPos += 2;\n                                            } else {\n                                              s0 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$e74); }\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              if (input.substr(peg$currPos, 2) === peg$c50) {\n                                                s0 = peg$c50;\n                                                peg$currPos += 2;\n                                              } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$e52); }\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                if (input.substr(peg$currPos, 2) === peg$c49) {\n                                                  s0 = peg$c49;\n                                                  peg$currPos += 2;\n                                                } else {\n                                                  s0 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$e51); }\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  if (input.substr(peg$currPos, 2) === peg$c120) {\n                                                    s0 = peg$c120;\n                                                    peg$currPos += 2;\n                                                  } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$e132); }\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    if (input.substr(peg$currPos, 2) === peg$c121) {\n                                                      s0 = peg$c121;\n                                                      peg$currPos += 2;\n                                                    } else {\n                                                      s0 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$e133); }\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      if (input.substr(peg$currPos, 2) === peg$c122) {\n                                                        s0 = peg$c122;\n                                                        peg$currPos += 2;\n                                                      } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$e134); }\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        if (input.substr(peg$currPos, 2) === peg$c123) {\n                                                          s0 = peg$c123;\n                                                          peg$currPos += 2;\n                                                        } else {\n                                                          s0 = peg$FAILED;\n                                                          if (peg$silentFails === 0) { peg$fail(peg$e135); }\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          if (input.substr(peg$currPos, 2) === peg$c124) {\n                                                            s0 = peg$c124;\n                                                            peg$currPos += 2;\n                                                          } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) { peg$fail(peg$e136); }\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            if (input.substr(peg$currPos, 2) === peg$c125) {\n                                                              s0 = peg$c125;\n                                                              peg$currPos += 2;\n                                                            } else {\n                                                              s0 = peg$FAILED;\n                                                              if (peg$silentFails === 0) { peg$fail(peg$e137); }\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              if (input.charCodeAt(peg$currPos) === 91) {\n                                                                s0 = peg$c34;\n                                                                peg$currPos++;\n                                                              } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) { peg$fail(peg$e36); }\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                if (input.charCodeAt(peg$currPos) === 93) {\n                                                                  s0 = peg$c35;\n                                                                  peg$currPos++;\n                                                                } else {\n                                                                  s0 = peg$FAILED;\n                                                                  if (peg$silentFails === 0) { peg$fail(peg$e37); }\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  if (input.charCodeAt(peg$currPos) === 40) {\n                                                                    s0 = peg$c9;\n                                                                    peg$currPos++;\n                                                                  } else {\n                                                                    s0 = peg$FAILED;\n                                                                    if (peg$silentFails === 0) { peg$fail(peg$e11); }\n                                                                  }\n                                                                  if (s0 === peg$FAILED) {\n                                                                    if (input.charCodeAt(peg$currPos) === 41) {\n                                                                      s0 = peg$c10;\n                                                                      peg$currPos++;\n                                                                    } else {\n                                                                      s0 = peg$FAILED;\n                                                                      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n                                                                    }\n                                                                    if (s0 === peg$FAILED) {\n                                                                      if (input.charCodeAt(peg$currPos) === 123) {\n                                                                        s0 = peg$c1;\n                                                                        peg$currPos++;\n                                                                      } else {\n                                                                        s0 = peg$FAILED;\n                                                                        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n                                                                      }\n                                                                      if (s0 === peg$FAILED) {\n                                                                        if (input.charCodeAt(peg$currPos) === 125) {\n                                                                          s0 = peg$c2;\n                                                                          peg$currPos++;\n                                                                        } else {\n                                                                          s0 = peg$FAILED;\n                                                                          if (peg$silentFails === 0) { peg$fail(peg$e4); }\n                                                                        }\n                                                                        if (s0 === peg$FAILED) {\n                                                                          if (input.charCodeAt(peg$currPos) === 46) {\n                                                                            s0 = peg$c71;\n                                                                            peg$currPos++;\n                                                                          } else {\n                                                                            s0 = peg$FAILED;\n                                                                            if (peg$silentFails === 0) { peg$fail(peg$e73); }\n                                                                          }\n                                                                          if (s0 === peg$FAILED) {\n                                                                            if (input.charCodeAt(peg$currPos) === 38) {\n                                                                              s0 = peg$c53;\n                                                                              peg$currPos++;\n                                                                            } else {\n                                                                              s0 = peg$FAILED;\n                                                                              if (peg$silentFails === 0) { peg$fail(peg$e55); }\n                                                                            }\n                                                                            if (s0 === peg$FAILED) {\n                                                                              if (input.charCodeAt(peg$currPos) === 42) {\n                                                                                s0 = peg$c33;\n                                                                                peg$currPos++;\n                                                                              } else {\n                                                                                s0 = peg$FAILED;\n                                                                                if (peg$silentFails === 0) { peg$fail(peg$e35); }\n                                                                              }\n                                                                              if (s0 === peg$FAILED) {\n                                                                                if (input.charCodeAt(peg$currPos) === 43) {\n                                                                                  s0 = peg$c62;\n                                                                                  peg$currPos++;\n                                                                                } else {\n                                                                                  s0 = peg$FAILED;\n                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e64); }\n                                                                                }\n                                                                                if (s0 === peg$FAILED) {\n                                                                                  if (input.charCodeAt(peg$currPos) === 45) {\n                                                                                    s0 = peg$c63;\n                                                                                    peg$currPos++;\n                                                                                  } else {\n                                                                                    s0 = peg$FAILED;\n                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e65); }\n                                                                                  }\n                                                                                  if (s0 === peg$FAILED) {\n                                                                                    if (input.charCodeAt(peg$currPos) === 126) {\n                                                                                      s0 = peg$c69;\n                                                                                      peg$currPos++;\n                                                                                    } else {\n                                                                                      s0 = peg$FAILED;\n                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e71); }\n                                                                                    }\n                                                                                    if (s0 === peg$FAILED) {\n                                                                                      if (input.charCodeAt(peg$currPos) === 33) {\n                                                                                        s0 = peg$c68;\n                                                                                        peg$currPos++;\n                                                                                      } else {\n                                                                                        s0 = peg$FAILED;\n                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e70); }\n                                                                                      }\n                                                                                      if (s0 === peg$FAILED) {\n                                                                                        if (input.charCodeAt(peg$currPos) === 47) {\n                                                                                          s0 = peg$c64;\n                                                                                          peg$currPos++;\n                                                                                        } else {\n                                                                                          s0 = peg$FAILED;\n                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e66); }\n                                                                                        }\n                                                                                        if (s0 === peg$FAILED) {\n                                                                                          if (input.charCodeAt(peg$currPos) === 37) {\n                                                                                            s0 = peg$c65;\n                                                                                            peg$currPos++;\n                                                                                          } else {\n                                                                                            s0 = peg$FAILED;\n                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e67); }\n                                                                                          }\n                                                                                          if (s0 === peg$FAILED) {\n                                                                                            if (input.charCodeAt(peg$currPos) === 60) {\n                                                                                              s0 = peg$c58;\n                                                                                              peg$currPos++;\n                                                                                            } else {\n                                                                                              s0 = peg$FAILED;\n                                                                                              if (peg$silentFails === 0) { peg$fail(peg$e60); }\n                                                                                            }\n                                                                                            if (s0 === peg$FAILED) {\n                                                                                              if (input.charCodeAt(peg$currPos) === 62) {\n                                                                                                s0 = peg$c59;\n                                                                                                peg$currPos++;\n                                                                                              } else {\n                                                                                                s0 = peg$FAILED;\n                                                                                                if (peg$silentFails === 0) { peg$fail(peg$e61); }\n                                                                                              }\n                                                                                              if (s0 === peg$FAILED) {\n                                                                                                if (input.charCodeAt(peg$currPos) === 94) {\n                                                                                                  s0 = peg$c52;\n                                                                                                  peg$currPos++;\n                                                                                                } else {\n                                                                                                  s0 = peg$FAILED;\n                                                                                                  if (peg$silentFails === 0) { peg$fail(peg$e54); }\n                                                                                                }\n                                                                                                if (s0 === peg$FAILED) {\n                                                                                                  if (input.charCodeAt(peg$currPos) === 124) {\n                                                                                                    s0 = peg$c51;\n                                                                                                    peg$currPos++;\n                                                                                                  } else {\n                                                                                                    s0 = peg$FAILED;\n                                                                                                    if (peg$silentFails === 0) { peg$fail(peg$e53); }\n                                                                                                  }\n                                                                                                  if (s0 === peg$FAILED) {\n                                                                                                    if (input.charCodeAt(peg$currPos) === 63) {\n                                                                                                      s0 = peg$c48;\n                                                                                                      peg$currPos++;\n                                                                                                    } else {\n                                                                                                      s0 = peg$FAILED;\n                                                                                                      if (peg$silentFails === 0) { peg$fail(peg$e50); }\n                                                                                                    }\n                                                                                                    if (s0 === peg$FAILED) {\n                                                                                                      if (input.charCodeAt(peg$currPos) === 58) {\n                                                                                                        s0 = peg$c16;\n                                                                                                        peg$currPos++;\n                                                                                                      } else {\n                                                                                                        s0 = peg$FAILED;\n                                                                                                        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n                                                                                                      }\n                                                                                                      if (s0 === peg$FAILED) {\n                                                                                                        if (input.charCodeAt(peg$currPos) === 59) {\n                                                                                                          s0 = peg$c4;\n                                                                                                          peg$currPos++;\n                                                                                                        } else {\n                                                                                                          s0 = peg$FAILED;\n                                                                                                          if (peg$silentFails === 0) { peg$fail(peg$e6); }\n                                                                                                        }\n                                                                                                        if (s0 === peg$FAILED) {\n                                                                                                          if (input.charCodeAt(peg$currPos) === 61) {\n                                                                                                            s0 = peg$c32;\n                                                                                                            peg$currPos++;\n                                                                                                          } else {\n                                                                                                            s0 = peg$FAILED;\n                                                                                                            if (peg$silentFails === 0) { peg$fail(peg$e34); }\n                                                                                                          }\n                                                                                                          if (s0 === peg$FAILED) {\n                                                                                                            if (input.charCodeAt(peg$currPos) === 44) {\n                                                                                                              s0 = peg$c31;\n                                                                                                              peg$currPos++;\n                                                                                                            } else {\n                                                                                                              s0 = peg$FAILED;\n                                                                                                              if (peg$silentFails === 0) { peg$fail(peg$e33); }\n                                                                                                            }\n                                                                                                            if (s0 === peg$FAILED) {\n                                                                                                              if (input.charCodeAt(peg$currPos) === 35) {\n                                                                                                                s0 = peg$c126;\n                                                                                                                peg$currPos++;\n                                                                                                              } else {\n                                                                                                                s0 = peg$FAILED;\n                                                                                                                if (peg$silentFails === 0) { peg$fail(peg$e138); }\n                                                                                                              }\n                                                                                                            }\n                                                                                                          }\n                                                                                                        }\n                                                                                                      }\n                                                                                                    }\n                                                                                                  }\n                                                                                                }\n                                                                                              }\n                                                                                            }\n                                                                                          }\n                                                                                        }\n                                                                                      }\n                                                                                    }\n                                                                                  }\n                                                                                }\n                                                                              }\n                                                                            }\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                    }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n    return s0;\n  }\n\n\n  const thisParser = this; // reference to the parser object itself (to get some variables)\n\n  function getCurrPosition() {\n    const loc = range();\n    return {\n      start: thisParser.tokenPositions.get(loc.start).start,\n      end: thisParser.tokenPositions.get(Math.max(loc.start, loc.end - 1)).end\n    }\n  }\n  \n  function throwErrorWithLocation(message) {\n    const e = new Error(message);\n    e.location = location();\n    throw e;\n  }\n\n  /**\n   * Helper function to create and return a Node with position and type information\n   */\n  function generateNode(type, data) {\n    return {\n      type: type,\n      position: getCurrPosition(),\n      ...data,\n    };\n  }\n\n  const C_Keywords = new Set([\n    \"auto\",\n    \"extern\",\n    \"break\",\n    \"float\",\n    \"case\",\n    \"for\",\n    \"char\",\n    \"goto\",\n    \"const\",\n    \"if\",\n    \"continue\",\n    \"inline\",\n    \"default\",\n    \"int\",\n    \"do\",\n    \"long\",\n    \"double\",\n    \"register\",\n    \"else\",\n    \"restrict\",\n    \"enum\",\n    \"return\",\n    \"short\",\n    \"signed\",\n    \"sizeof\",\n    \"static\",\n    \"struct\",\n    \"switch\",\n    \"typedef\",\n    \"union\",\n    \"unsigned\",\n    \"void\",\n    \"volatile\",\n    \"while\",\n    \"_Alignas\",\n    \"_Alignof\",\n    \"_Atomic\",\n    \"_Bool\",\n    \"_Complex\",\n    \"_Generic\",\n    \"_Imaginary\",\n    \"_Noreturn\",\n    \"_Static_assert\",\n    \"_Thread_local\",\n  ]);\n\n  const warnings = [];\n  // add a warning to warnings\n  function warn(message) {\n    warnings.push({ message, position: getCurrPosition() });\n  }\n\n  // any non-syntax related compilation errors detected during parsing\n  const compilationErrors = [];\n  function error(message) {\n    compilationErrors.push({ message, position: getCurrPosition() });\n  }\n\n  // this object is used to keep track of symbols, and identify whether they represent a variable/function or type (defined by struct/enum/typedef)\n  // this is critical for identifying if an identifier is a typename defined by typedef or a variable -> needed for resolving \"typedef ambiguity\"\n  // it is also used for resolving pointers to incomplete types (pointing to structs that are not yet defined)\n  let symbolTable = {\n    // 2 separate namespaces as per 6.2.3 of C17 standard\n    identifiers: {}, // namespace for identifiers (regular variables/functions and types) // a symbol entry is defined as such: { type: \"type\" | \"variable\", dataType: DataType }\n    tags: {}, // namespace for struct/enum tags // a symbol entry is defined as such: { type: \"enum\" | \"struct\", dataType: DataType }\n  };\n\n  function addIdentifierToSymbolTable(name, symbolEntry) {\n    if (name in symbolTable.identifiers) {\n      symbolTable.identifiers[name].push(symbolEntry);\n    } else {\n      symbolTable.identifiers[name] = [symbolEntry];\n    }\n    return { name, symbolEntry }; // returns details of the added symbol, to be removed at end of scope\n  }\n\n  function addTagToSymbolTable(name, symbolEntry) {\n    if (name in symbolTable.tags) {\n      symbolTable.tags[name].push(symbolEntry);\n    } else {\n      symbolTable.tags[name] = [symbolEntry];\n    }\n    return { name, symbolEntry }; // returns details of the added symbol, to be removed at end of scope\n  }\n\n  function isIdentifierAType(name) {\n    if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) {\n      return false;\n    }\n    const entries = symbolTable.identifiers[name];\n    return entries[entries.length - 1].type === \"type\";\n  }\n\n  function isIdentifierDefined(name) {\n    return name in symbolTable.identifiers && symbolTable.identifiers[name].length > 0;\n  }\n\n  function getIdentifierSymbolEntry(name) {\n    if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) {\n      throwErrorWithLocation(`'${name}' not declared`);\n    }\n    const entries = symbolTable.identifiers[name];\n    return entries[entries.length - 1];\n  }\n\n  function isTagDefined(name) {\n    return name in symbolTable.tags && symbolTable.tags[name].length > 0;\n  }\n\n  function getTagSymbolEntry(name) {\n    if (!(name in symbolTable.tags) || symbolTable.tags[name].length <= 0) {\n      throwErrorWithLocation(`'${name}' not declared`);\n    }\n    const entries = symbolTable.tags[name];\n    return entries[entries.length - 1];\n  }\n\n  // pop off the latest symbol entry for a symbol (to be done at end of scopes)\n  function removeIdentifierSymbolEntry(name) {\n    if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) {\n      throwErrorWithLocation(`'${name}' not declared`);\n    }\n    symbolTable.identifiers[name].pop();\n  }\n\n  function removeTagSymbolEntry(name) {\n    if (!(name in symbolTable.tags) || symbolTable.tags[name].length <= 0) {\n      throwErrorWithLocation(`'${name}' undeclared`);\n    }\n    return symbolTable.tags[name].pop();\n  }\n\n  /**\n   *  Try to resolve the incomplete pointers given. Return whatever is still unresolved.\n   */\n  function resolveIncompletePointers(incompletePointers) {\n    const unresolvedIncompletePointers = [];  \n    for (const incompletePointer of incompletePointers) {\n      if (isTagDefined(incompletePointer.pointeeType.tag)) {\n        // incomplete pointee type was defined - now complete\n        incompletePointer.pointeeType = getTagSymbolEntry(\n          incompletePointer.pointeeType.tag\n        ).dataType;\n      } else {\n        // incomplete pointee type still not defined\n        unresolvedIncompletePointers.push(incompletePointer);\n      }\n    }\n    return unresolvedIncompletePointers\n  }\n\n  /**\n   * Remove the identifiers and tags that a given declaration created.\n   * Also resolves incomplete pointers if the declaration resolves them. (declaration defines an incomplete type that a incomplete pointer points to)\n   * Returns any remainig unresolved incomplete pointers.\n   * \n   * Also checks for any redeclaration by checking if a given identifier/tag is removed more than once in the scope containing this declaration\n   * @param removedTagsInScope object containing the tags that were removed in the scope containg this declaration mapped to the type of tag (struct or enum)\n   * @param removedIdentifiersInScope\n   */\n  function removeDeclarationIdentifiersAndTags(declaration, existingIncompletePointers, removedTagsInScope, removedIdentifiersInScope, isRootScope) {\n    let incompletePointers = existingIncompletePointers ?? [];\n    if (declaration.incompletePointers) {\n      // add the incomplete pointers from the declaration itself\n      incompletePointers.push(...(declaration.incompletePointers));\n    }\n\n    incompletePointers = resolveIncompletePointers(incompletePointers);\n\n    // remove identifiers\n    for (const identifierDefinition of declaration.identifierDefinitions) {\n      // check if identifiers were declared before\n      if (identifierDefinition.name in removedIdentifiersInScope) {\n        if (!(identifierDefinition.symbolEntry.type === \"type\" && removedIdentifiersInScope[identifierDefinition.name].type === \"type\") || JSON.stringify(identifierDefinition.symbolEntry.dataType) !== JSON.stringify(removedIdentifiersInScope[identifierDefinition.name].dataType)) {  \n          // in all causes, unless the previous declaration was a typedef that declared as the same type, then there is a redeclaration error.\n          if (isRootScope) {\n            if (identifierDefinition.symbolEntry.type !== \"variable\" || removedIdentifiersInScope[identifierDefinition.name].type !== \"variable\" || JSON.stringify(identifierDefinition.symbolEntry.dataType) !== JSON.stringify(removedIdentifiersInScope[identifierDefinition.name].dataType)) {\n              // in root scope it is allowed to have the 2 declarations with linkage (object/function) as long as they declare the same type\n              error(`redeclaration of '${identifierDefinition.name}' with conflicting type`); \n            }\n          } else {\n            error(`redeclaration of '${identifierDefinition.name}'`);\n          }  \n        }\n      }\n      removedIdentifiersInScope[identifierDefinition.name] = identifierDefinition.symbolEntry;\n      removeIdentifierSymbolEntry(identifierDefinition.name);\n    }\n\n    // remove tags\n    if (declaration.tagDefinitions) {\n      for (const tagDefinition of declaration.tagDefinitions) {\n        if (tagDefinition.name in removedTagsInScope) {\n          if (removedTagsInScope[tagDefinition.name].type === tagDefinition.symbolEntry.type) {\n            // redefinition of enum / struct\n            error(`redefinition of '${removedTagsInScope[tagDefinition.name].type} ${tagDefinition.name}'`);\n          } else {\n            if (removedTagsInScope[tagDefinition.name].type !== \"incomplete\" || removedTagsInScope[tagDefinition.name].subtype !== tagDefinition.symbolEntry.type) {\n              // there is only an error is the previous tag was not incomplete or it was incomplete and its declaerd a different type of tag\n              error(`redefinition of '${tagDefinition.name}' as wrong kind of tag`)\n            }\n          }\n        }\n        removeTagSymbolEntry(tagDefinition.name);\n        removedTagsInScope[tagDefinition.name] = tagDefinition.symbolEntry.dataType;\n      }\n    }\n\n    return incompletePointers;\n  }\n\n  function createBlockNode(statements) {\n    // remove the declarations that were made in this block from the scope and unpack declarations\n    const unpackedBlockStatements = [];\n    let unresolvedIncompletePointers = [];\n    const removedIdentifiers = {};\n    const removedTags = {};\n    for (const statement of statements) {\n      const { unpackedStatements, incompletePointers } = unpackScopedStatement(statement, unresolvedIncompletePointers, removedTags, removedIdentifiers);\n      unpackedBlockStatements.push(...unpackedStatements);\n      unresolvedIncompletePointers = incompletePointers;\n    }\n\n    return generateNode(\"Block\", {\n      statements: unpackedBlockStatements,\n      incompletePointers: unresolvedIncompletePointers,\n    });\n  }\n\n  /**\n   * Unpacks statements in a scope (block, switch scope).\n   */\n  function unpackScopedStatement(statement, unresolvedIncompletePointers, removedTags, removedIdentifiers) {\n    const unpackedStatements = [];\n    let incompletePointers = unresolvedIncompletePointers;\n    if (statement === null) {\n      // ignore null statements\n    } else if (statement.type === \"Declaration\") {\n      unpackedStatements.push(...(statement.declarations));\n      // add any incompletepointers from the declaration\n      incompletePointers = removeDeclarationIdentifiersAndTags(\n        statement,\n        incompletePointers,\n        removedTags,\n        removedIdentifiers\n      );\n    } else if (statement.type === \"Block\" || statement.type === \"SwitchStatement\") {\n      // bring up all the incomplete pointers from the nested block\n      incompletePointers.push(...(statement.incompletePointers));\n      delete statement.incompletePointers;\n      unpackedStatements.push(statement);\n    } else {\n      unpackedStatements.push(statement);\n    }\n\n    return { unpackedStatements, incompletePointers };\n  }\n\n  /**\n   * Performs similarly to createBlockNode - has to remove any declared symbols \n   * as a new scope is defined in the switch statement block.\n   */\n  function createSwitchStatementNode(targetExpression, cases, defaultStatements) {\n    const switchStatementNode = generateNode(\"SwitchStatement\", {\n      targetExpression: targetExpression,\n      cases: [],\n      defaultStatements: [],\n      incompletePointers: []\n    });\n    const removedTags = {};\n    const removedIdentifiers = {};\n    for (const switchCase of cases) {\n      const switchStatementCase = {\n        type: \"SwitchStatementCase\",\n        position: switchCase.position,\n        conditionMatch: switchCase.conditionMatch,\n        statements: []\n      }\n      for (const statement of switchCase.statements) {\n        const { unpackedStatements, incompletePointers } = unpackScopedStatement(statement, switchStatementNode.incompletePointers, removedTags, removedIdentifiers);\n        switchStatementCase.statements.push(...unpackedStatements);\n        switchStatementNode.incompletePointers = incompletePointers;\n      }\n      switchStatementNode.cases.push(switchStatementCase);\n    }\n    for (const statement of defaultStatements) {\n      const { unpackedStatements, incompletePointers } = unpackScopedStatement(statement, switchStatementNode.incompletePointers, removedTags, removedIdentifiers);\n      switchStatementNode.defaultStatements.push(...unpackedStatements);\n      switchStatementNode.incompletePointers = incompletePointers;\n    }\n\n    return switchStatementNode;\n  }\n\n  /**\n   * Needed to handle ambiguity between identifier and keyword.\n   */\n  function isStringAKeyword(str) {\n    return C_Keywords.has(str);\n  }\n\n  /**\n   * Create a datatype that represents an incomplete type - a struct/enum that has not yet been defined, but has been referenced in a pointer.\n   */\n  function createIncompleteDataType(type, name) {\n    return {\n      type: \"incomplete\",\n      subtype: type,\n      tag: name,\n    };\n  }\n\n  /**\n   * Creates the Root node. Since Root node is created at the top of the parse tree, this function is run after the whole proram is parsed.\n   * Thus any cleanup/extra logic that requires information which is only completely available after parsing can be done here.\n   */\n  function createRootNode(children) {\n    const unpackedChildren = [];\n    let unresolvedIncompletePointers = [];\n    const removedTags = {};\n    const removedIdentifiers = {};\n    for (const child of children) {\n      if (child.type === \"Declaration\") {\n        unpackedChildren.push(...child.declarations);\n        unresolvedIncompletePointers = removeDeclarationIdentifiersAndTags(\n          child,\n          unresolvedIncompletePointers,\n          removedTags,\n          removedIdentifiers,\n          true\n        );\n      } else if (child.type === \"FunctionDefinition\") {\n        if (child.incompletePointers) {\n          unresolvedIncompletePointers.push(...(child.incompletePointers));\n        }\n        delete child.incompletePointers;\n        unpackedChildren.push(child);\n      } else {\n        // shoudlnt happen\n        error(\"Unknown child in root node\");\n      }\n    }\n    return generateNode(\"Root\", { children: unpackedChildren });\n  }\n\n  function generateIntegerConstant(value, suffix) {\n    let correctedSuffix;\n    if (suffix.length > 0) {\n      correctedSuffix = suffix.toLowerCase();\n      if (correctedSuffix.contains(\"ll\")) {\n        // in this implementation long long and long are identical\n        if (correctedSuffix.contains(\"u\")) {\n          correctedSuffix = \"ul\";\n        } else {\n          correctedSuffix = \"l\";\n        }\n      }\n    } else {\n      correctedSuffix = null;\n    }\n\n    return generateNode(\"IntegerConstant\", {\n      value: BigInt(value),\n      suffix: correctedSuffix,\n    });\n  }\n\n  function generateFloatConstant(value, suffix) {\n    return generateNode(\"FloatConstant\", {\n      value: Number(value),\n      suffix: suffix === \"f\" || suffix === \"F\" ? \"f\" : null,\n    });\n  }\n\n  /**\n   * Process declarations that do not have a declarator - i.e they should be declaring a struct/enum type.\n   */\n  function processDeclarationWithoutDeclarator(declarationSpecifiers) {\n    const { enumDeclarations, tagDefinitions, storageClass, incompletePointers, hasTypeDefSpecifier, constPresent, noType } =\n      unpackDeclarationSpecifiers(declarationSpecifiers, true);\n    const identifierDefinitions = [];\n    const declarations = [];\n    \n    // if no tags (struct or enum) were declared, then this violates 6.7/2 of C17 standard.\n    if ((typeof tagDefinitions === \"undefined\" || tagDefinitions.length === 0)) {\n      if (noType) {\n        if (constPresent) {\n          throwErrorWithLocation(\"useless type qualifier in empty declaration\")\n        }\n        if (storageClass) {\n          throwErrorWithLocation(\"useless storage class qualifier in empty declaration\");\n        }\n      } else {\n        throwErrorWithLocation(\"empty declaration\")\n      }\n      return generateNode(\"Declaration\", { declarations: [], identifierDefinitions: [] });\n    }\n\n    if (storageClass) {\n      warn(\"useless storage class qualifier in empty declaration\");\n    }\n\n    // add all enum variables that could have been defined in enum specifier\n    if (typeof enumDeclarations !== \"undefined\") {\n      enumDeclarations.forEach((enumDeclaration) => {\n        enumDeclaration.enumerators.forEach((enumerator) => {\n          identifierDefinitions.push(\n            addIdentifierToSymbolTable(enumerator.name, {\n              type: \"variable\",\n              dataType: createPrimaryDataType(\"signed int\"),\n            })\n          );\n        });\n\n        declarations.push(enumDeclaration);\n      });\n    }\n\n    return generateNode(\"Declaration\", {\n      declarations,\n      tagDefinitions,\n      identifierDefinitions,\n      incompletePointers,\n    });\n  }\n\n  /**\n   * Builds and returns a tree of binary operations which involves the 2 operaands (left and right expressions), and a operator\n   * @param firstExpr first expression in the operation expression e.g. \"2\" in \"2 + 3 + 4\"\n   * @param exprsWithOperatorArr an array of arrays of size 2 which contain an operator in first index and the expr in 2nd index. e.g: [[\"+\", 3], [\"+\", 4]]\n   */\n  function createLeftToRightBinaryExpressionTree(\n    firstExpr,\n    exprsWithOperatorArr\n  ) {\n    let currNode = firstExpr;\n    for (const operation of exprsWithOperatorArr) {\n      // create a new operation node\n      currNode = generateNode(\"BinaryExpression\", {\n        leftExpr: currNode,\n        rightExpr: operation[1],\n        operator: operation[0],\n      });\n    }\n    return currNode;\n  }\n\n  function createUnaryExpressionNode(expr, operator) {\n    // special handling for negated constants, just negate the value of constant\n    if (\n      operator === \"-\" &&\n      (expr.type === \"IntegerConstant\" || expr.type === \"FloatConstant\")\n    ) {\n      return {\n        ...expr,\n        value: -expr.value,\n      };\n    }\n\n    return generateNode(\"UnaryExpression\", {\n      operator,\n      expression: expr,\n    });\n  }\n\n  // Creates a PrimaryDataType object.\n  function createPrimaryDataType(primaryDataType) {\n    return {\n      type: \"primary\",\n      primaryDataType,\n    };\n  }\n\n  function createEnumDataType(tag) {\n    return {\n      type: \"enum\",\n      tag\n    }\n  }\n\n  function createArrayDataType(elementDataType, numElements) {\n    return {\n      type: \"array\",\n      elementDataType: elementDataType,\n      numElements,\n    };\n  }\n\n  function createInitializerList(values) {\n    values = values ?? [];\n    return generateNode(\"InitializerList\", {\n      values,\n    });\n  }\n\n  function createInitializerSingle(value) {\n    return generateNode(\"InitializerSingle\", {\n      value,\n    });\n  }\n\n  // Evaluates the string of postfix expressions to generate a complete tree of unary expression nodes\n  // Follows left to right associativity.\n  function createPostfixExpressionNode(firstExpr, operations) {\n    let currNode = firstExpr;\n    for (const operation of operations) {\n      if (operation.type === \"ArrayElementExpr\") {\n        // array element expr are equivalent to pointer dereference expression A[B] => *(A + B)\n        currNode = generateNode(\"PointerDereference\", {\n          expr: {\n            type: \"BinaryExpression\",\n            leftExpr: currNode,\n            rightExpr: operation.index,\n            operator: \"+\",\n          },\n        });\n      } else if (operation.type === \"StructPointerMemberAccess\") {\n        // similar to array element expr, a->x is equivalent to *a.x\n        currNode = generateNode(\"StructMemberAccess\", {\n          expr: {\n            type: \"PointerDereference\",\n            expr: currNode,\n          },\n          fieldTag: operation.fieldTag,\n        });\n      } else {\n        currNode = {\n          ...operation,\n          expr: currNode,\n        };\n      }\n    }\n    currNode.position = getCurrPosition();\n    return currNode;\n  }\n\n  // Evaluates the string of prefix expressions to generate a complete tree of unary expression nodes\n  // Follows right to left associativity\n  // @param firstExpr refers to the rightmost expression\n  function createPrefixExpressionNode(firstExpr, operations) {\n    let currNode = firstExpr;\n    for (let i = operations.length - 1; i >= 0; --i) {\n      const { type, ...rest } = operations[i];\n      currNode = generateNode(type, {\n        ...rest,\n        expr: currNode,\n      });\n    }\n    return currNode;\n  }\n\n  function createAssignmentNode(lvalue, assignedExpression, assignmentOperator) {\n    if (assignmentOperator.length > 1) {\n      // compond assignment operator\n      return generateNode(\"Assignment\", {\n          lvalue,\n          expr: {\n            type: \"BinaryExpression\",\n            leftExpr: lvalue,\n            rightExpr: assignedExpression,\n            operator: assignmentOperator[0], // only take the first char of assignmentOperator e.g. \"+\" of \"+=\"\n          },\n        }); \n    } else {\n      return generateNode(\"Assignment\", {\n        lvalue,\n        expr: assignedExpression\n        }\n      )\n    }\n  } \n\n  /**\n   * Given an array of pointers (\"*\"), create a tree of PointerDeclarators, ending in the directDeclarator.\n   */\n  function createPointerDeclaratorNode(pointers, directDeclarator) {\n    let currNode = directDeclarator;\n    for (const pointer of pointers) {\n      currNode = {\n        type: \"PointerDeclarator\",\n        isConst: pointer.isConst,\n        directDeclarator: currNode,\n      };\n    }\n    if (directDeclarator.functionDefinitionInfo) {\n      currNode.functionDefinitionInfo = directDeclarator.functionDefinitionInfo; \n      delete directDeclarator.functionDefinitionInfo; \n    }\n    return currNode;\n  }\n\n  function createFunctionDeclarator(parameterDeclarations) {\n    if (typeof parameterDeclarations === \"undefined\") {\n      return generateNode(\"FunctionDeclarator\", {\n        parameters: [],\n        functionDefinitionInfo: {\n          parameterNames: [],\n          enumDeclarations: [],\n          tagDefinitions: [],\n          incompletePointers: [],\n        }, // information that is only relevant to function definitions\n      });\n    }\n    return generateNode(\"FunctionDeclarator\", {\n      parameters: parameterDeclarations.dataTypes,\n      functionDefinitionInfo: {\n        parameterNames: parameterDeclarations.names,\n        enumDeclarations: parameterDeclarations.enumDeclarations,\n        tagDefinitions: parameterDeclarations.tagDefinitions,\n        incompletePointers: parameterDeclarations.incompletePointers,\n      }, // information that is only relevant to function definitions\n    });\n  }\n\n  // evaluate the delclarator suffixes of direct_declarator\n  // this is used to evaluate declarators which have [] or () suffixes which indicate\n  // that they are array or function suffixes respectively\n  function evaluateDeclaratorSuffixes(directDeclarator, declaratorSuffixes) {\n    let currNode = directDeclarator;\n    for (const suffix of declaratorSuffixes) {\n      // some error checking\n      if (suffix.type === \"FunctionDeclarator\") {\n        // you can only have string of consecutive array declarators\n        if (currNode.type === \"FunctionDeclarator\") {\n          error(\"Cannot have a function returning a function\");\n        }\n        // you cannot have an array of functions\n        if (currNode.type === \"ArrayDeclarator\") {\n          error(\"Cannot have an array of functions\");\n        }\n      } else {\n        // suffix is \"ArrayDeclarator\"\n        if (currNode.type === \"FunctionDeclarator\") {\n          // cannot have a function returning array\n          error(\"Cannot have a function returning an array\");\n        }\n      }\n\n      currNode = { directDeclarator: currNode, ...suffix };\n    }\n    return currNode;\n  }\n\n  /**\n   * Unpack and process declaration specifiers\n   * @returns { dataType: DataType | { type: \"void\" }, enumDeclarations?: { type: \"EnumDeclaration\", enumerators: { name: string, value?: Expression }[]}[], tagDefinition?: { name: string, dataType: DataType }, storageClass: \"auto\" | \"static\", hasTypeDefSpecifier: boolean, incompletePointers?: PointerDataType[]}\n   */\n  function unpackDeclarationSpecifiers(declarationSpecifiers, reportErrors = false) {\n    const typeSpecifiers = [];\n    let storageClass;\n    let isConst = false; // only type qualifier that is supported\n    let hasTypeDefSpecifier = false;\n\n    function declarationSpecifierError(message) {\n      if (reportErrors) {\n        error(message)\n      }\n    }\n\n    declarationSpecifiers.forEach((specifier) => {\n      switch (specifier.type) {\n        case \"TypeSpecifier\":\n          typeSpecifiers.push(specifier.specifier);\n          break;\n        case \"TypeQualifier\":\n          if (specifier.qualifier !== \"const\") {\n            // should not happen\n            declarationSpecifierError(`Unknown type qualifier '${specifier.qualifier}'`);\n          }\n          isConst = true;\n          break;\n        case \"StorageClassSpecifier\":\n          if (storageClass) {\n            // a storage class specifier already specified\n            declarationSpecifierError(\n              `multiple storage class specifiers: '${storageClass}' and '${specifier.specifier}'`\n            );\n          }\n          if (hasTypeDefSpecifier) {\n            declarationSpecifierError(`multiple storage class specifiers in declaration specifiers: 'typedef' and '${specifier.specifier}'`);\n          }\n          storageClass = specifier.specifier;\n          break;\n        case \"TypeDefSpecifier\":\n          if (storageClass) {\n            declarationSpecifierError(`multiple storage class specifiers in declaration specifiers: '${specifier.specifier}' and 'typedef'`);\n          } \n          if (hasTypeDefSpecifier) {\n            declarationSpecifierError(\"duplicate 'typedef'\");\n          }\n          hasTypeDefSpecifier = true;\n      }\n    });\n\n    if (typeSpecifiers.length < 1) {\n      return { dataType: createPrimaryDataType(\"signed int\"), noType: true, storageClass, constPresent: isConst }; // placeholder data type (other compilers would default to int, but full standard compliance means an error)\n    }\n\n    const { dataType, enumDeclarations, tagDefinitions, incompletePointers } =\n      processTypeSpecifiers(typeSpecifiers);\n    if (isConst) {\n      dataType.isConst = true;\n    }\n\n    return {\n      dataType,\n      enumDeclarations,\n      tagDefinitions,\n      incompletePointers,\n      storageClass,\n      hasTypeDefSpecifier,\n      constPresent: isConst // only used when processing declarations with no declarator\n    };\n  }\n\n  /**\n   * Processes a list of typeSpecifiers, to extract a dataType that they represent, as well as any enum variable definitions, and struct/enum type definitions\n   * @returns { dataType: DataType | { type: \"void\" }, enumDeclarations?: { type: \"EnumDeclaration\" enumerators: { name: string, value?: Expression }[] }[], tagDefinitions?: { name: string, tagSymbolEntry: { type: \"struct\" | \"enum\", dataType: DataType} } }\n   * dataType is the datatype indicated by the typespecifiers\n   * enumDeclarations are any enum variables declared with the enum specifiers\n   * tagDefinitions are any structs that are being\n   */\n  function processTypeSpecifiers(typeSpecifiers) {\n    const firstTypeSpecifier = typeSpecifiers[0];\n    if (\n      firstTypeSpecifier.type === \"StructTypeSpecifier\" ||\n      firstTypeSpecifier.type === \"EnumTypeSpecifier\" ||\n      firstTypeSpecifier.type === \"VoidTypeSpecifier\" ||\n      firstTypeSpecifier.type === \"UserNamedTypeSpecifier\"\n    ) {\n      if (typeSpecifiers.length > 1) {\n        // cannot have any more specifiers\n        error(\"Two or more data types in declaration specifiers\");\n      }\n      if (firstTypeSpecifier.type === \"StructTypeSpecifier\") {\n        const structSpecifier = firstTypeSpecifier.specifier;\n        if (structSpecifier.type === \"AnonymousStruct\") {\n          // a struct may have an enum declared within it\n          return {\n            dataType: structSpecifier.dataType,\n            enumDeclarations: structSpecifier.enumDeclarations,\n            tagDefinitions: structSpecifier.tagDefinitions,\n            incompletePointers: structSpecifier.incompletePointers,\n          };\n        } else if (structSpecifier.type === \"NamedStructDefinition\") {\n          // within the struct there may have been more struct/enum tags defined\n          // tag has already been added within createStructSpecifier()\n          return {\n            dataType: structSpecifier.dataType,\n            tagDefinitions: structSpecifier.tagDefinitions,\n            enumDeclarations: structSpecifier.enumDeclarations,\n            incompletePointers: structSpecifier.incompletePointers,\n          };\n        } else if (structSpecifier.type === \"NamedStructReference\") {\n          // retrieve type from symbol table if it exists and was also a struct\n          if (isTagDefined(structSpecifier.tag) && getTagSymbolEntry(structSpecifier.tag).type === \"struct\") {\n            const symbolEntry = getTagSymbolEntry(structSpecifier.tag);\n            return { dataType: symbolEntry.dataType };\n          } else {\n            const incompleteType = createIncompleteDataType(\n                \"struct\",\n                structSpecifier.tag\n              );\n            const symbolEntry = { type: \"struct\", dataType: incompleteType }\n            const tagDefinition = addTagToSymbolTable(structSpecifier.tag, symbolEntry)\n            return {\n              dataType: incompleteType,\n              tagDefinitions: [\n                tagDefinition\n              ],\n            }; // incomplete type for now, to be resolved later when struct is defined\n          }\n        }\n      } else if (firstTypeSpecifier.type === \"EnumTypeSpecifier\") {\n        const enumSpecifier = firstTypeSpecifier.specifier;\n        if (enumSpecifier.type === \"NamedDefinedEnum\") {\n          // a new enum has been defined\n          const newTagSymbolEntry = {\n            type: \"enum\",\n            dataType: createEnumDataType(enumSpecifier.tag),\n          };\n          addTagToSymbolTable(enumSpecifier.tag, newTagSymbolEntry);\n          enumSpecifier.enumerators.forEach((enumerator) => {\n            addIdentifierToSymbolTable(enumerator.name, {\n              type: \"variable\",\n              dataType: createEnumDataType(enumSpecifier.tag),\n            });\n          });\n          return {\n            dataType: createEnumDataType(enumSpecifier.tag),\n            enumDeclarations: [\n              { type: \"EnumDeclaration\", enumerators: enumSpecifier.enumerators },\n            ],\n            tagDefinitions: [\n              { name: enumSpecifier.tag, symbolEntry: newTagSymbolEntry },\n            ],\n          }; // all enums defined as having signed int type\n        } else if (enumSpecifier.type === \"AnonymousEnum\") {\n          enumSpecifier.enumerators.forEach((enumerator) => {\n            addIdentifierToSymbolTable(enumerator.name, {\n              type: \"variable\",\n              dataType: createEnumDataType(enumSpecifier.tag),\n            });\n          });\n          return {\n            dataType: createEnumDataType(null),\n            enumDeclarations: [\n              { type: \"EnumDeclaration\", enumerators: enumSpecifier.enumerators },\n            ],\n          };\n        } else if (enumSpecifier.type === \"NamedEnumReference\") {\n          if (isTagDefined(enumSpecifier.tag) && getTagSymbolEntry(enumSpecifier.tag).type === \"enum\") {\n            const symbolEntry = getTagSymbolEntry(enumSpecifier.tag);\n            return { dataType: symbolEntry.dataType };\n          } else {\n            const incompleteType = createIncompleteDataType(\n                \"enum\",\n                enumSpecifier.tag\n              );\n            const symbolEntry = { type: \"enum\", dataType: incompleteType }\n            const tagDefinition = addTagToSymbolTable(enumSpecifier.tag, symbolEntry)\n            return { dataType: incompleteType, tagDefinitions: [ tagDefinition ] };\n          }\n        }\n      } else if (firstTypeSpecifier.type === \"VoidTypeSpecifier\") {\n        return { dataType: { type: \"void\" } };\n      } else if (firstTypeSpecifier.type === \"UserNamedTypeSpecifier\") {\n        if (!isIdentifierAType(firstTypeSpecifier.typeName)) {\n          error(`undeclared type '${firstTypeSpecifier.typeName}'`);\n        }\n        return {\n          dataType: getIdentifierSymbolEntry(firstTypeSpecifier.typeName)\n            .dataType,\n        };\n      }\n    } else if (firstTypeSpecifier.type === \"UnknownTypeSpecifier\") {\n      throwErrorWithLocation(`unknown type name '${firstTypeSpecifier.typeName}'`);\n    } else {\n      // only dealing with primary data types now\n      let lengthSpecifier;\n      let intSignSpecifier;\n      let primaryDataTypeSpecifier;\n      for (const specifier of typeSpecifiers) {\n        if (specifier.type === \"PrimaryTypeSpecifier\") {\n          if (primaryDataTypeSpecifier) {\n            // error if primary data type already given\n            error(\"Two or more data types in declaration specifiers\");\n          }\n          primaryDataTypeSpecifier = specifier.specifier;\n        } else if (specifier.type === \"PrimaryDataTypeLengthSpecifier\") {\n          if (lengthSpecifier) {\n            error(\n              `Both '${lengthSpecifier}' and '${specifier.specifier}' in declaration specifiers`\n            );\n          }\n          lengthSpecifier = specifier.specifier;\n        } else if (specifier.type === \"IntegerSignSpecifier\") {\n          if (intSignSpecifier) {\n            error(\n              `Both '${intSignSpecifier}' and '${specifier.specifier}' in declaration specifiers`\n            );\n          }\n          intSignSpecifier = specifier.specifier;\n        }\n      }\n\n      if (!primaryDataTypeSpecifier && !lengthSpecifier && !intSpecifier) {\n        error(\"type specifier required in declaration specifiers\");\n      }\n\n      if (\n        primaryDataTypeSpecifier === \"float\" ||\n        primaryDataTypeSpecifier === \"double\"\n      ) {\n        if (intSignSpecifier) {\n          error(\n            `Both '${intSignSpecifier}' and '${primaryDataTypeSpecifier}' in declaration specifiers`\n          );\n        }\n        return { dataType: createPrimaryDataType(primaryDataTypeSpecifier) };\n      } else if (primaryDataTypeSpecifier === \"char\") {\n        const intSignPrefix = intSignSpecifier ? intSignSpecifier + \" \" : \"signed \"; // integral types are signed by default\n        if (lengthSpecifier) {\n          error(\n            `Both '${lengthSpecifier}' and '${primaryDataTypeSpecifier}' in declaration specifiers`\n          );\n        }\n        return { dataType: createPrimaryDataType(intSignPrefix + \"char\") };\n      } else {\n        // default primary data type is int\n        const intSignPrefix = intSignSpecifier ? intSignSpecifier + \" \" : \"signed \"; // integral types are signed by default\n        if (lengthSpecifier) {\n          return {\n            dataType: createPrimaryDataType(intSignPrefix + lengthSpecifier),\n          };\n        } else {\n          // just int\n          return { dataType: createPrimaryDataType(intSignPrefix + \"int\") };\n        }\n      }\n    }\n  }\n\n  // Unpacks a series of { declarations: Declaration, incompletePointers: PointerDataType } objects into\n  // one singular object { declarations: Declaration, incompletePointers: PointerDataType }\n  function unpackDeclarations(declarations) {\n    const unpackedResult = {\n      declarations: [],\n      incompletePointers: [],\n    };\n\n    declarations.forEach(({ declarations, incompletePointers }) => {\n      unpackedResult.declarations.push(...declarations);\n      unpackedResult.incompletePointers.push(...incompletePointers);\n    });\n    return unpackedResult;\n  }\n\n  // Similar to unpackDeclarations, with enumDeclarations and tagDefinitions also being unpacked\n  function unpackStructDeclarations(declarations) {\n    const unpackedResult = {\n      declarations: [],\n      incompletePointers: [],\n      enumDeclarations: [], // all the enum variables declarad within the struct\n      tagDefinitions: [], // all the structs/enums declared within the struct\n    };\n\n    declarations.forEach(\n      ({\n        declarations,\n        incompletePointers,\n        enumDeclarations,\n        tagDefinitions,\n      }) => {\n        unpackedResult.declarations.push(...declarations);\n        if (incompletePointers) {\n          unpackedResult.incompletePointers.push(...incompletePointers);\n        }\n        if (enumDeclarations) {\n          unpackedResult.enumDeclarations.push(...enumDeclarations);\n        }\n        if (tagDefinitions) {\n          unpackedResult.tagDefinitions.push(...tagDefinitions);\n        }\n      }\n    );\n    return unpackedResult;\n  }\n\n  /**\n   * Called after a new struct is declared.\n   * @returns { dataType: StructDataType, incompletePointers: PointerDataType[], enumDeclarations: { type: \"EnumeratorDeclaration\", enumerators: { name: string, value: number}[]}[], tagDefinitions }\n   * \n   */\n  function createStructSpecifier(unpackedFieldDeclarations, tag) {\n    const structDataType = {\n      type: \"struct\",\n      tag,\n      fields: [],\n    };\n\n    // add the declarations of each field to the struct\n    if (unpackedFieldDeclarations.declarations) {\n      unpackedFieldDeclarations.declarations.forEach((declaration) => {\n        structDataType.fields.push({\n          tag: declaration.name,\n          dataType: declaration.dataType,\n        });\n      });\n    }\n\n    // resolve all incomplete pointers which can be resolved\n    const incompletePointers = [];\n    unpackedFieldDeclarations.incompletePointers.forEach((incompletePointer) => {\n      const pointeeTag = incompletePointer.pointeeType.tag;\n      const tagType = incompletePointer.pointeeType.subtype;\n      if (pointeeTag === tag) {\n        // this is a pointer that points to the struct it is within\n        if (tagType !== \"struct\") {\n          error(`'${pointeeTag}' declared as wrong kind of tag`);\n        }\n        delete incompletePointer.pointeeType;\n        incompletePointer.type = \"struct self pointer\";\n      } else {\n        if (isTagDefined(pointeeTag)) {\n          const symbolEntry = getTagSymbolEntry(pointeeTag);\n          if (symbolEntry.type !== tagType) {\n            error(`'${pointeeTag}' declared as wrong kind of tag`);\n          }\n          // incomplete pointer is now complete (pointing to complete type)\n          incompletePointer.pointeeType = symbolEntry.dataType;\n        } else {\n          // still incomplete\n          incompletePointers.push(incompletePointer.pointeeType);\n        }\n      }\n    });\n\n    // add this new struct (if named) thats been declared to the tagDefinitions & symboltable\n    const tagDefinitions = unpackedFieldDeclarations.tagDefinitions ?? [];\n    if (tag) {\n      const symbolEntry = { type: \"struct\", dataType: structDataType };\n      const tagDefinition = addTagToSymbolTable(tag, symbolEntry);\n      tagDefinitions.push(tagDefinition);\n    }\n\n    return {\n      dataType: structDataType,\n      incompletePointers,\n      enumDeclarations: unpackedFieldDeclarations.enumDeclarations,\n      tagDefinitions,\n    };\n  }\n\n  function createEmptyStructSpecifier(tag) {\n    error(\"struct has no members\");\n    return {\n      dataType: {\n        type: \"struct\",\n        tag,\n        fields: [], \n      },\n      incompletePointers: [],\n      enumDeclarations: [],\n      tagDefinitions: [],\n    }; \n  }\n\n  // Recursively traverses a tree of declarators to create a DataType object and extract the name of the symbol with this dataType,\n  // returning the object with type: { name: string, dataType: DataType, incompletePointer?: PointerDataType }\n  // this function is able to evaluate declarators used in function declarations that do not have a symbol as well.\n  // optionally takes a param @isFunctionParam that indicates that this declarator is used in a function parameter\n  function convertDeclaratorIntoDataTypeAndSymbolName(\n    declarator,\n    typeSpecifierDataType,\n    isFunctionParam\n  ) {\n    const result = { functionDefinitionInfo: declarator.functionDefinitionInfo };\n    let currNode = result;\n    // helper function to add datatype to currNode\n    function addDataType(dataTypeToAdd) {\n      // only pointers and functions can have null type specifier - void type\n      if (dataTypeToAdd.type === \"void\") {\n        if (typeof currNode.type === \"undefined\" || currNode.type === \"primary\") {\n          error(`Variable or field declared as void`);\n        } else if (currNode.type === \"array\") {\n          error(`Declaration of array of void type`);\n        } \n      }\n      if (currNode.type === \"array\") {\n        currNode.elementDataType = dataTypeToAdd;\n      } else if (currNode.type === \"pointer\") {\n        currNode.pointeeType = dataTypeToAdd;\n      } else if (currNode.type === \"function\") {\n        currNode.returnType = dataTypeToAdd;\n      } else {\n        currNode.dataType = dataTypeToAdd;\n      }\n    }\n\n    function recursiveHelper(declarator) {\n      if (declarator.type === \"SymbolDeclarator\") {\n        // all non-abstract declarations will end with a symbol (based on parsing rules)\n        result.name = declarator.symbolName;\n        return;\n      } else if (declarator.type === \"AbstractDeclarator\") {\n        // recursive tail of symboless declaration that can only be used in function declarations\n        result.name = null;\n        return;\n      } else {\n        // all other declarators require more traversal\n        recursiveHelper(declarator.directDeclarator);\n      }\n\n      if (declarator.type === \"PointerDeclarator\") {\n        const pointerType = {\n          type: \"pointer\",\n          isConst: declarator.isConst,\n        };\n        addDataType(pointerType);\n        currNode = pointerType;\n      } else if (declarator.type === \"FunctionDeclarator\") {\n        const functionType = {\n          type: \"function\",\n          parameters: declarator.parameters,\n          parameterNames: declarator.parameterNames,\n        };\n        // some error checks\n        if (currNode.type === \"FunctionDeclarator\") {\n          error(\"Cannot declare a function returning a function\");\n        } else if (currNode.type === \"ArrayDeclarator\") {\n          error(\"Cannot declare an array of functions\");\n        }\n\n        addDataType(functionType);\n        currNode = functionType;\n      } else if (declarator.type === \"ArrayDeclarator\") {\n        const arrayType = {\n          type: \"array\",\n          numElements: declarator.numElements,\n        };\n\n        if (currNode.type === \"FunctionDeclarator\") {\n          error(\"Cannot declare a function returning an array\");\n        }\n\n        addDataType(arrayType);\n        currNode = arrayType;\n      } else {\n        error(\"Unknown declarator type\");\n      }\n    }\n\n    recursiveHelper(declarator);\n\n    // Only pointers can point to incomplete types\n    if (typeSpecifierDataType.type === \"incomplete\") {\n      if (currNode.type !== \"pointer\") {\n        error(`'${typeSpecifierDataType.tag}' is an incomplete type`);\n      } else {\n        // keep track that this pointer datatype as incomplete\n        result.incompletePointer = currNode;\n      }\n    }\n\n    addDataType(typeSpecifierDataType);\n\n    if (isFunctionParam && result.dataType.type === \"array\") {\n      // function parameters that are arrays are implictly converted into pointers to the underlying array element type\n      result.dataType = {\n        type: \"pointer\",\n        pointeeType: result.dataType.elementDataType,\n      };\n    }\n\n    return result;\n  }\n\n  /**\n   * Creates intiializer list from string literal.\n   * @param chars array of characters in the string, already in numeric form\n   */\n  function generateInitializerListFromStringLiteral(chars) {\n    return generateNode(\"InitializerList\", {\n      values: chars.map((char) => ({\n        type: \"InitializerSingle\",\n        value: {\n          type: \"IntegerConstant\",\n          value: BigInt(char),\n          suffix: null,\n        },\n      })),\n    });\n  }\n\n  /**\n   * Removes all the identifiers and tags(structs/enums) that were introduced to the symboltable inside parameter declarations of a function.\n   */\n  function removeFunctionParamIdentifiersAndTags(\n    tagDefinitions,\n    enumDeclarations,\n    parameterNames\n  ) {\n    // remove all struct/enum tags\n    const removedTags = new Set();\n    for (const tagDefinition of tagDefinitions) {\n      if (removedTags.has(tagDefinition.name)) {\n        error(`redefinition of '${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}'`);\n      }\n      removedTags.add(tagDefinition.name);\n      removeTagSymbolEntry(tagDefinition.name);\n    }\n\n    const removedIdentifiers = new Set();\n    // remove all enumerator identifiers defined in params\n    for (const enumDeclaration of enumDeclarations) {\n      enumDeclaration.enumerators.forEach((e) => {\n        if (removedIdentifiers.has(e.name)) {\n          error(`'${e.name}' redeclared as different kind of symbol`)\n        }\n        removedIdentifiers.add(e.name);\n        removeIdentifierSymbolEntry(e.name);\n      });\n    }\n    \n\n    // remove all parameter identifiers, no need check for redefintion as it was done in unpackParameters() already\n    for (const paramName of parameterNames) {\n      if (paramName !== null) {\n        removeIdentifierSymbolEntry(paramName);\n      }\n    }\n  }\n\n  /**\n   * Processes declarations.\n   * Returns the declarations, as well as the dataType objects that are pointers to incomplete types\n   * @returns { type: \"Declaration\", declarations: Declaration[], incompletePointers: PointerDataType[], tagDefinitions: { name: string, symbolEntry: { type: \"struct\" | \"enum\", dataType: DataType } }[], identifierDefinitions: { name: string, symbolEntry: { type: \"type\" | \"variable\", dataType: DataType } }[] }\n   * identifierDefinitions is { name: string, symbolEntry: SymbolEntry } that represents each declared identifier\n   * tagDefinitions is { name: string, symbolEntry: SymbolEntry } that represents each declared tag\n   */\n  function processDeclaration(declarationSpecifiers, declarators) {\n    const declarations = [];\n    const identifierDefinitions = [];\n    const {\n      enumDeclarations,\n      tagDefinitions,\n      hasTypeDefSpecifier,\n      incompletePointers: incompletePointersFromSpecifiers,\n      noType\n    } = unpackDeclarationSpecifiers(declarationSpecifiers, true);\n\n    if (noType) {\n      error(\"at least 1 type specifier required in declaration specifiers of declaration\");\n    }\n\n    const incompletePointers = incompletePointersFromSpecifiers ?? [];\n    // add all enum fields as enum declarations to the array of all declarations\n    if (typeof enumDeclarations !== \"undefined\") {\n      enumDeclarations.forEach((enumDeclaration) => {\n        declarations.push(enumDeclaration);\n        // enumerator identifiers were already added to the symboltable, just track their identifier definitions\n        for (const enumerator of enumDeclaration.enumerators) {\n          identifierDefinitions.push({\n            name: enumerator.name,\n            symbolEntry: getIdentifierSymbolEntry(enumerator.name),\n          });\n        }\n      });\n    }\n    declarators.forEach((declarator) => {\n      const { declaration, incompletePointer } = evaluateDeclarator(\n        declarationSpecifiers,\n        declarator\n      );\n      // actually a typedef declaration\n      if (hasTypeDefSpecifier) {\n        if (declaration.initializer) {\n          error(\"typedef is initialized\");\n        }\n        identifierDefinitions.push(\n          addIdentifierToSymbolTable(declaration.name, {\n            type: \"type\",\n            dataType: declaration.dataType,\n          })\n        );\n      } else {\n        identifierDefinitions.push(\n          addIdentifierToSymbolTable(declaration.name, {\n            type: \"variable\",\n            dataType: declaration.dataType,\n          })\n        );\n        declarations.push(declaration);\n        // remove all tags and identifiers that were introduced in the parameters if this were a function declaration\n        if (declarator.functionDefinitionInfo) {\n          removeFunctionParamIdentifiersAndTags(\n            declarator.functionDefinitionInfo.tagDefinitions,\n            declarator.functionDefinitionInfo.enumDeclarations,\n            declarator.functionDefinitionInfo.parameterNames\n          );\n          // delete this functionDefinition field from declarator - it is not needed\n          delete declarator.functionDefinitionInfo;\n        }\n      }\n\n      if (incompletePointer) {\n        incompletePointers.push(incompletePointer);\n      }\n    });\n\n    return generateNode(\"Declaration\", {\n      declarations,\n      incompletePointers,\n      identifierDefinitions,\n      tagDefinitions,\n    });\n  }\n\n  // similar to processDeclarations, with added enumeratorDeclaration as a result field (no longer incorporated into declarations)\n  function processStructDeclaration(declarationSpecifiers, declarators) {\n    const declarations = [];\n    const incompletePointers = [];\n    const {\n      enumDeclarations,\n      tagDefinitions,\n      storageClass,\n      hasTypeDefSpecifier,\n    } = unpackDeclarationSpecifiers(declarationSpecifiers, true);\n    if (storageClass || hasTypeDefSpecifier) {\n      error(\"Struct field cannot have storage class specifier\");\n    }\n\n    declarators.forEach((declarator) => {\n      const { declaration, incompletePointer } = evaluateDeclarator(\n        declarationSpecifiers,\n        declarator\n      );\n      declarations.push(declaration);\n      if (incompletePointer) {\n        incompletePointers.push(incompletePointer);\n      }\n    });\n\n    return { declarations, incompletePointers, enumDeclarations, tagDefinitions };\n  }\n\n  // evaluates the return of init_declarator or declarator with the given array of declaration specifiers, to return a declaration\n  // return type: { declaration: Declaration, incompletePointer?: PointerDataType }\n  function evaluateDeclarator(declarationSpecifiers, declarator) {\n    const { dataType: typeSpecifierDataType, storageClass } =\n      unpackDeclarationSpecifiers(declarationSpecifiers);\n    const { name, dataType, incompletePointer, functionDefinitionInfo } =\n      convertDeclaratorIntoDataTypeAndSymbolName(\n        declarator,\n        typeSpecifierDataType\n      );\n\n    const declarationNode = generateNode(\"Declaration\", {\n      name: name,\n      storageClass: storageClass ?? \"auto\", // storage class is auto by default\n      dataType: dataType,\n      initializer: declarator.initializer, // may be undefined\n    });\n    if (declarationNode.dataType.type === \"array\") {\n      if (typeof declarationNode.initializer !== \"undefined\") {\n        if (declarationNode.initializer.type !== \"InitializerList\") {\n          if (declarationNode.initializer.value.type === \"StringLiteral\") {\n            declarationNode.initializer =\n              generateInitializerListFromStringLiteral(\n                declarationNode.initializer.value.chars\n              );\n          } else {\n            error(\"Invalid initializer for array\");\n          }\n        }\n        // Array size deduction based on initializer list size\n        if (typeof declarationNode.dataType.numElements === \"undefined\") {\n          declarationNode.dataType.numElements = generateNode(\"IntegerConstant\", {\n            value: BigInt(declarationNode.initializer.values.length),\n          });\n        }\n      } else if (typeof declarationNode.dataType.numElements === \"undefined\") {\n        // no intializer provided, if numElements not defined, then it is set to 1 - TODO: provide warning to user\n        declarationNode.dataType.numElements = generateNode(\"IntegerConstant\", {\n          value: 1n,\n        });\n      }\n    }\n\n    return {\n      declaration: declarationNode,\n      incompletePointer,\n      functionDefinitionInfo,\n    };\n  }\n\n  // Process function parameter.\n  // @returns { type: \"ParameterDeclaration\", name: string | null, dataType: DataType, enumDeclarations, tagDefinitions, incompletePointers }\n  function processParameterDeclaration(declarationSpecifiers, declarator) {\n    const {\n      dataType: typeSpecifierDataType,\n      enumDeclarations,\n      tagDefinitions,\n      incompletePointers,\n      storageClass,\n      hasTypeDefSpecifier,\n      noType\n    } = unpackDeclarationSpecifiers(declarationSpecifiers, true);\n\n    if (noType) {\n      error(\"at least 1 type specifier required in declaration specifiers of declaration\");\n    }\n\n    if (storageClass || hasTypeDefSpecifier) {\n      error(`Cannot specify storage class for function parameter`);\n    }\n    if (declarator === null) {\n      // abstractDeclarator was null\n      return generateNode(\"ParameterDeclaration\", {\n        name: null,\n        dataType: typeSpecifierDataType,\n        enumDeclarations,\n        tagDefinitions,\n        incompletePointers,\n      });\n    }\n    const { name, dataType, incompletePointer } =\n      convertDeclaratorIntoDataTypeAndSymbolName(\n        declarator,\n        typeSpecifierDataType,\n        true\n      );\n\n    if (incompletePointer) {\n      incompletePointers.push(incompletePointer);\n    }\n\n    // add this parameter to symbol table\n    addIdentifierToSymbolTable(name, {\n      type: \"variable\",\n      dataType: dataType,\n    });\n\n    if (enumDeclarations) {\n      for (const enumDeclaration of enumDeclarations) {\n        // add any declared enum variables\n        enumDeclaration.enumerator.forEach((enumerator) => {\n          addIdentifierToSymbolTable(enumerator.name, {\n            type: \"variable\",\n            dataType: createPrimaryDataType(\"signed int\"),\n          });\n        });\n      }\n    }\n\n    return generateNode(\"ParameterDeclaration\", {\n      name,\n      dataType,\n      enumDeclarations,\n      tagDefinitions,\n      incompletePointers,\n    });\n  }\n\n  /**\n   * Used to generate the DataType for type_name rule.\n   * Functionally very similar to convertParameterDeclarationToDataTypeAndSymbolName.\n   */\n  function generateDataTypeFromSpecifierAndAbstractDeclarators(\n    declarationSpecifiers,\n    declarator\n  ) {\n    const { dataType: typeSpecifierDataType } = unpackDeclarationSpecifiers(\n      declarationSpecifiers\n    );\n    if (declarator === null) {\n      // abstractDeclarator was null\n      return typeSpecifierDataType;\n    }\n    return convertDeclaratorIntoDataTypeAndSymbolName(\n      declarator,\n      typeSpecifierDataType\n    ).dataType;\n  }\n\n  // extracts out all the datatype, names, enumDeclarations, tagDefinitions and incompletePointers from a set of parameterDeclarations\n  function unpackParameters(parameterDeclarations) {\n    const dataTypes = [];\n    const names = [];\n    const enumDeclarations = [];\n    const tagDefinitions = [];\n    const incompletePointers = [];\n    const setOfIdentifiers = new Set();\n    const setOfTags = new Set(); \n    parameterDeclarations.forEach((paramDeclaration) => {\n      if (paramDeclaration.name !== null && setOfIdentifiers.has(paramDeclaration.name)) {\n        error(`redefinition of parameter '${paramDeclaration.name}'`)\n      }\n      dataTypes.push(paramDeclaration.dataType);\n      names.push(paramDeclaration.name);\n      setOfIdentifiers.add(paramDeclaration.name);\n      if (paramDeclaration.enumDeclarations) {\n        enumDeclarations.forEach(enumDeclaration => {\n          enumDeclaration.enumerators.forEach(enumerator => {\n            if (setOfIdentifiers.has(enumerator.name)) {\n              error(`'${enumerator.name}' redeclared as different kind of symbol`) \n            }\n            setOfIdentifiers.add(enumerator.name);\n          });\n        });\n        enumDeclarations.push(...paramDeclaration.enumDeclarations);\n      }\n      if (paramDeclaration.tagDefinitions) {\n        tagDefinitions.forEach(tagDefinition => {\n          if (setOfTags.has(tagDefinition.name)) {\n            error(`redefinition of '${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}'`);\n          } \n        });\n        tagDefinitions.push(...paramDeclaration.tagDefinitions);\n      }\n      if (paramDeclaration.incompletePointers) {\n        incompletePointers.push(...paramDeclaration.incompletePointers);\n      }\n    });\n\n    return {\n      names,\n      dataTypes,\n      enumDeclarations,\n      tagDefinitions,\n      incompletePointers,\n    };\n  }\n\n  function generateFunctionDefinitionNode(\n    declarationSpecifiers,\n    declarator,\n    body\n  ) {\n    const { declaration, functionDefinitionInfo } = evaluateDeclarator(\n      declarationSpecifiers,\n      declarator\n    );\n    const dataType = declaration.dataType;\n    const name = declaration.name;\n    if (!functionDefinitionInfo || dataType.type !== \"function\") {\n      error(\"compound statement can only follow a function declarator\");\n    }\n\n    addIdentifierToSymbolTable(declaration.name, {type: \"variable\", dataType});  \n\n    const incompletePointers = body.incompletePointers;\n    delete body.incompletePointers;\n\n    // remove all tagDefinitions and identifiers declared in params from symboltable\n    removeFunctionParamIdentifiersAndTags(\n      functionDefinitionInfo.tagDefinitions,\n      functionDefinitionInfo.enumDeclarations,\n      functionDefinitionInfo.parameterNames\n    );\n\n    return generateNode(\"FunctionDefinition\", {\n      type: \"FunctionDefinition\",\n      name: name,\n      dataType: dataType,\n      body,\n      parameterNames: functionDefinitionInfo.parameterNames,\n      incompletePointers\n    });\n  }\n\n  /**\n   * Used to create a ForLoop node whose clause is a declaration.\n   */\n  function createDeclarationForLoopNode(declaration, condition, update, body) {\n    const { declarations, incompletePointers, identifierDefinitions, tagDefinitions } = declaration;\n    // tagDefinitions not allowed in for loop\n    if (tagDefinitions) {\n      for (const tagDefinition of tagDefinitions) {\n        error(`'${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}' declared in 'for' loop initialization`)\n      }\n    }\n    // no need to handle incmplete pointers since there is no possibility of declaring them in a tag \n\n    // checks on declarations\n    for (const declaration of declarations) {\n      if (declaration.type === \"EnumDeclaration\") {\n        // enum declarations not allowed in for loop clause\n        for (const enumerator of declaration.enumerators) {\n          error(`Declaration of non-variable '${enumerator.name}' in for loop initial declaration`);\n        }\n      } else if (declaration.storageClass !== \"auto\" && declaration.storageClass !== \"register\") { // as per standard, for loop variable can only be \"auto\" or \"register\" \n        error(`Declaration of ${declaration.storageClass} variable '${declaration.name}' in for loop initial declaration`);\n      }\n    }\n\n    // remove all identifiers that were declared in for loop clause\n    const removedIdentifiers = new Set();\n    for (const identifierDefinition of identifierDefinitions) {\n      if (identifierDefinition.name !== null) {\n        if (removedIdentifiers.has(identifierDefinition.name)) {\n          error(`redeclaration of variable ${identifierDefinition.name}`)\n        }\n        removedIdentifiers.add(identifierDefinition.name);\n        removeIdentifierSymbolEntry(identifierDefinition.name);\n      }\n    }\n\n    return generateNode(\"ForLoop\", { clause: { type: \"Declaration\", value: declarations }, condition, update, body });\n  }\n\n  function addIncludedModuleDefinitions(includedModuleName) {\n    addIncludedModuleFunctionDefinitions(includedModuleName);\n    addIncludedModuleStructDefinitions(includedModuleName); \n  }\n  \n  function addIncludedModuleFunctionDefinitions(includedModuleName) {\n   if (!(includedModuleName in thisParser.moduleRepository.modules)) {\n      // included module is not found\n      error(`Included module \"${includedModuleName}\" does not exist`);\n    }\n\n    // add all the defined structs in the module\n    Object.entries(thisParser.moduleRepository.modules[includedModuleName].moduleFunctions).forEach(([name, fnDataType]) => {\n      addIdentifierToSymbolTable(name, {type: \"variable\", dataType: fnDataType});\n    }) \n  }\n\n  function addIncludedModuleStructDefinitions(includedModuleName) {\n    if (!(includedModuleName in thisParser.moduleRepository.modules)) {\n      // included module is not found\n      error(`Included module \"${includedModuleName}\" does not exist`);\n    }\n\n    // add all the defined structs in the module\n    thisParser.moduleRepository.modules[includedModuleName].moduleDeclaredStructs.forEach(s => {\n      addTagToSymbolTable(s.tag, {type: \"struct\", dataType: s});\n    })\n  }\n\n  function createSizeOfDataTypeExpression(dataType) {\n    if (dataType.type === \"incomplete\") {\n      error(\"invalid application of 'sizeof' to incomplete type\");\n    }\n    return generateNode(\"SizeOfExpression\", { subtype: \"dataType\", dataType });\n  }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","/**\n * C AST Processor Module.\n */\n\nimport { CAstRoot } from \"~src/parser/c-ast/core\";\nimport { CAstRootP } from \"~src/processor/c-ast/core\";\nimport processFunctionDefinition from \"~src/processor/processFunctionDefinition\";\nimport { processGlobalScopeDeclaration } from \"~src/processor/processDeclaration\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\nimport ModuleRepository, { ModuleName } from \"~src/modules\";\nimport { ProcessingError } from \"~src/errors\";\nimport { Warning, clearWarnings, warnings } from \"~src/processor/warningUtil\";\nimport { resetProcessorAuxInfo } from \"~src/processor/processBlockItem\";\nimport { memoryManager } from \"~src/processor/memoryManager\";\n\n/**\n * Processes the C AST tree generated by parsing, to add additional needed information for certain nodes.\n * @param ast\n * @param sourceCode\n * @returns { astRootNode: root node of processed C AST, includedModules: list of all modules included in the C program}\n */\nexport default function process(\n  ast: CAstRoot,\n  moduleRepository: ModuleRepository\n): {\n  astRootNode: CAstRootP;\n  includedModules: ModuleName[];\n  warnings: Warning[];\n} {\n  clearWarnings();\n  const includedModules: ModuleName[] = [];\n  const symbolTable = new SymbolTable();\n  const processedExternalFunctions = symbolTable.setExternalFunctions(\n    ast.includedModules,\n    moduleRepository\n  );\n  const processedAst: CAstRootP = {\n    type: \"Root\",\n    functions: [],\n    dataSegmentByteStr: \"\",\n    dataSegmentSizeInBytes: 0,\n    externalFunctions: [],\n    functionTable: [],\n    position: ast.position,\n  };\n\n  // save the processed details of external functions\n  for (const moduleName of ast.includedModules) {\n    includedModules.push(moduleName);\n    Object.keys(moduleRepository.modules[moduleName].moduleFunctions).forEach(\n      (moduleFunctionName) => {\n        processedAst.externalFunctions.push({\n          moduleName,\n          name: moduleFunctionName,\n          parameters:\n            processedExternalFunctions[moduleFunctionName].functionDetails\n              .parameters,\n          returnObjects:\n            processedExternalFunctions[moduleFunctionName].functionDetails\n              .returnObjects,\n        });\n      }\n    );\n  }\n  ast.children.forEach((child) => {\n    // special handling for function definitions\n    resetProcessorAuxInfo();\n    if (child.type === \"FunctionDefinition\") {\n      processedAst.functions.push(\n        processFunctionDefinition(child, symbolTable)\n      );\n    } else {\n      processGlobalScopeDeclaration(child, symbolTable);\n    }\n  });\n\n  // check for presence of main function\n  if (!symbolTable.hasSymbol(\"main\")) {\n    throw new ProcessingError(\"main function not defined\");\n  }\n\n  debugPrintMemoryMap(); // Add this function call\n\n  processedAst.dataSegmentByteStr = symbolTable.dataSegmentByteStr.value;\n  processedAst.dataSegmentSizeInBytes = symbolTable.dataSegmentOffset.value;\n  processedAst.functionTable = symbolTable.functionTable;\n  return { astRootNode: processedAst, includedModules, warnings };\n}\n\nfunction debugPrintMemoryMap(): void {\n  console.log(\"\\n=== MEMORY ADDRESS MAP ===\");\n  console.log(\"Variable Name         | Scope           | Offset | Size\");\n  console.log(\"----------------------------------------------------\");\n\n  const addressMap = memoryManager.getAddressMap();\n  const map = addressMap.getAddressMap();\n\n  // Group entries by scope for better organization\n  const globalEntries: Array<[string, any]> = [];\n  const localEntriesByFunction: Record<string, Array<[string, any]>> = {};\n\n  map.forEach((entry, name) => {\n    // Check if this is a scoped name (contains a dot)\n    // const scopeMatch = name.name.match(/^(.+)\\.(.+)$/);\n    const scopeMatch = name.split(\"::\");\n    const varName = scopeMatch[1];\n    const functionName = scopeMatch[0];\n    \n    if (entry.isGlobal && varName) {\n      globalEntries.push([varName, entry]);\n    } else if (varName && functionName) {\n      if (!localEntriesByFunction[functionName]) {\n        localEntriesByFunction[functionName] = [];\n      }\n\n      // Store with the real variable name (without scope prefix)\n      localEntriesByFunction[functionName].push([varName, entry]);\n    } else if(varName) {\n      // Local variable without proper scope - fallback\n      if (!localEntriesByFunction[\"unknown\"]) {\n        localEntriesByFunction[\"unknown\"] = [];\n      }\n      localEntriesByFunction[\"unknown\"].push([varName, entry]);\n    } else {\n      throw new Error(\"Error parsing MemoryAddressKey\")\n    }\n  });\n\n  // Print all variables in a flat list but with their scope displayed\n  const allEntries: Array<[string, string, any]> = [];\n\n  // Add global variables\n  globalEntries.forEach(([name, entry]) => {\n    allEntries.push([name, \"global\", entry]);\n  });\n\n  // Add local variables with their function name as scope\n  Object.entries(localEntriesByFunction).forEach(([functionName, entries]) => {\n    entries.forEach(([name, entry]) => {\n      allEntries.push([name, functionName, entry]);\n    });\n  });\n\n  // Sort by scope and then by offset\n  allEntries.sort((a, b) => {\n    if (a[1] !== b[1]) {\n      // Sort global scope first\n      if (a[1] === \"global\") return -1;\n      if (b[1] === \"global\") return 1;\n      // Then alphabetically by function name\n      return a[1].localeCompare(b[1]);\n    }\n    // Within same scope, sort by offset\n    return a[2].offset - b[2].offset;\n  });\n\n  // Print the sorted entries\n  allEntries.forEach(([name, scope, entry]) => {\n    console.log(\n      `${name.padEnd(20)} | ${scope.padEnd(15)} | ` +\n        `${entry.offset.toString().padEnd(6)} | ${entry.size} bytes`\n    );\n  });\n\n  console.log(\"=============================================\\n\");\n}\n","/**\n * Utility functions for processing C functions.\n */\n\nimport { ProcessingError } from \"~src/errors\";\nimport { Expression } from \"~src/parser/c-ast/core\";\nimport { ExpressionP, StatementP } from \"~src/processor/c-ast/core\";\nimport {\n  FunctionCallP,\n  FunctionDefinitionP,\n} from \"~src/processor/c-ast/function\";\nimport { FunctionSymbolEntry, SymbolTable } from \"~src/processor/symbolTable\";\nimport processExpression from \"~src/processor/processExpression\";\nimport {\n  createMemoryOffsetIntegerConstant,\n  getDataTypeOfExpression,\n  extractFunctionDataTypeFromFunctionPointer,\n} from \"~src/processor/util\";\nimport FunctionDefinition from \"~src/parser/c-ast/functionDefinition\";\nimport processBlockItem from \"~src/processor/processBlockItem\";\nimport { FunctionCall } from \"~src/parser/c-ast/expression/unaryExpression\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport {\n  checkAssignability,\n  convertFunctionDataTypeToFunctionDetails,\n  stringifyDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport { DataType, FunctionDataType } from \"~src/parser/c-ast/dataTypes\";\nimport { ExpressionWrapperP } from \"~src/processor/c-ast/expression/expressions\";\nimport { memoryManager } from \"~src/processor/memoryManager\";\n\nexport default function processFunctionDefinition(\n  node: FunctionDefinition,\n  symbolTable: SymbolTable,\n): FunctionDefinitionP {\n  symbolTable.addFunctionEntry(node.name, node.dataType);\n  symbolTable.setFunctionIsDefinedFlag(node.name);\n  if (node.dataType.returnType.type === \"array\") {\n    throw new ProcessingError(\"arrays cannot be returned from a function\");\n  }\n\n  const funcSymbolTable = new SymbolTable(symbolTable);\n\n  memoryManager.enterScope(node.name);\n\n  // add all the params to the symbol table\n  for (let i = 0; i < node.parameterNames.length; ++i) {\n    funcSymbolTable.addVariableEntry(\n      node.parameterNames[i],\n      node.dataType.parameters[i],\n      \"auto\", // all function parameters must have \"auto\" storage class\n    );\n  }\n\n  const functionDefinitionNode: FunctionDefinitionP = {\n    type: \"FunctionDefinition\",\n    name: node.name,\n    sizeOfLocals: 0, // will be incremented as body is visited\n    body: [],\n    dataType: node.dataType,\n    position: node.position,\n  };\n\n  // visit body\n  const body = processBlockItem(\n    node.body,\n    funcSymbolTable,\n    functionDefinitionNode,\n  );\n  functionDefinitionNode.body = body; // body is a Block, an array of StatementP will be returned\n\n  memoryManager.exitScope();\n\n  return functionDefinitionNode;\n}\n\n/**\n * Process the expression that is returned from a function into a series of stores\n * of primary data objects in the return object location.\n */\nexport function processFunctionReturnStatement(\n  expr: Expression,\n  symbolTable: SymbolTable,\n): StatementP[] {\n  const statements: StatementP[] = [];\n  const processedExpr = processExpression(expr, symbolTable);\n\n  // TODO: data type check\n  // if (\n  //   enclosingFunc.dataType.returnType !== null &&\n  //   !checkDataTypeCompatibility(\n  //     processedExpr.originalDataType,\n  //     enclosingFunc.dataType.returnType\n  //   )\n  // ) {\n  //   throw new ProcessingError(\n  //     `Data type of expression being returned does not match declared function returntype - expression type: ${toJson(\n  //       processedExpr.originalDataType\n  //     )} declared type: ${toJson(enclosingFunc.dataType.returnType)}`\n  //   );\n  // }\n\n  let currOffset = 0;\n  processedExpr.exprs.forEach((expr) => {\n    statements.push({\n      type: \"MemoryStore\",\n      value: expr,\n      dataType: expr.dataType,\n      address: {\n        type: \"ReturnObjectAddress\",\n        subtype: \"store\",\n        offset: createMemoryOffsetIntegerConstant(currOffset),\n        dataType: \"pointer\",\n        position: expr.position,\n      },\n      position: expr.position,\n    });\n    currOffset += getSizeOfScalarDataType(expr.dataType);\n  });\n\n  statements.push({\n    type: \"ReturnStatement\",\n    position: expr.position,\n  });\n  return statements;\n}\n\n/**\n * Convert a FunctionCall node into its corresponding FunctionCallP.\n */\nexport function convertFunctionCallToFunctionCallP(\n  node: FunctionCall,\n  symbolTable: SymbolTable,\n): { functionCallP: FunctionCallP; returnType: DataType } {\n  // direct call of a function\n  if (\n    node.expr.type === \"IdentifierExpression\" &&\n    symbolTable.getSymbolEntry(node.expr.name).type === \"function\"\n  ) {\n    const symbolEntry = symbolTable.getSymbolEntry(\n      node.expr.name,\n    ) as FunctionSymbolEntry;\n\n    return {\n      functionCallP: {\n        type: \"FunctionCall\",\n        calledFunction: {\n          type: \"DirectlyCalledFunction\",\n          functionName: node.expr.name,\n          position: node.position,\n        },\n        functionDetails: symbolEntry.functionDetails,\n        args: processFunctionCallArgs(\n          node.args,\n          symbolEntry.dataType,\n          symbolTable,\n        ),\n        position: node.position,\n      },\n      returnType: symbolEntry.dataType.returnType,\n    };\n  }\n\n  // indirect call of function from an expression that is a function pointer\n  const processedCalledExpr = processExpression(node.expr, symbolTable);\n  const dataTypeOfCalledExpr = getDataTypeOfExpression({\n    expression: processedCalledExpr,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n\n  const functionDataType =\n    extractFunctionDataTypeFromFunctionPointer(dataTypeOfCalledExpr);\n\n  return {\n    returnType: functionDataType.returnType,\n    functionCallP: {\n      type: \"FunctionCall\",\n      calledFunction: {\n        type: \"IndirectlyCalledFunction\",\n        functionAddress: processedCalledExpr.exprs[0],\n        position: processedCalledExpr.exprs[0].position,\n      },\n      functionDetails:\n        convertFunctionDataTypeToFunctionDetails(functionDataType),\n      args: processFunctionCallArgs(node.args, functionDataType, symbolTable),\n      position: processedCalledExpr.exprs[0].position,\n    },\n  };\n}\n\nfunction processFunctionCallArgs(\n  args: Expression[],\n  fnDataType: FunctionDataType,\n  symbolTable: SymbolTable,\n): ExpressionP[] {\n  const argExpressions = [];\n  const argExpressionWrappers: ExpressionWrapperP[] = [];\n  for (const arg of args) {\n    const expr = processExpression(arg, symbolTable);\n    argExpressionWrappers.push(expr);\n    // each inidividual expression is concatenated in reverse order, as stack grows from high to low,\n    // whereas indiviudal primary data types within larger aggergates go from low to high (reverse direction)\n    argExpressions.push(...expr.exprs.reverse());\n  }\n\n  checkFunctionCallArgsAreCompatible(fnDataType, argExpressionWrappers);\n  return argExpressions;\n}\n\n/**\n * For a function call with given args,\n * Checks that for adherence to  Constraint 2 in 6.5.2.2 of C17 standard.\n * 1. the number of arguments shall agree with the number of parameters\n * 2. Each argument shall have a type such that its value may be assigned to an object with the unqualified version of the type of its corresponding parameter.\n */\nfunction checkFunctionCallArgsAreCompatible(\n  fnDataType: FunctionDataType,\n  args: ExpressionWrapperP[],\n) {\n  if (args.length != fnDataType.parameters.length) {\n    throw new ProcessingError(\n      \"number of arguments provided to function call does not match number of parameters specfied in prototype\",\n    );\n  }\n  for (let i = 0; i < args.length; ++i) {\n    if (!checkAssignability(fnDataType.parameters[i], args[i])) {\n      throw new ProcessingError(\n        `cannot assign function call argument to parameter\\nFunction parameter type: \"${stringifyDataType(\n          fnDataType.parameters[i],\n        )}\"\\nFunction argument type: \"${stringifyDataType(\n          getDataTypeOfExpression({\n            expression: args[i],\n            convertArrayToPointer: true,\n            convertFunctionToPointer: true,\n          }),\n        )}\"`,\n      );\n    }\n  }\n}\n","import { memoryManager } from \"~src/processor/memoryManager\";\nimport { ENUM_DATA_TYPE } from \"~src/common/constants\";\nimport { DataType, FunctionDataType } from \"../parser/c-ast/dataTypes\";\nimport { ProcessingError, toJson } from \"~src/errors\";\nimport { VariableDeclaration } from \"~src/parser/c-ast/declaration\";\nimport { FunctionDetails } from \"~src/processor/c-ast/function\";\nimport {\n  convertFunctionDataTypeToFunctionDetails,\n  getDataTypeSize,\n  stringifyDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport ModuleRepository, { ModuleName } from \"~src/modules\";\nimport { unpackDataSegmentInitializerAccordingToDataType } from \"~src/processor/processDeclaration\";\nimport { convertIntegerToByteString } from \"~src/processor/byteStrUtil\";\n\n/**\n * Definition of symbol table used by processor and semantic analyser\n */\nexport type SymbolEntry =\n  | FunctionSymbolEntry\n  | VariableSymbolEntry\n  | EnumeratorSymbolEntry;\n\nexport interface FunctionSymbolEntry {\n  type: \"function\";\n  dataType: FunctionDataType;\n  functionDetails: FunctionDetails; // process and save the function details\n}\n\n/**\n * Represent an enumerators present within Enum declarations.\n * Such enumerators can be used like constants.\n */\nexport interface EnumeratorSymbolEntry {\n  type: \"enumerator\";\n  dataType: { type: \"primary\"; primaryDataType: typeof ENUM_DATA_TYPE }; // in this compiler implementation enums directly correspond to signed ints\n  value: bigint;\n}\n\nexport interface VariableSymbolEntry {\n  type: \"localVariable\" | \"dataSegmentVariable\";\n  dataType: DataType;\n  offset: number; // offset in number of bytes of this from the first byte of the first encountered symbol in the same function OR global scope\n}\n\nexport type FunctionTable = FunctionTableEntry[];\n\nexport interface FunctionTableEntry {\n  functionName: string;\n  functionDetails: FunctionDetails;\n  isDefined: boolean; // whether the given function has been defined\n}\n\nexport class SymbolTable {\n  parentTable: SymbolTable | null;\n  currOffset: { value: number }; // current offset saved as \"value\" in an object. Used to make it sharable as a reference across tables\n  dataSegmentByteStr: { value: string }; // the string of bytes that forms the data segment\n  dataSegmentOffset: { value: number }; // the current offset at data segment (address of next allocated data segment object)\n  functionTable: FunctionTableEntry[]; // list of all functions declared in the program in one table\n  functionTableIndexes: Record<string, number>; // map function name to index in functionTable for fast lookup\n  symbols: Record<string, SymbolEntry>;\n  externalFunctions: Record<string, FunctionSymbolEntry>;\n  currentFunctionName: string = \"\";\n\n  constructor(parentTable?: SymbolTable | null) {\n    this.symbols = {};\n\n    if (parentTable) {\n      this.externalFunctions = parentTable.externalFunctions;\n      this.parentTable = parentTable;\n      this.dataSegmentByteStr = parentTable.dataSegmentByteStr;\n      this.dataSegmentOffset = parentTable.dataSegmentOffset;\n      this.functionTable = parentTable.functionTable;\n      this.functionTableIndexes = parentTable.functionTableIndexes;\n    } else {\n      this.externalFunctions = {};\n      this.parentTable = null;\n      // Initial value to reserve for the null space\n      this.dataSegmentByteStr = { value: \"\\\\d0\\\\e0\\\\b0\\\\f0\" };\n      // 4 Bytes are reserved for the null space\n      this.dataSegmentOffset = { value: 4 };\n      this.functionTable = [];\n      this.functionTableIndexes = {};\n    }\n\n    if (!parentTable || parentTable.parentTable === null) {\n      // all tables take the previous tables offset except the top 2 level parenttables\n      // root table (1st level) is the global scope\n      // 2nd level table is function scope\n      this.currOffset = { value: 0 };\n    } else {\n      this.currOffset = parentTable.currOffset;\n    }\n  }\n\n  /**\n   * Add all the functions of imoprted modules to global scope.\n   */\n  setExternalFunctions(\n    includedModules: ModuleName[],\n    moduleRepository: ModuleRepository,\n  ) {\n    this.externalFunctions = {};\n    for (const moduleName of includedModules) {\n      Object.keys(moduleRepository.modules[moduleName].moduleFunctions).forEach(\n        (funcName) => {\n          this.addFunctionEntry(\n            funcName,\n            moduleRepository.modules[moduleName].moduleFunctions[funcName]\n              .functionType,\n            true,\n          );\n          this.setFunctionIsDefinedFlag(funcName);\n        },\n      );\n    }\n    return this.externalFunctions;\n  }\n\n  isExternalFunction(funcName: string) {\n    return funcName in this.externalFunctions;\n  }\n\n  addEntry(declaration: VariableDeclaration): SymbolEntry {\n    if (declaration.dataType.type === \"function\") {\n      return this.addFunctionEntry(declaration.name, declaration.dataType);\n    } else {\n      if (this.parentTable === null || declaration.storageClass === \"static\") {\n        // the declaration is either a global or static\n        // allocate space for and the initializer bytes for this declared object in data segment\n        const byteStr = unpackDataSegmentInitializerAccordingToDataType(\n          declaration.dataType,\n          typeof declaration.initializer === \"undefined\"\n            ? null\n            : declaration.initializer,\n          this,\n        );\n        this.dataSegmentByteStr.value += byteStr;\n      }\n      return this.addVariableEntry(\n        declaration.name,\n        declaration.dataType,\n        declaration.storageClass,\n      );\n    }\n  }\n\n  addEnumeratorEntry(\n    enumeratorName: string,\n    enumeratorValue: bigint,\n  ): EnumeratorSymbolEntry {\n    const entry: EnumeratorSymbolEntry = {\n      type: \"enumerator\",\n      dataType: { type: \"primary\", primaryDataType: ENUM_DATA_TYPE },\n      value: enumeratorValue,\n    };\n    this.symbols[enumeratorName] = entry;\n    return entry;\n  }\n\n  /**\n   * Allocate bytes on data segment\n   * Adds the initializing bytes to the dataSegmentByteStr as well.\n   * @params the array of bytes (in demical numeric form) to put on data segment.\n   * @returns offset in data segment of the allocated object.\n   */\n  addDataSegmentObject(bytes: number[]): number {\n    bytes.forEach((byte) => {\n      this.dataSegmentByteStr.value += convertIntegerToByteString(\n        BigInt(byte),\n        1,\n      );\n    });\n    const offset = this.dataSegmentOffset.value;\n    this.dataSegmentOffset.value += bytes.length;\n    return offset;\n  }\n\n  addVariableEntry(\n    name: string,\n    dataType: DataType,\n    storageClass: \"auto\" | \"static\",\n  ): VariableSymbolEntry {\n    if (name in this.symbols) {\n      // given variable already exists in given scope\n      // multiple declarations only allowed outside of function bodies\n      if (this.parentTable !== null) {\n        throw new ProcessingError(`redeclaration of ${name}`);\n      }\n      const symbolEntry = this.symbols[name];\n      if (\n        symbolEntry.type === \"function\" ||\n        symbolEntry.type === \"enumerator\"\n      ) {\n        throw new ProcessingError(`redeclaration of ${name}`);\n      }\n\n      if (toJson(symbolEntry.dataType) !== toJson(dataType)) {\n        throw new ProcessingError(\n          `conflicting types for ${name}:  redeclared as \"${stringifyDataType(\n            dataType,\n          )}\" instead of ${stringifyDataType(symbolEntry.dataType)}`,\n        ); //TODO: stringify there datatype in english instead of just printing json\n      }\n      return this.symbols[name] as VariableSymbolEntry;\n    }\n\n    let entry: SymbolEntry;\n    if (this.parentTable === null) {\n      // the offset grows inthe positive direction (low to high adress) for globals\n      entry = {\n        type: \"dataSegmentVariable\",\n        dataType: dataType,\n        offset: this.dataSegmentOffset.value,\n      };\n      this.dataSegmentOffset.value += getDataTypeSize(dataType);\n    } else {\n      if (storageClass === \"static\") {\n        entry = {\n          type: \"dataSegmentVariable\",\n          dataType: dataType,\n          offset: this.dataSegmentOffset.value,\n        };\n        this.dataSegmentOffset.value += getDataTypeSize(dataType);\n      } else if (storageClass === \"auto\") {\n        // offset grows in negative direction (high to low adderss) for locals\n        this.currOffset.value -= getDataTypeSize(dataType);\n        entry = {\n          type: \"localVariable\",\n          dataType: dataType,\n          offset: this.currOffset.value,\n        };\n      } else {\n        throw new ProcessingError(\n          \"addVariableEntry(): Unhandled storage class\",\n        );\n      }\n    }\n    this.symbols[name] = entry;\n\n    const varEntry = entry as VariableSymbolEntry;\n    memoryManager.getAddressMap().addVariable(name, {\n      name,\n      offset: varEntry.offset,\n      isGlobal: varEntry.type === \"dataSegmentVariable\",\n      size: getDataTypeSize(dataType),\n      dataType: varEntry.dataType,\n    });\n\n    return entry;\n  }\n\n  addFunctionEntry(\n    name: string,\n    dataType: FunctionDataType,\n    isExternalFunction?: boolean,\n  ): FunctionSymbolEntry {\n    if (!isExternalFunction && name in this.symbols) {\n      // function was already declared before\n      // simple check that symbol is a function and the params and return types match\n      if (this.symbols[name].type !== \"function\") {\n        throw new ProcessingError(\n          `redeclaration of ${name} as different kind of symbol: function instead of variable`,\n        );\n      }\n\n      return this.symbols[name] as FunctionSymbolEntry;\n    }\n\n    const entry: FunctionSymbolEntry = {\n      type: \"function\",\n      dataType,\n      functionDetails: convertFunctionDataTypeToFunctionDetails(dataType),\n    };\n\n    if (isExternalFunction) {\n      this.externalFunctions[name] = entry;\n    } else {\n      this.symbols[name] = entry;\n    }\n\n    this.functionTable.push({\n      functionName: name,\n      functionDetails: entry.functionDetails,\n      isDefined: false,\n    });\n    this.functionTableIndexes[name] = this.functionTable.length - 1;\n    return entry;\n  }\n\n  hasSymbol(name: string): boolean {\n    let curr: SymbolTable | null = this;\n    while (curr !== null) {\n      if (name in curr.symbols) {\n        return true;\n      }\n      curr = curr.parentTable;\n    }\n\n    if (name in this.externalFunctions) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Look up the symbol starting from the lowest symbol table (most recent).\n   */\n  getSymbolEntry(name: string): SymbolEntry {\n    let curr: SymbolTable | null = this;\n    while (curr !== null) {\n      if (name in curr.symbols) {\n        return curr.symbols[name];\n      }\n      curr = curr.parentTable;\n    }\n\n    if (name in this.externalFunctions) {\n      return this.externalFunctions[name];\n    }\n    throw new ProcessingError(`'${name}' undeclared`);\n  }\n\n  /**\n   * Returns the index of function with given name in the functionTable\n   */\n  getFunctionIndex(name: string) {\n    return this.functionTableIndexes[name];\n  }\n\n  /**\n   * Set the isDefined flag for the given function to true.\n   */\n  setFunctionIsDefinedFlag(functionName: string) {\n    this.functionTable[this.getFunctionIndex(functionName)].isDefined = true;\n  }\n\n  enterFunctionScope(functionName: string): void {\n    this.currentFunctionName = functionName;\n    memoryManager.enterScope(functionName);\n  }\n\n  exitFunctionScope(): void {\n    this.currentFunctionName = \"\";\n    memoryManager.exitScope();\n  }\n}\n","import { MemoryAddressMap } from \"~src/processor/memoryAddressMap\";\nimport { getDataTypeSize } from \"~src/processor/dataTypeUtil\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\n\nclass MemoryManager {\n  private static instance: MemoryManager;\n  private addressMap: MemoryAddressMap;\n\n  private constructor() {\n    this.addressMap = new MemoryAddressMap();\n  }\n\n  public reload() {\n    if (MemoryManager.instance) {\n      MemoryManager.instance = new MemoryManager();\n    }\n  }\n\n  public static getInstance(): MemoryManager {\n    if (!MemoryManager.instance) {\n      MemoryManager.instance = new MemoryManager();\n    }\n    return MemoryManager.instance;\n  }\n\n  public initFromSymbolTable(symbolTable: SymbolTable): void {\n    this.addressMap = MemoryAddressMap.buildFromSymbolTable(\n      symbolTable,\n      getDataTypeSize\n    );\n  }\n\n  // public getSymbolTable(): Map<>\n\n  // public getVariableAddress(name: string): number | undefined {\n  //   const entry = this.addressMap.getVariableAddress(name);\n  //   return entry?.offset;\n  // }\n\n  public getAddressMap(): MemoryAddressMap {\n    return this.addressMap;\n  }\n\n  public enterScope(scopeName: string): void {\n    this.addressMap.pushScope(scopeName);\n  }\n\n  public exitScope(): void {\n    this.addressMap.popScope();\n  }\n}\n\nexport const memoryManager = MemoryManager.getInstance();\n","import { SymbolTable, VariableSymbolEntry } from \"~src/processor/symbolTable\";\nimport { DataType } from \"../parser/c-ast/dataTypes\";\n\nexport interface MemoryAddressEntry {\n  name: string;\n  offset: number;\n  isGlobal: boolean;\n  size: number;\n  dataType: DataType;\n  value?: number;\n  absoluteAddress?: number;\n}\n\nexport class MemoryAddressKey {\n  name: string;\n  scope: string;\n  offset: number;\n\n  constructor(name: string, scope: string, offset: number) {\n    this.name = name;\n    this.scope = scope;\n    this.offset = offset;\n  }\n\n  public toString(): string {\n    return `${this.scope}::${this.name}::${this.offset.toString()}`;\n  }\n}\n\nexport class MemoryAddressMap {\n  private addressMap: Map<string, MemoryAddressEntry> = new Map();\n  private scopeChain: string[] = [];\n\n  addVariable(name: string, entry: MemoryAddressEntry): void {\n    const scopedName = this.getScopedName(name);\n    this.addressMap.set(\n      new MemoryAddressKey(name, scopedName, entry.offset).toString(),\n      entry\n    );\n  }\n\n  // getVariableAddress(name: string): MemoryAddressEntry | undefined {\n  //   const scopedName = this.getScopedName(name);\n  //   if (this.addressMap.has(scopedName)) {\n  //     return this.addressMap.get(scopedName);\n  //   }\n\n  //   if (this.addressMap.has(name)) {\n  //     return this.addressMap.get(name);\n  //   }\n\n  //   return undefined;\n  // }\n\n  // getEffectiveAddress(name: string): number | undefined {\n  //   const entry = this.getVariableAddress(name);\n  //   if (!entry) return undefined;\n\n  //   return entry.absoluteAddress !== undefined\n  //     ? entry.absoluteAddress\n  //     : entry.offset;\n  // }\n\n  pushScope(scopeName: string): void {\n    this.scopeChain.push(scopeName);\n  }\n\n  popScope(): string | undefined {\n    return this.scopeChain.pop();\n  }\n\n  private getScopedName(name: string): string {\n    if (this.scopeChain.length === 0) {\n      return name;\n    }\n    return this.scopeChain[this.scopeChain.length - 1];\n    // return `${this.scopeChain.join(\".\")}.${name}`;\n  }\n\n  static buildFromSymbolTable(\n    symbolTable: SymbolTable,\n    getDataTypeSize: (dataType: any) => number\n  ): MemoryAddressMap {\n    const map = new MemoryAddressMap();\n\n    function processSymbolTable(table: SymbolTable, isGlobal: boolean): void {\n      if (!isGlobal) {\n        map.pushScope(getFunctionNameFromSymbolTable(table));\n      }\n\n      for (const [name, entry] of Object.entries(table.symbols)) {\n        if (\n          entry.type === \"localVariable\" ||\n          entry.type === \"dataSegmentVariable\"\n        ) {\n          const varEntry = entry as VariableSymbolEntry;\n          map.addVariable(name, {\n            name,\n            offset: varEntry.offset,\n            isGlobal: entry.type === \"dataSegmentVariable\",\n            size: getDataTypeSize(varEntry.dataType),\n            dataType: varEntry.dataType,\n          });\n        }\n      }\n\n      if (!isGlobal) {\n        map.popScope();\n      }\n    }\n\n    function getFunctionNameFromSymbolTable(table: SymbolTable): string {\n      return \"function_\" + Math.random().toString(36).substring(2, 9);\n    }\n\n    processSymbolTable(getRootSymbolTable(symbolTable), true);\n    processFunctionScopes(symbolTable, processSymbolTable);\n\n    return map;\n  }\n\n  public debugPrint(): void {\n    console.log(\"=== Memory Address Map ===\");\n\n    // Convert the Map to an array for easier logging\n    const entries: Array<[string, any]> = [];\n    this.addressMap.forEach((entry, name) => {\n      const parts = name.split(\"::\");\n      if(!parts[1]) {\n        throw new Error(\"Cannot parse MemoryAddressKey\");\n      }\n      \n      entries.push([parts[1], entry]);\n    });\n\n    // Sort by address for cleaner output\n    entries.sort((a, b) => a[1].offset - b[1].offset);\n\n    entries.forEach(([name, entry]) => {\n      console.log(\n        `${name.padEnd(20)} | ${entry.isGlobal ? \"Global\" : \"Local\"} | ` +\n          `Offset: ${entry.offset} | Size: ${entry.size} bytes`\n      );\n    });\n\n    console.log(\"========================\");\n  }\n\n  getAddressMap(): Map<string, MemoryAddressEntry> {\n    return this.addressMap;\n  }\n}\n\nfunction getRootSymbolTable(symbolTable: SymbolTable): SymbolTable {\n  let current = symbolTable;\n  while (current.parentTable !== null) {\n    current = current.parentTable;\n  }\n  return current;\n}\n\nfunction processFunctionScopes(\n  symbolTable: SymbolTable,\n  processFn: (table: SymbolTable, isGlobal: boolean) => void\n): void {\n  const functionNames: string[] = [];\n  for (const [name, entry] of Object.entries(symbolTable.symbols)) {\n    if (entry.type === \"function\") {\n      functionNames.push(name);\n    }\n  }\n\n  console.log(`Found ${functionNames.length} functions to process`);\n\n  for (const entry of symbolTable.functionTable) {\n    if (entry.isDefined) {\n      const functionName = entry.functionName;\n      console.log(`Processing local variables for function: ${functionName}`);\n\n      processFn(symbolTable, false);\n    }\n  }\n}\n","/**\n * Some utility functions used by the processor when working with data types.\n */\n\nimport {\n  ArrayDataType,\n  DataType,\n  FunctionDataType,\n  PointerDataType,\n  PrimaryDataType,\n  StructDataType,\n  StructField,\n  StructSelfPointer,\n} from \"~src/parser/c-ast/dataTypes\";\n\nimport { ProcessingError, toJson } from \"~src/errors\";\nimport evaluateCompileTimeExpression from \"~src/processor/evaluateCompileTimeExpression\";\nimport { ScalarCDataType } from \"~src/common/types\";\nimport {\n  getSizeOfScalarDataType,\n  isFloatType,\n  isIntegerType,\n  primaryDataTypeSizes,\n} from \"~src/common/utils\";\nimport { ENUM_DATA_TYPE, POINTER_SIZE } from \"~src/common/constants\";\nimport { FunctionDetails } from \"~src/processor/c-ast/function\";\nimport { ExpressionWrapperP } from \"~src/processor/c-ast/expression/expressions\";\nimport { getDataTypeOfExpression } from \"~src/processor/util\";\n\nfunction getNumberOfElementsInArray(dataType: ArrayDataType): number {\n  try {\n    const numElementsConstant = evaluateCompileTimeExpression(\n      dataType.numElements,\n    );\n    if (numElementsConstant.type === \"FloatConstant\") {\n      throw new ProcessingError(\"array size must be an integer-type\");\n    }\n    return Number(numElementsConstant.value);\n  } catch (e) {\n    if (e instanceof ProcessingError) {\n      throw new ProcessingError(\n        \"Array size must be compile-time constant expression (Variable Length Arrays not supported)\",\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Returns the size in bytes of a data type.\n */\nexport function getDataTypeSize(\n  dataType: DataType | StructSelfPointer,\n): number {\n  if (\n    dataType.type === \"primary\" ||\n    dataType.type === \"pointer\" ||\n    dataType.type === \"struct self pointer\"\n  ) {\n    return getSizeOfScalarDataType(\n      dataType.type === \"pointer\" || dataType.type === \"struct self pointer\"\n        ? \"pointer\"\n        : dataType.primaryDataType,\n    );\n  } else if (dataType.type === \"array\") {\n    return (\n      getNumberOfElementsInArray(dataType) *\n      getDataTypeSize(dataType.elementDataType)\n    );\n  } else if (dataType.type === \"struct\") {\n    return dataType.fields.reduce(\n      (sum, field) =>\n        sum +\n        (field.dataType.type === \"struct self pointer\"\n          ? POINTER_SIZE\n          : getDataTypeSize(field.dataType)),\n      0,\n    );\n  } else if (dataType.type === \"enum\") {\n    return primaryDataTypeSizes[ENUM_DATA_TYPE];\n  } else if (dataType.type === \"void\") {\n    throw new ProcessingError(`void value not ignored as it should be`);\n  } else {\n    throw new Error(\n      `getDataTypeSize(): unhandled data type: ${toJson(dataType)}`,\n    );\n  }\n}\n/**\n * Returns true if the type is scalar.\n * Only primary data types and pointers are scalar.\n */\n\nexport function isScalarDataType(dataType: DataType) {\n  return (\n    dataType.type === \"primary\" ||\n    dataType.type === \"pointer\" ||\n    dataType.type === \"enum\"\n  ); // enums are signed ints, thus scalar\n}\n\nexport function isRealDataType(dataType: DataType) {\n  return isScalarDataType(dataType);\n}\n\nexport function isIntegralDataType(dataType: DataType) {\n  return (\n    (dataType.type === \"primary\" && isIntegerType(dataType.primaryDataType)) ||\n    dataType.type === \"enum\"\n  );\n}\n\nexport function isFloatDataType(dataType: DataType) {\n  return dataType.type === \"primary\" && isFloatType(dataType.primaryDataType);\n}\n\nexport function isArithmeticDataType(dataType: DataType) {\n  return dataType.type === \"primary\" || dataType.type === \"enum\";\n}\n\nexport function isVoidPointer(dataType: DataType) {\n  return dataType.type === \"pointer\" && dataType.pointeeType.type === \"void\";\n}\n\nexport function isPointerToCompleteDataType(dataType: DataType) {\n  return dataType.type === \"pointer\" && dataType.pointeeType.type !== \"void\";\n}\n\nexport function isPointer(dataType: DataType) {\n  return dataType.type === \"pointer\";\n}\n\nexport function getDecayedArrayPointerType(\n  dataType: ArrayDataType,\n): PointerDataType {\n  return {\n    type: \"pointer\",\n    pointeeType: dataType.elementDataType,\n    isConst: dataType.isConst,\n  };\n}\n\nexport function getFunctionPointerOfFunction(\n  fn: FunctionDataType,\n): PointerDataType {\n  return {\n    type: \"pointer\",\n    pointeeType: fn,\n  };\n}\n\n// export function checkPrimaryDataTypeCompatibility(dataTypeA: PrimaryCDataType, dataTypeB: PrimaryCDataType) {\n//   return\n// }\n\n/**\n * Utlity function to generate data type string.\n */\n// export function stringifyDataType(dataType: DataType) {\n//   let str = \"\";\n//   function helperFunction(dataType: DataType) {\n//     if (dataType.type === \"primary\") {\n//       str = `${dataType.primaryDataType} ${str}`;\n//     } else if (dataType.type === \"array\") {\n//       helperFunction(dataType.elementDataType);\n//       str += \" []\";\n//     } else if (dataType.type === \"pointer\") {\n//       if (dataType.pointeeType === null) {\n//         str = \"void *\";\n//       } else if (dataType.pointeeType.type === \"function\" || dataType.pointeeType.type === \"array\") {\n//         str = `(*${str})`;\n//       } else {\n//         str = `*${str}`;\n//       }\n//     } else if (dataType.type === \"function\") {\n//       if (dataType.returnType === null) {\n//         str = `void ${str}`;\n//       } else {helperFunction(dataType.returnType)}\n//       str += \"(\";\n//       for (let i = 0; i < dataType.parameters.length - 1; ++i) {\n//         str += stringifyDataType(dataType.parameters[i]);\n//         str += \", \";\n//       }\n//       str += \")\";\n//     }\n//   }\n//   helperFunction(dataType);\n//   return str;\n// }\n\nexport function stringifyDataType(dataType: DataType): string {\n  if (dataType.type === \"primary\") {\n    return `${dataType.isConst ? \"const \" : \"\"}${dataType.primaryDataType}`;\n  } else if (dataType.type === \"array\") {\n    return `${dataType.isConst ? \"const \" : \"\"}array with size ${\n      evaluateCompileTimeExpression(dataType.numElements).value\n    } of ${stringifyDataType(dataType.elementDataType)}`;\n  } else if (dataType.type === \"pointer\") {\n    return `${dataType.isConst ? \"const \" : \"\"}pointer to ${stringifyDataType(\n      dataType.pointeeType,\n    )}`;\n  } else if (dataType.type === \"function\") {\n    return `function (${dataType.parameters\n      .map(stringifyDataType)\n      .join(\", \")}) returning ${stringifyDataType(dataType.returnType)}`;\n  } else if (dataType.type === \"struct\") {\n    return `struct ${dataType.tag ? dataType.tag : \" \"}`;\n  } else if (dataType.type === \"enum\") {\n    return `enum ${dataType.tag}`;\n  } else if (dataType.type === \"void\") {\n    return `void`;\n  } else {\n    console.assert(false, \"stringifyDataType() unreachable else\");\n    return \"\";\n  }\n}\n\n/**\n * Returns true if 2 struct fields are compatible (equivalent).\n */\nfunction checkStructFieldCompatibility(\n  a: StructField,\n  b: StructField,\n  ignoreQualifiers = false,\n) {\n  if (a.tag !== b.tag) {\n    return false;\n  }\n  if (a.dataType.type === \"struct self pointer\") {\n    if (b.dataType.type !== \"struct self pointer\") {\n      return false;\n    }\n    return true;\n  } else {\n    if (b.dataType.type === \"struct self pointer\") {\n      return false;\n    }\n    return checkDataTypeCompatibility(a.dataType, b.dataType, ignoreQualifiers);\n  }\n}\n\n/**\n * Checks the compatibility of two data types. Returns true if two data types are compatible as per the C17 standard.\n * @param ignoreQualifiers to check if the unqualified data types of a and b are compatible.\n */\nexport function checkDataTypeCompatibility(\n  a: DataType,\n  b: DataType,\n  ignoreQualifiers = false,\n): boolean {\n  if (\n    a.type !== b.type ||\n    (!ignoreQualifiers && a.isConst && !b.isConst) ||\n    (b.isConst && !a.isConst)\n  ) {\n    return false;\n  }\n  if (a.type === \"primary\" && b.type === \"primary\") {\n    return a.primaryDataType === b.primaryDataType;\n  } else if (a.type === \"array\" && b.type === \"array\") {\n    return (\n      evaluateCompileTimeExpression(a.numElements).value ===\n        evaluateCompileTimeExpression(b.numElements).value &&\n      checkDataTypeCompatibility(\n        a.elementDataType,\n        b.elementDataType,\n        ignoreQualifiers,\n      )\n    );\n  } else if (a.type === \"function\" && b.type === \"function\") {\n    // check return type compatibility\n    if (a.returnType.type === \"void\") {\n      if (b.returnType.type !== \"void\") {\n        return false;\n      }\n    } else {\n      if (\n        b.returnType.type === \"void\" ||\n        !checkDataTypeCompatibility(\n          a.returnType,\n          b.returnType,\n          ignoreQualifiers,\n        )\n      ) {\n        return false;\n      }\n    }\n    if (a.parameters.length !== b.parameters.length) {\n      return false;\n    }\n    for (let i = 0; i < a.parameters.length; ++i) {\n      if (\n        !checkDataTypeCompatibility(\n          a.parameters[i],\n          b.parameters[i],\n          ignoreQualifiers,\n        )\n      ) {\n        return false;\n      }\n    }\n    return true;\n  } else if (a.type === \"struct\" && b.type === \"struct\") {\n    if (a.tag !== b.tag) {\n      return false;\n    }\n    if (a.fields.length !== b.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < a.fields.length; ++i) {\n      if (\n        !checkStructFieldCompatibility(\n          a.fields[i],\n          b.fields[i],\n          ignoreQualifiers,\n        )\n      ) {\n        return false;\n      }\n    }\n    return true;\n  } else if (a.type === \"pointer\" && b.type === \"pointer\") {\n    if (isVoidPointer(a) && isVoidPointer(b)) {\n      return true;\n    }\n    if (isVoidPointer(a) || isVoidPointer(b)) {\n      return false;\n    }\n    return checkDataTypeCompatibility(\n      a.pointeeType,\n      b.pointeeType,\n      ignoreQualifiers,\n    );\n  } else if (a.type === \"enum\" && b.type === \"enum\") {\n    // all enums in this implementation are equivalent to \"signed int\" and thus are compatibile with one another\n    return true;\n  } else if (a.type === \"void\" && b.type === \"void\") {\n    return true;\n  } else {\n    console.assert(false, \"checkDataTypeCompatibility(): Unhandled case\");\n    return false;\n  }\n}\n\n/**\n * Represents a primary data type (scalar) that is part of a DataType. e.g. the field of a struct\n */\nexport interface PrimaryDataTypeMemoryObjectDetails {\n  dataType: ScalarCDataType;\n  offset: number; // offset in number of bytes from the first byte of the memory object that this primary data type object belongs in.\n}\n/**\n * Unpacks an data type into its constituent primary data types (including multi dim arrays and structs)\n */\nexport function unpackDataType(\n  dataType: DataType,\n): PrimaryDataTypeMemoryObjectDetails[] {\n  let currOffset = 0;\n  const memoryObjects: PrimaryDataTypeMemoryObjectDetails[] = [];\n  function recursiveHelper(dataType: DataType) {\n    if (dataType.type === \"primary\") {\n      memoryObjects.push({\n        dataType: dataType.primaryDataType,\n        offset: currOffset,\n      });\n      currOffset += getDataTypeSize(dataType);\n    } else if (dataType.type === \"pointer\") {\n      memoryObjects.push({\n        dataType: \"pointer\",\n        offset: currOffset,\n      });\n      currOffset += getDataTypeSize(dataType);\n    } else if (dataType.type === \"array\") {\n      const numElements = getNumberOfElementsInArray(dataType);\n      for (let i = 0; i < numElements; ++i) {\n        recursiveHelper(dataType.elementDataType);\n      }\n    } else if (dataType.type === \"struct\") {\n      for (const field of dataType.fields) {\n        if (field.dataType.type === \"struct self pointer\") {\n          // pointer to the struct itself\n          memoryObjects.push({\n            dataType: \"pointer\",\n            offset: currOffset,\n          });\n          currOffset += getDataTypeSize(dataType);\n        } else {\n          recursiveHelper(field.dataType);\n        }\n      }\n    } else if (dataType.type === \"enum\") {\n      memoryObjects.push({\n        dataType: ENUM_DATA_TYPE,\n        offset: currOffset,\n      });\n      currOffset += getDataTypeSize(dataType);\n    } else {\n      // should not happen\n      throw new Error(\n        `unpackDataType(): Invalid data type to unpack: ${toJson(dataType)}`,\n      );\n    }\n  }\n  recursiveHelper(dataType);\n  return memoryObjects;\n}\n\n/**\n * Returns the number of primary objects that compose a data type.\n */\nfunction getDataTypeNumberOfPrimaryObjects(dataType: DataType): number {\n  if (\n    dataType.type === \"primary\" ||\n    dataType.type === \"pointer\" ||\n    dataType.type === \"enum\"\n  ) {\n    return 1;\n  } else if (dataType.type === \"array\") {\n    try {\n      const numElementsConstant = evaluateCompileTimeExpression(\n        dataType.numElements,\n      );\n      if (numElementsConstant.type === \"FloatConstant\") {\n        throw new ProcessingError(\"array size must be an integer-type\");\n      }\n      return (\n        getDataTypeNumberOfPrimaryObjects(dataType.elementDataType) *\n        Number(numElementsConstant.value)\n      );\n    } catch (e) {\n      if (e instanceof ProcessingError) {\n        throw new ProcessingError(\n          \"array size must be compile-time constant expression (Variable Length Arrays not supported)\",\n        );\n      } else {\n        throw e;\n      }\n    }\n  } else if (dataType.type === \"struct\") {\n    return dataType.fields.reduce(\n      (sum, field) =>\n        sum +\n        (field.dataType.type === \"struct self pointer\"\n          ? 1\n          : getDataTypeNumberOfPrimaryObjects(field.dataType)),\n      0,\n    );\n  } else {\n    throw new Error(\n      `getDataTypeNumberOfPrimaryObjects(): unhandled data type: ${toJson(\n        dataType,\n      )}`,\n    );\n  }\n}\n\n/**\n * Determines the index of the given field tag in a struct based in terms of the index in the unpacked primary data objects\n * that is returned by running unpackDataType on the whole struct,\n * as well as the datatype of the field.\n */\nexport function determineIndexAndDataTypeOfFieldInStruct(\n  structDataType: StructDataType,\n  fieldTag: string,\n): { fieldIndex: number; fieldDataType: DataType | StructSelfPointer } {\n  let currIndex = 0;\n  for (const field of structDataType.fields) {\n    if (fieldTag === field.tag) {\n      return { fieldIndex: currIndex, fieldDataType: field.dataType };\n    }\n    currIndex +=\n      field.dataType.type === \"struct self pointer\"\n        ? 1\n        : getDataTypeNumberOfPrimaryObjects(field.dataType);\n  }\n  throw new ProcessingError(\n    `struct${\n      structDataType.tag !== null ? \" \" + structDataType.tag : \"\"\n    } has no member named '${fieldTag}'`,\n  );\n}\n\nexport function convertFunctionDataTypeToFunctionDetails(\n  dataType: FunctionDataType,\n): FunctionDetails {\n  const functionDetails: FunctionDetails = {\n    sizeOfParams: 0,\n    sizeOfReturn: 0,\n    parameters: [],\n    returnObjects: null,\n  };\n\n  if (dataType.returnType.type !== \"void\") {\n    if (dataType.returnType.type === \"array\") {\n      throw new ProcessingError(\n        \"array is not a valid return type from a function\",\n      );\n    }\n\n    functionDetails.sizeOfReturn += getDataTypeSize(dataType.returnType);\n    functionDetails.returnObjects = unpackDataType(dataType.returnType).map(\n      (scalarDataType) => ({\n        dataType: scalarDataType.dataType,\n        offset: scalarDataType.offset,\n      }),\n    );\n  }\n\n  let offset = 0;\n  for (const param of dataType.parameters) {\n    // sanity check, as parser should have converted all array params into pointers.\n    if (param.type === \"array\") {\n      console.assert(\n        param.type !== \"array\",\n        \"Compiler error: The type of a function parameter should not be an array after parsing\",\n      );\n    }\n    const dataTypeSize = getDataTypeSize(param);\n    offset -= dataTypeSize;\n    functionDetails.sizeOfParams += dataTypeSize;\n    const unpackedParam = unpackDataType(param).map((scalarDataType) => ({\n      dataType: scalarDataType.dataType,\n      offset: offset + scalarDataType.offset, // offset of entire aggregate object + offset of particular sacalar data type within object\n    }));\n    // need to load unpacked param in reverse order, as in stack frame creation, the highest address subobject of an aggregate type gets loaded first as the stack frame grows from high to low address\n    functionDetails.parameters.push(...unpackedParam.reverse());\n  }\n\n  return functionDetails;\n}\n\nexport function isNullPointerConstant(expr: ExpressionWrapperP) {\n  return (\n    expr.exprs[0].type === \"IntegerConstant\" &&\n    Number(expr.exprs[0].value) === 0\n  );\n}\n\n/**\n * Checks if expr with a given datatype can be assigned to lvalue of another datatype.\n * Follows constraints on simple assignment as listed in 6.5.16.1 of C17 standard.\n */\nexport function checkAssignability(\n  lvalue: DataType,\n  expr: ExpressionWrapperP, // the expression being assigned\n) {\n  if (\n    lvalue.type === \"array\" ||\n    lvalue.type === \"function\" ||\n    lvalue.type === \"void\"\n  ) {\n    return false;\n  }\n\n  const exprDataType = getDataTypeOfExpression({\n    expression: expr,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n\n  // assigning null pointer constant\n  if (lvalue.type === \"pointer\" && isNullPointerConstant(expr)) {\n    return true;\n  }\n\n  return (\n    (isArithmeticDataType(lvalue) && isArithmeticDataType(exprDataType)) ||\n    (lvalue.type === \"struct\" &&\n      checkDataTypeCompatibility(lvalue, exprDataType)) ||\n    (lvalue.type === \"pointer\" &&\n      exprDataType.type === \"pointer\" &&\n      checkAssignabilityOfPointers(lvalue, exprDataType))\n  );\n}\n\nexport function checkAssignabilityOfPointers(\n  left: PointerDataType,\n  right: PointerDataType,\n) {\n  if (isVoidPointer(left) || isVoidPointer(right)) {\n    return true;\n  }\n\n  if (!left.pointeeType.isConst && right.pointeeType.isConst) {\n    // right pointer has more pointee qualifiers than left\n    return false;\n  }\n\n  return checkDataTypeCompatibility(\n    left.pointeeType as DataType,\n    right.pointeeType as DataType,\n    true,\n  );\n}\n\nexport function isFieldInStruct(dataType: StructDataType, fieldTag: string) {\n  for (const field of dataType.fields) {\n    if (field.tag === fieldTag) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst integerPromotableTypes = new Set([\n  \"unsigned char\",\n  \"signed char\",\n  \"unsigned short\",\n  \"signed short\",\n]);\n\n/**\n * Returns the integer promoted version of the given datatype\n * @param dataType\n */\nexport function getIntegerPromotedDataType(dataType: DataType): DataType {\n  if (\n    isIntegralDataType(dataType) &&\n    integerPromotableTypes.has((dataType as PrimaryDataType).primaryDataType)\n  ) {\n    return {\n      type: \"primary\",\n      primaryDataType: \"signed int\",\n    };\n  }\n  return dataType;\n}\n","import { determineResultDataTypeOfBinaryExpression } from \"./expressionUtil\";\nimport processConstant, {\n  getAdjustedIntValueAccordingToDataType,\n} from \"./processConstant\";\n\nimport {\n  BinaryOperator,\n  UnaryOperator,\n  IntegerDataType,\n  FloatDataType,\n} from \"~src/common/types\";\nimport { isIntegerType } from \"~src/common/utils\";\nimport { ProcessingError } from \"~src/errors\";\nimport { Expression } from \"~src/parser/c-ast/core\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\n\n/**\n * Evaluates the result of the binary expression a <operator> b.\n */\n\nexport function performBinaryOperation<T extends number | bigint>(\n  a: T,\n  operator: BinaryOperator,\n  b: T,\n): T;\nexport function performBinaryOperation(\n  a: any,\n  operator: BinaryOperator,\n  b: any,\n) {\n  const isNonZero = (x: any) => (typeof x === \"bigint\" ? x !== 0n : x !== 0);\n\n  switch (operator) {\n    // arithmetic operators\n    case \"+\":\n      return a + b;\n    case \"-\":\n      return a - b;\n    case \"*\":\n      return a * b;\n    case \"/\":\n      return a / b;\n    case \"%\":\n      return a % b;\n    // logical operators\n    case \"&&\":\n      return isNonZero(a) && isNonZero(b) ? 1 : 0;\n    case \"||\":\n      return isNonZero(a) || isNonZero(b) ? 1 : 0;\n    // relational operator\n    case \"<\":\n      return a < b ? 1 : 0;\n    case \"<=\":\n      return a <= b ? 1 : 0;\n    case \"!=\":\n      return a !== b ? 1 : 0;\n    case \"==\":\n      return a === b ? 1 : 0;\n    case \">=\":\n      return a >= b ? 1 : 0;\n    case \">\":\n      return a > b ? 1 : 0;\n    // bitwise binary operator\n    case \">>\":\n      return a >> b;\n    case \"<<\":\n      return a << b;\n    case \"&\":\n      return a & b;\n    case \"|\":\n      return a | b;\n    case \"^\":\n      return a ^ b;\n  }\n}\n\nexport function performUnaryOperation<T extends number | bigint>(\n  a: T,\n  operator: UnaryOperator,\n): T;\nexport function performUnaryOperation(a: any, operator: UnaryOperator) {\n  switch (operator) {\n    // Arithmetic unary opreators\n    case \"++\":\n      return a + 1;\n    case \"--\":\n      return a - 1;\n    // Prefix Operators\n    case \"!\":\n      if (typeof a === \"bigint\") {\n        return a === 0n ? 1n : 0n;\n      } else {\n        return a === 0 ? 1 : 0;\n      }\n    case \"~\":\n      if (typeof a === \"bigint\") {\n        return ~a;\n      } else {\n        throw new Error(\n          \"Bitwise NOT (~) operator can only be applied to integer types\",\n        );\n      }\n    case \"-\":\n      return -a;\n    case \"+\":\n      return a;\n  }\n}\n\n/**\n * Returns true if a given expression can be evaluated at compile-time.\n */\nexport function isCompileTimeExpression(expr: Expression): boolean {\n  if (expr.type === \"FloatConstant\" || expr.type === \"IntegerConstant\") {\n    return true;\n  } else if (expr.type === \"BinaryExpression\") {\n    return (\n      isCompileTimeExpression(expr.leftExpr) &&\n      isCompileTimeExpression(expr.rightExpr)\n    );\n  } else if (\n    expr.type === \"PrefixExpression\" ||\n    expr.type === \"PostfixExpression\"\n  ) {\n    return isCompileTimeExpression(expr.expr);\n  }\n  return false;\n}\n\n/**\n * Evaluates a compile time expression.\n */\nexport default function evaluateCompileTimeExpression(\n  expr: Expression,\n): ConstantP {\n  if (expr.type === \"FloatConstant\" || expr.type === \"IntegerConstant\") {\n    // alerady a constant\n    return processConstant(expr);\n  } else if (expr.type === \"BinaryExpression\") {\n    // binary expressions\n    const evaluatedLeftExpr = evaluateCompileTimeExpression(expr.leftExpr);\n    const evaluatedRightExpr = evaluateCompileTimeExpression(expr.rightExpr);\n    let value = performBinaryOperation(\n      evaluatedLeftExpr.value,\n      expr.operator,\n      evaluatedRightExpr.value,\n    );\n\n    const dataType = determineResultDataTypeOfBinaryExpression(\n      { type: \"primary\", primaryDataType: evaluatedLeftExpr.dataType },\n      { type: \"primary\", primaryDataType: evaluatedRightExpr.dataType },\n      expr.operator,\n    );\n\n    if (dataType.type !== \"primary\") {\n      throw new ProcessingError(\"invalid compile-time expression\");\n    }\n\n    if (isIntegerType(dataType.primaryDataType)) {\n      // need to cap integer values correctly\n      value = getAdjustedIntValueAccordingToDataType(\n        value as bigint,\n        dataType.primaryDataType,\n      );\n\n      return {\n        type: \"IntegerConstant\",\n        dataType: dataType.primaryDataType as IntegerDataType,\n        value,\n        position: expr.position,\n      };\n    } else {\n      // the result of the binary expression is a floating point\n      return {\n        type: \"FloatConstant\",\n        dataType: dataType.primaryDataType as FloatDataType,\n        value: value as number,\n        position: expr.position,\n      };\n    }\n  } else if (\n    expr.type === \"PrefixExpression\" ||\n    expr.type === \"PostfixExpression\"\n  ) {\n    // unary expressions\n    const evaluatedExpr = evaluateCompileTimeExpression(expr.expr);\n    const dataType = evaluatedExpr.dataType;\n    let value = performUnaryOperation(evaluatedExpr.value, expr.operator);\n    if (isIntegerType(dataType)) {\n      // need to cap integer values correctly\n      value = getAdjustedIntValueAccordingToDataType(value as bigint, dataType);\n\n      return {\n        type: \"IntegerConstant\",\n        dataType: dataType as IntegerDataType,\n        value,\n        position: expr.position,\n      };\n    } else {\n      // the result of the binary expression is a floating point\n      return {\n        type: \"FloatConstant\",\n        dataType: dataType as FloatDataType,\n        value: value as number,\n        position: expr.position,\n      };\n    }\n  } else {\n    throw new ProcessingError(\n      \"cannot evaluate non compile-time constant type at compile-time\",\n    );\n  }\n}\n","/**\n * Definitions of various utility functions used for processing the C AST expressions.\n */\n\nimport { BinaryOperator, ScalarCDataType } from \"~src/common/types\";\n\nimport { primaryDataTypeSizes } from \"~src/common/utils\";\nimport {\n  DataType,\n  PrimaryDataType,\n  ScalarDataType,\n} from \"~src/parser/c-ast/dataTypes\";\nimport { ExpressionWrapperP } from \"~src/processor/c-ast/expression/expressions\";\nimport { ProcessingError } from \"~src/errors\";\nimport {\n  getDataTypeSize,\n  isArithmeticDataType,\n  isIntegralDataType,\n  isVoidPointer,\n  isScalarDataType,\n  getIntegerPromotedDataType,\n  isFloatDataType,\n  isPointer,\n} from \"~src/processor/dataTypeUtil\";\nimport {\n  PostfixExpression,\n  PrefixExpression,\n} from \"~src/parser/c-ast/expression/unaryExpression\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\nimport processExpression from \"~src/processor/processExpression\";\nimport { MemoryLoad, MemoryStore } from \"~src/processor/c-ast/memory\";\nimport { getDataTypeOfExpression } from \"~src/processor/util\";\nimport { checkPrePostfixTypeConstraint } from \"~src/processor/constraintChecks\";\nimport { PTRDIFF_T } from \"~src/common/constants\";\n\nfunction isRelationalOperator(op: BinaryOperator) {\n  return (\n    op === \"!=\" ||\n    op === \"<\" ||\n    op === \"<=\" ||\n    op === \"==\" ||\n    op === \">=\" ||\n    op === \">\"\n  );\n}\n\nfunction isLogicalOperator(op: BinaryOperator) {\n  return op === \"&&\" || op === \"||\";\n}\n\n/**\n * Extracts the ScalarCDataType of a dataType.\n * @throws ProcessingError if the argument is not actually scalar data type.\n */\nexport function convertDataTypeToScalarCDataType(\n  dataType: DataType,\n): ScalarCDataType {\n  if (\n    dataType.type !== \"pointer\" &&\n    dataType.type !== \"primary\" &&\n    dataType.type !== \"array\"\n  ) {\n    throw new ProcessingError(\"non scalar data type\");\n  }\n  return dataType.type === \"pointer\" || dataType.type === \"array\"\n    ? \"pointer\"\n    : dataType.primaryDataType;\n}\n\n/**\n * Determine the overall datatype of a ConditionalExpression (e.g. 1 ? 2 : 3).\n * Follows the rules in 6.5.15 of C17 standard.\n * Can assume valid combination of types, as constraints would have been checked already.\n */\nexport function determineConditionalExpressionDataType(\n  leftExprDataType: DataType,\n  rightExprDataType: DataType,\n): DataType {\n  if (\n    isArithmeticDataType(leftExprDataType) &&\n    isArithmeticDataType(rightExprDataType)\n  ) {\n    return performArithmeticConversions(\n      leftExprDataType as PrimaryDataType,\n      rightExprDataType as PrimaryDataType,\n    );\n  }\n  if (leftExprDataType.type === \"struct\" || leftExprDataType.type === \"void\") {\n    return leftExprDataType;\n  }\n  if (isVoidPointer(leftExprDataType) || isVoidPointer(rightExprDataType)) {\n    return {\n      type: \"pointer\",\n      pointeeType: {\n        isConst: leftExprDataType.isConst || rightExprDataType.isConst,\n        type: \"void\",\n      },\n    };\n  }\n  // at least one of the operands must be non void pointer (other might be the same pointer, of a null pointer constant)\n  if (isPointer(leftExprDataType)) {\n    return {\n      ...leftExprDataType,\n      isConst: leftExprDataType.isConst || rightExprDataType.isConst,\n    };\n  }\n  if (isPointer(rightExprDataType)) {\n    return {\n      ...rightExprDataType,\n      isConst: leftExprDataType.isConst || rightExprDataType.isConst,\n    };\n  }\n  // shouldnt happen\n  throw new Error(\n    \"determineConditionalExpressionDataType(): error in function\",\n  );\n}\n\n/**\n * Determines the type that operands in a binary expression should be converted to before the operation,\n * according to rules of arithemetic conversion 6.3.1.8 in C17 standard.\n * Follows integer promition rules for integral types. Promotion follows by size of the variable (larger size = higher rank)\n * The data type of all relational operator expressions is signed int, as per the standard.\n */\nexport function determineOperandTargetDataTypeOfBinaryExpression(\n  leftExprDataType: ScalarDataType,\n  rightExprDataType: ScalarDataType,\n  operator: BinaryOperator,\n): ScalarDataType {\n  // no need to check for validity of operand types, as this will have been checked before the function was called\n  // if either data type are pointers, then target data type is pointer (unsigned int)\n  // if both are pointer, it can only be a subtraction, in which case the resultant data type is PTRDIFF\n  if (\n    leftExprDataType.type === \"pointer\" &&\n    rightExprDataType.type === \"pointer\"\n  ) {\n    return {\n      type: \"primary\",\n      primaryDataType: PTRDIFF_T,\n    };\n  } else if (leftExprDataType.type === \"pointer\") {\n    return leftExprDataType;\n  } else if (rightExprDataType.type === \"pointer\") {\n    return rightExprDataType;\n  } else if (operator === \"<<\" || operator === \">>\") {\n    return leftExprDataType;\n  }\n  return performArithmeticConversions(leftExprDataType, rightExprDataType);\n}\n\nexport function performArithmeticConversions(\n  leftExprDataType: PrimaryDataType,\n  rightExprDataType: PrimaryDataType,\n): PrimaryDataType {\n  if (isFloatDataType(leftExprDataType) && isFloatDataType(rightExprDataType)) {\n    // take more higher ranking float type\n    if (\n      primaryDataTypeSizes[leftExprDataType.primaryDataType] >\n      primaryDataTypeSizes[rightExprDataType.primaryDataType]\n    ) {\n      return leftExprDataType;\n    } else {\n      return rightExprDataType;\n    }\n  } else if (isFloatDataType(leftExprDataType)) {\n    // float types have greater precedence than any integer types\n    return leftExprDataType;\n  } else if (isFloatDataType(rightExprDataType)) {\n    return rightExprDataType;\n  } else {\n    if (\n      primaryDataTypeSizes[leftExprDataType.primaryDataType] >\n      primaryDataTypeSizes[rightExprDataType.primaryDataType]\n    ) {\n      return leftExprDataType;\n    } else {\n      return rightExprDataType;\n    }\n  }\n}\n\n/**\n * Returns the correct variable type for both the result of a binary expression,\n * according to rules of arithemetic conversion 6.3.1.8 in C17 standard.\n * This should be the same as the operand target data type, except for relational operators.\n *\n */\nexport function determineResultDataTypeOfBinaryExpression(\n  leftExprDataType: ScalarDataType,\n  rightExprDataType: ScalarDataType,\n  operator: BinaryOperator,\n): ScalarDataType {\n  if (isRelationalOperator(operator) || isLogicalOperator(operator)) {\n    return {\n      type: \"primary\",\n      primaryDataType: \"signed int\",\n    };\n  }\n  return determineOperandTargetDataTypeOfBinaryExpression(\n    leftExprDataType,\n    rightExprDataType,\n    operator,\n  );\n}\n\n/**\n * Get the MemoryStore and MemoryLoad nodes needed for a increment/decrement of an lvalue of appropriate type.\n */\nexport function getArithmeticPrePostfixExpressionNodes(\n  expr: PrefixExpression | PostfixExpression,\n  symbolTable: SymbolTable,\n): { storeNodes: MemoryStore[]; loadNode: MemoryLoad; dataType: DataType } {\n  const binaryOperator = expr.operator === \"++\" ? \"+\" : \"-\";\n  const processedExpr = processExpression(expr.expr, symbolTable);\n  checkPrePostfixTypeConstraint(expr, processedExpr, symbolTable);\n  const dataType = getDataTypeOfExpression({\n    expression: processedExpr,\n  });\n\n  // do some checks on the operand\n  // simply use the load exprs from the processed expr to create the memory store staements\n  if (processedExpr.exprs[0].type !== \"MemoryLoad\") {\n    throw new ProcessingError(\n      `lvalue required for '${expr.operator}' expression`,\n    );\n  } else if (processedExpr.exprs.length > 1) {\n    throw new ProcessingError(\n      `'${expr.operator}' expression operand must be a scalar type`,\n    );\n  } else if (isVoidPointer(dataType)) {\n    throw new ProcessingError(`cannot perform arithmetic on void pointer`);\n  }\n\n  let amountToIncrementBy;\n  if (dataType.type === \"pointer\") {\n    amountToIncrementBy = BigInt(\n      getDataTypeSize(dataType.pointeeType as DataType),\n    );\n  } else if (dataType.type === \"array\") {\n    // need increment the underying expression (a pointer) by size of array\n    amountToIncrementBy = BigInt(getDataTypeSize(dataType));\n  } else {\n    amountToIncrementBy = 1n;\n  }\n\n  const memoryLoad = processedExpr.exprs[0] as MemoryLoad;\n  const memoryStoreNodes: MemoryStore[] = [\n    {\n      type: \"MemoryStore\",\n      address: memoryLoad.address,\n      value: {\n        type: \"BinaryExpression\",\n        leftExpr: memoryLoad,\n        rightExpr: {\n          type: \"IntegerConstant\",\n          value: amountToIncrementBy,\n          dataType: \"signed int\",\n          position: memoryLoad.position,\n        },\n        dataType: memoryLoad.dataType,\n        operandTargetDataType: memoryLoad.dataType,\n        operator: binaryOperator,\n        position: memoryLoad.position,\n      },\n      dataType: memoryLoad.dataType,\n      position: memoryLoad.position,\n    },\n  ];\n\n  return {\n    loadNode: memoryLoad,\n    storeNodes: memoryStoreNodes,\n    dataType,\n  };\n}\n\nexport function processPrefixExpression(\n  prefixExpression: PrefixExpression,\n  symbolTable: SymbolTable,\n): ExpressionWrapperP {\n  if (\n    prefixExpression.operator === \"++\" ||\n    prefixExpression.operator === \"--\"\n  ) {\n    const { loadNode, storeNodes, dataType } =\n      getArithmeticPrePostfixExpressionNodes(prefixExpression, symbolTable);\n    return {\n      originalDataType: dataType,\n      exprs: [\n        {\n          type: \"PreStatementExpression\",\n          statements: storeNodes,\n          expr: loadNode,\n          dataType: loadNode.dataType,\n          position: loadNode.position,\n        },\n      ],\n    };\n  } else {\n    const processedExpression = processExpression(\n      prefixExpression.expr,\n      symbolTable,\n    );\n    const dataType = getDataTypeOfExpression({\n      expression: processedExpression,\n    });\n    // check constraints for each opeartor as per 6.5.3.3/1 of C standard\n    if (\n      (prefixExpression.operator === \"+\" ||\n        prefixExpression.operator === \"-\") &&\n      !isArithmeticDataType(dataType)\n    ) {\n      throw new ProcessingError(\n        `wrong type argument to unary '${prefixExpression.operator}' expression; arithmetic type required`,\n      );\n    } else if (\n      prefixExpression.operator === \"~\" &&\n      !isIntegralDataType(dataType)\n    ) {\n      throw new ProcessingError(\n        `wrong type argument in unary '${prefixExpression.operator}' expression; integer type required`,\n      );\n    } else if (\n      prefixExpression.operator === \"!\" &&\n      !isScalarDataType(dataType)\n    ) {\n      throw new ProcessingError(\n        `wrong type argument in unary '${prefixExpression.operator}' expression; scalar type required`,\n      );\n    }\n\n    if (prefixExpression.operator === \"+\") {\n      // \"+\" does nothing except integer promotion\n      processedExpression.originalDataType = getIntegerPromotedDataType(\n        processedExpression.originalDataType,\n      );\n      return processedExpression;\n    } else {\n      let resultDataType: DataType;\n      switch (prefixExpression.operator) {\n        case \"-\":\n        case \"~\":\n          resultDataType = getIntegerPromotedDataType(\n            processedExpression.originalDataType,\n          );\n          break;\n        case \"!\":\n          resultDataType = {\n            type: \"primary\",\n            primaryDataType: \"signed int\",\n          };\n      }\n      return {\n        originalDataType: resultDataType,\n        exprs: [\n          {\n            type: \"UnaryExpression\",\n            operator: prefixExpression.operator,\n            expr: processedExpression.exprs[0],\n            dataType: processedExpression.exprs[0].dataType,\n            position: processedExpression.exprs[0].position,\n          },\n        ],\n      };\n    }\n  }\n}\n\nexport function processPostfixExpression(\n  postfixExpression: PostfixExpression,\n  symbolTable: SymbolTable,\n): ExpressionWrapperP {\n  const { loadNode, storeNodes, dataType } =\n    getArithmeticPrePostfixExpressionNodes(postfixExpression, symbolTable);\n  return {\n    originalDataType: dataType,\n    exprs: [\n      {\n        type: \"PostStatementExpression\",\n        statements: storeNodes,\n        expr: loadNode,\n        dataType: loadNode.dataType,\n        position: loadNode.position,\n      },\n    ],\n  };\n}\n","/**\n * Definition of function to process Expression expr s.\n */\n\nimport { ProcessingError, toJson } from \"~src/errors\";\nimport { Expression } from \"~src/parser/c-ast/core\";\nimport {\n  ExpressionWrapperP,\n  PreStatementExpressionP,\n} from \"~src/processor/c-ast/expression/expressions\";\nimport { MemoryLoad } from \"~src/processor/c-ast/memory\";\nimport {\n  determineConditionalExpressionDataType,\n  determineOperandTargetDataTypeOfBinaryExpression,\n  determineResultDataTypeOfBinaryExpression,\n  processPostfixExpression,\n  processPrefixExpression,\n} from \"~src/processor/expressionUtil\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\nimport {\n  createFunctionTableIndexExpressionWrapper,\n  createMemoryOffsetIntegerConstant,\n  getDataTypeOfExpression,\n  isFunctionPointer,\n} from \"~src/processor/util\";\nimport { convertFunctionCallToFunctionCallP } from \"~src/processor/processFunctionDefinition\";\nimport { getAssignmentNodes, isLValue } from \"~src/processor/lvalueUtil\";\nimport {\n  determineIndexAndDataTypeOfFieldInStruct,\n  getDataTypeSize,\n  isVoidPointer,\n  unpackDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport { IntegerDataType } from \"~src/common/types\";\nimport processConstant from \"~src/processor/processConstant\";\nimport { PTRDIFF_T, SIZE_T } from \"~src/common/constants\";\nimport {\n  DataType,\n  PointerDataType,\n  ScalarDataType,\n} from \"~src/parser/c-ast/dataTypes\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport processBlockItem from \"~src/processor/processBlockItem\";\nimport { FunctionDefinitionP } from \"~src/processor/c-ast/function\";\nimport { StatementP } from \"~src/processor/c-ast/core\";\nimport { addWarning } from \"~src/processor/warningUtil\";\nimport {\n  checkBinaryExpressionConstraints,\n  checkConditionalExpressionOperands,\n} from \"~src/processor/constraintChecks\";\n\n/**\n * Processes an Expression node in the context where value(s) are expected to be loaded from memory for use in a statement (action).\n */\nexport default function processExpression(\n  expr: Expression,\n  symbolTable: SymbolTable,\n  enclosingFunc?: FunctionDefinitionP,\n): ExpressionWrapperP {\n  try {\n    if (expr.type === \"Assignment\") {\n      const { memoryStoreStatements, memoryLoadExpressions, dataType } =\n        getAssignmentNodes(expr, symbolTable);\n\n      return {\n        originalDataType: dataType,\n        exprs: [\n          // first expr has all the assignment nodes TODO: see if any better way\n          {\n            type: \"PreStatementExpression\",\n            statements: memoryStoreStatements,\n            expr: memoryLoadExpressions[0],\n            dataType: memoryLoadExpressions[0].dataType,\n            position: memoryLoadExpressions[0].position,\n          },\n          ...memoryLoadExpressions.slice(1),\n        ],\n      };\n    } else if (expr.type === \"BinaryExpression\") {\n      const processedLeftExpr = processExpression(expr.leftExpr, symbolTable);\n      const processedLeftExprDataType = getDataTypeOfExpression({\n        expression: processedLeftExpr,\n        convertArrayToPointer: true,\n        convertFunctionToPointer: true,\n      });\n      const processedRightExpr = processExpression(expr.rightExpr, symbolTable);\n      const processedRightExprDataType = getDataTypeOfExpression({\n        expression: processedRightExpr,\n        convertArrayToPointer: true,\n        convertFunctionToPointer: true,\n      });\n\n      checkBinaryExpressionConstraints(\n        expr,\n        processedLeftExpr,\n        processedRightExpr,\n      );\n\n      // at this point all the operands can only be scalar data types\n\n      const binaryExpressionDataType =\n        determineResultDataTypeOfBinaryExpression(\n          processedLeftExprDataType as ScalarDataType,\n          processedRightExprDataType as ScalarDataType,\n          expr.operator,\n        );\n\n      const operandTargetDataType =\n        determineOperandTargetDataTypeOfBinaryExpression(\n          processedLeftExprDataType as ScalarDataType,\n          processedRightExprDataType as ScalarDataType,\n          expr.operator,\n        );\n\n      let leftExpr = processedLeftExpr.exprs[0];\n      let rightExpr = processedRightExpr.exprs[0];\n\n      // account for pointer type arithmetic - already checked that it must be '+' or '-' in determineDataTypeOfBinaryExpression\n      if (\n        processedLeftExprDataType.type === \"pointer\" &&\n        processedRightExprDataType.type === \"primary\"\n      ) {\n        rightExpr = {\n          type: \"BinaryExpression\",\n          operator: \"*\",\n          leftExpr: rightExpr,\n          rightExpr: {\n            type: \"IntegerConstant\",\n            value: BigInt(\n              getDataTypeSize(\n                processedLeftExprDataType.pointeeType as DataType,\n              ),\n            ), // void pointer already checked for\n            dataType: rightExpr.dataType as IntegerDataType, // datatype is confirmed by determineDataTypeOfBinaryExpression\n            position: rightExpr.position,\n          },\n          position: rightExpr.position,\n          dataType: rightExpr.dataType,\n          operandTargetDataType: rightExpr.dataType,\n        };\n      } else if (\n        processedRightExprDataType.type === \"pointer\" &&\n        processedLeftExprDataType.type === \"primary\"\n      ) {\n        leftExpr = {\n          type: \"BinaryExpression\",\n          operator: \"*\",\n          leftExpr: leftExpr,\n          rightExpr: {\n            type: \"IntegerConstant\",\n            value: BigInt(\n              getDataTypeSize(\n                processedRightExprDataType.pointeeType as DataType,\n              ),\n            ),\n            dataType: leftExpr.dataType as IntegerDataType, // datatype is confirmed by determineDataTypeOfBinaryExpression\n            position: rightExpr.position,\n          },\n          position: leftExpr.position,\n          dataType: leftExpr.dataType,\n          operandTargetDataType: leftExpr.dataType,\n        };\n      }\n\n      if (\n        processedRightExprDataType.type === \"pointer\" &&\n        processedLeftExprDataType.type === \"pointer\" &&\n        expr.operator === \"-\"\n      ) {\n        // special handling for subtraction between pointers, need to divide result by underlying type size\n        return {\n          originalDataType: binaryExpressionDataType,\n          exprs: [\n            {\n              type: \"BinaryExpression\",\n              leftExpr: {\n                type: \"BinaryExpression\",\n                leftExpr,\n                rightExpr,\n                operator: expr.operator,\n                dataType:\n                  binaryExpressionDataType.type === \"pointer\"\n                    ? \"pointer\"\n                    : binaryExpressionDataType.primaryDataType,\n                operandTargetDataType: \"pointer\",\n                position: leftExpr.position,\n              },\n              operator: \"/\",\n              rightExpr: {\n                type: \"IntegerConstant\",\n                value: BigInt(\n                  getDataTypeSize(\n                    processedRightExprDataType.pointeeType as DataType,\n                  ),\n                ),\n                dataType: PTRDIFF_T,\n                position: rightExpr.position,\n              },\n              dataType: PTRDIFF_T,\n              operandTargetDataType: PTRDIFF_T,\n              position: expr.position,\n            },\n          ],\n        };\n      }\n\n      return {\n        originalDataType: binaryExpressionDataType,\n        exprs: [\n          {\n            type: \"BinaryExpression\",\n            leftExpr,\n            rightExpr,\n            operator: expr.operator,\n            dataType:\n              binaryExpressionDataType.type === \"pointer\"\n                ? \"pointer\"\n                : binaryExpressionDataType.primaryDataType,\n            operandTargetDataType:\n              operandTargetDataType.type === \"pointer\"\n                ? \"pointer\"\n                : operandTargetDataType.primaryDataType,\n            position: expr.position,\n          },\n        ],\n      };\n    } else if (\n      expr.type === \"IntegerConstant\" ||\n      expr.type === \"FloatConstant\"\n    ) {\n      const processedConstant = processConstant(expr);\n      return {\n        originalDataType: {\n          type: \"primary\",\n          primaryDataType: processedConstant.dataType,\n        },\n        exprs: [processedConstant],\n      };\n    } else if (expr.type === \"FunctionCall\") {\n      const {\n        functionCallP: functionCallStatement,\n        returnType: funcReturnType,\n      } = convertFunctionCallToFunctionCallP(expr, symbolTable);\n\n      if (funcReturnType.type === \"void\") {\n        // trying to use a function call as an expression in context that expects a return object\n        throw new ProcessingError(\"void value not ignored as it should be\");\n      }\n\n      // start curr offset at negative of the size of the return obj\n      let currOffset = -getDataTypeSize(funcReturnType);\n      const returnObjectMemoryLoads: MemoryLoad[] = [];\n\n      unpackDataType(funcReturnType).forEach((returnObj) => {\n        returnObjectMemoryLoads.push({\n          type: \"MemoryLoad\",\n          address: {\n            type: \"ReturnObjectAddress\",\n            subtype: \"load\",\n            offset: createMemoryOffsetIntegerConstant(currOffset),\n            dataType: \"pointer\",\n            position: expr.position,\n          },\n          dataType: returnObj.dataType,\n          position: expr.position,\n        });\n        currOffset += getSizeOfScalarDataType(returnObj.dataType);\n      });\n\n      // regardless of return type, all function call expression have a preStatementExpression\n      return {\n        originalDataType: funcReturnType,\n        exprs: [\n          {\n            type: \"PreStatementExpression\",\n            // run function call before loading return values\n            statements: [functionCallStatement],\n            dataType: returnObjectMemoryLoads[0].dataType,\n            expr: returnObjectMemoryLoads[0],\n            position: expr.position,\n          },\n          ...returnObjectMemoryLoads.slice(1),\n        ],\n      };\n    } else if (expr.type === \"PrefixExpression\") {\n      return processPrefixExpression(expr, symbolTable);\n    } else if (expr.type === \"PostfixExpression\") {\n      return processPostfixExpression(expr, symbolTable);\n    } else if (expr.type === \"IdentifierExpression\") {\n      const symbolEntry = symbolTable.getSymbolEntry(expr.name);\n      if (!symbolEntry) {\n        throw new ProcessingError(`'${expr.name}' undeclared`);\n      }\n\n      // a function becomes a pointer to a function\n      if (symbolEntry.type === \"function\") {\n        return createFunctionTableIndexExpressionWrapper(\n          expr.name,\n          symbolEntry.dataType,\n          symbolTable,\n        );\n      }\n\n      if (symbolEntry.type === \"enumerator\") {\n        // enumerator values are just compile-time constants\n        return {\n          originalDataType: symbolEntry.dataType,\n          exprs: [\n            {\n              type: \"IntegerConstant\",\n              value: symbolEntry.value,\n              dataType: symbolEntry.dataType.primaryDataType,\n              position: expr.position,\n            },\n          ],\n        };\n      }\n\n      if (symbolEntry.dataType.type === \"array\") {\n        // arrays are treated as pointer\n        return {\n          originalDataType: symbolEntry.dataType,\n          exprs: [\n            {\n              type:\n                symbolEntry.type === \"dataSegmentVariable\"\n                  ? \"DataSegmentAddress\"\n                  : \"LocalAddress\",\n              offset: createMemoryOffsetIntegerConstant(symbolEntry.offset),\n              dataType: \"pointer\",\n              position: expr.position,\n            },\n          ],\n        };\n      } else {\n        const unpackedDataType = unpackDataType(symbolEntry.dataType);\n        return {\n          originalDataType: symbolEntry.dataType,\n          exprs: unpackedDataType.map((primaryDataObject) => ({\n            type: \"MemoryLoad\",\n            address: {\n              type:\n                symbolEntry.type === \"dataSegmentVariable\"\n                  ? \"DataSegmentAddress\"\n                  : \"LocalAddress\",\n              offset: createMemoryOffsetIntegerConstant(\n                symbolEntry.offset + primaryDataObject.offset,\n              ),\n              dataType: \"pointer\",\n              position: expr.position,\n            },\n            dataType: primaryDataObject.dataType,\n            position: expr.position,\n          })),\n        };\n      }\n    } else if (expr.type === \"AddressOfExpression\") {\n      if (expr.expr.type === \"IdentifierExpression\") {\n        // taking the address of a symbol - could be a variable or function\n        const identifier = expr.expr.name;\n        const symbolEntry = symbolTable.getSymbolEntry(identifier);\n        if (symbolEntry.type === \"function\") {\n          return createFunctionTableIndexExpressionWrapper(\n            expr.expr.name,\n            symbolEntry.dataType,\n            symbolTable,\n          );\n        }\n\n        if (\n          symbolEntry.type === \"enumerator\" ||\n          !isLValue(expr.expr, symbolEntry.dataType, symbolTable, true)\n        ) {\n          throw new ProcessingError(\"lvalue required as unary '&' operand\");\n        }\n\n        // If function pointer, dont increase the pointer nesting, just return processed identifier expression\n        if (isFunctionPointer(symbolEntry.dataType)) {\n          return processExpression(expr.expr, symbolTable, enclosingFunc);\n        }\n\n        return {\n          originalDataType: {\n            type: \"pointer\",\n            pointeeType: symbolEntry.dataType,\n          },\n          exprs: [\n            {\n              type:\n                symbolEntry.type === \"dataSegmentVariable\"\n                  ? \"DataSegmentAddress\"\n                  : \"LocalAddress\",\n              offset: createMemoryOffsetIntegerConstant(symbolEntry.offset),\n              dataType: \"pointer\",\n              position: expr.position,\n            },\n          ],\n        };\n      } else if (expr.expr.type === \"PointerDereference\") {\n        return processExpression(expr.expr.expr, symbolTable); // simply return the expression within the deref expression (& cancels *)\n      } else {\n        throw new ProcessingError(\"lvalue required for unary '&' operand\");\n      }\n    } else if (expr.type === \"PointerDereference\") {\n      // process the expression being dereferenced first\n      const derefedExpression = processExpression(expr.expr, symbolTable);\n      const derefedExpressionDataType = getDataTypeOfExpression({\n        expression: derefedExpression,\n        convertArrayToPointer: true,\n        convertFunctionToPointer: true,\n      });\n      if (derefedExpressionDataType.type !== \"pointer\") {\n        throw new ProcessingError(`cannot dereference non-pointer type`);\n      }\n\n      if (isVoidPointer(derefedExpressionDataType)) {\n        addWarning(\"dereferencing void pointer\", expr.position);\n        return {\n          originalDataType: derefedExpressionDataType.pointeeType,\n          exprs: [],\n        };\n      }\n\n      // if the derefed expression a function pointer, it remains one\n      if (isFunctionPointer(derefedExpressionDataType)) {\n        return derefedExpression;\n      }\n\n      if (\n        derefedExpressionDataType.pointeeType.type === \"primary\" ||\n        derefedExpressionDataType.pointeeType.type === \"pointer\"\n      ) {\n        return {\n          originalDataType: derefedExpressionDataType.pointeeType,\n          exprs: [\n            {\n              type: \"MemoryLoad\",\n              address: {\n                type: \"DynamicAddress\",\n                address: derefedExpression.exprs[0],\n                dataType: \"pointer\",\n                position: derefedExpression.exprs[0].position,\n              },\n              dataType:\n                derefedExpressionDataType.pointeeType.type === \"pointer\"\n                  ? \"pointer\"\n                  : derefedExpressionDataType.pointeeType.primaryDataType,\n              position: expr.position,\n            },\n          ],\n        };\n      } else if (derefedExpressionDataType.pointeeType.type === \"array\") {\n        // the resultant data type of the whole dereference expression should be pointer to the array element type, as arrays are treated as pointers\n        return {\n          originalDataType: derefedExpressionDataType.pointeeType,\n          exprs: [\n            {\n              type: \"DynamicAddress\",\n              address: derefedExpression.exprs[0],\n              dataType: \"pointer\",\n              position: derefedExpression.exprs[0].position,\n            },\n          ],\n        };\n      } else {\n        const unpackedStruct = unpackDataType(\n          derefedExpressionDataType.pointeeType,\n        );\n        return {\n          originalDataType: derefedExpressionDataType.pointeeType,\n          exprs: unpackedStruct.map((primaryDataObject) => ({\n            type: \"MemoryLoad\",\n            address: {\n              type: \"DynamicAddress\",\n              address: {\n                type: \"BinaryExpression\",\n                leftExpr: derefedExpression.exprs[0], // value of dereferenced expression (starting address of the pointed to struct)\n                rightExpr: createMemoryOffsetIntegerConstant(\n                  primaryDataObject.offset,\n                ), // offset of particular primary data object in struct\n                operator: \"+\",\n                operandTargetDataType: \"pointer\",\n                dataType: \"pointer\",\n                position: expr.position,\n              },\n              dataType: \"pointer\",\n              position: expr.position,\n            },\n            dataType: primaryDataObject.dataType,\n            position: expr.position,\n          })),\n        };\n      }\n    } else if (expr.type === \"SizeOfExpression\") {\n      let dataTypeToGetSizeOf;\n\n      if (expr.subtype === \"expression\") {\n        // sizeof used on expression\n        dataTypeToGetSizeOf = getDataTypeOfExpression({\n          expression: processExpression(expr.expr, symbolTable),\n        });\n      } else {\n        // sizeof used on datatype\n        dataTypeToGetSizeOf = expr.dataType;\n      }\n\n      // check constraints are met as per 6.5.3.4/1 of C17 standard\n      // incomplete pointer check already done at parser\n\n      if (dataTypeToGetSizeOf.type === \"function\") {\n        throw new ProcessingError(\n          \"invalid application of 'sizeof' to function type\",\n        );\n      }\n\n      return {\n        originalDataType: {\n          type: \"primary\",\n          primaryDataType: SIZE_T,\n        },\n        exprs: [\n          {\n            type: \"IntegerConstant\",\n            value: BigInt(getDataTypeSize(dataTypeToGetSizeOf)),\n            dataType: SIZE_T,\n            position: expr.position,\n          },\n        ],\n      };\n    } else if (expr.type === \"StructMemberAccess\") {\n      const processedExpr = processExpression(expr.expr, symbolTable); // process the underlying expression being operated on\n      const dataTypeOfExpr = getDataTypeOfExpression({\n        expression: processedExpr,\n        convertArrayToPointer: true,\n        convertFunctionToPointer: true,\n      });\n      if (dataTypeOfExpr.type !== \"struct\") {\n        throw new ProcessingError(\n          `request for member '${expr.fieldTag}' in something that is not a structure`,\n        );\n      }\n      const { fieldIndex, fieldDataType } =\n        determineIndexAndDataTypeOfFieldInStruct(dataTypeOfExpr, expr.fieldTag);\n      if (fieldDataType.type === \"array\") {\n        // treat array field as just a pointer\n        const dataTypeOfPointer: PointerDataType = {\n          type: \"pointer\",\n          pointeeType: fieldDataType.elementDataType,\n        };\n\n        if (processedExpr.exprs[0].type === \"PreStatementExpression\") {\n          // handle special case of accessing struct field of a returned struct from function call\n          // the prestaetments need to be incorporated, even if the first primary expression (exprs[0]) is not\n          let memoryLoadExpr: MemoryLoad; // the memoryload that the pointer value is being derived from\n          if (fieldIndex === 0) {\n            const memLoad = processedExpr.exprs[0].expr;\n            if (memLoad.type !== \"MemoryLoad\") {\n              throw new ProcessingError(\n                `request for member '${expr.fieldTag}' in something that is not a structure or union`,\n              );\n            }\n            memoryLoadExpr = memLoad;\n          } else {\n            const memLoad = processedExpr.exprs[fieldIndex];\n            if (memLoad.type !== \"MemoryLoad\") {\n              throw new ProcessingError(\n                `request for member '${expr.fieldTag}' in something that is not a structure or union`,\n              );\n            }\n            memoryLoadExpr = memLoad;\n          }\n          return {\n            originalDataType: dataTypeOfPointer,\n            exprs: [\n              {\n                type: \"PreStatementExpression\",\n                statements: processedExpr.exprs[0].statements,\n                expr: {\n                  type: \"DynamicAddress\",\n                  address: memoryLoadExpr.address,\n                  dataType: \"pointer\",\n                  position: memoryLoadExpr.position,\n                },\n                dataType: \"pointer\",\n                position: memoryLoadExpr.position,\n              },\n            ],\n          };\n        }\n\n        return {\n          originalDataType: {\n            type: \"pointer\",\n            pointeeType: fieldDataType.elementDataType,\n          },\n          exprs: [\n            {\n              type: \"DynamicAddress\",\n              address: (processedExpr.exprs[fieldIndex] as MemoryLoad).address,\n              dataType: \"pointer\",\n              position: (processedExpr.exprs[fieldIndex] as MemoryLoad)\n                .position,\n            },\n          ],\n        };\n      } else {\n        // procssedExpr already consists of accessing the whole struct (all primary memory object loads)\n        // just use field index to access the right ones\n        const memoryLoadExprs: (MemoryLoad | PreStatementExpressionP)[] = [];\n        let totalBytesLoaded = 0;\n        let currLoadIndex = fieldIndex;\n\n        if (processedExpr.exprs[0].type === \"PreStatementExpression\") {\n          // special case - if the first expression is a prestatement, then it is probably a function call, need to make sure that the statements from the prestatement are included\n          const loadExpr = processedExpr.exprs[currLoadIndex++];\n          if (loadExpr.type === \"PreStatementExpression\") {\n            // fieldIndex could be 0, so loadExpr and exprs[0] could be the same prestatementexpression\n            memoryLoadExprs.push(loadExpr);\n            totalBytesLoaded += getSizeOfScalarDataType(loadExpr.expr.dataType);\n          } else if (loadExpr.type === \"MemoryLoad\") {\n            memoryLoadExprs.push({\n              type: \"PreStatementExpression\",\n              statements: processedExpr.exprs[0].statements,\n              expr: loadExpr,\n              dataType: loadExpr.dataType,\n              position: loadExpr.position,\n            });\n            totalBytesLoaded += getSizeOfScalarDataType(loadExpr.dataType);\n          } else {\n            throw new ProcessingError(\n              `request for member '${expr.fieldTag}' in something that is not a structure or union`,\n            );\n          }\n        }\n\n        while (totalBytesLoaded < getDataTypeSize(fieldDataType)) {\n          if (processedExpr.exprs[currLoadIndex].type !== \"MemoryLoad\") {\n            // only \"MemoryLoads\" can possibly indicate an lvalue\n            throw new ProcessingError(\n              `request for member '${expr.fieldTag}' in something that is not a structure or union`,\n            );\n          }\n          totalBytesLoaded += getSizeOfScalarDataType(\n            (processedExpr.exprs[currLoadIndex] as MemoryLoad).dataType,\n          );\n          memoryLoadExprs.push(\n            processedExpr.exprs[currLoadIndex++] as MemoryLoad,\n          );\n        }\n        return {\n          originalDataType:\n            fieldDataType.type === \"struct self pointer\"\n              ? { type: \"pointer\", pointeeType: dataTypeOfExpr } // datatype is a pointer to the struct itself\n              : fieldDataType,\n          exprs: memoryLoadExprs,\n        };\n      }\n    } else if (expr.type === \"CommaSeparatedExpressions\") {\n      // only last expression becomes a true Expression (one where a value is expected)\n      // process the first expressions as statements\n      const processedLastExpr = processExpression(\n        expr.expressions[expr.expressions.length - 1],\n        symbolTable,\n      );\n      const precedingExpressionsAsStatements: StatementP[] = [];\n      for (let i = 0; i < expr.expressions.length - 1; ++i) {\n        precedingExpressionsAsStatements.push(\n          ...processBlockItem(\n            expr.expressions[i],\n            symbolTable,\n            enclosingFunc as FunctionDefinitionP,\n          ),\n        );\n      }\n      return {\n        originalDataType: processedLastExpr.originalDataType,\n        exprs: [\n          {\n            type: \"PreStatementExpression\",\n            statements: precedingExpressionsAsStatements,\n            expr: processedLastExpr.exprs[0],\n            dataType: processedLastExpr.exprs[0].dataType,\n            position: processedLastExpr.exprs[0].position,\n          },\n          ...processedLastExpr.exprs.slice(1),\n        ],\n      };\n    } else if (expr.type === \"ConditionalExpression\") {\n      const processedCondition = processExpression(\n        expr.condition,\n        symbolTable,\n        enclosingFunc,\n      );\n      const processedTrueExpression = processExpression(\n        expr.trueExpression,\n        symbolTable,\n      );\n      const dataTypeOfTrueExpression = getDataTypeOfExpression({\n        expression: processedTrueExpression,\n        convertArrayToPointer: true,\n        convertFunctionToPointer: true,\n      });\n      const processedFalseExpression = processExpression(\n        expr.falseExpression,\n        symbolTable,\n      );\n      const dataTypeOfFalseExpression = getDataTypeOfExpression({\n        expression: processedFalseExpression,\n        convertArrayToPointer: true,\n        convertFunctionToPointer: true,\n      });\n\n      checkConditionalExpressionOperands(\n        processedCondition,\n        processedTrueExpression,\n        processedFalseExpression,\n      );\n\n      const resultDataType = determineConditionalExpressionDataType(\n        dataTypeOfTrueExpression,\n        dataTypeOfFalseExpression,\n      );\n\n      return {\n        originalDataType: resultDataType,\n        exprs: processedTrueExpression.exprs.map((truePrimaryExpr, index) => ({\n          type: \"ConditionalExpression\",\n          condition: processedCondition.exprs[0],\n          trueExpression: truePrimaryExpr,\n          falseExpression: processedFalseExpression.exprs[index],\n          dataType:\n            resultDataType.type === \"primary\"\n              ? resultDataType.primaryDataType\n              : resultDataType.type === \"pointer\"\n              ? \"pointer\"\n              : truePrimaryExpr.dataType,\n          position: truePrimaryExpr.position,\n        })),\n      };\n    } else if (expr.type === \"StringLiteral\") {\n      // allocate the string in datasegment\n      const dataSegmentOffset = symbolTable.addDataSegmentObject(expr.chars);\n      return {\n        originalDataType: {\n          type: \"pointer\",\n          pointeeType: {\n            type: \"primary\",\n            primaryDataType: \"signed char\",\n          },\n        },\n        exprs: [\n          {\n            type: \"DataSegmentAddress\",\n            offset: createMemoryOffsetIntegerConstant(dataSegmentOffset),\n            dataType: \"pointer\",\n            position: expr.position,\n          },\n        ],\n      };\n    } else {\n      // this should not happen\n      throw new ProcessingError(`unhandled Expression: ${toJson(expr)}`);\n    }\n  } catch (e) {\n    if (e instanceof ProcessingError && e.position === null) {\n      e.addPositionInfo(expr.position);\n    }\n    throw e;\n  }\n}\n","/**\n * Definitions of various utility functions.\n */\n\nimport { SymbolTable } from \"~src/processor/symbolTable\";\nimport { ProcessingError } from \"~src/errors\";\nimport { Expression } from \"~src/parser/c-ast/core\";\nimport processExpression from \"~src/processor/processExpression\";\nimport { IntegerConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport {\n  getDecayedArrayPointerType,\n  getFunctionPointerOfFunction,\n  isScalarDataType,\n  stringifyDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport {\n  DataType,\n  FunctionDataType,\n  PointerDataType,\n} from \"~src/parser/c-ast/dataTypes\";\nimport { ExpressionWrapperP } from \"~src/processor/c-ast/expression/expressions\";\nimport { PTRDIFF_T } from \"~src/common/constants\";\n\nexport function processCondition(\n  condition: Expression,\n  symbolTable: SymbolTable,\n) {\n  const processedCondition = processExpression(condition, symbolTable);\n  const dataTypeOfConditionExpression = getDataTypeOfExpression({\n    expression: processedCondition,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n  if (!isScalarDataType(dataTypeOfConditionExpression)) {\n    throw new ProcessingError(\n      `used '${stringifyDataType(\n        dataTypeOfConditionExpression,\n      )}' where scalar is required`,\n    );\n  }\n  return processedCondition.exprs[0];\n}\n\nexport function createMemoryOffsetIntegerConstant(\n  offset: number,\n): IntegerConstantP {\n  return {\n    type: \"IntegerConstant\",\n    dataType: PTRDIFF_T,\n    value: BigInt(offset),\n    position: {\n      start: {\n        line: 0,\n        column: 0,\n        offset: 0,\n      },\n      end: {\n        line: 0,\n        column: 0,\n        offset: 0,\n      },\n    },\n  };\n}\n\n/**\n * Retrieves the DataType of the processed expression. This should be same as the originalDataType field of ExpressionWrapperP, except in the case\n * when @param convertArrayToPointer is set to true, in which case any originalDataType that is array should be converted to pointer.\n */\nexport function getDataTypeOfExpression({\n  expression,\n  convertArrayToPointer,\n  convertFunctionToPointer,\n}: {\n  expression: ExpressionWrapperP;\n  convertArrayToPointer?: boolean;\n  convertFunctionToPointer?: boolean;\n}): DataType {\n  if (convertArrayToPointer && expression.originalDataType.type === \"array\") {\n    return getDecayedArrayPointerType(expression.originalDataType);\n  }\n  if (\n    convertFunctionToPointer &&\n    expression.originalDataType.type === \"function\"\n  ) {\n    return getFunctionPointerOfFunction(expression.originalDataType);\n  }\n  return expression.originalDataType;\n}\n\nexport function createFunctionTableIndexExpressionWrapper(\n  functionName: string,\n  functionDataType: FunctionDataType,\n  symbolTable: SymbolTable,\n): ExpressionWrapperP {\n  const indexInFunctionTable = symbolTable.getFunctionIndex(functionName);\n  return {\n    originalDataType: functionDataType, // leave as function data type. Dependding on where this expression is used, it will be interpreted as pointer of function as per 6.3.2.1/4 of C17 standard\n    exprs: [\n      {\n        type: \"FunctionTableIndex\",\n        index: createMemoryOffsetIntegerConstant(indexInFunctionTable),\n        dataType: \"pointer\",\n        position: {\n          start: {\n            line: 0,\n            column: 0,\n            offset: 0,\n          },\n          end: {\n            line: 0,\n            column: 0,\n            offset: 0,\n          },\n        },\n      },\n    ],\n  };\n}\n\nexport function isFunctionPointer(dataType: DataType) {\n  return (\n    dataType.type === \"pointer\" && dataType.pointeeType.type === \"function\"\n  );\n}\n\n/**\n * Extracts the FunctionDataType from a dataType which is a pointer to a function\n */\nexport function extractFunctionDataTypeFromFunctionPointer(\n  dataType: DataType,\n): FunctionDataType {\n  if (!isFunctionPointer(dataType)) {\n    throw new ProcessingError(\n      \"called object is not a function or function pointer\",\n    );\n  }\n\n  return (dataType as PointerDataType).pointeeType as FunctionDataType;\n}\n","/**\n * Utility functions relating to the handling of variable related nodes.\n */\n\nimport { ProcessingError } from \"~src/errors\";\nimport { Assignment } from \"~src/parser/c-ast/expression/assignment\";\nimport { MemoryLoad, MemoryStore } from \"~src/processor/c-ast/memory\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\n\nimport processExpression from \"~src/processor/processExpression\";\nimport { DataType, StructDataType } from \"~src/parser/c-ast/dataTypes\";\nimport { Expression } from \"~src/parser/c-ast/core\";\nimport {\n  checkAssignability,\n  isScalarDataType,\n  stringifyDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport { getDataTypeOfExpression } from \"~src/processor/util\";\n\nfunction isAllowableLValueType(dataType: DataType, specialCase = false) {\n  return (\n    isScalarDataType(dataType) ||\n    dataType.type === \"struct\" ||\n    (specialCase && (dataType.type === \"array\" || dataType.type === \"function\"))\n  );\n}\n\n/**\n * Determines if a given expression is an lvalue.\n * @param expression the original expression\n * @param dataType datatype of the expression\n */\nexport function isLValue(\n  expression: Expression,\n  dataType: DataType,\n  symbolTable: SymbolTable,\n  specialCase = false, // specialCase refers to certain expressions where types that normally are not lvalues (array/function) are treated as lvalue (sizeof, &)\n) {\n  if (expression.type === \"IdentifierExpression\") {\n    const symbolEntry = symbolTable.getSymbolEntry(expression.name);\n    if (\n      symbolEntry.type !== \"dataSegmentVariable\" &&\n      symbolEntry.type !== \"localVariable\"\n    ) {\n      // enumerator / function symbol entries cannot be lvalue\n      return false;\n    }\n  }\n\n  return (\n    (expression.type === \"IdentifierExpression\" ||\n      expression.type === \"PointerDereference\" ||\n      expression.type === \"StructMemberAccess\") &&\n    isAllowableLValueType(dataType, specialCase)\n  );\n}\n\nexport function isModifiableLValue(\n  expression: Expression,\n  dataType: DataType,\n  symbolTable: SymbolTable,\n  specialCase = false,\n) {\n  return (\n    !dataType.isConst &&\n    isLValue(expression, dataType, symbolTable, specialCase) &&\n    (dataType.type !== \"struct\" || isStructModifiableDataType(dataType))\n  );\n}\n\nexport function isStructModifiableDataType(dataType: StructDataType) {\n  if (dataType.isConst) {\n    return false;\n  }\n  for (const field of dataType.fields) {\n    if (\n      field.isConst ||\n      (field.dataType.type === \"struct\" &&\n        !isStructModifiableDataType(field.dataType))\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Handles the processing of assignment to a variable.\n * Shared logic between handling Assignment and AssignmentExpression nodes.\n * Returns both the arrays of instructions needed to store the assignee expression\n * and then load the assigned to value.\n */\nexport function getAssignmentNodes(\n  assignmentNode: Assignment,\n  symbolTable: SymbolTable,\n): {\n  memoryStoreStatements: MemoryStore[];\n  memoryLoadExpressions: MemoryLoad[];\n  dataType: DataType;\n} {\n  // the memory load instructions from processing the expression being assigned to as an expression\n  const assignedMemoryLoadExprs = processExpression(\n    assignmentNode.lvalue,\n    symbolTable,\n  );\n  const lvalueDataType = getDataTypeOfExpression({\n    expression: assignedMemoryLoadExprs,\n  });\n  const assignee = processExpression(assignmentNode.expr, symbolTable);\n  const assigneeDataType = getDataTypeOfExpression({\n    expression: assignee,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n\n  if (lvalueDataType.type === \"array\" || lvalueDataType.type === \"function\") {\n    throw new ProcessingError(\n      `assignment to expression with type '${stringifyDataType(\n        lvalueDataType,\n      )}'`,\n    );\n  }\n\n  if (!isLValue(assignmentNode.lvalue, lvalueDataType, symbolTable)) {\n    throw new ProcessingError(`assignment to expression that is not a lvalue`);\n  }\n\n  if (!isModifiableLValue(assignmentNode.lvalue, lvalueDataType, symbolTable)) {\n    throw new ProcessingError(\n      `assignment to non-modifiable lvalue with type '${stringifyDataType(\n        lvalueDataType,\n      )}'`,\n    );\n  }\n\n  if (!checkAssignability(lvalueDataType, assignee)) {\n    throw new ProcessingError(\n      `cannot assign expression with type '${stringifyDataType(\n        lvalueDataType,\n      )}' to '${stringifyDataType(assigneeDataType)}'`,\n    );\n  }\n\n  const result = {\n    memoryStoreStatements: [] as MemoryStore[],\n    memoryLoadExpressions: assignedMemoryLoadExprs.exprs as MemoryLoad[],\n    dataType: assignedMemoryLoadExprs.originalDataType,\n  };\n\n  // assigned and assignee number of primary data expression should match in length\n  console.assert(\n    assignedMemoryLoadExprs.exprs.length === assignee.exprs.length,\n    \"getAssignmentMemoryStoreNodes: assigned and assignee number of primary data expression should match in length\",\n  );\n\n  // merely need to convert each memoryload into a store of the corresponding assignee expression\n  for (let i = 0; i < assignedMemoryLoadExprs.exprs.length; ++i) {\n    const memoryLoadExpr = assignedMemoryLoadExprs.exprs[i];\n    const assigneeValue = assignee.exprs[i];\n    if (memoryLoadExpr.type !== \"MemoryLoad\") {\n      throw new ProcessingError(\n        \"lvalue required as left operand of assignment\",\n        assignmentNode.position,\n      );\n    }\n    result.memoryStoreStatements.push({\n      type: \"MemoryStore\",\n      address: memoryLoadExpr.address,\n      value: assigneeValue,\n      dataType: memoryLoadExpr.dataType,\n      position: memoryLoadExpr.position,\n    });\n  }\n\n  return result;\n}\n","/**\n * Some helper functions regarding the processing of constants.\n */\nimport { POINTER_SIZE } from \"~src/common/constants\";\nimport {\n  ScalarCDataType,\n  SignedIntegerType,\n  UnsignedIntegerType,\n  IntegerDataType,\n  FloatDataType,\n  PrimaryCDataType,\n} from \"~src/common/types\";\nimport {\n  isSignedIntegerType,\n  isUnsignedIntegerType,\n  primaryDataTypeSizes,\n} from \"~src/common/utils\";\nimport Constant from \"~src/parser/c-ast/expression/constant\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\n\n/**\n * Get the adjusted numeric value of a value according to its variable type, as per C standard.\n */\n\nexport function getAdjustedIntValueAccordingToDataType(\n  value: bigint,\n  dataType: ScalarCDataType,\n) {\n  let newValue = value;\n  // handle integer overflows\n  if (\n    isSignedIntegerType(dataType) &&\n    newValue > getMaxValueOfSignedIntType(dataType as SignedIntegerType)\n  ) {\n    newValue =\n      newValue %\n      (getMaxValueOfSignedIntType(dataType as SignedIntegerType) + 1n);\n  } else if (\n    isUnsignedIntegerType(dataType) &&\n    newValue > getMaxValueOfUnsignedIntType(dataType as UnsignedIntegerType)\n  ) {\n    newValue =\n      newValue %\n      (getMaxValueOfUnsignedIntType(dataType as UnsignedIntegerType) + 1n);\n  } else if (dataType === \"pointer\" && newValue > 2 ** (POINTER_SIZE * 8) - 1) {\n    // just some implementation defined behaviour\n    // although assigning int values to pointer types directly is undefined behaviour and should not be done.\n    // TODO: check this\n    newValue = newValue % 2n ** (BigInt(POINTER_SIZE) * 8n);\n  }\n\n  return newValue;\n}\n/**\n * Returns the maximum value of a signed int type.\n */\nfunction getMaxValueOfSignedIntType(val: SignedIntegerType): bigint {\n  return 2n ** (BigInt(primaryDataTypeSizes[val]) * 8n - 1n) - 1n;\n}\nfunction getMinValueOfSignedIntType(val: SignedIntegerType): bigint {\n  return -(2n ** (BigInt(primaryDataTypeSizes[val]) * 8n - 1n));\n}\nfunction getMaxValueOfUnsignedIntType(val: UnsignedIntegerType): bigint {\n  return 2n ** (BigInt(primaryDataTypeSizes[val]) * 8n) - 1n;\n}\n/**\n * Logic for handling when the value of a constant is a very negative number that lies out of a range of a maxNegativeValue.\n * This, according to the standard, is signed integer overflow which is undefined. Thus the logic here is specific to this compiler\n * implementation, and is made to function similarly to other compilers.\n */\nfunction capNegativeValue(value: bigint, integerType: IntegerDataType): bigint {\n  const minNegativeValue =\n    -(2n ** (BigInt(primaryDataTypeSizes[integerType]) * 8n)) - 1n;\n  if (value >= minNegativeValue) {\n    // no overflow\n    return value;\n  }\n  const diff = minNegativeValue - value;\n  return (\n    2n ** (BigInt(primaryDataTypeSizes[integerType]) * 8n - 1n) -\n    (diff % (2n ** BigInt(primaryDataTypeSizes[integerType]) * 8n))\n  );\n}\n/**\n * Handles signed integer constant values which are too large. This in undefined behaviour as per standard, hence this handling is specific to this compiler, meant to mimic existing compilers.\n */\nfunction handlePositiveSignedIntegerOverflow(\n  value: bigint,\n  signedType: SignedIntegerType,\n): bigint {\n  const maxVal = getMaxValueOfSignedIntType(signedType);\n  if (value <= maxVal) {\n    // no overflow\n    return value;\n  }\n  const diff = value - maxVal;\n  return (\n    getMinValueOfSignedIntType(signedType) +\n    ((diff % 2n ** (BigInt(primaryDataTypeSizes[signedType]) * 8n)) - 1n)\n  );\n}\n/**\n * Performs capping of excessively large or negative integer values used for constants. This is needed to prevent wasm errors.\n * For unsigned types, this will be wraparound. (defined behaviour)\n * For signed types with positive value, it will also be wraparound (undefined behaviour)\n * For signed types with negative value, it excessively negative numbers will \"wrap\" by moving from most neagtive to most positive. E.g. for 8 bits, -129 becomes 127\n */\nfunction getCappedIntegerValue(value: bigint, dataType: IntegerDataType) {\n  if (value > 0) {\n    if (isUnsignedIntegerType(dataType)) {\n      return (\n        value % getMaxValueOfUnsignedIntType(dataType as UnsignedIntegerType)\n      );\n    } else {\n      return handlePositiveSignedIntegerOverflow(\n        value,\n        dataType as SignedIntegerType,\n      );\n    }\n  } else if (value < 0) {\n    return capNegativeValue(value, dataType);\n  } else {\n    return value;\n  }\n}\n/**\n * If the constant overflows float (double corresponds to js number type, so that is already handled), need to cap it to ensure there is no wasm error. This is undefined behaviour, but meant to mimic existing compilers.\n */\nfunction getCappedFloatValue(value: number, dataType: FloatDataType) {\n  if (dataType === \"float\") {\n    return Math.fround(value);\n  }\n  return value;\n}\n/**\n * Cap the values of constants that have overflowing values to avoid wasm runtime errors.\n */\nfunction getCappedConstantValue(\n  constant: Constant,\n  dataType: PrimaryCDataType,\n): bigint | number {\n  if (constant.type === \"IntegerConstant\") {\n    return getCappedIntegerValue(constant.value, dataType as IntegerDataType);\n  } else {\n    // floating point constant\n    return getCappedFloatValue(constant.value, dataType as FloatDataType);\n  }\n}\n/**\n * Sets the dataType of a constant (like a literal number \"123\") as per 6.4.4.1 of C17 standard.\n * Caps the values of the constants if necessary.\n */\nfunction getDataTypeOfConstant(constant: Constant) {\n  if (constant.type === \"IntegerConstant\") {\n    if (constant.suffix === \"ul\") {\n      return \"unsigned long\";\n    } else if (constant.suffix === \"u\") {\n      if (constant.value <= getMaxValueOfUnsignedIntType(\"unsigned int\")) {\n        return \"unsigned int\";\n      } else {\n        return \"unsigned long\";\n      }\n    } else if (constant.suffix === \"l\") {\n      return \"signed long\";\n    } else {\n      // no suffix\n      if (constant.value < 0) {\n        if (constant.value >= getMinValueOfSignedIntType(\"signed int\")) {\n          return \"signed int\";\n        } else if (\n          constant.value >= getMinValueOfSignedIntType(\"signed long\")\n        ) {\n          return \"signed long\";\n        } else {\n          // integer is too negative\n          // TODO: possibly inform user with warning here\n          return \"signed long\";\n        }\n      } else {\n        if (constant.value <= getMaxValueOfSignedIntType(\"signed int\")) {\n          return \"signed int\";\n        } else if (\n          constant.value <= getMaxValueOfSignedIntType(\"signed long\")\n        ) {\n          return \"signed long\";\n        } else {\n          // integer is too large\n          // TODO: possibly inform user with warning here\n          return \"signed long\";\n        }\n      }\n    }\n  } else {\n    // handle float constant\n    if (constant.suffix === \"f\") {\n      return \"float\";\n    } else {\n      // by default all float constants are doubles if \"f\"/\"F\" suffix is not specified\n      return \"double\";\n    }\n  }\n}\n\nexport default function processConstant(constant: Constant): ConstantP {\n  const dataType = getDataTypeOfConstant(constant);\n  const cappedValue = getCappedConstantValue(constant, dataType);\n  return {\n    type: constant.type,\n    value: cappedValue,\n    dataType: dataType,\n  } as ConstantP;\n}\n","/**\n * Definition of visitor function for statements.\n */\n\nimport { SymbolTable } from \"~src/processor/symbolTable\";\n\nimport { ProcessingError, toJson } from \"~src/errors\";\n\nimport { StatementP } from \"~src/processor/c-ast/core\";\nimport { FunctionDefinitionP } from \"~src/processor/c-ast/function\";\nimport { getDataTypeOfExpression, processCondition } from \"~src/processor/util\";\nimport {\n  convertFunctionCallToFunctionCallP,\n  processFunctionReturnStatement,\n} from \"./processFunctionDefinition\";\nimport { ForLoopP } from \"~src/processor/c-ast/statement/iterationStatement\";\nimport { getAssignmentNodes } from \"~src/processor/lvalueUtil\";\nimport { BlockItem } from \"~src/parser/c-ast/core\";\nimport {\n  determineResultDataTypeOfBinaryExpression,\n  getArithmeticPrePostfixExpressionNodes,\n} from \"~src/processor/expressionUtil\";\nimport { processLocalDeclaration } from \"~src/processor/processDeclaration\";\nimport processExpression from \"~src/processor/processExpression\";\nimport { isIntegralDataType } from \"~src/processor/dataTypeUtil\";\nimport { SwitchStatementCaseP } from \"~src/processor/c-ast/statement/selectionStatement\";\nimport evaluateCompileTimeExpression from \"~src/processor/evaluateCompileTimeExpression\";\nimport { addWarning } from \"~src/processor/warningUtil\";\nimport { PrimaryDataType } from \"~src/parser/c-ast/dataTypes\";\n\n// some auxillary information used during processing\nlet auxInfo = {\n  inLoop: false,\n  inSwitch: false,\n};\n\nexport function resetProcessorAuxInfo() {\n  auxInfo = {\n    inLoop: false,\n    inSwitch: false,\n  };\n}\n\nfunction processLoopBody(\n  bodyStaement: BlockItem,\n  symbolTable: SymbolTable,\n  enclosingFunc: FunctionDefinitionP,\n) {\n  const originalInLoop = auxInfo.inLoop;\n  auxInfo.inLoop = true;\n  const body = processBlockItem(bodyStaement, symbolTable, enclosingFunc);\n  auxInfo.inLoop = originalInLoop;\n  return body;\n}\n\n/**\n * Visitor function for traversing C Statement AST nodes.\n * This function is to be used to process any node that is used in a context where it is expected to correspond\n * to a statement - i.e an action that occurs.\n * Thus it can process Expression types as well, specifically expressions which have side effects.\n * @param ast\n * @param sourceCode\n */\nexport default function processBlockItem(\n  node: BlockItem,\n  symbolTable: SymbolTable,\n  enclosingFunc: FunctionDefinitionP,\n): StatementP[] {\n  try {\n    if (node.type === \"Block\") {\n      const blockSymbolTable = new SymbolTable(symbolTable);\n      const statements: StatementP[] = [];\n      node.statements.forEach((child) => {\n        const result = processBlockItem(child, blockSymbolTable, enclosingFunc);\n        if (result === null) {\n          return;\n        } else if (Array.isArray(result)) {\n          // A block was visited, returning an array of StatementP\n          result.forEach((statement) => statements.push(statement));\n        } else {\n          statements.push(result);\n        }\n      });\n      return statements;\n    } else if (node.type === \"ForLoop\") {\n      let clause: StatementP[];\n      let forLoopSymbolTable = symbolTable;\n      if (node.clause !== null && node.clause.type === \"Declaration\") {\n        // create new scope for this declaration\n        forLoopSymbolTable = new SymbolTable(symbolTable);\n        clause = [];\n        for (const declaration of node.clause.value) {\n          clause.push(\n            ...processLocalDeclaration(\n              declaration,\n              forLoopSymbolTable,\n              enclosingFunc,\n            ),\n          );\n        }\n      } else if (node.clause !== null && node.clause.type === \"Expression\") {\n        clause = processBlockItem(\n          node.clause.value,\n          forLoopSymbolTable,\n          enclosingFunc,\n        );\n      } else {\n        clause = [];\n      }\n\n      const processedForLoopNode: ForLoopP = {\n        type: \"ForLoop\",\n        clause,\n        condition:\n          node.condition !== null\n            ? processCondition(node.condition, forLoopSymbolTable)\n            : null,\n        update:\n          node.update !== null\n            ? processBlockItem(node.update, forLoopSymbolTable, enclosingFunc)\n            : [],\n        body: processLoopBody(node.body, forLoopSymbolTable, enclosingFunc),\n        position: node.position,\n      };\n\n      return [processedForLoopNode];\n    } else if (node.type === \"DoWhileLoop\" || node.type === \"WhileLoop\") {\n      return [\n        {\n          type: node.type,\n          condition: processCondition(node.condition, symbolTable),\n          body: processLoopBody(node.body, symbolTable, enclosingFunc), // processing a block always gives array of statements\n          position: node.position,\n        },\n      ];\n    } else if (node.type === \"ReturnStatement\") {\n      // there must be an enclosing func\n      if (typeof enclosingFunc === \"undefined\") {\n        throw new ProcessingError(\n          \"return statement is not valid outside of a function\",\n          node.position,\n        );\n      }\n\n      if (typeof node.value === \"undefined\") {\n        return [\n          {\n            type: \"ReturnStatement\",\n            position: node.position,\n          },\n        ];\n      }\n\n      // there is an expression to return, break up the return into series of memory stores of the expression\n      // in the return memory object locations\n      return processFunctionReturnStatement(node.value, symbolTable);\n    } else if (node.type === \"SelectionStatement\") {\n      return [\n        {\n          type: \"SelectionStatement\",\n          condition: processCondition(node.condition, symbolTable),\n          ifStatements: processBlockItem(\n            node.ifStatement,\n            symbolTable,\n            enclosingFunc,\n          ),\n          elseStatements: node.elseStatement\n            ? processBlockItem(node.elseStatement, symbolTable, enclosingFunc)\n            : null,\n          position: node.position,\n        },\n      ];\n    } else if (node.type === \"BreakStatement\") {\n      if (!auxInfo.inLoop && !auxInfo.inSwitch) {\n        throw new ProcessingError(\n          \"break statement not within a switch or loop body\",\n        );\n      }\n      return [\n        {\n          type: node.type,\n          position: node.position,\n        },\n      ];\n      // start of processing Expression nodes which may have side effects\n    } else if (node.type === \"ContinueStatement\") {\n      if (!auxInfo.inLoop) {\n        throw new ProcessingError(\"continue statement not within a loop body\");\n      }\n      return [\n        {\n          type: node.type,\n          position: node.position,\n        },\n      ];\n      // start of processing Expression nodes which may have side effects\n    } else if (node.type === \"SwitchStatement\") {\n      const processedTargetExpression = processExpression(\n        node.targetExpression,\n        symbolTable,\n      );\n      const dataTypeOfTargetExpression = getDataTypeOfExpression({\n        expression: processedTargetExpression,\n      });\n      if (!isIntegralDataType(dataTypeOfTargetExpression)) {\n        throw new ProcessingError(\"switch quantity is not an integer\");\n      }\n\n      if (node.cases.length === 0 && node.defaultStatements.length === 0) {\n        // empty switch statement, just process the expression as block item\n        return processBlockItem(\n          node.targetExpression,\n          symbolTable,\n          enclosingFunc,\n        );\n      }\n\n      const originalInSwitch = auxInfo.inSwitch;\n      auxInfo.inSwitch = true;\n      const processedCases: SwitchStatementCaseP[] = [];\n      for (const switchStatementCase of node.cases) {\n        const dataTypeOfLabel = getDataTypeOfExpression({\n          expression: processExpression(\n            switchStatementCase.conditionMatch,\n            symbolTable,\n            enclosingFunc,\n          ),\n        });\n        if (!isIntegralDataType(dataTypeOfLabel)) {\n          throw new ProcessingError(\n            \"case value not an integer constant expression\",\n            switchStatementCase.position,\n          );\n        }\n        const evaluatedConstant = evaluateCompileTimeExpression(\n          switchStatementCase.conditionMatch,\n        );\n        const processedStatements: StatementP[] = [];\n        for (const statement of switchStatementCase.statements) {\n          processedStatements.push(\n            ...processBlockItem(statement, symbolTable, enclosingFunc),\n          );\n        }\n        // the conditon of each switch case is adjusted to be a relational expression: targetExpression == case value\n        const dataTypeOfSwitchCaseOperandAndTarget = (\n          determineResultDataTypeOfBinaryExpression(\n            dataTypeOfTargetExpression as PrimaryDataType,\n            dataTypeOfLabel as PrimaryDataType,\n            \"==\",\n          ) as PrimaryDataType\n        ).primaryDataType;\n        processedCases.push({\n          condition: {\n            type: \"BinaryExpression\",\n            leftExpr: processedTargetExpression.exprs[0],\n            rightExpr: evaluatedConstant,\n            operator: \"==\",\n            operandTargetDataType: dataTypeOfSwitchCaseOperandAndTarget,\n            dataType: dataTypeOfSwitchCaseOperandAndTarget,\n            position: switchStatementCase.position,\n          },\n          statements: processedStatements,\n          position: switchStatementCase.position,\n        });\n      }\n      const processedDefaultStatements: StatementP[] = [];\n      for (const defaultStatement of node.defaultStatements) {\n        processedDefaultStatements.push(\n          ...processBlockItem(defaultStatement, symbolTable, enclosingFunc),\n        );\n      }\n      auxInfo.inSwitch = originalInSwitch;\n      return [\n        {\n          type: \"SwitchStatement\",\n          targetExpression: processedTargetExpression.exprs[0], // since processedtargetexpression has integer type, only has one primary data expression\n          cases: processedCases,\n          defaultStatements: processedDefaultStatements,\n          position: node.position,\n        },\n      ];\n    } else if (node.type === \"Assignment\") {\n      return getAssignmentNodes(node, symbolTable).memoryStoreStatements;\n    } else if (node.type === \"FunctionCall\") {\n      // in this context, the return (if any) of the functionCall is ignored, as it is used as a statement\n      return [\n        convertFunctionCallToFunctionCallP(node, symbolTable).functionCallP,\n      ];\n    } else if (\n      node.type === \"PrefixExpression\" ||\n      node.type === \"PostfixExpression\"\n    ) {\n      if (node.operator === \"++\" || node.operator === \"--\") {\n        // only increment and decrement expressions become statements\n        return getArithmeticPrePostfixExpressionNodes(node, symbolTable)\n          .storeNodes;\n      } else {\n        // NOTE: commented out to disable removal of \"redundant\" statements\n        // processExpression(node, symbolTable, enclosingFunc);\n        // return [];\n        const processed = processExpression(node, symbolTable, enclosingFunc);\n\n        return [\n          {\n            type: \"ExpressionStatement\",\n            expr: processed.exprs[0],\n            position: processed.exprs[0].position,\n          },\n        ];\n      }\n    } else if (node.type === \"CommaSeparatedExpressions\") {\n      const processedExpressions: StatementP[] = [];\n      node.expressions.forEach((e) => {\n        processedExpressions.push(\n          ...processBlockItem(e, symbolTable, enclosingFunc),\n        );\n      });\n      return processedExpressions;\n    } else if (node.type === \"ConditionalExpression\") {\n      processExpression(node, symbolTable, enclosingFunc);\n      // break this conditional into a simple if else expression (expressions inside condtional may have side effects)\n      return [\n        {\n          type: \"SelectionStatement\",\n          condition: processCondition(node.condition, symbolTable),\n          ifStatements: processBlockItem(\n            node.trueExpression,\n            symbolTable,\n            enclosingFunc,\n          ),\n          elseStatements: processBlockItem(\n            node.falseExpression,\n            symbolTable,\n            enclosingFunc,\n          ),\n          position: node.position,\n        },\n      ];\n    } else if (\n      node.type === \"AddressOfExpression\" ||\n      node.type === \"BinaryExpression\" ||\n      node.type === \"FloatConstant\" ||\n      node.type === \"IntegerConstant\" ||\n      node.type === \"IdentifierExpression\" ||\n      node.type === \"PointerDereference\" ||\n      node.type === \"SizeOfExpression\" ||\n      node.type === \"StructMemberAccess\"\n    ) {\n      addWarning(\"statement with no effect\", node.position);\n\n      // NOTE: commented out to disable removal of \"redundant\" statements\n      // processExpression(node, symbolTable, enclosingFunc);\n      // all these expression statements can be safely ignored as they have no side effects\n      // return [];\n\n      const processed = processExpression(node, symbolTable, enclosingFunc);\n\n      return [\n        {\n          type: \"ExpressionStatement\",\n          expr: processed.exprs[0],\n          position: processed.exprs[0].position,\n        },\n      ];\n    } else if (node.type === \"StringLiteral\") {\n      addWarning(\"statement with no effect\", node.position);\n      return [];\n    } else if (node.type === \"Declaration\" || node.type === \"EnumDeclaration\") {\n      return processLocalDeclaration(node, symbolTable, enclosingFunc);\n    } else {\n      throw new ProcessingError(`unhandled C AST node: ${toJson(node)}`);\n    }\n  } catch (e) {\n    if (e instanceof ProcessingError && e.position === null) {\n      e.addPositionInfo(node.position);\n    }\n    throw e;\n  }\n}\n","import { ProcessingError } from \"~src/errors\";\nimport {\n  VariableDeclaration,\n  Initializer,\n  InitializerSingle,\n  Declaration,\n} from \"~src/parser/c-ast/declaration\";\nimport { StatementP } from \"~src/processor/c-ast/core\";\nimport { FunctionDefinitionP } from \"~src/processor/c-ast/function\";\nimport {\n  checkAssignability,\n  getDataTypeSize,\n  isFloatDataType,\n  isScalarDataType,\n  stringifyDataType,\n  unpackDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport { SymbolTable, VariableSymbolEntry } from \"~src/processor/symbolTable\";\nimport processExpression from \"~src/processor/processExpression\";\nimport {\n  FloatDataType,\n  IntegerDataType,\n  ScalarCDataType,\n} from \"~src/common/types\";\nimport {\n  getSizeOfScalarDataType,\n  primaryDataTypeSizes,\n} from \"~src/common/utils\";\nimport { MemoryStore } from \"~src/processor/c-ast/memory\";\nimport {\n  createMemoryOffsetIntegerConstant,\n  getDataTypeOfExpression,\n} from \"~src/processor/util\";\nimport evaluateCompileTimeExpression, {\n  isCompileTimeExpression,\n} from \"~src/processor/evaluateCompileTimeExpression\";\nimport {\n  DataType,\n  PointerDataType,\n  PrimaryDataType,\n  StructDataType,\n  StructSelfPointer,\n} from \"~src/parser/c-ast/dataTypes\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport {\n  convertConstantToByteStr,\n  convertIntegerToByteString,\n  getZeroInializerByteStrForDataType,\n} from \"~src/processor/byteStrUtil\";\nimport { ENUM_DATA_TYPE, POINTER_TYPE } from \"~src/common/constants\";\nimport processEnumDeclaration from \"~src/processor/processEnumDeclaration\";\nimport { ExpressionWrapperP } from \"~src/processor/c-ast/expression/expressions\";\nimport { Expression } from \"~src/parser/c-ast/core\";\nimport { memoryManager } from \"~src/processor/memoryManager\";\n\n/**\n * Processes a Declaration node that is found within a function.\n * Adds the symbol to the symbolTable, and returns any memory store nodes needed for initialization, if any.\n */\nexport function processLocalDeclaration(\n  declaration: Declaration,\n  symbolTable: SymbolTable,\n  enclosingFunc: FunctionDefinitionP, // reference to enclosing function, if any\n): StatementP[] {\n  if (declaration.type === \"Declaration\") {\n    let symbolEntry = symbolTable.addEntry(declaration);\n    \n    if (symbolEntry.type !== \"function\") {\n      const varEntry = symbolEntry as VariableSymbolEntry;\n      memoryManager.getAddressMap().addVariable(declaration.name, {\n        name: declaration.name,\n        offset: varEntry.offset,\n        isGlobal: varEntry.type === \"dataSegmentVariable\",\n        size: getDataTypeSize(declaration.dataType),\n        dataType: declaration.dataType\n      });\n    }\n\n    if (\n      symbolEntry.type === \"function\" &&\n      typeof declaration.initializer !== \"undefined\"\n    ) {\n      throw new ProcessingError(\n        `function '${declaration.name}' is initialized like a variable`,\n      );\n    }\n\n    if (typeof enclosingFunc !== \"undefined\") {\n      enclosingFunc.sizeOfLocals += getDataTypeSize(declaration.dataType);\n    }\n\n    symbolEntry = symbolEntry as VariableSymbolEntry; // definitely not dealing with a function declaration already\n\n    // We have already allocated space for data segment variables, no more memory statements are needed\n    if (\n      typeof declaration.initializer !== \"undefined\" &&\n      symbolEntry.type !== \"dataSegmentVariable\"\n    ) {\n      return unpackLocalVariableInitializerAccordingToDataType(\n        symbolEntry,\n        declaration.initializer,\n        symbolTable,\n      );\n    } else {\n      return [];\n    }\n  } else if (declaration.type === \"EnumDeclaration\") {\n    processEnumDeclaration(declaration, symbolTable);\n    return [];\n  } else {\n    console.assert(false, \"Unknown declaration type\");\n    return [];\n  }\n}\n\n/**\n * Some basic checks for invalid initialization.\n */\nfunction runInitializerChecks(dataType: DataType, initializer: Initializer) {\n  if (isScalarDataType(dataType)) {\n    if (\n      initializer.type === \"InitializerList\" &&\n      initializer.values.length > 1\n    ) {\n      throw new ProcessingError(\"excess elements in scalar intializer\"); // undefined behaviour, for not throw TODO: perhaps toggle based on flag\n    }\n  } else if (dataType.type === \"function\") {\n    throw new ProcessingError(`function cannot be initialized like a variable`);\n  } else if (\n    dataType.type === \"array\" &&\n    initializer.type === \"InitializerSingle\"\n  ) {\n    throw new ProcessingError(\"invalid intializer for aggregate type\");\n  }\n}\n\nfunction createStructSelfPointerDataType(\n  struct: StructDataType,\n): PointerDataType {\n  return {\n    type: \"pointer\",\n    pointeeType: struct,\n  };\n}\n\nexport function checkIntializerExpressionAssignability(\n  lvalue: DataType,\n  expr: ExpressionWrapperP,\n) {\n  if (!checkAssignability(lvalue, expr)) {\n    throw new ProcessingError(\n      `incompatible types when initializing type '${stringifyDataType(\n        lvalue,\n      )}' using type '${stringifyDataType(\n        getDataTypeOfExpression({\n          expression: expr,\n          convertArrayToPointer: true,\n          convertFunctionToPointer: true,\n        }),\n      )}'`,\n    );\n  }\n}\n\nexport function unpackLocalVariableInitializerAccordingToDataType(\n  variableSymbolEntry: VariableSymbolEntry, // the symbol entry of the the variable being initialized\n  initializer: Initializer,\n  symbolTable: SymbolTable,\n): MemoryStore[] {\n  const memoryStoreStatements: MemoryStore[] = [];\n  let currOffset = variableSymbolEntry.offset; // offset to use for address in memory store statements\n\n  runInitializerChecks(variableSymbolEntry.dataType, initializer);\n\n  let structBeingFilled: StructDataType; // the current struct being filled, used for struct self pointer logic\n  function helper(\n    dataType: DataType | StructSelfPointer,\n    initializer: Initializer,\n    offset: number,\n  ): number {\n    if (\n      dataType.type === \"primary\" ||\n      dataType.type === \"pointer\" ||\n      dataType.type === \"enum\" ||\n      dataType.type === \"struct self pointer\"\n    ) {\n      let scalarDataType: ScalarCDataType;\n      if (\n        dataType.type === \"pointer\" ||\n        dataType.type === \"struct self pointer\"\n      ) {\n        scalarDataType = \"pointer\";\n      } else if (dataType.type === \"enum\") {\n        scalarDataType = ENUM_DATA_TYPE;\n      } else {\n        scalarDataType = dataType.primaryDataType;\n      }\n\n      if (initializer.type === \"InitializerSingle\") {\n        const processedExpr = processExpression(initializer.value, symbolTable);\n        if (dataType.type === \"struct self pointer\") {\n          checkIntializerExpressionAssignability(\n            createStructSelfPointerDataType(structBeingFilled),\n            processedExpr,\n          );\n        } else {\n          checkIntializerExpressionAssignability(dataType, processedExpr);\n        }\n\n        memoryStoreStatements.push({\n          type: \"MemoryStore\",\n          address: {\n            type: \"LocalAddress\",\n            offset: createMemoryOffsetIntegerConstant(currOffset), // offset of this primary data object = offset of variable it belongs to + offset within variable type\n            dataType: \"pointer\",\n            position: initializer.position,\n          },\n          value: processedExpr.exprs[0],\n          dataType: scalarDataType,\n          position: initializer.position,\n        });\n        currOffset += getDataTypeSize(dataType);\n      } else {\n        if (offset >= initializer.values.length) {\n          let zeroExpression: ConstantP;\n          if (\n            dataType.type !== \"struct self pointer\" &&\n            isFloatDataType(dataType)\n          ) {\n            zeroExpression = {\n              type: \"FloatConstant\",\n              value: 0,\n              dataType: (dataType as PrimaryDataType)\n                .primaryDataType as FloatDataType,\n              position: initializer.position,\n            };\n          } else {\n            zeroExpression = {\n              type: \"IntegerConstant\",\n              value: 0n,\n              dataType:\n                dataType.type === \"pointer\" ||\n                dataType.type === \"struct self pointer\"\n                  ? POINTER_TYPE\n                  : dataType.type === \"enum\"\n                  ? ENUM_DATA_TYPE\n                  : (dataType.primaryDataType as IntegerDataType),\n              position: initializer.position,\n            };\n          }\n          memoryStoreStatements.push({\n            type: \"MemoryStore\",\n            address: {\n              type: \"LocalAddress\",\n              offset: createMemoryOffsetIntegerConstant(currOffset), // offset of this primary data object = offset of variable it belongs to + offset within variable type\n              dataType: \"pointer\",\n              position: initializer.position,\n            },\n            value: zeroExpression,\n            dataType: scalarDataType,\n            position: initializer.position,\n          });\n          currOffset += getDataTypeSize(dataType);\n        } else {\n          // unpack the element at offset of the list until hit a single\n          let firstInitializer = initializer.values[offset++];\n          while (firstInitializer.type === \"InitializerList\") {\n            if (firstInitializer.values.length === 0) {\n              // empty initializer list\n              let zeroExpression: ConstantP;\n              if (\n                dataType.type !== \"struct self pointer\" &&\n                isFloatDataType(dataType)\n              ) {\n                zeroExpression = {\n                  type: \"FloatConstant\",\n                  value: 0,\n                  dataType: (dataType as PrimaryDataType)\n                    .primaryDataType as FloatDataType,\n                  position: initializer.position,\n                };\n              } else {\n                zeroExpression = {\n                  type: \"IntegerConstant\",\n                  value: 0n,\n                  dataType:\n                    dataType.type === \"pointer\" ||\n                    dataType.type === \"struct self pointer\"\n                      ? POINTER_TYPE\n                      : dataType.type === \"enum\"\n                      ? ENUM_DATA_TYPE\n                      : (dataType.primaryDataType as IntegerDataType),\n                  position: initializer.position,\n                };\n              }\n              memoryStoreStatements.push({\n                type: \"MemoryStore\",\n                address: {\n                  type: \"LocalAddress\",\n                  offset: createMemoryOffsetIntegerConstant(currOffset), // offset of this primary data object = offset of variable it belongs to + offset within variable type\n                  dataType: \"pointer\",\n                  position: initializer.position,\n                },\n                value: zeroExpression,\n                dataType: scalarDataType,\n                position: initializer.position,\n              });\n              currOffset += getDataTypeSize(dataType);\n              return offset;\n            } else if (firstInitializer.values.length > 1) {\n              // excess elements\n              throw new ProcessingError(\"excess elements in initializer\");\n            }\n            firstInitializer = firstInitializer.values[0];\n          }\n          const processedExpr = processExpression(\n            firstInitializer.value,\n            symbolTable,\n          );\n          // check assignability\n          if (dataType.type === \"struct self pointer\") {\n            checkIntializerExpressionAssignability(\n              createStructSelfPointerDataType(structBeingFilled),\n              processedExpr,\n            );\n          } else {\n            checkIntializerExpressionAssignability(dataType, processedExpr);\n          }\n          memoryStoreStatements.push({\n            type: \"MemoryStore\",\n            address: {\n              type: \"LocalAddress\",\n              offset: createMemoryOffsetIntegerConstant(currOffset), // offset of this primary data object = offset of variable it belongs to + offset within variable type\n              dataType: \"pointer\",\n              position: processedExpr.exprs[0].position,\n            },\n            value: processedExpr.exprs[0],\n            dataType: scalarDataType,\n            position: processedExpr.exprs[0].position,\n          });\n          currOffset += getDataTypeSize(dataType);\n        }\n      }\n    } else if (dataType.type === \"array\") {\n      if (initializer.type === \"InitializerSingle\") {\n        throw new ProcessingError(\"invalid initializer for aggregate type\");\n      }\n      const numElements = evaluateCompileTimeExpression(\n        dataType.numElements,\n      ).value;\n      for (let i = 0; i < numElements; i++) {\n        if (\n          dataType.elementDataType.type === \"pointer\" ||\n          dataType.elementDataType.type === \"primary\"\n        ) {\n          // same initializer list, offset shld incr by 1\n          offset = helper(dataType.elementDataType, initializer, offset);\n        } else if (dataType.elementDataType.type === \"struct\") {\n          if (\n            offset < initializer.values.length &&\n            initializer.values[offset].type === \"InitializerSingle\"\n          ) {\n            // special handling in case the current initializer at offset is a struct expression\n            const processedExpr = processExpression(\n              (initializer.values[offset] as InitializerSingle).value,\n              symbolTable,\n            );\n            if (processedExpr.originalDataType.type === \"struct\") {\n              checkIntializerExpressionAssignability(\n                dataType.elementDataType,\n                processedExpr,\n              );\n              const unpackedStruct = unpackDataType(dataType.elementDataType);\n              for (let i = 0; i < unpackedStruct.length; ++i) {\n                const primaryExpr = processedExpr.exprs[i];\n                const primaryMemoryObj = unpackedStruct[i];\n                memoryStoreStatements.push({\n                  type: \"MemoryStore\",\n                  address: {\n                    type: \"LocalAddress\",\n                    offset: createMemoryOffsetIntegerConstant(currOffset), // offset of this primary data object = offset of variable it belongs to + offset within variable type\n                    dataType: \"pointer\",\n                    position: primaryExpr.position,\n                  },\n                  value: primaryExpr,\n                  dataType: primaryMemoryObj.dataType,\n                  position: primaryExpr.position,\n                });\n                currOffset += getSizeOfScalarDataType(\n                  primaryMemoryObj.dataType,\n                );\n              }\n              ++offset;\n              continue;\n            }\n          }\n          if (\n            offset >= initializer.values.length ||\n            initializer.values[offset].type === \"InitializerSingle\"\n          ) {\n            // sub aggregate will take from the same \"level\" of initializer list, offset will be incremented\n            offset = helper(dataType.elementDataType, initializer, offset);\n          } else {\n            helperWithExcessInitializerCheck(\n              dataType.elementDataType,\n              initializer.values[offset++],\n            ); // fresh offset for sub aggregate\n          }\n        } else if (dataType.elementDataType.type === \"array\") {\n          if (\n            offset >= initializer.values.length ||\n            initializer.values[offset].type === \"InitializerSingle\"\n          ) {\n            // sub aggregate will take from the same \"level\" of initializer list, offset will be incremented\n            offset = helper(dataType.elementDataType, initializer, offset);\n          } else {\n            helperWithExcessInitializerCheck(\n              dataType.elementDataType,\n              initializer.values[offset++],\n            );\n          }\n        } else if (dataType.elementDataType.type === \"function\") {\n          // should not be possible\n          throw new ProcessingError(\"cannot have array of functions\");\n        }\n      }\n    } else if (dataType.type === \"struct\") {\n      if (initializer.type === \"InitializerSingle\") {\n        const processedExpr = processExpression(initializer.value, symbolTable);\n        // handle direct initialization of struct with another struct\n        checkIntializerExpressionAssignability(dataType, processedExpr);\n        const unpackedStruct = unpackDataType(dataType);\n        for (let i = 0; i < unpackedStruct.length; ++i) {\n          const primaryExpr = processedExpr.exprs[i];\n          const primaryMemoryObj = unpackedStruct[i];\n          memoryStoreStatements.push({\n            type: \"MemoryStore\",\n            address: {\n              type: \"LocalAddress\",\n              offset: createMemoryOffsetIntegerConstant(currOffset), // offset of this primary data object = offset of variable it belongs to + offset within variable type\n              dataType: \"pointer\",\n              position: primaryExpr.position,\n            },\n            value: primaryExpr,\n            dataType: primaryMemoryObj.dataType,\n            position: primaryExpr.position,\n          });\n          currOffset += getSizeOfScalarDataType(primaryMemoryObj.dataType);\n        }\n        return offset;\n      }\n\n      structBeingFilled = dataType;\n      for (const field of dataType.fields) {\n        if (initializer.values[offset].type === \"InitializerSingle\") {\n          // same initializer list, offset shld incr by 1\n          offset = helper(field.dataType, initializer, offset);\n        } else {\n          helperWithExcessInitializerCheck(\n            field.dataType,\n            initializer.values[offset++],\n          );\n        }\n      }\n    }\n    return offset;\n  }\n\n  function helperWithExcessInitializerCheck(\n    dataType: DataType | StructSelfPointer,\n    initializer: Initializer,\n  ) {\n    const finalOffset = helper(dataType, initializer, 0);\n    if (\n      initializer.type === \"InitializerList\" &&\n      finalOffset < initializer.values.length\n    ) {\n      throw new ProcessingError(\"excess elements in initializer\");\n    }\n  }\n\n  helperWithExcessInitializerCheck(variableSymbolEntry.dataType, initializer);\n\n  return memoryStoreStatements;\n}\n\nexport function processGlobalScopeDeclaration(\n  declaration: Declaration,\n  symbolTable: SymbolTable,\n) {\n  if (declaration.type === \"Declaration\") {\n    processDataSegmentVariableDeclaration(declaration, symbolTable);\n  } else if (declaration.type === \"EnumDeclaration\") {\n    processEnumDeclaration(declaration, symbolTable);\n  } else {\n    console.assert(false, \"Unknown declaration type\");\n  }\n}\n\n/**\n * Processes a data segment variable declaration.\n */\nexport function processDataSegmentVariableDeclaration(\n  node: VariableDeclaration,\n  symbolTable: SymbolTable,\n) {\n  const symbolEntry = symbolTable.addEntry(node);\n  if (node.dataType.type === \"function\") {\n    if (typeof node.initializer !== \"undefined\") {\n      throw new ProcessingError(\n        `function '${node.name}' is initialized like a variable`,\n      );\n    }\n    return;\n  }\n\n  // sanity check\n  if (symbolEntry.type === \"localVariable\") {\n    throw new ProcessingError(\n      \"processDataSegmentVariableDeclaration: symbol entry has type 'localVariable'\",\n    );\n  }\n}\n\nfunction checkCompileTimeInitializer(initializerValue: Expression) {\n  if (!isCompileTimeExpression(initializerValue)) {\n    throw new ProcessingError(\"initializer element is not constant\");\n  }\n}\n\n/**\n * Function to recursively go through the declaration data type and the intiializer to assign appropriately\n * (and handle zeroing of memory when insufficient intializer exprs are present).\n * Returns byte string of bytes to intialize the memory in the data segment that the declared variable occupies.\n */\nexport function unpackDataSegmentInitializerAccordingToDataType(\n  dataType: DataType,\n  initializer: Initializer | null,\n  symbolTable: SymbolTable,\n): string {\n  let byteStr = \"\";\n  function helper(\n    dataType: DataType | StructSelfPointer,\n    initializer: Initializer,\n    offset: number,\n  ): number {\n    if (\n      dataType.type === \"primary\" ||\n      dataType.type === \"pointer\" ||\n      dataType.type === \"enum\" ||\n      dataType.type === \"struct self pointer\"\n    ) {\n      let scalarDataType: ScalarCDataType;\n      if (\n        dataType.type === \"pointer\" ||\n        dataType.type === \"struct self pointer\"\n      ) {\n        scalarDataType = \"pointer\";\n      } else if (dataType.type === \"enum\") {\n        scalarDataType = ENUM_DATA_TYPE;\n      } else {\n        scalarDataType = dataType.primaryDataType;\n      }\n      if (initializer.type === \"InitializerSingle\") {\n        // special handling for string literal\n        if (initializer.value.type === \"StringLiteral\") {\n          const dataSegmentOffset = symbolTable.addDataSegmentObject(\n            initializer.value.chars,\n          );\n          byteStr += convertIntegerToByteString(\n            BigInt(dataSegmentOffset),\n            primaryDataTypeSizes[POINTER_TYPE],\n          );\n        } else {\n          checkCompileTimeInitializer(initializer.value);\n          const processedConstant = evaluateCompileTimeExpression(\n            initializer.value,\n          );\n          byteStr += convertConstantToByteStr(\n            processedConstant,\n            scalarDataType,\n          );\n        }\n      } else {\n        if (offset >= initializer.values.length) {\n          byteStr += getZeroInializerByteStrForDataType(dataType);\n        } else {\n          // unpack the element at offset of the list until hit a single\n          let firstInitializer = initializer.values[offset++];\n          while (firstInitializer.type === \"InitializerList\") {\n            if (firstInitializer.values.length === 0) {\n              // empty initializer\n              byteStr += getZeroInializerByteStrForDataType(dataType);\n              return offset;\n            } else if (firstInitializer.values.length > 1) {\n              throw new ProcessingError(\"excess elements in initializer\");\n            }\n            firstInitializer = firstInitializer.values[0];\n          }\n          checkCompileTimeInitializer(firstInitializer.value);\n          const processedConstant = evaluateCompileTimeExpression(\n            firstInitializer.value,\n          );\n          byteStr += convertConstantToByteStr(\n            processedConstant,\n            scalarDataType,\n          );\n        }\n      }\n    } else if (dataType.type === \"array\") {\n      if (initializer.type === \"InitializerSingle\") {\n        throw new ProcessingError(\"invalid initializer for aggregate type\");\n      }\n      const numElements = evaluateCompileTimeExpression(\n        dataType.numElements,\n      ).value;\n      for (let i = 0; i < numElements; i++) {\n        if (\n          dataType.elementDataType.type === \"pointer\" ||\n          dataType.elementDataType.type === \"primary\"\n        ) {\n          // same initializer list, offset shld incr by 1\n          offset = helper(dataType.elementDataType, initializer, offset);\n        } else if (\n          dataType.elementDataType.type === \"array\" ||\n          dataType.elementDataType.type === \"struct\"\n        ) {\n          if (\n            offset >= initializer.values.length ||\n            initializer.values[offset].type === \"InitializerSingle\"\n          ) {\n            // sub aggregate will take from the same \"level\" of initializer list, offset will be incremented\n            offset = helper(dataType.elementDataType, initializer, offset);\n          } else {\n            helperWithExcessInitializerCheck(\n              dataType.elementDataType,\n              initializer.values[offset++],\n            ); // fresh offset for sub aggregate\n          }\n        }\n      }\n    } else if (dataType.type === \"struct\") {\n      if (initializer.type === \"InitializerSingle\") {\n        throw new ProcessingError(\"invalid initializer for aggregate type\");\n      }\n      for (const field of dataType.fields) {\n        if (\n          field.dataType.type === \"pointer\" ||\n          field.dataType.type === \"primary\"\n        ) {\n          // same initializer list, offset shld incr by 1\n          offset = helper(field.dataType, initializer, offset);\n        } else if (\n          field.dataType.type === \"array\" ||\n          field.dataType.type === \"struct\"\n        ) {\n          if (\n            offset >= initializer.values.length ||\n            initializer.values[offset].type === \"InitializerSingle\"\n          ) {\n            // sub aggregate will take from the same \"level\" of initializer list, offset will be incremented\n            offset = helper(field.dataType, initializer, offset);\n          } else {\n            helperWithExcessInitializerCheck(\n              field.dataType,\n              initializer.values[offset++],\n            ); // fresh offset for sub aggregate\n          }\n        } else if (field.dataType.type === \"function\") {\n          throw new ProcessingError(\"function is not valid field of struct\");\n        }\n      }\n    } else if (dataType.type === \"function\") {\n      throw new ProcessingError(\"cannot initialize function type\");\n    }\n    return offset;\n  }\n\n  function helperWithExcessInitializerCheck(\n    dataType: DataType | StructSelfPointer,\n    initializer: Initializer,\n  ) {\n    const finalOffset = helper(dataType, initializer, 0);\n    if (\n      initializer.type === \"InitializerList\" &&\n      finalOffset < initializer.values.length\n    ) {\n      throw new ProcessingError(\"excess elements in initializer\");\n    }\n  }\n\n  if (initializer === null) {\n    return getZeroInializerByteStrForDataType(dataType);\n  }\n\n  helperWithExcessInitializerCheck(dataType, initializer);\n  return byteStr;\n}\n","/**\n * Some utility functions for converting variable intializers into byte strings.\n */\n\nimport { ProcessingError } from \"~src/errors\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { DataType, StructSelfPointer } from \"~src/parser/c-ast/dataTypes\";\nimport evaluateCompileTimeExpression from \"~src/processor/evaluateCompileTimeExpression\";\nimport { getDataTypeSize } from \"~src/processor/dataTypeUtil\";\nimport { isIntegerType, primaryDataTypeSizes } from \"~src/common/utils\";\nimport {\n  FloatDataType,\n  IntegerDataType,\n  ScalarCDataType,\n} from \"~src/common/types\";\n\nexport function getZeroInializerByteStrForDataType(\n  dataType: DataType | StructSelfPointer,\n) {\n  let byteStr = \"\";\n  if (\n    dataType.type === \"primary\" ||\n    dataType.type === \"pointer\" ||\n    dataType.type === \"enum\" ||\n    dataType.type === \"struct self pointer\"\n  ) {\n    const numOfBytes = getDataTypeSize(dataType);\n    for (let i = 0; i < numOfBytes; ++i) {\n      byteStr += \"\\\\00\";\n    }\n  } else if (dataType.type === \"array\") {\n    const numElements = evaluateCompileTimeExpression(\n      dataType.numElements,\n    ).value;\n    const elementZeroStr = getZeroInializerByteStrForDataType(\n      dataType.elementDataType,\n    );\n    for (let i = 0; i < numElements; i++) {\n      byteStr += elementZeroStr;\n    }\n  } else if (dataType.type === \"struct\") {\n    dataType.fields.forEach((field) => {\n      byteStr +=\n        field.dataType.type === \"struct self pointer\"\n          ? getZeroInializerByteStrForDataType({\n              // just initialize the zero pointer like any other pointer\n              type: \"pointer\",\n              pointeeType: { type: \"void\" },\n            })\n          : getZeroInializerByteStrForDataType(field.dataType);\n    });\n  } else if (dataType.type === \"function\") {\n    throw new ProcessingError(\"cannot initialize a function data type\");\n  }\n\n  return byteStr;\n}\n\n/**\n * Converts a Constant into its byte string representation in little endian format.\n * Takes into account the target data type.\n */\nexport function convertConstantToByteStr(\n  constant: ConstantP,\n  targetDataType: ScalarCDataType,\n) {\n  // shouldnt be assigning ints to pointer. THis is a constraint violation TODO: consider an error here to user based on a flag set on compiler\n  if (targetDataType === \"pointer\") {\n    targetDataType = \"unsigned int\";\n  }\n\n  if (isIntegerType(targetDataType)) {\n    targetDataType = targetDataType as IntegerDataType;\n    if (constant.type === \"FloatConstant\") {\n      // need to truncate the value\n      return convertIntegerToByteString(\n        BigInt(Math.trunc(constant.value)),\n        primaryDataTypeSizes[targetDataType],\n      );\n    } else {\n      return convertIntegerToByteString(\n        constant.value,\n        primaryDataTypeSizes[targetDataType],\n      );\n    }\n  } else {\n    targetDataType = targetDataType as FloatDataType;\n    if (constant.type === \"IntegerConstant\") {\n      // Number will automatically handle converting to the next representable value TODO: check if this is next highest or lowest\n      return convertFloatNumberToByteString(\n        Number(constant.value),\n        targetDataType,\n      );\n    } else {\n      // need to get a float byte string\n      return convertFloatNumberToByteString(constant.value, targetDataType);\n    }\n  }\n}\n\n/**\n * Converts an integer into a string of bytes with numOfBytes length.\n */\nexport function convertIntegerToByteString(\n  integer: bigint,\n  numOfBytes: number,\n) {\n  if (integer < 0) {\n    // convert to 2's complement equivalent in terms of positive number\n    integer = 2n ** (BigInt(numOfBytes) * 8n) + integer;\n  }\n  const hexString = integer.toString(16);\n  const strSplit = hexString.split(\"\");\n  if (hexString.length % 2 == 1) {\n    strSplit.splice(0, 0, \"0\");\n  }\n  let finalStr = \"\";\n  for (let i = strSplit.length - 1; i >= 0; i = i - 2) {\n    finalStr += \"\\\\\" + strSplit[i - 1] + strSplit[i];\n  }\n\n  // fill up rest of the bytes with zeroes if the integer needs fewer bytes than numOfBytes to represent\n  const goalSize = numOfBytes * 3;\n  while (finalStr.length < goalSize) {\n    finalStr += \"\\\\00\";\n  }\n\n  // truncate the integer by taking lowest numOfBytes bytes\n  return finalStr.slice(0, 3 * numOfBytes);\n}\n\nfunction convertFloatNumberToByteString(\n  floatValue: number,\n  targetDataType: FloatDataType,\n) {\n  const buffer = new ArrayBuffer(primaryDataTypeSizes[targetDataType]);\n  let integerValue;\n  if (targetDataType === \"float\") {\n    const float32Arr = new Float32Array(buffer);\n    const uint32Arr = new Uint32Array(buffer);\n    // if the floatValue is out of range, this will set it to infinity. Whereas if not exactly representable, it will also round up to next representable.\n    float32Arr[0] = floatValue;\n    integerValue = uint32Arr[0];\n  } else {\n    const float64Arr = new Float64Array(buffer);\n    const uint64Arr = new BigUint64Array(buffer);\n    float64Arr[0] = floatValue;\n    integerValue = uint64Arr[0];\n  }\n\n  // convert the integer view of the float variable to a byte string\n  return convertIntegerToByteString(\n    BigInt(integerValue),\n    primaryDataTypeSizes[targetDataType],\n  );\n}\n","import { ProcessingError } from \"~src/errors\";\nimport { EnumDeclaration } from \"~src/parser/c-ast/declaration\";\nimport evaluateCompileTimeExpression from \"~src/processor/evaluateCompileTimeExpression\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\n\nexport default function processEnumDeclaration(\n  enumDeclaration: EnumDeclaration,\n  symbolTable: SymbolTable,\n) {\n  let currValue = 0n;\n  enumDeclaration.enumerators.forEach((enumerator) => {\n    if (typeof enumerator.value !== \"undefined\" && enumerator.value !== null) {\n      const value = evaluateCompileTimeExpression(enumerator.value).value;\n      if (typeof value !== \"bigint\") {\n        throw new ProcessingError(\n          `enumerator value for '${enumerator.name}' is not an integer constant`,\n        );\n      }\n      currValue = value;\n    }\n    symbolTable.addEnumeratorEntry(enumerator.name, currValue++);\n  });\n}\n","import { Position } from \"~src/parser/c-ast/misc\";\n\nexport interface Warning {\n  message: string;\n  position: Position;\n}\n\nexport let warnings: Warning[] = [];\n\nexport function clearWarnings() {\n  warnings = [];\n}\n\nexport function addWarning(message: string, position: Position) {\n  warnings.push({ message, position });\n}\n","/**\n * This file contains various utility functions to help in checking the fulfillment of constraints of different language features.\n */\n\nimport { ProcessingError } from \"~src/errors\";\nimport { DataType } from \"~src/parser/c-ast/dataTypes\";\nimport { BinaryExpression } from \"~src/parser/c-ast/expression/binaryExpression\";\nimport {\n  PostfixExpression,\n  PrefixExpression,\n} from \"~src/parser/c-ast/expression/unaryExpression\";\nimport { ExpressionWrapperP } from \"~src/processor/c-ast/expression/expressions\";\nimport {\n  checkDataTypeCompatibility,\n  isArithmeticDataType,\n  isIntegralDataType,\n  isNullPointerConstant,\n  isPointer,\n  isPointerToCompleteDataType,\n  isRealDataType,\n  isScalarDataType,\n  isVoidPointer,\n  stringifyDataType,\n} from \"~src/processor/dataTypeUtil\";\nimport { isModifiableLValue } from \"~src/processor/lvalueUtil\";\nimport { SymbolTable } from \"~src/processor/symbolTable\";\nimport { getDataTypeOfExpression } from \"~src/processor/util\";\n\n/**\n * Checks if given expression and its result after processing fulfills pre or postfix type constraint.\n * Constraint 6.5.2.4/1 of C17 standard.\n */\nexport function checkPrePostfixTypeConstraint(\n  expression: PrefixExpression | PostfixExpression,\n  processedUnderlyingExpr: ExpressionWrapperP,\n  symbolTable: SymbolTable,\n) {\n  const dataType = getDataTypeOfExpression({\n    expression: processedUnderlyingExpr,\n  });\n  // must be real or pointer type and be modifiable lvalue\n  if (!isScalarDataType(dataType)) {\n    throw new ProcessingError(\n      `wrong type argument to ${\n        expression.operator === \"++\" ? \"increment\" : \"decrement\"\n      }`,\n    );\n  }\n\n  if (!isModifiableLValue(expression.expr, dataType, symbolTable)) {\n    throw new ProcessingError(\n      `argument to ${\n        expression.operator === \"++\" ? \"increment\" : \"decrement\"\n      } is not a modifiable lvalue`,\n    );\n  }\n}\n\n/**\n * Performs type checking on operands of a binary expression as per constraints found from 6.5.5 to 6.5.14 of the C17 standard.\n */\nexport function checkBinaryExpressionConstraints(\n  binaryExpr: BinaryExpression,\n  processedLeftExpr: ExpressionWrapperP,\n  processedRightExpr: ExpressionWrapperP,\n) {\n  const leftDataType = getDataTypeOfExpression({\n    expression: processedLeftExpr,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n  const rightDataType = getDataTypeOfExpression({\n    expression: processedRightExpr,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n  function throwBinaryExpressionInvalidOperandsError() {\n    throw new ProcessingError(\n      `invalid operands to binary '${\n        binaryExpr.operator\n      }' (have '${stringifyDataType(leftDataType)}' and '${stringifyDataType(\n        rightDataType,\n      )}')`,\n    );\n  }\n\n  function checkBothOperandsHaveType(checker: (dataType: DataType) => boolean) {\n    return checker(leftDataType) && checker(rightDataType);\n  }\n\n  function checkOperandsTypeCombination(\n    checker1: (dataType: DataType) => boolean,\n    checker2: (dataType: DataType) => boolean,\n  ) {\n    return (\n      (checker1(leftDataType) && checker2(rightDataType)) ||\n      (checker2(leftDataType) && checker1(rightDataType))\n    );\n  }\n\n  function checkPointerCompatibilityIgnoringQualifiers() {\n    return (\n      checkBothOperandsHaveType(isPointer) &&\n      checkDataTypeCompatibility(leftDataType, rightDataType, true)\n    );\n  }\n\n  switch (binaryExpr.operator) {\n    case \"*\":\n    case \"/\":\n      if (!checkBothOperandsHaveType(isArithmeticDataType)) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \"%\":\n      if (!checkBothOperandsHaveType(isIntegralDataType)) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \"+\":\n      if (\n        !(\n          checkBothOperandsHaveType(isArithmeticDataType) ||\n          checkOperandsTypeCombination(\n            isPointerToCompleteDataType,\n            isIntegralDataType,\n          )\n        )\n      ) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \"-\":\n      if (\n        !(\n          checkBothOperandsHaveType(isArithmeticDataType) ||\n          (isPointerToCompleteDataType(leftDataType) &&\n            isIntegralDataType(rightDataType)) ||\n          checkPointerCompatibilityIgnoringQualifiers()\n        )\n      ) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \">>\":\n    case \"<<\":\n      if (!checkBothOperandsHaveType(isIntegralDataType)) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \">\":\n    case \"<\":\n    case \"<=\":\n    case \">=\":\n      if (\n        !(\n          checkBothOperandsHaveType(isRealDataType) ||\n          checkPointerCompatibilityIgnoringQualifiers()\n        )\n      ) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \"==\":\n    case \"!=\":\n      if (\n        !(\n          checkBothOperandsHaveType(isArithmeticDataType) ||\n          checkPointerCompatibilityIgnoringQualifiers() ||\n          checkOperandsTypeCombination(isPointer, isVoidPointer) ||\n          (isPointer(leftDataType) &&\n            isNullPointerConstant(processedRightExpr)) ||\n          (isPointer(rightDataType) && isNullPointerConstant(processedLeftExpr))\n        )\n      ) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \"&\":\n    case \"^\":\n    case \"|\":\n      if (!checkBothOperandsHaveType(isIntegralDataType)) {\n        throwBinaryExpressionInvalidOperandsError();\n      }\n      break;\n    case \"&&\":\n    case \"||\":\n      if (!checkBothOperandsHaveType(isScalarDataType)) {\n        throw throwBinaryExpressionInvalidOperandsError();\n      }\n  }\n}\n\nexport function checkConditionalExpressionOperands(\n  processedCondition: ExpressionWrapperP,\n  processedTrueExpression: ExpressionWrapperP,\n  processedFalseExpression: ExpressionWrapperP,\n) {\n  // check condition\n  const dataTypeOfConditionExpression = getDataTypeOfExpression({\n    expression: processedCondition,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n  if (!isScalarDataType(dataTypeOfConditionExpression)) {\n    throw new ProcessingError(\n      `used '${stringifyDataType(\n        dataTypeOfConditionExpression,\n      )}' in first operand of conditional expression where scalar is required`,\n    );\n  }\n\n  const dataTypeOfTrueOperand = getDataTypeOfExpression({\n    expression: processedTrueExpression,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n  const dataTypeOfFalseOperand = getDataTypeOfExpression({\n    expression: processedFalseExpression,\n    convertArrayToPointer: true,\n    convertFunctionToPointer: true,\n  });\n  // check 2nd and 3rd operand constraints\n  if (\n    !(\n      (isArithmeticDataType(dataTypeOfTrueOperand) &&\n        isArithmeticDataType(dataTypeOfFalseOperand)) ||\n      checkDataTypeCompatibility(\n        dataTypeOfTrueOperand,\n        dataTypeOfFalseOperand,\n        true,\n      ) ||\n      (isPointer(dataTypeOfTrueOperand) &&\n        (isNullPointerConstant(processedFalseExpression) ||\n          isVoidPointer(dataTypeOfFalseOperand))) ||\n      (isPointer(dataTypeOfFalseOperand) &&\n        (isNullPointerConstant(processedTrueExpression) ||\n          isVoidPointer(dataTypeOfTrueOperand)))\n    )\n  ) {\n    throw new ProcessingError(\n      `type mismatch in conditional expression (have '${stringifyDataType(\n        dataTypeOfTrueOperand,\n      )}' and '${stringifyDataType(dataTypeOfFalseOperand)}')`,\n    );\n  }\n}\n","/**\n * WAT Generator module for generating a WAT string from WAT AST.\n */\nimport { calculateNumberOfPagesNeededForBytes } from \"~src/common/utils\";\nimport { WasmModule } from \"~src/translator/wasm-ast/core\";\nimport { FUNCTION_TYPE_LABEL } from \"~src/wat-generator/constants\";\nimport generateWatExpression from \"~src/wat-generator/generateWatExpression\";\nimport generateWatStatement from \"~src/wat-generator/generateWatStatement\";\nimport { generateLine } from \"~src/wat-generator/util\";\n\nexport function generateWat(module: WasmModule, baseIndentation: number = 0) {\n  let watStr = generateLine(\"(module\", baseIndentation);\n\n  // add the memory import\n  watStr += generateLine(\n    `(import \"js\" \"mem\" (memory ${calculateNumberOfPagesNeededForBytes(\n      module.dataSegmentSize,\n    )}))`,\n    baseIndentation + 1,\n  );\n\n  // add the imported functions\n  for (const importedFunction of module.importedFunctions) {\n    watStr += generateLine(\n      `(import ${importedFunction.importPath\n        .map((s) => `\"${s}\"`)\n        .join(\" \")} (func $${importedFunction.name}${\n        importedFunction.wasmParamTypes.length > 0\n          ? \" \" +\n            importedFunction.wasmParamTypes\n              .map((param) => `(param ${param})`)\n              .join(\" \")\n          : \"\"\n      }${\n        importedFunction.returnWasmTypes.length > 0\n          ? \" \" +\n            importedFunction.returnWasmTypes\n              .map((r) => `(result ${r})`)\n              .join(\" \")\n          : \"\"\n      }))`,\n      baseIndentation + 1,\n    );\n  }\n\n  for (const importedGlobal of module.importedGlobalWasmVariables) {\n    watStr += generateLine(\n      `(global $${importedGlobal.name} (import \"js\" \"${\n        importedGlobal.name\n      }\") (${importedGlobal.isConst ? \"\" : \"mut\"} ${\n        importedGlobal.wasmDataType\n      }))`,\n      baseIndentation + 1,\n    );\n  }\n\n  // add the table of functions\n  watStr += generateLine(\n    `(import \"js\" \"function_table\" (table ${module.functionTable.size} funcref))`,\n    baseIndentation + 1,\n  );\n\n  // add all the wasm global variable declarations\n  for (const global of module.globalWasmVariables) {\n    watStr += generateLine(\n      `(global $${global.name} (${global.isConst ? \"\" : \"mut\"} ${\n        global.wasmDataType\n      }) ${\n        global.initializerValue\n          ? generateWatExpression(global.initializerValue)\n          : \"\"\n      })`,\n      baseIndentation + 1,\n    );\n  }\n\n  // add all the global variables (in linear memory) intiializations\n  watStr += generateLine(\n    `(data (i32.const 0) \"${module.dataSegmentByteStr}\")`,\n    baseIndentation + 1,\n  );\n\n  // add the type of all user defined functions (to wasm the functions simply take no params, no return (memory model handles these))\n  watStr += generateLine(\n    `(type ${FUNCTION_TYPE_LABEL} (func))`,\n    baseIndentation + 1,\n  );\n\n  // add all functions into the table\n  for (const f of module.functionTable.elements) {\n    watStr += generateLine(\n      `(elem (i32.const ${f.index}) $${f.functionName})`,\n      baseIndentation + 1,\n    );\n  }\n\n  // add all the function definitions\n  for (const functionName of Object.keys(module.functions)) {\n    const func = module.functions[functionName];\n    watStr += generateLine(`(func $${func.name}`, baseIndentation + 1);\n    for (const statement of func.body) {\n      watStr += generateLine(\n        generateWatStatement(statement),\n        baseIndentation + 2,\n      );\n    }\n    watStr += generateLine(\")\", baseIndentation + 1);\n  }\n\n  watStr += generateLine(\"(start $main)\", 1);\n  watStr += generateLine(\")\", 0);\n  return watStr;\n}\n","export const FUNCTION_TYPE_LABEL = \"$func_type\";\nexport const FUNCTION_TABLE_NAME = \"function_table\"; // table name for exporting table of functions of wasm module\n","import { WatGeneratorError, toJson } from \"~src/errors\";\nimport { WasmExpression } from \"~src/translator/wasm-ast/core\";\nimport {\n  generateStatementsList,\n  getWasmMemoryLoadInstruction,\n} from \"~src/wat-generator/util\";\n\nexport default function generateWatExpression(node: WasmExpression): string {\n  if (node.type === \"IntegerConst\") {\n    return `(${node.wasmDataType}.const ${node.value.toString()})`;\n  } else if (node.type === \"FloatConst\") {\n    let valueStr = node.value.toString();\n    if (node.value === Infinity) {\n      // special handling for infinity values\n      valueStr = \"inf\";\n    }\n    return `(${node.wasmDataType}.const ${valueStr})`;\n  } else if (node.type === \"LocalGet\") {\n    return `(local.get $${node.name}})`;\n  } else if (node.type === \"GlobalGet\") {\n    return `(global.get $${node.name})`;\n  } else if (node.type === \"BinaryExpression\") {\n    return `(${node.instruction} ${generateWatExpression(\n      node.leftExpr,\n    )} ${generateWatExpression(node.rightExpr)})`;\n  } else if (node.type === \"BooleanExpression\") {\n    if (node.isNegated) {\n      return `(${node.wasmDataType}.eq (${\n        node.wasmDataType\n      }.const 0) ${generateWatExpression(node.expr)})`;\n    } else {\n      return `(${node.wasmDataType}.ne (${\n        node.wasmDataType\n      }.const 0) ${generateWatExpression(node.expr)})`;\n    }\n  } else if (node.type === \"MemorySize\") {\n    return \"(memory.size)\";\n  } else if (node.type === \"MemoryLoad\") {\n    return `(${getWasmMemoryLoadInstruction(\n      node.wasmDataType,\n      node.numOfBytes,\n    )} ${generateWatExpression(node.addr)})`;\n  } else if (node.type === \"NumericWrapper\") {\n    return `(${node.instruction} ${generateWatExpression(node.expr)})`;\n  } else if (node.type === \"NegateFloatExpression\") {\n    return `(${node.wasmDataType}.neg ${node.expr})`;\n  } else if (node.type === \"PostStatementExpression\") {\n    return `${generateWatExpression(node.expr)} ${generateStatementsList(\n      node.statements,\n    )}`;\n  } else if (node.type === \"PreStatementExpression\") {\n    return `${generateStatementsList(node.statements)} ${generateWatExpression(\n      node.expr,\n    )}`;\n  } else if (node.type === \"ConditionalExpression\") {\n    return `(if (result ${node.wasmDataType}) ${generateWatExpression(\n      node.condition,\n    )} (then ${generateWatExpression(\n      node.trueExpression,\n    )}) (else ${generateWatExpression(node.falseExpression)}))`;\n  } else {\n    throw new WatGeneratorError(`Unhandled WAT AST node: ${toJson(node)}`);\n  }\n}\n","/**\n * Utility functions for WAT generation.\n */\n\nimport { REG_2, REG_F32, REG_F64, REG_I64 } from \"~src/translator/memoryUtil\";\nimport { WasmBranchTable } from \"~src/translator/wasm-ast/control\";\nimport { WasmExpression, WasmStatement } from \"~src/translator/wasm-ast/core\";\nimport { WasmDataType } from \"~src/translator/wasm-ast/dataTypes\";\nimport generateWatExpression from \"~src/wat-generator/generateWatExpression\";\nimport generateWatStatement from \"~src/wat-generator/generateWatStatement\";\n\n/**\n * Function that returns a line in wat file with given level of identation & ending with newline.\n */\nexport function generateLine(line: string, indentation: number) {\n  return \"\\t\".repeat(indentation) + line + \"\\n\";\n}\n\n/**\n * Function that takes a block of strings (newline separated lines) and indents them with given indentation.\n */\nexport function generateBlock(block: string, indentation: number) {\n  let watStr = \"\";\n  for (const line of block.split(\"\\n\")) {\n    watStr += generateLine(line, indentation);\n  }\n  return watStr;\n}\n\n/**\n * Returns the appropriate memory instruction for a memory load.\n * TODO: support unsigned types in future.\n */\nexport function getWasmMemoryLoadInstruction(\n  varType: WasmDataType,\n  numOfBytes: number,\n) {\n  if (\n    ((varType === \"i32\" || varType === \"f32\") && numOfBytes === 4) ||\n    ((varType === \"i64\" || varType === \"f64\") && numOfBytes === 8)\n  ) {\n    return `${varType}.load`;\n  }\n  return `${varType}.load${(numOfBytes * 8).toString()}_s`;\n}\n\nexport function getWasmMemoryStoreInstruction(\n  varType: WasmDataType,\n  numOfBytes: number,\n) {\n  if (\n    ((varType === \"i32\" || varType === \"f32\") && numOfBytes === 4) ||\n    ((varType === \"i64\" || varType === \"f64\") && numOfBytes === 8)\n  ) {\n    return `${varType}.store`;\n  }\n  return `${varType}.store${(numOfBytes * 8).toString()}`;\n}\n\n/**\n * Returns string of argument expressions that are provided to function calls, or certain instructions like add.\n * Basically any instruction that needs to read multiple variables from the stack can use this function to conveniently attach all\n * the subexpressions that form the stack values.\n */\nexport function generateArgString(exprs: WasmExpression[]) {\n  if (exprs.length === 0) {\n    return \"\";\n  }\n  let argsStr = \"\";\n  for (const arg of exprs) {\n    argsStr += generateWatExpression(arg) + \" \";\n  }\n  return \" \" + argsStr.trim();\n}\n\n/**\n * Given an array of WASM statement AST nodes, returns a list of WAT statements.\n */\nexport function generateStatementsList(statements: WasmStatement[]) {\n  return statements.map((s) => generateWatStatement(s)).join(\" \");\n}\n\nexport function generateBranchTableInstruction(branchTable: WasmBranchTable) {\n  let indexes = \"\";\n  for (let i = 0; i <= branchTable.maxIndex; ++i) {\n    indexes += `${i} `;\n  }\n  return `(br_table ${indexes}${generateWatExpression(\n    branchTable.indexExpression,\n  )})`;\n}\n\n/**\n * Returns the name of temp psuedo register for storing temp value of given wasm data type.\n */\nexport function getTempRegister(wasmDataType: WasmDataType) {\n  switch (wasmDataType) {\n    case \"i32\":\n      return REG_2;\n    case \"i64\":\n      return REG_I64;\n    case \"f32\":\n      return REG_F32;\n    case \"f64\":\n      return REG_F64;\n  }\n}\n","import { WatGeneratorError, toJson } from \"~src/errors\";\nimport { WasmSelectionStatement } from \"~src/translator/wasm-ast/control\";\nimport { WasmStatement } from \"~src/translator/wasm-ast/core\";\nimport { FUNCTION_TYPE_LABEL } from \"~src/wat-generator/constants\";\nimport generateWatExpression from \"~src/wat-generator/generateWatExpression\";\nimport {\n  generateStatementsList,\n  generateArgString,\n  getWasmMemoryStoreInstruction,\n  generateBranchTableInstruction,\n  getTempRegister,\n} from \"~src/wat-generator/util\";\n\n/**\n * Generates the WAT from given AST node. Only to be used for nodes within a function body.\n */\nexport default function generateWatStatement(node: WasmStatement): string {\n  if (node.type === \"GlobalSet\") {\n    return `(global.set $${node.name} ${generateWatExpression(node.value)})`;\n  } else if (node.type === \"LocalSet\") {\n    return `(local.set $${node.name} ${generateWatExpression(node.value)})`;\n  } else if (node.type === \"FunctionCall\") {\n    return `(call $${node.name} ${generateStatementsList(\n      node.stackFrameSetup,\n    )}) ${generateStatementsList(node.stackFrameTearDown)}`;\n  } else if (node.type === \"IndirectFunctionCall\") {\n    return `(call_indirect (type ${FUNCTION_TYPE_LABEL}) ${generateWatExpression(\n      node.index,\n    )} ${generateStatementsList(\n      node.stackFrameSetup,\n    )}) ${generateStatementsList(node.stackFrameTearDown)}`;\n  } else if (node.type === \"RegularFunctionCall\") {\n    return `(call $${node.name}${generateArgString(node.args)})`;\n  } else if (node.type === \"SelectionStatement\") {\n    const n = node as WasmSelectionStatement;\n    return `(if ${generateWatExpression(n.condition)} (then ${n.actions\n      .map((action) => generateWatStatement(action))\n      .join(\" \")})${\n      n.elseStatements.length > 0\n        ? \" (else\" +\n          n.elseStatements\n            .map((statement) => generateWatStatement(statement))\n            .join(\" \") +\n          \")\"\n        : \"\"\n    })`;\n  } else if (node.type === \"ReturnStatement\") {\n    return `(return)`;\n  } else if (node.type === \"Loop\") {\n    return `(loop $${node.label}${\n      node.body.length > 0\n        ? \" \" + node.body.map((line) => generateWatStatement(line)).join(\" \")\n        : \"\"\n    })`;\n  } else if (node.type === \"Block\") {\n    return `(block $${node.label}${\n      node.body.length > 0\n        ? \" \" + node.body.map((line) => generateWatStatement(line)).join(\" \")\n        : \"\"\n    })`;\n  } else if (node.type === \"Branch\") {\n    return `(br $${node.label})`;\n  } else if (node.type === \"BranchIf\") {\n    return `(br_if $${node.label} ${generateWatExpression(node.condition)})`;\n  } else if (node.type === \"MemoryGrow\") {\n    return `(drop (memory.grow ${generateWatExpression(node.pagesToGrowBy)}))`;\n  } else if (node.type === \"MemoryStore\") {\n    return `(${getWasmMemoryStoreInstruction(\n      node.wasmDataType,\n      node.numOfBytes,\n    )} ${generateWatExpression(node.addr)} ${generateWatExpression(\n      node.value,\n    )})`;\n  } else if (node.type === \"MemoryStoreFromWasmStack\") {\n    // need to use psuedoregister R2 to temporarily store value from virtual stack,\n    // then put store address on virtual stack followed by loading from psuedoregister R2.\n    // This is needed to provide the intsructions in correct order to store instruction.\n    return `(${getWasmMemoryStoreInstruction(\n      node.wasmDataType,\n      node.numOfBytes,\n    )} (global.set $${getTempRegister(\n      node.wasmDataType,\n    )}) ${generateWatExpression(node.addr)} (global.get $${getTempRegister(\n      node.wasmDataType,\n    )}))`;\n  } else if (node.type === \"BranchTable\") {\n    return generateBranchTableInstruction(node);\n  } else if (node.type === \"Nop\") {\n    return \"(nop)\";\n  } else {\n    throw new WatGeneratorError(`Unhandled statement: ${toJson(node)}`);\n  }\n}\n","import wabt from \"wabt\";\n\nexport async function compileWatToWasm(wat: string): Promise<Uint8Array> {\n  const w = await wabt();\n  return w.parseWat(\"a\", wat).toBinary({}).buffer;\n}\n","/**\n * Translator module which performs translation of C AST to WAT AST.\n */\nimport {\n  createWasmFunctionTable,\n  setPseudoRegisters,\n} from \"~src/translator/util\";\nimport { WasmModule } from \"~src/translator/wasm-ast/core\";\nimport translateFunction from \"~src/translator/translateFunction\";\nimport { CAstRootP } from \"~src/processor/c-ast/core\";\nimport processIncludedModules from \"~src/translator/processImportedFunctions\";\nimport ModuleRepository from \"~src/modules\";\n\nexport default function translate(\n  CAstRoot: CAstRootP,\n  moduleRepository: ModuleRepository,\n) {\n  const wasmRoot: WasmModule = {\n    type: \"Module\",\n    dataSegmentByteStr: CAstRoot.dataSegmentByteStr, // byte str to set the data segment to\n    globalWasmVariables: [], // actual wasm global variables -  used for pseudo registers\n    importedGlobalWasmVariables: [],\n    functions: {},\n    dataSegmentSize: CAstRoot.dataSegmentSizeInBytes,\n    importedFunctions: [],\n    functionTable: createWasmFunctionTable(CAstRoot.functionTable),\n  };\n\n  const processedImportedFunctions = processIncludedModules(\n    moduleRepository,\n    CAstRoot.externalFunctions,\n  );\n\n  wasmRoot.importedFunctions = processedImportedFunctions.functionImports;\n  // add function wrappers of imported functions\n  processedImportedFunctions.wrappedFunctions.forEach((wrappedFunction) => {\n    wasmRoot.functions[wrappedFunction.name] = wrappedFunction;\n  });\n\n  CAstRoot.functions.forEach((func) => {\n    wasmRoot.functions[func.name] = translateFunction(func);\n  });\n\n  setPseudoRegisters(wasmRoot);\n\n  return wasmRoot;\n}\n","/**\n * Various utility functions with different uses will be defined here.\n */\n\nimport { WasmDataType, WasmIntType } from \"~src/translator/wasm-ast/dataTypes\";\nimport { WasmModule } from \"~src/translator/wasm-ast/core\";\nimport {\n  STACK_POINTER,\n  BASE_POINTER,\n  HEAP_POINTER,\n  REG_1,\n  REG_2,\n  WASM_ADDR_TYPE,\n  REG_I64,\n  REG_F32,\n  REG_F64,\n} from \"~src/translator/memoryUtil\";\n\nimport { MemoryVariableByteSize } from \"~src/translator/wasm-ast/memory\";\nimport { ArithemeticUnaryOperator } from \"~src/common/types\";\nimport { DataType } from \"~src/parser/c-ast/dataTypes\";\nimport { priamryCDataTypeToWasmType } from \"./dataTypeUtil\";\nimport { WasmIntegerConst } from \"~src/translator/wasm-ast/consts\";\nimport { TranslationError, toJson } from \"~src/errors\";\nimport { WasmBooleanExpression } from \"~src/translator/wasm-ast/expressions\";\nimport { ExpressionP } from \"~src/processor/c-ast/core\";\nimport translateExpression from \"~src/translator/translateExpression\";\nimport { FunctionTable } from \"~src/processor/symbolTable\";\nimport { WasmFunctionTable } from \"~src/translator/wasm-ast/functionTable\";\n\n/**\n * Converts a given unary opeartor to its corresponding binary operator\n */\nexport function arithmeticUnaryOperatorToInstruction(\n  op: ArithemeticUnaryOperator,\n  dataType: DataType,\n) {\n  if (dataType.type === \"primary\") {\n    return `${priamryCDataTypeToWasmType[dataType.primaryDataType]}.${\n      op === \"++\" ? \"add\" : \"sub\"\n    }`;\n  } else if (dataType.type === \"pointer\") {\n    return `${WASM_ADDR_TYPE}.${op === \"++\" ? \"add\" : \"sub\"}`;\n  } else {\n    // arithmetic is not defined for non ints or non pointers\n    throw new TranslationError(\n      `arithmeticUnaryOperatorToInstruction(): Unsupported variable type: ${toJson(\n        dataType,\n      )}`,\n    );\n  }\n}\n\n// Maps wasm type to number of bytes it uses\nexport const wasmTypeToSize: Record<WasmDataType, MemoryVariableByteSize> = {\n  i32: 4,\n  i64: 8,\n  f32: 4,\n  f64: 8,\n};\n\n/**\n * Creates the global wasm variables that act as psuedo-registers.\n * @param wasmRoot\n * @param stackPreallocate the amount of space in bytes to preallocate before intitial stack pointer position\n * @param dataSegmentSize the size of the data segment in memory\n */\nexport function setPseudoRegisters(wasmRoot: WasmModule) {\n  // imported from JS runtime\n  wasmRoot.importedGlobalWasmVariables.push({\n    type: \"ImportedGlobalVariable\",\n    name: STACK_POINTER,\n    wasmDataType: \"i32\",\n  });\n\n  wasmRoot.importedGlobalWasmVariables.push({\n    type: \"ImportedGlobalVariable\",\n    name: BASE_POINTER,\n    wasmDataType: \"i32\",\n  });\n\n  // heap segment follows immediately after data segment\n  // imported from JS runtime\n  wasmRoot.importedGlobalWasmVariables.push({\n    type: \"ImportedGlobalVariable\",\n    name: HEAP_POINTER,\n    wasmDataType: \"i32\",\n  });\n\n  wasmRoot.globalWasmVariables.push({\n    type: \"GlobalVariable\",\n    name: REG_1,\n    wasmDataType: \"i32\",\n    initializerValue: {\n      type: \"IntegerConst\",\n      wasmDataType: \"i32\",\n      value: 0n,\n    },\n  });\n\n  wasmRoot.globalWasmVariables.push({\n    type: \"GlobalVariable\",\n    name: REG_2,\n    wasmDataType: \"i32\",\n    initializerValue: {\n      type: \"IntegerConst\",\n      wasmDataType: \"i32\",\n      value: 0n,\n    },\n  });\n\n  wasmRoot.globalWasmVariables.push({\n    type: \"GlobalVariable\",\n    name: REG_I64,\n    wasmDataType: \"i64\",\n    initializerValue: {\n      type: \"IntegerConst\",\n      wasmDataType: \"i64\",\n      value: 0n,\n    },\n  });\n\n  wasmRoot.globalWasmVariables.push({\n    type: \"GlobalVariable\",\n    name: REG_F32,\n    wasmDataType: \"f32\",\n    initializerValue: {\n      type: \"FloatConst\",\n      wasmDataType: \"f32\",\n      value: 0,\n    },\n  });\n\n  wasmRoot.globalWasmVariables.push({\n    type: \"GlobalVariable\",\n    name: REG_F64,\n    wasmDataType: \"f64\",\n    initializerValue: {\n      type: \"FloatConst\",\n      wasmDataType: \"f64\",\n      value: 0,\n    },\n  });\n}\n\n/**\n * Returns a WasmIntegerConst node that contains maximum integer value for either i32 or i64 type.\n * Used for negating integer types.\n */\nexport function getMaxIntConstant(intType: \"i32\" | \"i64\"): WasmIntegerConst {\n  if (intType === \"i32\") {\n    return {\n      type: \"IntegerConst\",\n      value: 4294967295n,\n      wasmDataType: \"i32\",\n    };\n  } else {\n    return {\n      type: \"IntegerConst\",\n      value: 18446744073709551615n,\n      wasmDataType: \"i64\",\n    };\n  }\n}\n\n/**\n * Translate an expression that is expected to be a boolean value.\n */\nexport function createWasmBooleanExpression(\n  expression: ExpressionP,\n  isNegated?: boolean,\n): WasmBooleanExpression {\n  return {\n    type: \"BooleanExpression\",\n    expr: translateExpression(expression, \"signed int\"),\n    wasmDataType: \"i32\",\n    isNegated,\n  };\n}\n\nexport function createIntegerConst(\n  value: number,\n  wasmDataType: WasmIntType,\n): WasmIntegerConst {\n  return {\n    type: \"IntegerConst\",\n    wasmDataType,\n    value: BigInt(value),\n  };\n}\n\nexport function createWasmFunctionTable(\n  functionTable: FunctionTable,\n): WasmFunctionTable {\n  const wasmFunctionTable: WasmFunctionTable = {\n    elements: [],\n    size: functionTable.length,\n  };\n  functionTable.forEach((f, index) => {\n    if (f.isDefined) {\n      wasmFunctionTable.elements.push({ functionName: f.functionName, index });\n    }\n  });\n  return wasmFunctionTable;\n}\n","/**\n * Defines functions for evaluating C AST expression nodes and converting them to corresponding WAT AST nodes.\n */\n\nimport { POINTER_TYPE, WASM_ADDR_SIZE } from \"~src/common/constants\";\nimport { ScalarCDataType } from \"~src/common/types\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport { TranslationError, toJson } from \"~src/errors\";\nimport { ExpressionP } from \"~src/processor/c-ast/core\";\nimport {\n  convertConstantToWasmConst,\n  convertScalarDataTypeToWasmType,\n  getTypeConversionWrapper,\n} from \"~src/translator/dataTypeUtil\";\nimport { EnclosingLoopDetails } from \"~src/translator/loopUtil\";\nimport {\n  basePointerGetNode,\n  getRegisterPointerArithmeticNode,\n} from \"~src/translator/memoryUtil\";\nimport translateBinaryExpression, {\n  getBinaryExpressionInstruction,\n} from \"~src/translator/translateBinaryExpression\";\nimport translateStatement from \"~src/translator/translateStatement\";\nimport translateUnaryExpression from \"~src/translator/translateUnaryExpression\";\nimport { createWasmBooleanExpression } from \"~src/translator/util\";\nimport { WasmExpression } from \"~src/translator/wasm-ast/core\";\n\n/**\n * Evaluates a given C expression and returns the corresponding WASM expression.\n */\nexport default function translateExpression(\n  expr: ExpressionP,\n  targetType: ScalarCDataType, // the wasm type that is expected for the result of this expression\n  enclosingLoopDetails?: EnclosingLoopDetails,\n): WasmExpression {\n  function translateExpressionHelper(): WasmExpression {\n    if (expr.type === \"BinaryExpression\") {\n      return translateBinaryExpression(expr, enclosingLoopDetails);\n    } else if (\n      expr.type === \"IntegerConstant\" ||\n      expr.type === \"FloatConstant\"\n    ) {\n      return convertConstantToWasmConst(expr);\n    } else if (expr.type === \"PreStatementExpression\") {\n      return {\n        type: \"PreStatementExpression\",\n        statements: expr.statements.map((statement) =>\n          translateStatement(statement, enclosingLoopDetails),\n        ),\n        expr: translateExpression(\n          expr.expr,\n          expr.expr.dataType,\n          enclosingLoopDetails,\n        ),\n      };\n    } else if (expr.type === \"PostStatementExpression\") {\n      return {\n        type: \"PostStatementExpression\",\n        statements: expr.statements.map((statement) =>\n          translateStatement(statement, enclosingLoopDetails),\n        ),\n        expr: translateExpression(\n          expr.expr,\n          expr.expr.dataType,\n          enclosingLoopDetails,\n        ),\n      };\n    } else if (expr.type === \"UnaryExpression\") {\n      return translateUnaryExpression(expr, enclosingLoopDetails);\n    } else if (expr.type === \"DataSegmentAddress\") {\n      // since data segment starts at memory address 0, simply return the offset expression\n      return translateExpression(\n        expr.offset,\n        expr.offset.dataType,\n        enclosingLoopDetails,\n      );\n    } else if (expr.type === \"LocalAddress\") {\n      // the locals start at BP\n      return {\n        type: \"BinaryExpression\",\n        leftExpr: basePointerGetNode,\n        rightExpr: translateExpression(\n          expr.offset,\n          expr.offset.dataType,\n          enclosingLoopDetails,\n        ),\n        instruction: getBinaryExpressionInstruction(\"+\", \"pointer\"),\n      };\n    } else if (expr.type === \"DynamicAddress\") {\n      return translateExpression(\n        expr.address,\n        expr.address.dataType,\n        enclosingLoopDetails,\n      );\n    } else if (expr.type === \"ReturnObjectAddress\") {\n      if (expr.subtype === \"store\") {\n        return getRegisterPointerArithmeticNode(\n          \"bp\",\n          \"+\",\n          WASM_ADDR_SIZE + Number(expr.offset.value),\n        );\n      } else {\n        return getRegisterPointerArithmeticNode(\n          \"sp\",\n          \"+\",\n          Number(expr.offset.value),\n        );\n      }\n    } else if (expr.type === \"MemoryLoad\") {\n      return {\n        type: \"MemoryLoad\",\n        addr: translateExpression(\n          expr.address,\n          expr.address.dataType,\n          enclosingLoopDetails,\n        ),\n        wasmDataType: convertScalarDataTypeToWasmType(expr.dataType),\n        numOfBytes: getSizeOfScalarDataType(expr.dataType),\n      };\n    } else if (expr.type === \"ConditionalExpression\") {\n      return {\n        type: \"ConditionalExpression\",\n        condition: createWasmBooleanExpression(expr.condition),\n        trueExpression: translateExpression(\n          expr.trueExpression,\n          expr.dataType,\n          enclosingLoopDetails,\n        ),\n        falseExpression: translateExpression(\n          expr.falseExpression,\n          expr.dataType,\n          enclosingLoopDetails,\n        ),\n        wasmDataType: convertScalarDataTypeToWasmType(expr.dataType),\n      };\n    } else if (expr.type === \"FunctionTableIndex\") {\n      return translateExpression(\n        expr.index,\n        POINTER_TYPE,\n        enclosingLoopDetails,\n      ); // translate the underlying integer constant\n    } else {\n      throw new TranslationError(`Unhandled expression: ${toJson(expr)}`);\n    }\n  }\n\n  // add any type conversion wrapper on the WasmExpression node if needed\n  return getTypeConversionWrapper(\n    expr.dataType,\n    targetType,\n    translateExpressionHelper(),\n  );\n}\n","/**\n * Translate a binary expression into corresponding WAT AST nodes based on operator.\n */\n\nimport { BinaryOperator, ScalarCDataType } from \"~src/common/types\";\nimport { isUnsignedIntegerType, isSignedIntegerType } from \"~src/common/utils\";\nimport translateExpression from \"~src/translator/translateExpression\";\nimport { convertScalarDataTypeToWasmType } from \"./dataTypeUtil\";\nimport { WasmBinaryExpression } from \"~src/translator/wasm-ast/expressions\";\nimport { BinaryExpressionP } from \"~src/processor/c-ast/expression/expressions\";\nimport { EnclosingLoopDetails } from \"~src/translator/loopUtil\";\n\nexport default function translateBinaryExpression(\n  binaryExpr: BinaryExpressionP,\n  enclosingLoopDetails?: EnclosingLoopDetails,\n): WasmBinaryExpression {\n  // special handling for && and || since wasm does not have native instructions for these operations\n  if (binaryExpr.operator === \"&&\" || binaryExpr.operator === \"||\") {\n    // need to convert the left and right expr to boolean expression (1 or 0) before doing bitwise AND or OR\n    return {\n      type: \"BinaryExpression\",\n      leftExpr: {\n        type: \"BooleanExpression\",\n        expr: translateExpression(\n          binaryExpr.leftExpr,\n          binaryExpr.leftExpr.dataType,\n          enclosingLoopDetails,\n        ),\n        wasmDataType: convertScalarDataTypeToWasmType(\n          binaryExpr.leftExpr.dataType,\n        ),\n      },\n      rightExpr: {\n        type: \"BooleanExpression\",\n        expr: translateExpression(\n          binaryExpr.rightExpr,\n          binaryExpr.rightExpr.dataType,\n          enclosingLoopDetails,\n        ),\n        wasmDataType: convertScalarDataTypeToWasmType(\n          binaryExpr.rightExpr.dataType,\n        ),\n      },\n      instruction: getBinaryExpressionInstruction(\n        binaryExpr.operator,\n        binaryExpr.dataType,\n      ),\n    };\n  }\n\n  return {\n    type: \"BinaryExpression\",\n    // perform implicit arithmetic type conversions\n    leftExpr: translateExpression(\n      binaryExpr.leftExpr,\n      binaryExpr.operandTargetDataType,\n      enclosingLoopDetails,\n    ),\n    rightExpr: translateExpression(\n      binaryExpr.rightExpr,\n      binaryExpr.operandTargetDataType,\n      enclosingLoopDetails,\n    ),\n    instruction: getBinaryExpressionInstruction(\n      binaryExpr.operator,\n      binaryExpr.operandTargetDataType,\n    ),\n  };\n}\n\nconst binaryOperatorToInstructionMap: Record<BinaryOperator, string> = {\n  \"+\": \"add\",\n  \"-\": \"sub\",\n  \"*\": \"mul\",\n  \"/\": \"div\",\n  \"%\": \"rem\",\n  \"<\": \"lt\",\n  \"<=\": \"le\",\n  \"!=\": \"ne\",\n  \"==\": \"eq\",\n  \">=\": \"ge\",\n  \">\": \"gt\",\n  \"&&\": \"and\",\n  \"||\": \"or\",\n  \"&\": \"and\",\n  \"|\": \"or\",\n  \"<<\": \"shl\",\n  \">>\": \"shr\",\n  \"^\": \"xor\",\n};\n\nconst signedUnsignedVariantOps = [\"div\", \"rem\", \"lt\", \"le\", \"gt\", \"ge\", \"shr\"];\n\nfunction isOperationWithUnsignedSignedVariant(op: string) {\n  return signedUnsignedVariantOps.includes(op);\n}\n\n/**\n * Returns the correct WAT binary instruction, given a binary operator.\n * Takes the dataType into account, as certain integer operations have signed and unsigned variant.\n */\nexport function getBinaryExpressionInstruction(\n  operator: BinaryOperator,\n  dataType: ScalarCDataType,\n) {\n  const op = binaryOperatorToInstructionMap[operator];\n\n  const instruction = `${convertScalarDataTypeToWasmType(dataType)}.${op}`;\n  if (isOperationWithUnsignedSignedVariant(op)) {\n    // these instructions have unsigned vs signed variants for integers\n    if (isUnsignedIntegerType(dataType) || dataType === \"pointer\") {\n      return instruction + \"_u\";\n    }\n\n    if (isSignedIntegerType(dataType)) {\n      return instruction + \"_s\";\n    }\n\n    // floats have no sign prefix\n    return instruction;\n  }\n\n  return instruction;\n}\n","import { TranslationError } from \"~src/errors\";\nimport { StatementP } from \"~src/processor/c-ast/core\";\nimport translateExpression from \"~src/translator/translateExpression\";\nimport translateFunctionCall from \"~src/translator/translateFunctionCall\";\nimport { createWasmBooleanExpression } from \"~src/translator/util\";\nimport { WasmStatement } from \"~src/translator/wasm-ast/core\";\nimport {\n  EnclosingLoopDetails,\n  createEnclosingLoopDetails,\n  generateBlockLabel,\n  generateLoopLabel,\n} from \"~src/translator/loopUtil\";\nimport { convertScalarDataTypeToWasmType } from \"~src/translator/dataTypeUtil\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport { FUNCTION_BLOCK_LABEL } from \"~src/translator/constants\";\nimport translateSwitchStatement from \"~src/translator/translateSwitchStatement\";\n\n/**\n * Visitor function for visting StatementP nodes and translating them to statements to add to enclosingBody.\n * @param statement node being visited.\n * @returns the translated wasm statements\n */\nexport default function translateStatement(\n  statement: StatementP,\n  enclosingLoopDetails?: EnclosingLoopDetails, // the loop labelname of the loop enclosing this statement Used to translate break statements.\n): WasmStatement {\n  if (statement.type === \"MemoryStore\") {\n    return {\n      type: \"MemoryStore\",\n      addr: translateExpression(\n        statement.address,\n        statement.address.dataType,\n        enclosingLoopDetails,\n      ),\n      value: translateExpression(\n        statement.value,\n        statement.dataType,\n        enclosingLoopDetails,\n      ),\n      wasmDataType: convertScalarDataTypeToWasmType(statement.dataType),\n      numOfBytes: getSizeOfScalarDataType(statement.dataType),\n    };\n  } else if (statement.type === \"FunctionCall\") {\n    return translateFunctionCall(statement);\n  } else if (statement.type === \"SelectionStatement\") {\n    return {\n      type: \"SelectionStatement\",\n      condition: createWasmBooleanExpression(statement.condition),\n      actions: statement.ifStatements.map((s) =>\n        translateStatement(s, enclosingLoopDetails),\n      ),\n      elseStatements: statement.elseStatements\n        ? statement.elseStatements.map((s) =>\n            translateStatement(s, enclosingLoopDetails),\n          )\n        : [],\n    };\n  } else if (statement.type === \"DoWhileLoop\") {\n    const newEnclosingLoopDetails =\n      createEnclosingLoopDetails(enclosingLoopDetails);\n    const loopLabel = generateLoopLabel(newEnclosingLoopDetails);\n    const blockLabel = generateBlockLabel(newEnclosingLoopDetails);\n    const body: WasmStatement[] = statement.body.map((s) =>\n      translateStatement(s, newEnclosingLoopDetails),\n    );\n\n    body.push({\n      type: \"BranchIf\",\n      label: loopLabel,\n      condition: createWasmBooleanExpression(statement.condition),\n    });\n\n    return {\n      type: \"Block\",\n      label: blockLabel,\n      body: [\n        {\n          type: \"Loop\",\n          label: loopLabel,\n          body,\n        },\n      ],\n    };\n  } else if (statement.type === \"WhileLoop\") {\n    const newEnclosingLoopDetails =\n      createEnclosingLoopDetails(enclosingLoopDetails);\n    const loopLabel = generateLoopLabel(newEnclosingLoopDetails);\n    const blockLabel = generateBlockLabel(newEnclosingLoopDetails);\n    const negatedCondition = createWasmBooleanExpression(\n      statement.condition,\n      true,\n    );\n    const body: WasmStatement[] = [];\n\n    // branch out of the loop if the condition is not met\n    body.push({\n      type: \"BranchIf\",\n      label: blockLabel,\n      condition: negatedCondition,\n    });\n\n    statement.body.forEach((s) =>\n      body.push(translateStatement(s, newEnclosingLoopDetails)),\n    );\n\n    // add the branching statement at end of loop body\n    body.push({\n      type: \"Branch\",\n      label: loopLabel,\n    });\n\n    return {\n      type: \"Block\",\n      label: blockLabel,\n      body: [\n        {\n          type: \"Loop\",\n          label: loopLabel,\n          body,\n        },\n      ],\n    };\n  } else if (statement.type === \"ForLoop\") {\n    const newEnclosingLoopDetails =\n      createEnclosingLoopDetails(enclosingLoopDetails);\n    const loopLabel = generateLoopLabel(newEnclosingLoopDetails);\n    const blockLabel = generateBlockLabel(newEnclosingLoopDetails);\n    const negatedCondition =\n      statement.condition !== null\n        ? createWasmBooleanExpression(statement.condition, true)\n        : null;\n    const loopBody: WasmStatement[] = [];\n\n    if (negatedCondition !== null) {\n      loopBody.push({\n        type: \"BranchIf\",\n        label: blockLabel,\n        condition: negatedCondition,\n      });\n    }\n\n    // add for loop body\n    statement.body.forEach((s) =>\n      loopBody.push(translateStatement(s, newEnclosingLoopDetails)),\n    );\n\n    // add the for loop update expression\n    statement.update.forEach((s) =>\n      loopBody.push(translateStatement(s, newEnclosingLoopDetails)),\n    );\n\n    // add the branching statement at end of loop body\n    loopBody.push({\n      type: \"Branch\",\n      label: loopLabel,\n    });\n\n    const blockBody: WasmStatement[] = [];\n    // push on the clause statements\n    statement.clause.forEach((s) =>\n      blockBody.push(translateStatement(s, newEnclosingLoopDetails)),\n    );\n\n    blockBody.push({\n      type: \"Loop\",\n      label: loopLabel,\n      body: loopBody,\n    });\n\n    return {\n      type: \"Block\",\n      label: blockLabel,\n      body: blockBody,\n    };\n  } else if (statement.type === \"ReturnStatement\") {\n    // branch out of the block holding the function body\n    return {\n      type: \"Branch\",\n      label: FUNCTION_BLOCK_LABEL,\n    };\n  } else if (statement.type === \"BreakStatement\") {\n    if (typeof enclosingLoopDetails === \"undefined\") {\n      throw new TranslationError(\n        \"Break statement cannot be present outside a loop or switch body\",\n      );\n    }\n    return {\n      type: \"Branch\",\n      label: generateBlockLabel(enclosingLoopDetails),\n    };\n  } else if (statement.type === \"ContinueStatement\") {\n    if (typeof enclosingLoopDetails === \"undefined\") {\n      throw new TranslationError(\n        \"Continue statement cannot be present outside a loop body\",\n      );\n    }\n    return {\n      type: \"Branch\",\n      label: generateLoopLabel(enclosingLoopDetails),\n    };\n  } else if (statement.type === \"SwitchStatement\") {\n    // psuedo-register 2 is used for holding the switch block index\n    return translateSwitchStatement(statement);\n  } else if (statement.type === \"ExpressionStatement\") {\n    return {\n      type: \"Nop\",\n    };\n  } else {\n    throw new TranslationError(\"Unhandled statement\");\n  }\n}\n","/**\n * Definition of function to translate function calls.\n */\n\nimport {\n  getFunctionCallStackFrameSetupStatements,\n  getFunctionCallStackFrameTeardownStatements,\n} from \"~src/translator/memoryUtil\";\nimport translateExpression from \"~src/translator/translateExpression\";\nimport { WasmExpression } from \"~src/translator/wasm-ast/core\";\nimport {\n  WasmFunctionCall,\n  WasmIndirectFunctionCall,\n} from \"~src/translator/wasm-ast/functions\";\nimport { FunctionCallP } from \"~src/processor/c-ast/function\";\nimport { TranslationError } from \"~src/errors\";\nimport { POINTER_TYPE } from \"~src/common/constants\";\n\nexport default function translateFunctionCall(\n  node: FunctionCallP,\n): WasmFunctionCall | WasmIndirectFunctionCall {\n  // translate the arguments\n  const functionArgs: WasmExpression[] = [];\n  for (let i = 0; i < node.functionDetails.parameters.length; ++i) {\n    functionArgs.push(\n      translateExpression(\n        node.args[i],\n        node.functionDetails.parameters[i].dataType,\n      ),\n    );\n  }\n\n  const stackFrameSetup = getFunctionCallStackFrameSetupStatements(\n    node.functionDetails,\n    functionArgs,\n  );\n\n  const stackFrameTearDown = getFunctionCallStackFrameTeardownStatements(\n    node.functionDetails,\n  );\n\n  if (node.calledFunction.type === \"DirectlyCalledFunction\") {\n    return {\n      type: \"FunctionCall\",\n      name: node.calledFunction.functionName,\n      stackFrameSetup,\n      stackFrameTearDown,\n    };\n  } else if (node.calledFunction.type === \"IndirectlyCalledFunction\") {\n    return {\n      type: \"IndirectFunctionCall\",\n      index: translateExpression(\n        node.calledFunction.functionAddress,\n        POINTER_TYPE,\n      ),\n      stackFrameSetup,\n      stackFrameTearDown,\n    };\n  } else {\n    console.assert(false, \"translateFunctionCall(): unreachable block\");\n    throw new TranslationError(\"\");\n  }\n}\n","export interface EnclosingLoopDetails {\n  currLoopNumber: number; // loop label of the enclosing loop. branch to this label to restart loop. (continue / restart loop after condition still true)\n  currBlockNumber: number; // block label of the enclosing loop. branch to this label to end the loop. (break)\n}\n\nexport function createEnclosingLoopDetails(\n  prv?: EnclosingLoopDetails,\n): EnclosingLoopDetails {\n  if (typeof prv !== \"undefined\") {\n    return {\n      currLoopNumber: prv.currLoopNumber + 1,\n      currBlockNumber: prv.currBlockNumber + 1,\n    };\n  } else {\n    return {\n      currLoopNumber: 0,\n      currBlockNumber: 0,\n    };\n  }\n}\n\n/**\n * Used for generating unique names for block labels. This is needed for jumping to them in wasm.\n */\n\nexport function generateLoopLabel(\n  enclosingLoopDetails: EnclosingLoopDetails | undefined,\n) {\n  return `loop${\n    enclosingLoopDetails ? enclosingLoopDetails.currLoopNumber : 0\n  }`;\n}\n/**\n * Used for generating unique names for loop labels. This is needed for jumping to them in wasm.\n */\n\nexport function generateBlockLabel(\n  enclosingLoopDetails?: EnclosingLoopDetails | undefined,\n) {\n  return `block${\n    enclosingLoopDetails ? enclosingLoopDetails.currBlockNumber : 0\n  }`;\n}\n","export const FUNCTION_BLOCK_LABEL = \"func_block\"; //name for the block that holds entire body of each function. Used for implementing return statements.\n","import { SwitchStatementP } from \"~src/processor/c-ast/statement/selectionStatement\";\nimport {\n  EnclosingLoopDetails,\n  generateBlockLabel,\n} from \"~src/translator/loopUtil\";\nimport translateStatement from \"~src/translator/translateStatement\";\nimport {\n  createIntegerConst,\n  createWasmBooleanExpression,\n} from \"~src/translator/util\";\nimport { WasmBlock } from \"~src/translator/wasm-ast/control\";\nimport { WasmExpression, WasmStatement } from \"~src/translator/wasm-ast/core\";\n\nexport default function translateSwitchStatement(\n  switchStatement: SwitchStatementP,\n  enclosingLoopDetails?: EnclosingLoopDetails,\n): WasmStatement {\n  const numberOfBlocks =\n    switchStatement.cases.length +\n    (switchStatement.defaultStatements.length > 0 ? 1 : 0) +\n    1; // add 1 for the additional inner block that holds the branch itself\n  // construct the nested series of conditional expressions for getting correct index of block to jump to\n  const defaultExpressionIndex = createIntegerConst(numberOfBlocks - 2, \"i32\"); // the default expression index\n  let currExpression: WasmExpression = defaultExpressionIndex;\n  for (let i = switchStatement.cases.length - 1; i >= 0; --i) {\n    currExpression = {\n      type: \"ConditionalExpression\",\n      condition: createWasmBooleanExpression(\n        switchStatement.cases[i].condition,\n      ),\n      trueExpression: createIntegerConst(i, \"i32\"),\n      falseExpression: currExpression,\n      wasmDataType: \"i32\",\n    };\n  }\n\n  // start constructing the blocks\n  const brTableBlock: WasmBlock = {\n    type: \"Block\",\n    label: `switch_block_0`,\n    body: [\n      {\n        type: \"BranchTable\",\n        maxIndex: numberOfBlocks - 2,\n        indexExpression: currExpression,\n      },\n    ],\n  };\n\n  let newEnclosingLoopDetails: EnclosingLoopDetails;\n  if (enclosingLoopDetails) {\n    newEnclosingLoopDetails = {\n      currBlockNumber: enclosingLoopDetails.currBlockNumber + 1,\n      currLoopNumber: enclosingLoopDetails.currLoopNumber, // only increment the block number\n    };\n  } else {\n    newEnclosingLoopDetails = {\n      currBlockNumber: 0,\n      currLoopNumber: 0,\n    };\n  }\n\n  let currBlock: WasmBlock = brTableBlock;\n  let i = 0;\n  for (; i < switchStatement.cases.length; ++i) {\n    currBlock = {\n      type: \"Block\",\n      label: `switch_block_${i + 1}`,\n      body: [\n        currBlock,\n        ...switchStatement.cases[i].statements.map((statement) =>\n          translateStatement(statement, newEnclosingLoopDetails),\n        ),\n      ],\n    };\n  }\n\n  // add the last block for default case\n  currBlock = {\n    type: \"Block\",\n    label: generateBlockLabel(newEnclosingLoopDetails), // any break statement wil break out of this block specifically\n    body: [\n      currBlock,\n      ...switchStatement.defaultStatements.map((statement) =>\n        translateStatement(statement, newEnclosingLoopDetails),\n      ),\n    ],\n  };\n\n  return currBlock;\n}\n","/**\n * Definition of function to handle unary expressions\n */\n\nimport { isFloatType, isIntegerType } from \"~src/common/utils\";\nimport { TranslationError } from \"~src/errors\";\nimport translateExpression from \"~src/translator/translateExpression\";\nimport { convertScalarDataTypeToWasmType } from \"./dataTypeUtil\";\nimport { WasmExpression } from \"~src/translator/wasm-ast/core\";\n\nimport { UnaryExpressionP } from \"~src/processor/c-ast/expression/expressions\";\nimport { EnclosingLoopDetails } from \"~src/translator/loopUtil\";\nimport { getMaxIntConstant } from \"~src/translator/util\";\n\n/**\n * Translates a UnaryExpression into the nodes for that expression,\n * depedning on the expression dataType and operator.\n */\nexport default function translateUnaryExpression(\n  unaryExpr: UnaryExpressionP,\n  enclosingLoopDetails?: EnclosingLoopDetails,\n): WasmExpression {\n  if (unaryExpr.operator === \"-\") {\n    if (isIntegerType(unaryExpr.dataType)) {\n      return {\n        type: \"BinaryExpression\",\n        instruction:\n          convertScalarDataTypeToWasmType(unaryExpr.dataType) + \".add\",\n        leftExpr: {\n          type: \"BinaryExpression\",\n          instruction:\n            convertScalarDataTypeToWasmType(unaryExpr.dataType) + \".sub\",\n          leftExpr: getMaxIntConstant(\n            convertScalarDataTypeToWasmType(unaryExpr.dataType) as\n              | \"i32\"\n              | \"i64\",\n          ),\n          rightExpr: translateExpression(\n            unaryExpr.expr,\n            unaryExpr.dataType,\n            enclosingLoopDetails,\n          ),\n        },\n        rightExpr: {\n          type: \"IntegerConst\",\n          wasmDataType: convertScalarDataTypeToWasmType(unaryExpr.dataType) as\n            | \"i32\"\n            | \"i64\",\n          value: 1n,\n        },\n      };\n    } else if (isFloatType(unaryExpr.dataType)) {\n      return {\n        type: \"NegateFloatExpression\",\n        wasmDataType: convertScalarDataTypeToWasmType(unaryExpr.dataType) as\n          | \"f32\"\n          | \"f64\",\n        expr: translateExpression(\n          unaryExpr.expr,\n          unaryExpr.dataType,\n          enclosingLoopDetails,\n        ),\n      };\n    } else {\n      throw new TranslationError(\n        \"'-' prefix operator is only valid on arithmetic types\",\n      );\n    }\n  } else if (unaryExpr.operator === \"!\") {\n    return {\n      type: \"BooleanExpression\",\n      wasmDataType: \"i32\",\n      expr: translateExpression(\n        unaryExpr.expr,\n        unaryExpr.dataType,\n        enclosingLoopDetails,\n      ),\n      isNegated: true,\n    };\n  } else if (unaryExpr.operator === \"~\") {\n    if (!isIntegerType(unaryExpr.dataType)) {\n      // bitwise complement is undefined on non integral types\n      throw new TranslationError(\n        `Wrong type argument to bitwise-complement - type used: ${unaryExpr.dataType}`,\n      );\n    }\n\n    return {\n      type: \"BinaryExpression\",\n      leftExpr: {\n        type: \"IntegerConst\",\n        wasmDataType: convertScalarDataTypeToWasmType(unaryExpr.dataType) as\n          | \"i32\"\n          | \"i64\",\n        value: -1n,\n      },\n      rightExpr: translateExpression(\n        unaryExpr.expr,\n        unaryExpr.dataType,\n        enclosingLoopDetails,\n      ),\n      instruction: `${convertScalarDataTypeToWasmType(unaryExpr.dataType)}.xor`,\n    };\n  } else {\n    throw new TranslationError(\n      `translateUnaryExpression error: unknown unary operator: ${unaryExpr.operator}`,\n    );\n  }\n}\n","/**\n * Defines the vist function for traversing the C AST and translating into WAT-AST.\n */\n\nimport { FunctionDefinitionP } from \"~src/processor/c-ast/function\";\nimport { FUNCTION_BLOCK_LABEL } from \"~src/translator/constants\";\nimport {\n  STACK_POINTER,\n  getPointerDecrementNode,\n  getPointerIncrementNode,\n  getStackSpaceAllocationCheckStatement,\n} from \"~src/translator/memoryUtil\";\nimport translateStatement from \"~src/translator/translateStatement\";\nimport { WasmStatement } from \"~src/translator/wasm-ast/core\";\nimport { WasmFunction } from \"~src/translator/wasm-ast/functions\";\n\n/**\n * Function for trnslating a C function to a wasm function.\n * For now, expressions execpt function calls are ignored since they are inconsequential. TODO: check this\n * @param wasmRoot the wasm module itself.\n * @param Cfunction the function being translated.\n * @param rootSymbolTable the starting symbol table. contains globals.\n */\nexport default function translateFunction(\n  Cfunction: FunctionDefinitionP,\n): WasmFunction {\n  // evaluate all parameters first\n  // const params: WasmMemoryObject[] = [];\n  // Cfunction.parameters.forEach((param) => {\n  //   const localVar: WasmMemoryObject = {\n  //     type: \"LocalMemoryVariable\",\n  //     name: param.name,\n  //     offset: symbolTable.currOffset.value + getDataTypeSize(param.dataType),\n  //     dataType: param.dataType,\n  //   };\n  //   params.push(localVar);\n  //   addToSymbolTable(symbolTable, localVar);\n  // });\n\n  const functionBody: WasmStatement[] = [];\n  // add the space allocation statements for local variables to function body\n  functionBody.push(\n    getStackSpaceAllocationCheckStatement(Cfunction.sizeOfLocals),\n  );\n  functionBody.push(\n    getPointerDecrementNode(STACK_POINTER, Cfunction.sizeOfLocals),\n  );\n\n  // create a block to hold all function body statements\n  // returns will branch out of this block, so that the cleanup of stack will proceed before func exits\n  functionBody.push({\n    type: \"Block\",\n    label: FUNCTION_BLOCK_LABEL,\n    body: Cfunction.body.map((statement) => translateStatement(statement)),\n  });\n\n  // add the deallocation of locals\n  functionBody.push(\n    getPointerIncrementNode(STACK_POINTER, Cfunction.sizeOfLocals),\n  );\n\n  return {\n    type: \"Function\",\n    name: Cfunction.name,\n    body: functionBody,\n  };\n}\n","import {\n  WasmFunction,\n  WasmImportedFunction,\n  WasmRegularFunctionCall,\n} from \"~src/translator/wasm-ast/functions\";\nimport { convertScalarDataTypeToWasmType } from \"./dataTypeUtil\";\nimport { TranslationError } from \"~src/errors\";\nimport { ExternalFunction } from \"~src/processor/c-ast/core\";\nimport { unpackDataType } from \"~src/processor/dataTypeUtil\";\nimport {\n  BASE_POINTER,\n  getRegisterPointerArithmeticNode,\n} from \"~src/translator/memoryUtil\";\nimport { getSizeOfScalarDataType } from \"~src/common/utils\";\nimport { WASM_ADDR_SIZE } from \"~src/common/constants\";\nimport ModuleRepository from \"~src/modules\";\nimport { WasmDataType } from \"~src/translator/wasm-ast/dataTypes\";\n\n/**\n * Process the imported functions.\n * These functions must be wrapped within another function so that they can interface with the memory model properly.\n */\n\nexport default function processImportedFunctions(\n  moduleRepository: ModuleRepository,\n  externalCFunctions: ExternalFunction[], // external functions as defined by CAstRoot\n): {\n  functionImports: WasmImportedFunction[]; // the wasm function imports\n  wrappedFunctions: WasmFunction[]; // the wrapped imported functions (what is actually called directly by user code)\n} {\n  const functionImports: WasmImportedFunction[] = [];\n  const wrappedFunctions: WasmFunction[] = [];\n\n  for (const externalCFunction of externalCFunctions) {\n    const importedFunction =\n      moduleRepository.modules[externalCFunction.moduleName].moduleFunctions[\n        externalCFunction.name\n      ];\n\n    // need to unpack the datatype of each parameter of this external function into primary data types -> wasm types, in param order\n    // for aggregate parameters, their parameters should also remain in the same order as they were in the aggregate\n    const wasmParams: WasmDataType[] = [];\n    for (const param of importedFunction.functionType.parameters) {\n      const unpackedDataType = unpackDataType(param);\n      for (const scalarType of unpackedDataType) {\n        wasmParams.push(convertScalarDataTypeToWasmType(scalarType.dataType));\n      }\n    }\n\n    console.assert(\n      typeof importedFunction !== \"undefined\",\n      \"Translator: Imported function not found in module repository\",\n    );\n    functionImports.push({\n      name: externalCFunction.name + \"_imported\",\n      importPath: [\n        importedFunction.parentImportedObject,\n        externalCFunction.name,\n      ],\n      wasmParamTypes: wasmParams,\n      returnWasmTypes: externalCFunction.returnObjects\n        ? externalCFunction.returnObjects.map((retObj) =>\n            convertScalarDataTypeToWasmType(retObj.dataType),\n          )\n        : [],\n    });\n\n    // create the function wrapper\n    // function wrapper needs to first load up function args into virtual wasm stack from the real stack in linear memory\n    // then store the function results from virtual stack into the real stack\n    const functionWrapper: WasmFunction = {\n      type: \"Function\",\n      name: externalCFunction.name,\n      body: [],\n    };\n\n    // the actual call to the imported function that the wrapper wraps\n    const importedFunctionCall: WasmRegularFunctionCall = {\n      type: \"RegularFunctionCall\",\n      name: externalCFunction.name + \"_imported\",\n      args: [],\n    };\n\n    // load up the function args\n    let externalCFunctionParamIndex = 0;\n    for (const dataType of importedFunction.functionType.parameters) {\n      const unpackedDataType = unpackDataType(dataType); // unpack the data type into series of primary object first\n      externalCFunctionParamIndex += unpackedDataType.length; // the index of the next aggregate/primary param\n      for (let i = 0; i < unpackedDataType.length; ++i) {\n        // the primary data type param corresponding to the param\n        const correspondingExternalFunctionParam =\n          externalCFunction.parameters[externalCFunctionParamIndex - 1 - i];\n        // sanity check, should not occur\n        if (\n          unpackedDataType[i].dataType !==\n          correspondingExternalFunctionParam.dataType\n        ) {\n          throw new TranslationError(\n            `Load of function args in import function wrapper: Data type of args and param do not match: arg: '${unpackedDataType[i].dataType}' vs param: '${correspondingExternalFunctionParam.dataType}' `,\n          );\n        }\n        importedFunctionCall.args.push({\n          type: \"MemoryLoad\",\n          addr: getRegisterPointerArithmeticNode(\n            BASE_POINTER,\n            \"+\",\n            correspondingExternalFunctionParam.offset,\n          ),\n          wasmDataType: convertScalarDataTypeToWasmType(\n            correspondingExternalFunctionParam.dataType,\n          ),\n          numOfBytes: getSizeOfScalarDataType(\n            correspondingExternalFunctionParam.dataType,\n          ),\n        });\n      }\n    }\n\n    functionWrapper.body.push(importedFunctionCall);\n\n    // now all the return values of the imported function call are on the virtual wasm stack - need to load them into the real stack\n    // this needs to be done back to front, as the top of virtualstack contains the last primary data object of the return object\n    if (externalCFunction.returnObjects !== null) {\n      for (let i = externalCFunction.returnObjects.length - 1; i >= 0; --i) {\n        const returnObject = externalCFunction.returnObjects[i];\n        functionWrapper.body.push({\n          type: \"MemoryStoreFromWasmStack\",\n          addr: getRegisterPointerArithmeticNode(\n            \"bp\",\n            \"+\",\n            WASM_ADDR_SIZE + returnObject.offset,\n          ),\n          wasmDataType: convertScalarDataTypeToWasmType(returnObject.dataType),\n          numOfBytes: getSizeOfScalarDataType(returnObject.dataType),\n        });\n      }\n    }\n\n    wrappedFunctions.push(functionWrapper);\n  }\n\n  return { functionImports, wrappedFunctions };\n}\n","import { CAstRootP, CNodeP } from \"~src/processor/c-ast/core\";\nimport { CContext, Interpreter } from \"~src/interpreter/interpret\";\nimport { ModuleName, ModulesGlobalConfig } from \"~src/modules\";\nimport { ControlItem } from \"./utils/control\";\nimport {\n  BinaryOpInstruction,\n  branchOpInstruction,\n  BreakMarkInstruction,\n  CallInstruction,\n  CaseJumpInstruction,\n  CaseMarkInstruction,\n  ContinueMarkInstruction,\n  ForLoopInstruction,\n  FunctionIndexWrapper,\n  Instruction,\n  InstructionType,\n  isInstruction,\n  MemoryLoadInstruction,\n  MemoryStoreInstruction,\n  popInstruction,\n  StackFrameTearDownInstruction,\n  UnaryOpInstruction,\n  WhileLoopInstruction,\n} from \"./controlItems\";\nimport { Runtime } from \"./runtime\";\nimport { ExpressionStatementP } from \"~src/processor/c-ast/statement/expressionStatement\";\nimport {\n  SelectionStatementP,\n  SwitchStatementP,\n} from \"~src/processor/c-ast/statement/selectionStatement\";\nimport {\n  DoWhileLoopP,\n  ForLoopP,\n  WhileLoopP,\n} from \"~src/processor/c-ast/statement/iterationStatement\";\nimport {\n  BreakStatementP,\n  ContinueStatementP,\n  ReturnStatementP,\n} from \"~src/processor/c-ast/statement/jumpStatement\";\nimport {\n  DataSegmentAddress,\n  DynamicAddress,\n  FunctionTableIndex,\n  LocalAddress,\n  MemoryLoad,\n  MemoryStore,\n  ReturnObjectAddress,\n} from \"~src/processor/c-ast/memory\";\nimport {\n  FunctionCallP,\n  FunctionDefinitionP,\n} from \"~src/processor/c-ast/function\";\nimport {\n  FloatConstantP,\n  IntegerConstantP,\n} from \"~src/processor/c-ast/expression/constants\";\nimport {\n  BinaryExpressionP,\n  ConditionalExpressionP,\n  PostStatementExpressionP,\n  PreStatementExpressionP,\n  UnaryExpressionP,\n} from \"~src/processor/c-ast/expression/expressions\";\nimport { memoryManager } from \"../processor/memoryManager\";\n\nexport function interpret(\n  astRootNode: CAstRootP,\n  includedModules: ModuleName[],\n  moduleConfig: ModulesGlobalConfig,\n  sourceCode: string\n): void {\n  const interpreter = new Interpreter(\n    astRootNode,\n    includedModules,\n    moduleConfig,\n    sourceCode\n  );\n  interpreter.interpret();\n}\n\nexport async function evaluateTillStep(\n  astRootNode: CAstRootP,\n  includedModules: ModuleName[],\n  moduleConfig: ModulesGlobalConfig,\n  targetStep: number,\n  sourceCode: string\n): Promise<CContext> {\n  const interpreter = new Interpreter(\n    astRootNode,\n    includedModules,\n    moduleConfig,\n    sourceCode\n  );\n  memoryManager.reload();\n  return await interpreter.interpretTillStep(targetStep);\n}\n\nexport function extractCodeSegment(controlItem: ControlItem): string {\n  const codePosition = controlItem.position;\n\n  // extract the code position at a line start and line end\n  const lines = Runtime.sourceCode.split(\"\\n\");\n  const extractedCode = lines\n    .slice(codePosition.start.line - 1, codePosition.end.line)\n    .filter((line) => line.trim() !== \"\");\n\n  if (extractedCode.length > 0) {\n    extractedCode[0] = extractedCode[0].slice(codePosition.start.column - 1);\n    extractedCode[extractedCode.length - 1] = extractedCode[\n      extractedCode.length - 1\n    ].slice(0, codePosition.end.column - 1);\n  }\n\n  return extractedCode.join(\"\\n\");\n}\n\nexport function controlItemToString(controlItem: ControlItem): string {\n  if (isInstruction(controlItem)) {\n    const type = controlItem.type;\n    const fn = instructionToString[type] as\n      | ((instruction: Instruction) => string)\n      | undefined;\n    if (fn) {\n      return fn(controlItem as Instruction);\n    }\n  } else {\n    const type = controlItem.type;\n    const fn = nodeToString[type] as ((node: CNodeP) => string) | undefined;\n    if (fn) {\n      return fn(controlItem as CNodeP);\n    }\n  }\n  throw new Error(\"Unknown instruction type\");\n}\n\nexport const instructionToString: {\n  [InstrType in Instruction[\"type\"]]: (\n    instruction: Extract<Instruction, { type: InstrType }>\n  ) => string;\n} = {\n  [InstructionType.BINARY_OP]: (controlItem: BinaryOpInstruction): string => {\n    return \"Binary operator: \" + controlItem.operator;\n  },\n\n  [InstructionType.BRANCH]: (controlItem: branchOpInstruction): string => {\n    const extractedCode = extractCodeSegment(controlItem);\n    return \"Branch instruction: \" + extractedCode;\n  },\n\n  [InstructionType.BREAK_MARK]: (controlItem: BreakMarkInstruction): string => {\n    return \"Break Mark\";\n  },\n\n  [InstructionType.CALLINSTRUCTION]: (controlItem: CallInstruction): string => {\n    return \"Call Function\";\n  },\n\n  [InstructionType.CASE_JUMP]: (controlItem: CaseJumpInstruction): string => {\n    return \"Case Jump\";\n  },\n\n  [InstructionType.CASE_MARK]: (controlItem: CaseMarkInstruction): string => {\n    return \"Case Mark\";\n  },\n\n  [InstructionType.CONTINUE_MARK]: (\n    controlItem: ContinueMarkInstruction\n  ): string => {\n    return \"Continue Mark\";\n  },\n\n  [InstructionType.FORLOOP]: (controlItem: ForLoopInstruction): string => {\n    return \"Loop: \" + extractCodeSegment(controlItem);\n  },\n\n  [InstructionType.FUNCTIONINDEXWRAPPER]: (\n    controlItem: FunctionIndexWrapper\n  ): string => {\n    return \"Function Index Wrapper\";\n  },\n\n  [InstructionType.MEMORY_LOAD]: (\n    controlItem: MemoryLoadInstruction\n  ): string => {\n    return \"Memory Load: \" + extractCodeSegment(controlItem);\n  },\n\n  [InstructionType.MEMORY_STORE]: (\n    controlItem: MemoryStoreInstruction\n  ): string => {\n    return \"Memory Store: \" + extractCodeSegment(controlItem);\n  },\n\n  [InstructionType.POP]: (controlItem: popInstruction): string => {\n    return \"Pop\";\n  },\n\n  [InstructionType.STACKFRAMETEARDOWNINSTRUCTION]: (\n    controlItem: StackFrameTearDownInstruction\n  ): string => {\n    return \"Stack tear down\";\n  },\n\n  [InstructionType.UNARY_OP]: (controlItem: UnaryOpInstruction): string => {\n    return \"Unary operation: \" + controlItem.operator;\n  },\n\n  [InstructionType.WHILE]: (controlItem: WhileLoopInstruction): string => {\n    return \"While loop: \" + extractCodeSegment(controlItem);\n  },\n};\n\nexport const nodeToString: {\n  [ContrlType in CNodeP[\"type\"]]: (\n    controlItem: Extract<ControlItem, { type: ContrlType }>\n  ) => string;\n} = {\n  ExpressionStatement: (controlItem: ExpressionStatementP): string => {\n    return \"Expression: \" + extractCodeSegment(controlItem);\n  },\n\n  SelectionStatement: (controlItem: SelectionStatementP): string => {\n    return \"Selection: \" + extractCodeSegment(controlItem);\n  },\n\n  DoWhileLoop: (controlItem: DoWhileLoopP): string => {\n    return \"DoWhile: \" + extractCodeSegment(controlItem);\n  },\n\n  WhileLoop: (controlItem: WhileLoopP): string => {\n    return \"WhileLoop: \" + extractCodeSegment(controlItem);\n  },\n\n  ForLoop: (controlItem: ForLoopP): string => {\n    return \"ForLoop: \" + extractCodeSegment(controlItem);\n  },\n\n  ReturnStatement: (controlItem: ReturnStatementP): string => {\n    return \"Return Statement: \" + extractCodeSegment(controlItem);\n  },\n\n  BreakStatement: (controlItem: BreakStatementP): string => {\n    return \"Break: \" + extractCodeSegment(controlItem);\n  },\n\n  ContinueStatement: (controlItem: ContinueStatementP): string => {\n    return \"Continue Statement\";\n  },\n\n  SwitchStatement: (controlItem: SwitchStatementP): string => {\n    return \"Switch: \" + extractCodeSegment(controlItem);\n  },\n\n  MemoryLoad: (controlItem: MemoryLoad): string => {\n    return \"Memory Load Node: \" + extractCodeSegment(controlItem);\n  },\n\n  FunctionTableIndex: (controlItem: FunctionTableIndex): string => {\n    const funcIndex = controlItem.index.value;\n    if (funcIndex < 0 || funcIndex > Runtime.astRootP.functionTable.length) {\n      throw new Error(\"Index of desired function out of bounds\");\n    }\n\n    const funcName =\n      Runtime.astRootP.functionTable[Number(funcIndex)].functionName;\n    return funcName;\n  },\n\n  MemoryStore: (controlItem: MemoryStore): string => {\n    return \"Memory Store Node: \" + extractCodeSegment(controlItem);\n  },\n\n  LocalAddress: (controlItem: LocalAddress): string => {\n    return \"Local Address: \" + controlItem.offset.value.toString();\n  },\n\n  DataSegmentAddress: (controlItem: DataSegmentAddress): string => {\n    return \"Data Segment Address: \" + controlItem.offset.value.toString();\n  },\n\n  ReturnObjectAddress: (controlItem: ReturnObjectAddress): string => {\n    return \"Return Object Address: \" + controlItem.offset.value.toString();\n  },\n\n  DynamicAddress: (controlItem: DynamicAddress): string => {\n    return \"Dynamic Address: \" + extractCodeSegment(controlItem.address);\n  },\n\n  FunctionCall: (controlItem: FunctionCallP): string => {\n    return \"Function call: \" + extractCodeSegment(controlItem);\n  },\n\n  IntegerConstant: (controlItem: IntegerConstantP): string => {\n    return controlItem.value.toString();\n  },\n\n  FloatConstant: (controlItem: FloatConstantP): string => {\n    return controlItem.value.toString();\n  },\n\n  BinaryExpression: (controlItem: BinaryExpressionP): string => {\n    return \"Binary ExpressionP: \" + extractCodeSegment(controlItem);\n  },\n\n  UnaryExpression: (controlItem: UnaryExpressionP): string => {\n    return \"UnaryExpressionP: \" + extractCodeSegment(controlItem);\n  },\n\n  PreStatementExpression: (controlItem: PreStatementExpressionP): string => {\n    return \"PreStatemetn: \" + extractCodeSegment(controlItem);\n  },\n\n  PostStatementExpression: (controlItem: PostStatementExpressionP): string => {\n    return \"PostStatement: \" + extractCodeSegment(controlItem);\n  },\n\n  ConditionalExpression: (controlItem: ConditionalExpressionP): string => {\n    return \"Conditional: \" + extractCodeSegment(controlItem);\n  },\n\n  FunctionDefinition: (controlItem: FunctionDefinitionP): string => {\n    return \"Function: \" + extractCodeSegment(controlItem);\n  },\n};\n","import { CAstRootP } from \"~src/processor/c-ast/core\";\nimport { Runtime } from \"~src/interpreter/runtime\";\nimport { Control } from \"~src/interpreter/utils/control\";\nimport { Stash } from \"~src/interpreter/utils/stash\";\nimport { Memory } from \"~src/interpreter/memory\";\nimport ModuleRepository, {\n  ModuleName,\n  ModulesGlobalConfig,\n} from \"~src/modules\";\nimport { defaultPosition } from \"./utils/constantsUtils\";\nimport { StackFrame } from \"./stackFrame\";\nimport { InstructionType, StackFrameTearDownInstruction } from \"./controlItems\";\n\nexport interface CContext {\n  astRoot: CAstRootP;\n  control: Control;\n  stash: Stash;\n  memory: Memory;\n  stackFrames: StackFrame[];\n  step: number;\n}\n\nexport class Interpreter {\n  private readonly runtimeStack: Runtime[];\n  private readonly astRootNode: CAstRootP;\n  private readonly includedModules: ModuleName[];\n  private readonly moduleConfig: ModulesGlobalConfig;\n  private readonly sourceCode: string;\n\n  constructor(\n    astRootNode: CAstRootP,\n    includedModules: ModuleName[],\n    moduleConfig: ModulesGlobalConfig,\n    sourceCode: string\n  ) {\n    this.astRootNode = astRootNode;\n    this.runtimeStack = []; // CURRENTLY NOT USED WITH HOW INTERPRETER IS SETUP\n    this.includedModules = includedModules;\n    this.moduleConfig = moduleConfig;\n    this.sourceCode = sourceCode;\n  }\n\n  async interpretTillStep(targetStep: number): Promise<CContext> {\n    Runtime.astRootP = this.astRootNode;\n    Runtime.includedModules = this.includedModules;\n    Runtime.sourceCode = this.sourceCode;\n\n    const mainFunction = Runtime.astRootP.functions.find(\n      (x) => x.name === \"main\"\n    );\n\n    if (!mainFunction) {\n      throw new Error(\"Main function not defined\");\n    }\n\n    // call main\n    const initialRuntime = new Runtime(\n      new Control([\n        {\n          type: \"FunctionCall\",\n          calledFunction: {\n            type: \"DirectlyCalledFunction\",\n            functionName: \"main\",\n            position: this.astRootNode.position,\n          },\n          functionDetails: {\n            sizeOfParams: 0,\n            sizeOfReturn: 4,\n            parameters: [],\n            returnObjects: [\n              {\n                dataType: \"signed int\",\n                offset: 0,\n              },\n            ],\n          },\n          args: [],\n          position: this.astRootNode.position,\n        },\n      ])\n    );\n\n    Runtime.modules = new ModuleRepository(\n      initialRuntime.cloneMemory().memory,\n      new WebAssembly.Table({ element: \"anyfunc\", initial: 2 }),\n      this.moduleConfig\n    );\n\n    for (const moduleName of Runtime.includedModules) {\n      if (\n        typeof Runtime.modules.modules[moduleName].instantiate !== \"undefined\"\n      ) {\n        await (\n          Runtime.modules.modules[moduleName].instantiate as () => Promise<void>\n        )();\n      }\n    }\n    this.runtimeStack.push(initialRuntime);\n\n    let currentRuntime = initialRuntime;\n\n    let currStep: number = 0;\n    if (targetStep === -1) {\n      while (!currentRuntime.isControlEmpty()) {\n        currentRuntime = currentRuntime.next();\n        this.runtimeStack.push(currentRuntime);\n        currStep++;\n      }\n    } else {\n      while (currStep !== targetStep) {\n        currentRuntime = currentRuntime.next();\n        this.runtimeStack.push(currentRuntime);\n        currStep++;\n      }\n    }\n\n    // setup environment for visualizer\n    const tearDowns: StackFrameTearDownInstruction[] = currentRuntime\n      .getControl()\n      .getTearDowns()\n      .reverse();\n    let lastBasePointer: number =\n      currentRuntime.getPointers().basePointer.value;\n    const stackFrames: StackFrame[] = [];\n\n    for (let i = 0; i < tearDowns.length; i++) {\n      if (tearDowns[i].type !== InstructionType.STACKFRAMETEARDOWNINSTRUCTION) {\n        throw new Error(\"Expected a StackFrameTearDown Instruction\");\n      }\n\n      stackFrames.push(\n        new StackFrame(\n          tearDowns[i].functionName,\n          lastBasePointer,\n          currentRuntime.getMemory()\n        )\n      );\n\n      lastBasePointer = tearDowns[i].basePointer;\n    }\n\n    return {\n      astRoot: this.astRootNode,\n      control: currentRuntime.getControl(),\n      stash: currentRuntime.getStash(),\n      memory: currentRuntime.getMemory(),\n      step: currStep,\n      stackFrames: stackFrames,\n    };\n  }\n\n  async interpret(): Promise<void> {\n    Runtime.astRootP = this.astRootNode;\n    Runtime.includedModules = this.includedModules;\n\n    const mainFunction = Runtime.astRootP.functions.find(\n      (x) => x.name === \"main\"\n    );\n\n    if (!mainFunction) {\n      throw new Error(\"Main function not defined\");\n    }\n\n    // call main\n    console.log(\"Starting interpretation...\");\n    console.log(this.astRootNode.position);\n    const initialRuntime = new Runtime(\n      new Control([\n        {\n          type: \"FunctionCall\",\n          calledFunction: {\n            type: \"DirectlyCalledFunction\",\n            functionName: \"main\",\n            position: defaultPosition,\n          },\n          functionDetails: {\n            sizeOfParams: 0,\n            sizeOfReturn: 4,\n            parameters: [],\n            returnObjects: [\n              {\n                dataType: \"signed int\",\n                offset: 0,\n              },\n            ],\n          },\n          args: [],\n          position: this.astRootNode.position,\n        },\n      ])\n    );\n\n    Runtime.modules = new ModuleRepository(\n      initialRuntime.cloneMemory().memory,\n      new WebAssembly.Table({ element: \"anyfunc\", initial: 100 }),\n      this.moduleConfig\n    );\n\n    for (const moduleName of Runtime.includedModules) {\n      if (\n        typeof Runtime.modules.modules[moduleName].instantiate !== \"undefined\"\n      ) {\n        await (\n          Runtime.modules.modules[moduleName].instantiate as () => Promise<void>\n        )();\n      }\n    }\n    this.runtimeStack.push(initialRuntime);\n\n    let currentRuntime = initialRuntime;\n\n    // console.log(currentRuntime.toString());\n\n    while (!currentRuntime.hasCompleted()) {\n      currentRuntime = currentRuntime.next();\n      // console.log(currentRuntime.toString());\n      this.runtimeStack.push(currentRuntime);\n    }\n  }\n\n  toString(): string {\n    if (this.runtimeStack.length === 0) {\n      return \"Runtime Stack: <empty>\";\n    }\n\n    let result = `Runtime Stack: ${this.runtimeStack.length} states\\n`;\n\n    for (let i = 0; i < this.runtimeStack.length; i++) {\n      result += `\\n====== State ${i + 1} ======\\n`;\n      result += this.runtimeStack[i].toString();\n      result += \"\\n\";\n    }\n\n    return result;\n  }\n}\n","import { ControlItem, Control } from \"~src/interpreter/utils/control\";\nimport { StashItem, Stash } from \"~src/interpreter/utils/stash\";\nimport { CAstRootP, CNodeP } from \"~src/processor/c-ast/core\";\nimport {\n  Instruction,\n  isInstruction,\n} from \"~src/interpreter/controlItems/instructions\";\nimport { NodeEvaluator } from \"~src/interpreter/evaluators/nodeEvaluator\";\nimport { InstructionEvaluator } from \"~src/interpreter/evaluators/instructionEvaluator\";\nimport { FunctionDefinitionP } from \"~src/processor/c-ast/function\";\nimport { Memory, MemoryWriteInterface } from \"./memory\";\nimport ModuleRepository, {\n  ModuleName,\n  SharedWasmGlobalVariables,\n} from \"~src/modules\";\nimport {\n  MemoryAddress,\n  resolveValueToConstantP,\n  RuntimeMemoryPair,\n} from \"~src/interpreter/utils/addressUtils\";\nimport { ScalarCDataType } from \"~src/common/types\";\n\nexport class Runtime {\n  private readonly control: Control;\n  private readonly stash: Stash;\n  private readonly memory: Memory;\n\n  public static astRootP: CAstRootP;\n  public static includedModules: ModuleName[];\n  public static modules: ModuleRepository;\n  public static sourceCode: string;\n\n  constructor(control?: Control, stash?: Stash, memory?: Memory) {\n    this.stash = stash || new Stash();\n    this.control = control || new Control();\n\n    if (!memory) {\n      if (!Runtime.astRootP) {\n        throw new Error(\"AST Root node not assigned\");\n      }\n\n      this.memory = new Memory(\n        Runtime.astRootP.dataSegmentByteStr,\n        Runtime.astRootP.dataSegmentSizeInBytes\n      );\n    } else {\n      this.memory = memory;\n    }\n  }\n\n  next(): Runtime {\n    if (this.hasCompleted()) {\n      return new Runtime(this.control, this.stash, this.memory);\n    }\n\n    const [item, newControl] = this.control.pop();\n    const poppedRuntime = new Runtime(newControl, this.stash, this.memory);\n\n    if (isInstruction(item)) {\n      return poppedRuntime.evaluateInstruction(item as Instruction);\n    } else {\n      return poppedRuntime.evaluateNode(item as CNodeP);\n    }\n  }\n\n  private evaluateNode(node: CNodeP): Runtime {\n    const evaluator = NodeEvaluator[node.type];\n    if (evaluator) {\n      const result = evaluator(this, node as any);\n      return result;\n    } else {\n      throw new Error(`Unknown node type ${node.type}`);\n    }\n  }\n\n  private evaluateInstruction(instruction: Instruction): Runtime {\n    if (InstructionEvaluator[instruction.type]) {\n      const result = InstructionEvaluator[instruction.type](\n        this,\n        instruction as any\n      );\n      return result;\n    } else {\n      throw new Error(\"Unknown instruction type\");\n    }\n  }\n\n  getFunction(name: string): FunctionDefinitionP | undefined {\n    return Runtime.astRootP.functions.find((x) => x.name === name);\n  }\n\n  // ===== MEMORY =====\n\n  writeToModulesMemory(): void {\n    this.memory.writeToModuleMemory();\n  }\n\n  cloneModuleMemory(): Runtime {\n    const newMemory = this.memory.cloneModuleMemory();\n\n    return new Runtime(this.control, this.stash, newMemory);\n  }\n\n  cloneMemory(): Memory {\n    return this.memory.clone();\n  }\n\n  memoryWrite(pairs: RuntimeMemoryPair[]): Runtime {\n    const memoryWriteInterfaceArr: MemoryWriteInterface[] = pairs.map(\n      (pair) => {\n        const writeValue = resolveValueToConstantP(pair.value);\n\n        return {\n          type: \"MemoryWriteInterface\",\n          address: pair.address.value,\n          value: writeValue,\n          dataType: pair.dataType,\n        };\n      }\n    );\n\n    return new Runtime(\n      this.control,\n      this.stash,\n      this.memory.write(memoryWriteInterfaceArr)\n    );\n  }\n\n  memoryLoad(address: MemoryAddress, dataType: ScalarCDataType) {\n    const value = this.memory.load(address, dataType);\n    const [_, newRuntime] = this.popValue();\n    return newRuntime.pushValue(value);\n  }\n\n  stackFrameSetup(\n    sizeOfParams: number,\n    sizeOfLocals: number,\n    sizeOfReturn: number,\n    parameters: StashItem[]\n  ): Runtime {\n    const newMemory = this.memory.stackFrameSetup(\n      sizeOfParams,\n      sizeOfLocals,\n      sizeOfReturn,\n      parameters\n    );\n\n    return new Runtime(this.control, this.stash, newMemory);\n  }\n\n  stackFrameTearDown(stackPointer: number, basePointer: number) {\n    const newMemory = this.memory.stackFrameTearDown(stackPointer, basePointer);\n\n    return new Runtime(this.control, this.stash, newMemory);\n  }\n\n  getPointers(): SharedWasmGlobalVariables {\n    return this.memory.sharedWasmGlobalVariables;\n  }\n\n  // Control functions\n  // function to push general instruction/CNodeP onto the control\n  push(item: ControlItem[]): Runtime {\n    return new Runtime(\n      this.control.concat([...item].reverse()),\n      this.stash,\n      this.memory\n    );\n  }\n\n  pushNode(node: CNodeP[]): Runtime {\n    return new Runtime(\n      this.control.concat([...node].reverse()),\n      this.stash,\n      this.memory\n    );\n  }\n\n  pushInstruction(instruction: Instruction[]): Runtime {\n    return new Runtime(\n      this.control.concat([...instruction].reverse()),\n      this.stash,\n      this.memory\n    );\n  }\n\n  // STASH FUNCTIONS\n\n  pushValue(value: StashItem): Runtime {\n    return new Runtime(this.control, this.stash.push(value), this.memory);\n  }\n\n  popNode(): [ControlItem, Runtime] {\n    const [node, newControl] = this.control.pop();\n    if (node === undefined) {\n      throw new Error(\"Undefined popped node\");\n    }\n    return [node, new Runtime(newControl, this.stash, this.memory)];\n  }\n\n  popValue(): [StashItem, Runtime] {\n    const [value, newStash] = this.stash.pop();\n    if (value === undefined) {\n      throw new Error(\"Undefined popped stash value\");\n    }\n    return [value, new Runtime(this.control, newStash, this.memory)];\n  }\n\n  hasCompleted(): boolean {\n    return this.control.isEmpty();\n  }\n\n  getResult(): any {\n    return this.stash.isEmpty() ? null : this.stash.peek();\n  }\n\n  peekControl(): ControlItem {\n    return this.control.peek();\n  }\n\n  popControl(): [ControlItem, Runtime] {\n    const [popedItem, newControl] = this.control.pop();\n    const newRuntime = new Runtime(newControl, this.stash, this.memory);\n\n    if (popedItem === undefined) {\n      throw new Error(\"Cannot pop control: no elements left\");\n    }\n\n    return [popedItem, newRuntime];\n  }\n\n  isControlEmpty(): boolean {\n    return this.control.isEmpty();\n  }\n\n  toString(): string {\n    let result = \"\\n----- INTERPRETER STATE -----\\n\";\n\n    result += \"\\nCONTROL:\\n\";\n    result += this.control.toString();\n\n    result += \"\\n\\nSTASH:\\n\";\n    result += this.stash.toString();\n\n    result += \"\\n\\nREGISTERED FUNCTIONS:\\n\";\n    if (Runtime.astRootP.functions.length === 0) {\n      result += \"  <none>\";\n    } else {\n      for (const func of Runtime.astRootP.functions) {\n        result += `  ${func.name}\\n`;\n      }\n    }\n\n    result += \"\\n-----------------------------\";\n    result += this.memory.getFormattedMemoryView();\n\n    return result;\n  }\n\n  public getControl(): Control {\n    return this.control;\n  }\n\n  public getStash(): Stash {\n    return this.stash;\n  }\n\n  public getMemory(): Memory {\n    return this.memory;\n  }\n}\n","import { CNodeP } from \"~src/processor/c-ast/core\";\nimport { Stack } from \"./stack\";\nimport {\n  Instruction,\n  InstructionType,\n  isInstruction,\n  StackFrameTearDownInstruction,\n} from \"~src/interpreter/controlItems/instructions\";\n\nexport type ControlItem = CNodeP | Instruction;\n\nexport class Control extends Stack<ControlItem, Control> {\n  protected createNew(items: ReadonlyArray<ControlItem>): Control {\n    return new Control(items);\n  }\n\n  private numEnvDependentItems: any;\n\n  canAvoidEnvInstr(): boolean {\n    return true;\n  }\n\n  getTearDowns(): StackFrameTearDownInstruction[] {\n    return this.storage.filter(\n      (item): item is StackFrameTearDownInstruction =>\n        isInstruction(item) && item.type === InstructionType.STACKFRAMETEARDOWNINSTRUCTION\n    );\n  }\n\n  getNumEnvDependentItems(): number {\n    return this.numEnvDependentItems;\n  }\n\n  isInstruction(item: any) {\n    return isInstruction(item);\n  }\n\n  isNode(item: any) {\n    return !isInstruction(item);\n  }\n\n  copy(): Control {\n    return this;\n  }\n\n  toString(): string {\n    if (this.isEmpty()) {\n      return \"  <empty>\";\n    }\n\n    const controlItems = this.toArray();\n    let result = \"\";\n\n    for (let i = controlItems.length - 1; i >= 0; i--) {\n      const item = controlItems[i];\n      const itemPosition = controlItems.length - i;\n\n      if (isInstruction(item)) {\n        if (item.type === InstructionType.BINARY_OP) {\n          result += `  ${itemPosition}. [Instruction] ${item.type}: '${\n            (item as any).operator\n          }'\\n`;\n        } else if (item.type === InstructionType.UNARY_OP) {\n          result += `  ${itemPosition}. [Instruction] ${item.type}: '${\n            (item as any).operator\n          }'\\n`;\n        } else if (\n          item.type === InstructionType.BRANCH ||\n          item.type === InstructionType.POP ||\n          item.type === InstructionType.WHILE ||\n          item.type === InstructionType.BREAK_MARK ||\n          item.type === InstructionType.CONTINUE_MARK\n        ) {\n          result += `  ${itemPosition}. [Instruction] ${item.type}\\n`;\n        } else if (\n          item.type === InstructionType.CASE_JUMP ||\n          item.type === InstructionType.CASE_MARK\n        ) {\n          result += `  ${itemPosition}. [Instruction] ${item.type}: '${item.caseValue}'\\n`;\n        } else if (\n          item.type === InstructionType.MEMORY_LOAD ||\n          item.type === InstructionType.MEMORY_STORE\n        ) {\n          result += `  ${itemPosition}. [Instruction] ${item.type}: '${item.dataType}'\\n`;\n        } else {\n          result += `  ${itemPosition}. [Instruction] ${item.type}\\n`;\n        }\n      } else {\n        const nodeItem = item as any;\n        let additionalInfo = \"\";\n\n        switch (nodeItem.type) {\n          case \"FunctionDefinition\":\n            additionalInfo = nodeItem.name ? `: ${nodeItem.name}` : \"\";\n            break;\n          case \"IntegerConstant\":\n          case \"FloatConstant\":\n            additionalInfo =\n              nodeItem.value !== undefined ? `: ${nodeItem.value}` : \"\";\n            break;\n          case \"UnaryExpression\":\n          case \"BinaryExpression\":\n            additionalInfo = nodeItem.operator\n              ? `: '${nodeItem.operator}'`\n              : \"\";\n            break;\n          case \"MemoryAddress\":\n            additionalInfo = `: ${nodeItem.hexValue}`;\n            break;\n        }\n\n        result += `  ${itemPosition}. [Node] ${nodeItem.type}${additionalInfo}\\n`;\n      }\n    }\n    return result.trimEnd();\n  }\n}\n","/**\n * Stack is implemented for control and stash registers.\n * Adapted from https://github.com/source-academy/js-slang/blob/master/src/cse-machine/stack.ts\n * and made to be immutable\n */\n\nexport interface ImmutableStack<T, S> {\n  push(item: T): S;\n  pop(): [T | undefined, S];\n  peek(): T | undefined;\n  size(): number;\n  isEmpty(): boolean;\n  toArray(): ReadonlyArray<T>;\n}\n\nexport class Stack<T, R = any> implements ImmutableStack<T, R> {\n  protected readonly storage: ReadonlyArray<T>;\n\n  constructor(items: ReadonlyArray<T> = []) {\n    this.storage = items;\n  }\n\n  protected createNew(items: ReadonlyArray<T>): R {\n    return new Stack<T>(items) as unknown as R;\n  }\n\n  setTo(otherStack: Stack<T, R>): void {}\n\n  concat(item: T[]) {\n    return this.createNew([...this.storage, ...item]);\n  }\n\n  push(item: T): R {\n    return this.createNew([...this.storage, item]);\n  }\n\n  public getStack(): ReadonlyArray<T> {\n    return [...this.storage];\n  }\n\n  public some(predicate: (value: T) => boolean): boolean {\n    return this.storage.some(predicate);\n  }\n\n  pop(): [T | undefined, R] {\n    if (this.isEmpty()) {\n      return [undefined, this as unknown as R];\n    }\n    const lastItem = this.storage[this.storage.length - 1];\n    return [lastItem, this.createNew(this.storage.slice(0, -1))];\n  }\n\n  getIdx(idx: number): T {\n    if (idx < 0 || idx >= this.storage.length) {\n      throw new Error(\"Stack out of bounds\");\n    }\n    return this.storage[idx];\n  }\n\n  peek(): T {\n    if (this.isEmpty()) {\n      throw new Error(\"Cannot peek: stack is empty.\");\n    }\n    return this.storage[this.storage.length - 1];\n  }\n  /**\n   * Returns a subarray of the last `depth` elements from the stack.\n   * If depth is greater than the stack size, returns the whole stack.\n   */\n  peekLast(depth: number): ReadonlyArray<T> {\n    if (this.storage.length < depth) {\n      throw new Error(\"PeekLast out of bounds\");\n    }\n\n    return this.storage.slice(this.storage.length - depth);\n  }\n\n  size(): number {\n    return this.storage.length;\n  }\n\n  isEmpty(): boolean {\n    return this.size() === 0;\n  }\n\n  toArray(): ReadonlyArray<T> {\n    return this.storage;\n  }\n}\n","import { BinaryOperator, ScalarCDataType } from \"~src/common/types\";\nimport { CNodeP, ExpressionP } from \"~src/processor/c-ast/core\";\nimport { CalledFunction, FunctionDetails } from \"~src/processor/c-ast/function\";\nimport { ControlItem } from \"~src/interpreter/utils/control\";\nimport { Position } from \"~src/parser/c-ast/misc\";\n\n/**\n * Types of instructions for the interpreter\n */\nexport enum InstructionType {\n  BINARY_OP = \"BINARY_OP\",\n  UNARY_OP = \"UNARY_OP\",\n  BRANCH = \"BRANCH\",\n  POP = \"POP\",\n  MEMORY_STORE = \"MEMORY_STORE\",\n  MEMORY_LOAD = \"MEMORY_LOAD\",\n  WHILE = \"WHILE\",\n  FORLOOP = \"FORLOOP\",\n  STACKFRAMETEARDOWNINSTRUCTION = \"STACKFRAMETEARDOWNINSTRUCTION\",\n  CALLINSTRUCTION = \"CALLINSTRUCTION\",\n  FUNCTIONINDEXWRAPPER = \"FUNCTIONINDEXWRAPPER\",\n  BREAK_MARK = \"BREAK_MARK\",\n  CASE_JUMP = \"CASE_JUMP\",\n  CASE_MARK = \"CASE_MARK\",\n  CONTINUE_MARK = \"CONTINUE_MARK\",\n}\n\nexport interface BaseInstruction {\n  type: InstructionType;\n  position: Position;\n}\n\nexport interface BinaryOpInstruction extends BaseInstruction {\n  type: InstructionType.BINARY_OP;\n  operator: BinaryOperator;\n  dataType: ScalarCDataType;\n}\n\nexport const binaryOpInstruction = (\n  operator: BinaryOperator,\n  dataType: ScalarCDataType,\n  position: Position,\n): BinaryOpInstruction => ({\n  type: InstructionType.BINARY_OP,\n  operator,\n  dataType,\n  position,\n});\n\nexport interface UnaryOpInstruction extends BaseInstruction {\n  type: InstructionType.UNARY_OP;\n  operator: string;\n}\n\nexport const unaryOpInstruction = (\n  operator: string,\n  position: Position,\n): UnaryOpInstruction => ({\n  type: InstructionType.UNARY_OP,\n  operator,\n  position,\n});\n\nexport interface branchOpInstruction extends BaseInstruction {\n  type: InstructionType.BRANCH;\n  trueExpr: CNodeP[];\n  falseExpr: CNodeP[];\n}\n\nexport const branchOpInstruction = (\n  trueExpr: CNodeP[],\n  falseExpr: CNodeP[],\n  position: Position,\n): branchOpInstruction => ({\n  type: InstructionType.BRANCH,\n  trueExpr,\n  falseExpr,\n  position,\n});\n\nexport interface popInstruction extends BaseInstruction {\n  type: InstructionType.POP;\n}\n\nexport const popInstruction = (): popInstruction => ({\n  type: InstructionType.POP,\n  position: {\n    start: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n    end: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n  },\n});\n\n// ===== MEMORY =====\n\nexport interface MemoryStoreInstruction extends BaseInstruction {\n  type: InstructionType.MEMORY_STORE;\n  dataType: ScalarCDataType;\n}\n\nexport const memoryStoreInstruction = (\n  dataType: ScalarCDataType,\n  position: Position,\n): MemoryStoreInstruction => ({\n  type: InstructionType.MEMORY_STORE,\n  dataType: dataType,\n  position,\n});\n\nexport interface MemoryLoadInstruction extends BaseInstruction {\n  type: InstructionType.MEMORY_LOAD;\n  dataType: ScalarCDataType;\n}\n\nexport const memoryLoadInstruction = (\n  dataType: ScalarCDataType,\n  position: Position,\n): MemoryLoadInstruction => ({\n  type: InstructionType.MEMORY_LOAD,\n  dataType,\n  position,\n});\n\nexport interface WhileLoopInstruction extends BaseInstruction {\n  type: InstructionType.WHILE;\n  condition: ExpressionP;\n  body: CNodeP[];\n  hasContinue: boolean;\n}\n\nexport const whileLoopInstruction = (\n  condition: ExpressionP,\n  body: CNodeP[],\n  hasContinue: boolean,\n  position: Position,\n): WhileLoopInstruction => ({\n  type: InstructionType.WHILE,\n  condition,\n  body,\n  hasContinue,\n  position,\n});\n\nexport interface ForLoopInstruction extends BaseInstruction {\n  type: InstructionType.FORLOOP;\n  body: CNodeP[];\n  update: CNodeP[];\n  condition: ExpressionP;\n  hasContinue: boolean;\n}\n\nexport const forLoopInstruction = (\n  body: CNodeP[],\n  update: CNodeP[],\n  condition: ExpressionP,\n  hasContinue: boolean,\n  position: Position,\n): ForLoopInstruction => ({\n  type: InstructionType.FORLOOP,\n  body,\n  update,\n  condition,\n  hasContinue,\n  position,\n});\n\n// ===== FUNCTION CALLS =====\n\n// Tears down the current stack frame and moves base pointer and stack pointer to the previous stack frame\nexport interface StackFrameTearDownInstruction extends BaseInstruction {\n  functionName: string;\n  type: InstructionType.STACKFRAMETEARDOWNINSTRUCTION;\n  basePointer: number;\n  stackPointer: number;\n}\n\nexport const stackFrameTearDownInstruction = (\n  functionName: string,\n  basePointer: number,\n  stackPointer: number,\n  position: Position,\n): StackFrameTearDownInstruction => ({\n  functionName: functionName,\n  type: InstructionType.STACKFRAMETEARDOWNINSTRUCTION,\n  basePointer: basePointer,\n  stackPointer: stackPointer,\n  position,\n});\n\nexport interface CallInstruction extends BaseInstruction {\n  type: InstructionType.CALLINSTRUCTION;\n  calledFunction: CalledFunction;\n  functionDetails: FunctionDetails;\n}\n\nexport const callInstruction = (\n  calledFunction: CalledFunction,\n  functionDetails: FunctionDetails,\n  position: Position,\n): CallInstruction => ({\n  type: InstructionType.CALLINSTRUCTION,\n  calledFunction: calledFunction,\n  functionDetails: functionDetails,\n  position,\n});\n\nexport interface FunctionIndexWrapper extends BaseInstruction {\n  type: InstructionType.FUNCTIONINDEXWRAPPER;\n}\n\nexport const functionIndexWrapper = (): FunctionIndexWrapper => ({\n  type: InstructionType.FUNCTIONINDEXWRAPPER,\n  position: {\n    start: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n    end: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n  },\n});\n\nexport interface BreakMarkInstruction extends BaseInstruction {\n  type: InstructionType.BREAK_MARK;\n}\n\nexport const breakMarkInstruction = (): BreakMarkInstruction => ({\n  type: InstructionType.BREAK_MARK,\n  position: {\n    start: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n    end: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n  },\n});\n\nexport function isBreakMarkInstruction(\n  i: ControlItem,\n): i is BreakMarkInstruction {\n  return isInstruction(i) && i.type == InstructionType.BREAK_MARK;\n}\n\nexport interface ContinueMarkInstruction extends BaseInstruction {\n  type: InstructionType.CONTINUE_MARK;\n}\n\nexport const continueMarkInstruction = (): ContinueMarkInstruction => ({\n  type: InstructionType.CONTINUE_MARK,\n  position: {\n    start: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n    end: {\n      line: 0,\n      column: 0,\n      offset: 0,\n    },\n  },\n});\n\nexport function isContinueMarkInstruction(\n  i: ControlItem,\n): i is ContinueMarkInstruction {\n  return isInstruction(i) && i.type == InstructionType.CONTINUE_MARK;\n}\n\nexport interface CaseJumpInstruction extends BaseInstruction {\n  type: InstructionType.CASE_JUMP;\n  caseValue: number;\n}\n\nconst caseJumpInstruction = (\n  caseValue: number,\n  position: Position,\n): CaseJumpInstruction => ({\n  type: InstructionType.CASE_JUMP,\n  caseValue,\n  position,\n});\n\nexport interface CaseMarkInstruction extends BaseInstruction {\n  type: InstructionType.CASE_MARK;\n  caseValue: number;\n}\n\nconst caseMarkInstruction = (\n  caseValue: number,\n  position: Position,\n): CaseMarkInstruction => ({\n  type: InstructionType.CASE_MARK,\n  caseValue,\n  position,\n});\n\nconst DEFAULT_CASE_VALUE = -1;\n\nexport const createDefaultCaseInstructionPair = () => {\n  return createCaseInstructionPair(DEFAULT_CASE_VALUE);\n};\n\n// creates a caseJumpInstruction and caseMarkInstruction with the same caseValue\nexport const createCaseInstructionPair = (caseValue: number) => {\n  return {\n    jumpInstruction: {\n      type: InstructionType.CASE_JUMP,\n      caseValue,\n    } as CaseJumpInstruction,\n\n    markInstruction: {\n      type: InstructionType.CASE_MARK,\n      caseValue,\n    } as CaseMarkInstruction,\n  };\n};\n\nexport function isCaseMarkInstruction(\n  i: ControlItem,\n): i is CaseMarkInstruction {\n  return isInstruction(i) && i.type == InstructionType.CASE_MARK;\n}\n\nexport function isDefaultCaseInstruction(\n  instruction: CaseJumpInstruction | CaseMarkInstruction,\n): boolean {\n  return instruction.caseValue === DEFAULT_CASE_VALUE;\n}\n\nexport function doCaseInstructionsMatch(\n  jumpInstruction: CaseJumpInstruction,\n  markInstruction: CaseMarkInstruction,\n): boolean {\n  return jumpInstruction.caseValue === markInstruction.caseValue;\n}\n\nexport type Instruction =\n  | BinaryOpInstruction\n  | UnaryOpInstruction\n  | branchOpInstruction\n  | popInstruction\n  | MemoryStoreInstruction\n  | MemoryLoadInstruction\n  | StackFrameTearDownInstruction\n  | CallInstruction\n  | FunctionIndexWrapper\n  | WhileLoopInstruction\n  | ForLoopInstruction\n  | BreakMarkInstruction\n  | CaseJumpInstruction\n  | CaseMarkInstruction\n  | ContinueMarkInstruction;\n\nexport const isInstruction = (item: any): item is Instruction => {\n  return (\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    Object.values(InstructionType).includes(item.type as InstructionType)\n  );\n};\n","import { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { Stack } from \"./stack\";\nimport { MemoryAddress } from \"~src/interpreter/utils/addressUtils\";\nimport { FunctionTableIndex } from \"~src/processor/c-ast/memory\";\n\nexport type StashItem = ConstantP | MemoryAddress | FunctionTableIndex;\n\nexport class Stash extends Stack<StashItem, Stash> {\n  protected createNew(items: ReadonlyArray<StashItem>): Stash {\n    return new Stash(items);\n  }\n\n  static isConstant(item: StashItem): item is ConstantP {\n    return item.type === \"IntegerConstant\" || item.type === \"FloatConstant\";\n  }\n\n  static isMemoryAddress(value: StashItem): value is MemoryAddress {\n    return value.type === \"MemoryAddress\";\n  }\n\n  toString(): string {\n    if (this.isEmpty()) {\n      return \"  <empty>\";\n    }\n\n    const stashItems = this.toArray();\n    let result = \"\";\n\n    for (let i = stashItems.length - 1; i >= 0; i--) {\n      const item = stashItems[i];\n      const itemPosition = stashItems.length - i;\n      let displayValue = \"\";\n\n      switch (item.type) {\n        case \"IntegerConstant\":\n        case \"FloatConstant\":\n          displayValue = `${item.value}`;\n          break;\n        case \"MemoryAddress\":\n          displayValue = `MemoryAddress (${item.hexValue})`;\n          break;\n        case \"FunctionTableIndex\":\n          displayValue = `FunctionTableIndex (${item.index.value})`;\n        default:\n          break;\n      }\n      result += `  ${itemPosition}. ${displayValue}\\n`;\n    }\n    return result.trimEnd();\n  }\n}\n","import { Runtime } from \"~src/interpreter/runtime\";\nimport {\n  binaryOpInstruction,\n  branchOpInstruction,\n  callInstruction,\n  breakMarkInstruction,\n  continueMarkInstruction,\n  createCaseInstructionPair,\n  createDefaultCaseInstructionPair,\n  isBreakMarkInstruction,\n  isContinueMarkInstruction,\n  memoryLoadInstruction,\n  memoryStoreInstruction,\n  popInstruction,\n  stackFrameTearDownInstruction,\n  unaryOpInstruction,\n  whileLoopInstruction,\n  forLoopInstruction,\n} from \"~src/interpreter/controlItems/instructions\";\nimport { CNodeType } from \"~src/interpreter/controlItems/types\";\nimport { CNodeP, ExpressionP } from \"~src/processor/c-ast/core\";\nimport {\n  FloatConstantP,\n  IntegerConstantP,\n} from \"~src/processor/c-ast/expression/constants\";\nimport {\n  BinaryExpressionP,\n  UnaryExpressionP,\n  PreStatementExpressionP,\n  PostStatementExpressionP,\n  ConditionalExpressionP,\n} from \"~src/processor/c-ast/expression/expressions\";\nimport {\n  DirectlyCalledFunction,\n  FunctionCallP,\n} from \"~src/processor/c-ast/function\";\nimport {\n  MemoryStore,\n  MemoryLoad,\n  LocalAddress,\n  DataSegmentAddress,\n  DynamicAddress,\n  ReturnObjectAddress,\n  FunctionTableIndex,\n} from \"~src/processor/c-ast/memory\";\nimport {\n  BreakStatementP,\n  ContinueStatementP,\n  ReturnStatementP,\n} from \"~src/processor/c-ast/statement/jumpStatement\";\nimport {\n  SelectionStatementP,\n  SwitchStatementP,\n} from \"~src/processor/c-ast/statement/selectionStatement\";\nimport {\n  DoWhileLoopP,\n  WhileLoopP,\n  ForLoopP,\n} from \"~src/processor/c-ast/statement/iterationStatement\";\nimport { ExpressionStatementP } from \"~src/processor/c-ast/statement/expressionStatement\";\nimport {\n  containsBreakStatement,\n  containsContinueStatement,\n} from \"~src/interpreter/utils/jumpStatementChecking\";\nimport { ControlItem } from \"~src/interpreter/utils/control\";\nimport { createMemoryAddress } from \"~src/interpreter/utils/addressUtils\";\nimport { defaultPosition } from \"../utils/constantsUtils\";\n\nexport const NodeEvaluator: {\n  [Type in CNodeType]?: (\n    runtime: Runtime,\n    node: Extract<CNodeP, { type: Type }>\n  ) => Runtime;\n} = {\n  // ========== STATEMENTS ==========\n\n  ExpressionStatement: (\n    runtime: Runtime,\n    node: ExpressionStatementP\n  ): Runtime => {\n    const runtimeWithPop = runtime.pushInstruction([popInstruction()]);\n    return runtimeWithPop.pushNode([node.expr]);\n  },\n\n  SelectionStatement: (\n    runtime: Runtime,\n    node: SelectionStatementP\n  ): Runtime => {\n    const runtimeWithPushedInstruction = runtime.pushInstruction([\n      branchOpInstruction(\n        node.ifStatements,\n        node.elseStatements ?? [],\n        node.position\n      ),\n    ]);\n\n    return runtimeWithPushedInstruction.pushNode([node.condition]);\n  },\n\n  // === ITERATION STATEMENTS ===\n\n  DoWhileLoop: (runtime: Runtime, node: DoWhileLoopP): Runtime => {\n    const hasBreak = containsBreakStatement(node.body);\n    const hasContinue = containsContinueStatement(node.body);\n\n    let pRuntime = runtime;\n\n    if (hasBreak) {\n      pRuntime = pRuntime.push([breakMarkInstruction()]);\n    }\n\n    pRuntime = pRuntime.push([\n      node.condition,\n      whileLoopInstruction(\n        node.condition,\n        node.body,\n        hasContinue,\n        node.position\n      ),\n    ]);\n\n    if (hasContinue) {\n      pRuntime = pRuntime.push([continueMarkInstruction()]);\n    }\n\n    return pRuntime.push([...node.body]);\n  },\n\n  WhileLoop: (runtime: Runtime, node: WhileLoopP): Runtime => {\n    const hasBreak = containsBreakStatement(node.body);\n    const hasContinue = containsContinueStatement(node.body);\n\n    let pRuntime = runtime;\n\n    if (hasBreak) {\n      pRuntime = pRuntime.push([breakMarkInstruction()]);\n    }\n\n    pRuntime = pRuntime.push([\n      whileLoopInstruction(\n        node.condition,\n        node.body,\n        hasContinue,\n        node.position\n      ),\n    ]);\n\n    return pRuntime.push([node.condition]);\n  },\n\n  ForLoop: (runtime: Runtime, node: ForLoopP): Runtime => {\n    const hasBreak = containsBreakStatement(node.body);\n    const hasContinue = containsContinueStatement(node.body);\n\n    const condition: ExpressionP =\n      node.condition === null\n        ? {\n            type: \"IntegerConstant\",\n            value: 1n,\n            dataType: \"signed int\",\n            position: defaultPosition,\n          }\n        : node.condition;\n\n    const forLoopInstr = forLoopInstruction(\n      node.body,\n      node.update,\n      condition,\n      hasContinue,\n      node.position\n    );\n\n    let pRuntime = runtime;\n\n    if (hasBreak) {\n      pRuntime = pRuntime.push([breakMarkInstruction()]);\n    }\n\n    return pRuntime.push([...node.clause, condition, forLoopInstr]);\n  },\n\n  // === JUMP STATEMENTS ===\n\n  ReturnStatement: (runtime: Runtime, node: ReturnStatementP): Runtime => {\n    const topControlItem = runtime.peekControl();\n\n    if (\n      topControlItem.type === \"STACKFRAMETEARDOWNINSTRUCTION\" ||\n      runtime.hasCompleted()\n    ) {\n      return runtime;\n    } else {\n      const returnStatement: ReturnStatementP = {\n        type: \"ReturnStatement\",\n        position: defaultPosition,\n      };\n      const [_, popedRuntime] = runtime.popControl();\n      const newRuntime = popedRuntime.push([returnStatement]);\n\n      return newRuntime;\n    }\n  },\n\n  BreakStatement: (runtime: Runtime, node: BreakStatementP): Runtime => {\n    let currRuntime = runtime;\n    let foundBreakMark = false;\n\n    while (!currRuntime.isControlEmpty()) {\n      const [item, newRuntime] = currRuntime.popNode();\n      currRuntime = newRuntime;\n\n      if (isBreakMarkInstruction(item)) {\n        foundBreakMark = true;\n        break;\n      }\n    }\n\n    if (!foundBreakMark) {\n      throw new Error(\"Unable to locate break mark\");\n    }\n\n    return currRuntime;\n  },\n\n  ContinueStatement: (runtime: Runtime, node: ContinueStatementP): Runtime => {\n    let currRuntime = runtime;\n    let foundContinueMark = false;\n\n    while (!currRuntime.isControlEmpty()) {\n      const [item, newRuntime] = currRuntime.popNode();\n      currRuntime = newRuntime;\n\n      if (isContinueMarkInstruction(item)) {\n        foundContinueMark = true;\n        break;\n      }\n    }\n\n    if (!foundContinueMark) {\n      throw new Error(\"Unable to locate continue mark\");\n    }\n\n    return currRuntime;\n  },\n\n  /**\n   * Followed from: https://stackoverflow.com/questions/68406541/how-cases-get-evaluated-in-switch-statements-c\n   */\n  SwitchStatement: (runtime: Runtime, node: SwitchStatementP): Runtime => {\n    const hasBreak = containsBreakStatement([\n      ...node.cases.flatMap((c) => c.statements),\n      ...node.defaultStatements,\n    ]);\n\n    const conditions: ControlItem[] = [];\n    const statements: ControlItem[] = [];\n\n    for (let i = 0; i < node.cases.length; i++) {\n      const caseItem = node.cases[i];\n      const casePair = createCaseInstructionPair(i);\n\n      conditions.push(caseItem.condition.rightExpr);\n      conditions.push(casePair.jumpInstruction);\n\n      statements.push(casePair.markInstruction);\n      statements.push(...caseItem.statements);\n    }\n\n    if (node.defaultStatements) {\n      const defaultPair = createDefaultCaseInstructionPair();\n\n      conditions.push(defaultPair.jumpInstruction);\n\n      statements.push(defaultPair.markInstruction);\n      statements.push(...node.defaultStatements);\n    }\n\n    let updatedRuntime = runtime;\n\n    if (hasBreak) {\n      updatedRuntime = updatedRuntime.push([breakMarkInstruction()]);\n    }\n\n    return updatedRuntime\n      .push(statements)\n      .push(conditions)\n      .push([node.targetExpression]);\n  },\n\n  // ========== MEMORY ==========\n\n  MemoryLoad: (runtime: Runtime, node: MemoryLoad): Runtime => {\n    return runtime.push([\n      node.address,\n      memoryLoadInstruction(node.dataType, node.position),\n    ]);\n  },\n\n  FunctionTableIndex: (runtime: Runtime, node: FunctionTableIndex): Runtime => {\n    const newRuntime = runtime.pushValue(node);\n    return newRuntime;\n  },\n\n  MemoryStore: (runtime: Runtime, node: MemoryStore): Runtime => {\n    return runtime.push([\n      node.value,\n      node.address,\n      memoryStoreInstruction(node.dataType, defaultPosition),\n      popInstruction(),\n    ]);\n  },\n\n  LocalAddress: (runtime: Runtime, node: LocalAddress): Runtime => {\n    return runtime.pushValue(\n      createMemoryAddress(\n        BigInt(runtime.getPointers().basePointer.value) + node.offset.value\n      )\n    );\n  },\n\n  DataSegmentAddress: (runtime: Runtime, node: DataSegmentAddress): Runtime => {\n    return runtime.pushValue(createMemoryAddress(node.offset.value));\n  },\n\n  ReturnObjectAddress: (\n    runtime: Runtime,\n    node: ReturnObjectAddress\n  ): Runtime => {\n    if (node.subtype === \"load\") {\n      return runtime.pushValue(\n        createMemoryAddress(\n          BigInt(runtime.getPointers().stackPointer.value) + node.offset.value\n        )\n      );\n    } else {\n      return runtime.pushValue(\n        createMemoryAddress(\n          BigInt(runtime.getPointers().basePointer.value) + node.offset.value\n        )\n      );\n    }\n  },\n\n  DynamicAddress: (runtime: Runtime, node: DynamicAddress): Runtime => {\n    return runtime.pushNode([node.address]);\n  },\n\n  FunctionCall: (runtime: Runtime, node: FunctionCallP): Runtime => {\n    // push order: stack frame tear down instruction, call instruction (contains function details information, and function call information),\n    // arguments\n    const pointers = runtime.getPointers();\n\n    if (node.calledFunction.type === \"DirectlyCalledFunction\") {\n      const calledFunction = node.calledFunction;\n      calledFunction as DirectlyCalledFunction;\n      const index = Runtime.astRootP.functionTable.findIndex(\n        (x) => x.functionName === calledFunction.functionName\n      );\n\n      const funcDetails = Runtime.astRootP.functions.find(\n        (x) => x.name === calledFunction.functionName\n      );\n\n      if (index === -1) {\n        throw new Error(`Function not found: ${calledFunction.functionName}`);\n      }\n\n      const targetPosition = funcDetails?.position || defaultPosition;\n\n      const funcIndex: FunctionTableIndex = {\n        type: \"FunctionTableIndex\",\n        index: {\n          type: \"IntegerConstant\",\n          value: BigInt(index),\n          dataType: \"unsigned int\",\n          position: targetPosition,\n        },\n        position: targetPosition,\n        dataType: \"pointer\",\n      };\n\n      const newRuntime = runtime.push([\n        ...node.args,\n        funcIndex,\n        callInstruction(\n          node.calledFunction,\n          node.functionDetails,\n          targetPosition\n        ),\n        stackFrameTearDownInstruction(\n          calledFunction.functionName,\n          pointers.basePointer.value,\n          pointers.stackPointer.value,\n          targetPosition\n        ),\n      ]);\n\n      return newRuntime;\n    } else {\n      throw new Error(\"TODO: Implement indirectly called function\");\n      // const calledFunction = node.calledFunction;\n      // const funcIndex: ExpressionP = calledFunction.functionAddress;\n\n      // const newRuntime = runtime.push([\n      //   ...node.args,\n      //   funcIndex,\n      //   functionIndexWrapper(),\n      //   callInstruction(\n      //     node.calledFunction,\n      //     node.functionDetails,\n      //     calledFunction.functionAddress.position\n      //   ),\n      //   stackFrameTearDownInstruction(\n      //     pointers.basePointer.value,\n      //     pointers.stackPointer.value,\n      //     calledFunction.functionAddress.position\n      //   ),\n      // ]);\n\n      // return newRuntime;\n    }\n  },\n\n  // ========== EXPRESSIONS ==========\n\n  IntegerConstant: (runtime: Runtime, node: IntegerConstantP): Runtime => {\n    return runtime.pushValue(node);\n  },\n\n  FloatConstant: (runtime: Runtime, node: FloatConstantP): Runtime => {\n    return runtime.pushValue(node);\n  },\n\n  BinaryExpression: (runtime: Runtime, node: BinaryExpressionP): Runtime => {\n    const runtimeWithInstruction = runtime.pushInstruction([\n      binaryOpInstruction(node.operator, node.dataType, node.position),\n    ]);\n    const runtimeWithRight = runtimeWithInstruction.pushNode([node.rightExpr]);\n\n    const newRuntime = runtime.push([\n      node.leftExpr,\n      node.rightExpr,\n      binaryOpInstruction(node.operator, node.dataType, node.position),\n    ]);\n\n    return runtimeWithRight.pushNode([node.leftExpr]);\n  },\n\n  UnaryExpression: (runtime: Runtime, node: UnaryExpressionP): Runtime => {\n    const runtimeWithInstruction = runtime.pushInstruction([\n      unaryOpInstruction(node.operator, node.position),\n    ]);\n    return runtimeWithInstruction.pushNode([node.expr]);\n  },\n\n  PreStatementExpression: (\n    runtime: Runtime,\n    node: PreStatementExpressionP\n  ): Runtime => {\n    const newRuntime = runtime.push([...node.statements, node.expr]);\n\n    return newRuntime;\n  },\n\n  PostStatementExpression: (\n    runtime: Runtime,\n    node: PostStatementExpressionP\n  ): Runtime => {\n    const newRuntime = runtime.push([node.expr, ...node.statements]);\n\n    return newRuntime;\n  },\n\n  ConditionalExpression: (\n    runtime: Runtime,\n    node: ConditionalExpressionP\n  ): Runtime => {\n    const runtimeWithInstruction = runtime.pushInstruction([\n      branchOpInstruction(\n        [node.trueExpression],\n        [node.falseExpression],\n        node.position\n      ),\n    ]);\n    return runtimeWithInstruction.pushNode([node.condition]);\n  },\n};\n","import { CNodeP } from \"~src/processor/c-ast/core\";\n\n// Should consider combining these two functions into one\n// So the AST is traversed only once instead of twice\n\nexport function containsBreakStatement(stmt: CNodeP | CNodeP[]): boolean {\n  if (Array.isArray(stmt)) {\n    return stmt.some((s) => containsBreakStatement(s));\n  }\n\n  switch (stmt.type) {\n    case \"BreakStatement\":\n      return true;\n    case \"SelectionStatement\":\n      return (\n        containsBreakStatement(stmt.ifStatements) ||\n        (stmt.elseStatements\n          ? containsBreakStatement(stmt.elseStatements)\n          : false)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function containsContinueStatement(stmt: CNodeP | CNodeP[]): boolean {\n  if (Array.isArray(stmt)) {\n    return stmt.some((s) => containsContinueStatement(s));\n  }\n\n  switch (stmt.type) {\n    case \"ContinueStatement\":\n      return true;\n    case \"SelectionStatement\":\n      return (\n        containsContinueStatement(stmt.ifStatements) ||\n        (stmt.elseStatements\n          ? containsContinueStatement(stmt.elseStatements)\n          : false)\n      );\n    default:\n      return false;\n  }\n}\n","import { ScalarCDataType } from \"~src/common/types\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { defaultPosition } from \"./constantsUtils\";\n\nexport interface RuntimeMemoryPair {\n  type: \"RuntimeMemoryPair\";\n  address: MemoryAddress;\n  value: MemoryAddress | ConstantP;\n  dataType: ScalarCDataType;\n}\n\nexport interface MemoryAddress {\n  type: \"MemoryAddress\";\n  value: bigint;\n  hexValue: string;\n}\n\nexport function createMemoryAddress(value: bigint): MemoryAddress {\n  return {\n    type: \"MemoryAddress\",\n    value,\n    hexValue: `0x${value.toString(16).padStart(8, \"0\")}`,\n  };\n}\n\nexport function resolveValueToConstantP(\n  value: MemoryAddress | ConstantP,\n): ConstantP {\n  // if ConstantP return itself\n  if (value.type === \"IntegerConstant\" || value.type === \"FloatConstant\") {\n    return value;\n  }\n\n  // if MemoryAddress convert it to an unsigned int (equivalent)\n  return {\n    type: \"IntegerConstant\",\n    value: value.value,\n    dataType: \"unsigned int\",\n    position: defaultPosition,\n  };\n}\n","import {\n  BinaryOperator,\n  FloatDataType,\n  IntegerDataType,\n} from \"~src/common/types\";\nimport { isIntegerType } from \"~src/common/utils\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { performBinaryOperation } from \"~src/processor/evaluateCompileTimeExpression\";\nimport { determineResultDataTypeOfBinaryExpression } from \"~src/processor/expressionUtil\";\nimport { getAdjustedIntValueAccordingToDataType } from \"~src/processor/processConstant\";\nimport {\n  createMemoryAddress,\n  MemoryAddress,\n} from \"~src/interpreter/utils/addressUtils\";\nimport { Stash } from \"~src/interpreter/utils/stash\";\nimport { Position } from \"~src/parser/c-ast/misc\";\n\nexport const defaultPosition: Position = {\n  start: {\n    line: 0,\n    column: 0,\n    offset: 0,\n  },\n  end: {\n    line: 0,\n    column: 0,\n    offset: 0,\n  },\n};\n\n/**\n * Bottom evaluation is same as in ~src\\processor\\evaluateCompileTimeExpression.ts.\n * However, it has been fixed.\n * Adapted for the addition of MemoryAddress\n */\nexport function performConstantAndAddressBinaryOperation(\n  left: ConstantP | MemoryAddress,\n  operator: BinaryOperator,\n  right: ConstantP | MemoryAddress,\n): ConstantP | MemoryAddress {\n  let cLeft = left;\n  let cRight = right;\n  let addressReturn: boolean = false;\n\n  if (Stash.isMemoryAddress(cLeft)) {\n    cLeft = convertMemoryAddressToConstant(cLeft);\n    addressReturn = true;\n  }\n  if (Stash.isMemoryAddress(cRight)) {\n    cRight = convertMemoryAddressToConstant(cRight);\n    addressReturn = true;\n  }\n\n  const dataType = determineResultDataTypeOfBinaryExpression(\n    { type: \"primary\", primaryDataType: cLeft.dataType },\n    { type: \"primary\", primaryDataType: cRight.dataType },\n    operator,\n  );\n\n  if (dataType.type !== \"primary\") {\n    throw new Error(\"invalid expression\");\n  }\n\n  let leftVal: bigint | number;\n  let rightVal: bigint | number;\n\n  /**\n   * there is a need to ensure that both leftVal and rightVal are same types (both bigint or number)\n   * so that performBinaryOperation will give a result as intended\n   *\n   * only for unsigned long and signed long we convert them into BigInt so that we get the full 64-bit range\n   * this ensures that the calculations with longs produce the correct value and do not overflow\n   *\n   * for int, float and double we convert them to number so it adheres to the 32-bit range\n   * this ensures that for bitwise operators, they give the correct wrong value\n   */\n  if (\n    dataType.primaryDataType === \"unsigned long\" ||\n    dataType.primaryDataType === \"signed long\"\n  ) {\n    leftVal = BigInt(cLeft.value);\n    rightVal = BigInt(cRight.value);\n  } else {\n    leftVal = Number(cLeft.value);\n    rightVal = Number(cRight.value);\n  }\n\n  const value = performBinaryOperation(leftVal, operator, rightVal);\n\n  if (isIntegerType(dataType.primaryDataType)) {\n    const valueInt = getAdjustedIntValueAccordingToDataType(\n      typeof value === \"bigint\" ? value : BigInt(Math.floor(value)),\n      dataType.primaryDataType,\n    );\n\n    if (addressReturn) {\n      return createMemoryAddress(valueInt);\n    }\n\n    return {\n      type: \"IntegerConstant\",\n      dataType: dataType.primaryDataType as IntegerDataType,\n      value: valueInt as bigint,\n      position: defaultPosition,\n    };\n  }\n\n  return {\n    type: \"FloatConstant\",\n    dataType: dataType.primaryDataType as FloatDataType,\n    value: value as number,\n    position: defaultPosition,\n  };\n}\n\nfunction convertMemoryAddressToConstant(address: MemoryAddress): ConstantP {\n  return {\n    type: \"IntegerConstant\",\n    value: address.value,\n    dataType: \"unsigned int\",\n    position: defaultPosition,\n  };\n}\n/**\n * Checks whether the ConstantP is true or false\n */\nexport function isConstantTrue(item: ConstantP): item is ConstantP {\n  return item.value !== 0n;\n}\n","import { Runtime } from \"~src/interpreter/runtime\";\nimport {\n  Instruction,\n  InstructionType,\n  BinaryOpInstruction,\n  UnaryOpInstruction,\n  branchOpInstruction,\n  popInstruction,\n  MemoryLoadInstruction,\n  MemoryStoreInstruction,\n  WhileLoopInstruction,\n  BreakMarkInstruction,\n  CaseMarkInstruction,\n  CaseJumpInstruction,\n  isCaseMarkInstruction,\n  doCaseInstructionsMatch,\n  isDefaultCaseInstruction,\n  ContinueMarkInstruction,\n  continueMarkInstruction,\n  CallInstruction,\n  StackFrameTearDownInstruction,\n  FunctionIndexWrapper,\n  ForLoopInstruction,\n} from \"~src/interpreter/controlItems/instructions\";\nimport { FunctionTableIndex, MemoryStore } from \"~src/processor/c-ast/memory\";\nimport { getSizeOfScalarDataType, isIntegerType } from \"~src/common/utils\";\nimport { performUnaryOperation } from \"~src/processor/evaluateCompileTimeExpression\";\nimport { getAdjustedIntValueAccordingToDataType } from \"~src/processor/processConstant\";\nimport {\n  FloatDataType,\n  IntegerDataType,\n  UnaryOperator,\n} from \"~src/common/types\";\nimport { StashItem, Stash } from \"~src/interpreter/utils/stash\";\nimport { Module, ModuleFunction } from \"~src/modules/types\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { ReturnStatementP } from \"~src/processor/c-ast/statement/jumpStatement\";\nimport {\n  defaultPosition,\n  isConstantTrue,\n  performConstantAndAddressBinaryOperation,\n} from \"~src/interpreter/utils/constantsUtils\";\n\nexport const InstructionEvaluator: {\n  [InstrType in Instruction[\"type\"]]: (\n    runtime: Runtime,\n    instruction: Extract<Instruction, { type: InstrType }>,\n  ) => Runtime;\n} = {\n  [InstructionType.UNARY_OP]: (\n    runtime: Runtime,\n    instruction: UnaryOpInstruction,\n  ): Runtime => {\n    const [operand, runtimeAfterPop] = runtime.popValue();\n\n    if (!Stash.isConstant(operand)) {\n      throw new Error(\n        `Unary operation '${instruction.operator} requires an operand, but stash is empty'`,\n      );\n    }\n\n    /**\n     * Bottom evaluation is same as in ~src\\processor\\evaluateCompileTimeExpression.ts\n     * performUnaryOperation has been fixed to support \"!\" and \"~\"\n     */\n    const dataType = operand.dataType;\n\n    let value = performUnaryOperation(\n      operand.value,\n      instruction.operator as UnaryOperator,\n    );\n    if (isIntegerType(dataType)) {\n      value = getAdjustedIntValueAccordingToDataType(value as bigint, dataType);\n\n      return runtimeAfterPop.pushValue({\n        type: \"IntegerConstant\",\n        dataType: dataType as IntegerDataType,\n        value,\n        position: defaultPosition,\n      });\n    } else {\n      return runtimeAfterPop.pushValue({\n        type: \"FloatConstant\",\n        dataType: dataType as FloatDataType,\n        value: value as number,\n        position: operand.position,\n      });\n    }\n  },\n\n  [InstructionType.BINARY_OP]: (\n    runtime: Runtime,\n    instruction: BinaryOpInstruction,\n  ): Runtime => {\n    const [right, runtimeAfterPopRight] = runtime.popValue();\n    const [left, runtimeAfterPopLeft] = runtimeAfterPopRight.popValue();\n\n    if (\n      !(Stash.isConstant(left) || Stash.isMemoryAddress(left)) ||\n      !(Stash.isConstant(right) || Stash.isMemoryAddress(right))\n    ) {\n      throw new Error(\n        `Binary operator '${instruction.operator}' encountered operands that are not a constant or an address`,\n      );\n    }\n\n    return runtimeAfterPopLeft.pushValue(\n      performConstantAndAddressBinaryOperation(\n        left,\n        instruction.operator,\n        right,\n      ),\n    );\n  },\n\n  [InstructionType.BRANCH]: (\n    runtime: Runtime,\n    instruction: branchOpInstruction,\n  ): Runtime => {\n    const [condition, runtimeWithPoppedValue] = runtime.popValue();\n\n    if (!Stash.isConstant(condition)) {\n      throw new Error(\"Branch instruction expects a boolean\");\n    }\n\n    const isTrue = isConstantTrue(condition);\n\n    if (isTrue) {\n      return runtimeWithPoppedValue.pushNode(instruction.trueExpr);\n    }\n    return runtimeWithPoppedValue.pushNode(instruction.falseExpr);\n  },\n\n  [InstructionType.MEMORY_STORE]: (\n    runtime: Runtime,\n    instruction: MemoryStoreInstruction,\n  ): Runtime => {\n    const [address, runtimeAfter] = runtime.popValue();\n    const [value, _] = runtimeAfter.popValue();\n\n    /**\n     * Ensures that address is a MemoryAddress\n     * Checks for mismatches between address, value and instruction dataTypes\n     */\n    if (address.type !== \"MemoryAddress\") {\n      throw new Error(`Expected MemoryAddress, but got ${address.type}`);\n    }\n\n    // if (value.type === \"FunctionTableIndex\") {\n    //   throw new Error(`Did not expect FunctionTableIndex`);\n    // }\n\n    let newValue: StashItem;\n\n    if (value.type === \"FunctionTableIndex\") {\n      newValue = value.index;\n    } else {\n      newValue = value;\n    }\n\n    return runtimeAfter.memoryWrite([\n      {\n        type: \"RuntimeMemoryPair\",\n        address: address,\n        value: newValue,\n        dataType: instruction.dataType,\n      },\n    ]);\n  },\n\n  [InstructionType.MEMORY_LOAD]: (\n    runtime: Runtime,\n    instruction: MemoryLoadInstruction,\n  ): Runtime => {\n    const [address, _] = runtime.popValue();\n\n    if (address.type !== \"MemoryAddress\") {\n      throw new Error(`Expected MemoryAddress, but got ${address.type}`);\n    }\n\n    return runtime.memoryLoad(address, instruction.dataType);\n  },\n\n  [InstructionType.STACKFRAMETEARDOWNINSTRUCTION]: (\n    runtime: Runtime,\n    instruction: StackFrameTearDownInstruction,\n  ): Runtime => {\n    const newRuntime = runtime.stackFrameTearDown(\n      instruction.stackPointer,\n      instruction.basePointer,\n    );\n\n    return newRuntime;\n  },\n\n  [InstructionType.FUNCTIONINDEXWRAPPER]: (\n    runtime: Runtime,\n    instruction: FunctionIndexWrapper,\n  ): Runtime => {\n    const [index, popedRuntime] = runtime.popValue();\n\n    let wrappedFunctionIndex: FunctionTableIndex;\n\n    if (index.type === \"IntegerConstant\") {\n      wrappedFunctionIndex = {\n        type: \"FunctionTableIndex\",\n        index: index,\n        dataType: \"pointer\",\n        position: index.position,\n      };\n    } else if (index.type === \"MemoryAddress\") {\n      wrappedFunctionIndex = {\n        type: \"FunctionTableIndex\",\n        index: {\n          type: \"IntegerConstant\",\n          value: index.value,\n          dataType: \"unsigned int\",\n          position: defaultPosition,\n        },\n        dataType: \"pointer\",\n        position: defaultPosition,\n      };\n    } else if (index.type === \"FunctionTableIndex\") {\n      wrappedFunctionIndex = index;\n    } else {\n      throw new Error(\n        `Wrong type for function index value in Function index wrapper, expected: IntegerConstant or MemoryAddress, got: ${index.type}`,\n      );\n    }\n\n    const newRuntime = popedRuntime.pushValue(wrappedFunctionIndex);\n\n    return newRuntime;\n  },\n\n  [InstructionType.CALLINSTRUCTION]: (\n    runtime: Runtime,\n    instruction: CallInstruction,\n  ): Runtime => {\n    let [functionAddress, poppedRuntime] = runtime.popValue();\n\n    const numOfParameters = instruction.functionDetails.parameters.length;\n    const parameters: StashItem[] = [];\n    for (let i = 0; i < numOfParameters; i++) {\n      const [parameter, newRuntime] = poppedRuntime.popValue();\n\n      parameters.push(parameter);\n      poppedRuntime = newRuntime;\n    }\n    parameters.reverse();\n\n    if (functionAddress.type !== \"FunctionTableIndex\") {\n      throw new Error(\"Wrong function pointer type in Call instruction\");\n    }\n\n    const calledFunction =\n      Runtime.astRootP.functionTable[Number(functionAddress.index.value)];\n\n    if (\n      Runtime.astRootP.functions.find(\n        (x) => x.name === calledFunction.functionName,\n      )\n    ) {\n      const func = Runtime.astRootP.functions.find(\n        (x) => x.name === calledFunction.functionName,\n      );\n      if (!func) {\n        throw new Error(\"No function called: \" + calledFunction.functionName);\n      }\n\n      // Set up a new Stackframe\n      const sizeOfParams = instruction.functionDetails.sizeOfParams;\n      const sizeOfLocals = func.sizeOfLocals;\n      const sizeOfReturn = instruction.functionDetails.sizeOfReturn;\n\n      const writtenRuntime = poppedRuntime.stackFrameSetup(\n        sizeOfParams,\n        sizeOfLocals,\n        sizeOfReturn,\n        parameters,\n      );\n\n      // push body statements\n      const resultRuntime = writtenRuntime.push(func.body);\n\n      return resultRuntime;\n    } else {\n      // Set up a new Stackframe\n      const sizeOfParams = instruction.functionDetails.sizeOfParams;\n      const sizeOfReturn = instruction.functionDetails.sizeOfReturn;\n\n      const writtenRuntime = poppedRuntime.stackFrameSetup(\n        sizeOfParams,\n        0,\n        sizeOfReturn,\n        parameters,\n      );\n\n      // Copy current memory into the modules repository memory;\n      writtenRuntime.writeToModulesMemory();\n\n      let func: ModuleFunction | undefined = undefined,\n        encapsulatingModule: Module | undefined;\n\n      for (const moduleName of Runtime.includedModules) {\n        const module = Runtime.modules.modules[moduleName];\n\n        if (module.moduleFunctions[calledFunction.functionName]) {\n          func = module.moduleFunctions[calledFunction.functionName];\n          encapsulatingModule = module;\n          break;\n        }\n      }\n\n      if (!func) {\n        throw new Error(\n          `Function ${calledFunction.functionName} not found in included modules.`,\n        );\n      }\n\n      const returnObjects = calledFunction.functionDetails.returnObjects;\n\n      if (!returnObjects) {\n        func.jsFunction.apply(\n          encapsulatingModule,\n          parameters.map((x) => {\n            if (\n              x.type === \"IntegerConstant\" ||\n              x.type === \"FloatConstant\" ||\n              x.type === \"MemoryAddress\"\n            ) {\n              return Number(x.value);\n            } else {\n              return Number(x.index);\n            }\n          }),\n        );\n\n        // Clone module repository memory after function call\n        const finalRuntime = writtenRuntime.cloneModuleMemory();\n\n        return finalRuntime;\n      } else {\n        const res: unknown = func.jsFunction.apply(\n          encapsulatingModule,\n          parameters.map((x) => {\n            if (\n              x.type === \"IntegerConstant\" ||\n              x.type === \"FloatConstant\" ||\n              x.type === \"MemoryAddress\"\n            ) {\n              return Number(x.value);\n            } else {\n              return Number(x.index);\n            }\n          }),\n        );\n\n        // Clone module repository memory after function call\n        const finalRuntime = writtenRuntime.cloneModuleMemory();\n\n        let results = [];\n        // check if res is an array\n        if (Array.isArray(res)) {\n          results = res;\n        } else {\n          results = [res];\n        }\n\n        if (results.length !== returnObjects.length) {\n          throw new Error(\n            \"results of external function length does not match returnObjects length\",\n          );\n        }\n\n        // Prepare memory store expressions for each return object address\n        const memoryStoreExpressions: MemoryStore[] = [];\n        let currentOffSet = 0;\n\n        for (let i = 0; i < results.length; i++) {\n          let storedValue: ConstantP;\n          if (\n            returnObjects[i].dataType === \"float\" ||\n            returnObjects[i].dataType === \"double\"\n          ) {\n            storedValue = {\n              type: \"FloatConstant\",\n              value: Number(results[i]),\n              dataType: returnObjects[i].dataType as FloatDataType,\n              position: defaultPosition,\n            };\n          } else {\n            storedValue = {\n              type: \"IntegerConstant\",\n              value: BigInt(results[i]),\n              dataType: returnObjects[i].dataType as IntegerDataType,\n              position: defaultPosition,\n            };\n          }\n\n          const expression: MemoryStore = {\n            type: \"MemoryStore\",\n            address: {\n              type: \"ReturnObjectAddress\",\n              subtype: \"store\",\n              offset: {\n                type: \"IntegerConstant\",\n                value: BigInt(currentOffSet),\n                dataType: \"signed int\",\n                position: defaultPosition,\n              },\n              dataType: \"pointer\",\n              position: defaultPosition,\n            },\n            position: defaultPosition,\n            dataType: returnObjects[i].dataType,\n            value: storedValue,\n          };\n\n          memoryStoreExpressions.push(expression);\n          currentOffSet += getSizeOfScalarDataType(returnObjects[i].dataType);\n        }\n        const returnStatement: ReturnStatementP = {\n          type: \"ReturnStatement\",\n          position: defaultPosition,\n        };\n\n        return finalRuntime.push([...memoryStoreExpressions, returnStatement]);\n      }\n    }\n  },\n\n  [InstructionType.POP]: (\n    runtime: Runtime,\n    instruction: popInstruction,\n  ): Runtime => {\n    const [_, runtimeAfterPop] = runtime.popValue();\n    return runtimeAfterPop;\n  },\n\n  [InstructionType.WHILE]: (\n    runtime: Runtime,\n    instruction: WhileLoopInstruction,\n  ): Runtime => {\n    let [condition, updatedRuntime] = runtime.popValue();\n\n    if (!Stash.isConstant(condition)) {\n      throw new Error(\"While instruction expects a boolean\");\n    }\n\n    const isTrue = isConstantTrue(condition);\n\n    if (!isTrue) {\n      return updatedRuntime;\n    }\n\n    updatedRuntime = updatedRuntime.push([instruction.condition, instruction]);\n\n    if (instruction.hasContinue) {\n      updatedRuntime = updatedRuntime.push([continueMarkInstruction()]);\n    }\n\n    return updatedRuntime.push(instruction.body);\n  },\n\n  [InstructionType.FORLOOP]: (\n    runtime: Runtime,\n    instruction: ForLoopInstruction,\n  ): Runtime => {\n    let [condition, updatedRuntime] = runtime.popValue();\n\n    if (!Stash.isConstant(condition)) {\n      throw new Error(\"While instruction expects a boolean\");\n    }\n\n    const isTrue = isConstantTrue(condition);\n\n    if (!isTrue) {\n      return updatedRuntime;\n    }\n\n    updatedRuntime = updatedRuntime.push([\n      ...instruction.update,\n      instruction.condition,\n      instruction,\n    ]);\n\n    if (instruction.hasContinue) {\n      updatedRuntime = updatedRuntime.push([continueMarkInstruction()]);\n    }\n\n    return updatedRuntime.push(instruction.body);\n  },\n\n  [InstructionType.CASE_JUMP]: (\n    runtime: Runtime,\n    instruction: CaseJumpInstruction,\n  ): Runtime => {\n    const [right, runtimeAfterPopRight] = runtime.popValue();\n\n    let currRuntime = runtimeAfterPopRight;\n\n    // if not default case jump instruction perform the below\n    if (!isDefaultCaseInstruction(instruction)) {\n      const [left, runtimeAfterPopLeft] = runtimeAfterPopRight.popValue();\n\n      if (!Stash.isConstant(left) || !Stash.isConstant(right)) {\n        throw new Error(`Case jump requires 2 constants in stash`);\n      }\n\n      // manually check for equality\n      const isTrueValue = performConstantAndAddressBinaryOperation(\n        left,\n        \"==\",\n        right,\n      );\n\n      if (Stash.isMemoryAddress(isTrueValue)) {\n        throw new Error(\n          `Case jump '${instruction.caseValue}' encountered a MemoryAddress`,\n        );\n      }\n\n      const isTrue = isConstantTrue(isTrueValue);\n\n      // if not true, return stash after popping the case expression\n      if (!isTrue) {\n        return runtimeAfterPopRight;\n      }\n\n      currRuntime = runtimeAfterPopLeft;\n    }\n\n    let foundCaseMark = false;\n\n    // if true jump to the respective case markpo\n    while (!currRuntime.isControlEmpty()) {\n      const [item, newRuntime] = currRuntime.popNode();\n      currRuntime = newRuntime;\n\n      if (\n        isCaseMarkInstruction(item) &&\n        doCaseInstructionsMatch(instruction, item)\n      ) {\n        foundCaseMark = true;\n        break;\n      }\n    }\n\n    if (!foundCaseMark) {\n      throw new Error(\"Unable to locate associated case mark statement\");\n    }\n\n    return currRuntime;\n  },\n\n  [InstructionType.CASE_MARK]: (\n    runtime: Runtime,\n    instruction: CaseMarkInstruction,\n  ): Runtime => {\n    return runtime;\n  },\n\n  [InstructionType.CONTINUE_MARK]: (\n    runtime: Runtime,\n    instruction: ContinueMarkInstruction,\n  ): Runtime => {\n    return runtime;\n  },\n\n  [InstructionType.BREAK_MARK]: (\n    runtime: Runtime,\n    instruction: BreakMarkInstruction,\n  ): Runtime => {\n    return runtime;\n  },\n};\n","import { KB, WASM_PAGE_IN_HEX } from \"~src/common/constants\";\nimport {\n  calculateNumberOfPagesNeededForBytes,\n  getSizeOfScalarDataType,\n  isFloatType,\n  isIntegerType,\n  primaryDataTypeSizes,\n} from \"~src/common/utils\";\nimport { WASM_ADDR_TYPE } from \"~src/translator/memoryUtil\";\nimport { SharedWasmGlobalVariables } from \"~src/modules\";\nimport {\n  FloatDataType,\n  IntegerDataType,\n  ScalarCDataType,\n} from \"~src/common/types\";\nimport { ConstantP } from \"~src/processor/c-ast/expression/constants\";\nimport { convertConstantToByteStr } from \"~src/processor/byteStrUtil\";\nimport { Runtime } from \"./runtime\";\nimport {\n  createMemoryAddress,\n  MemoryAddress,\n  resolveValueToConstantP,\n} from \"~src/interpreter/utils/addressUtils\";\nimport { StashItem } from \"~src/interpreter/utils/stash\";\nimport { defaultPosition } from \"./utils/constantsUtils\";\n\nexport interface MemoryWriteInterface {\n  type: \"MemoryWriteInterface\";\n  address: bigint;\n  value: ConstantP;\n  dataType: ScalarCDataType;\n}\n\nexport function parseByteStr(byteStr: string): Uint8Array {\n  const matches = byteStr.match(/\\\\([0-9a-fA-F]{2})/g);\n  if (!matches) {\n    return new Uint8Array();\n  }\n  const byteArray = new Uint8Array(matches.length);\n  for (let i = 0; i < matches.length; ++i) {\n    const byteValue = parseInt(matches[i].slice(1), 16);\n    byteArray[i] = byteValue;\n  }\n  return byteArray;\n}\n\nexport class Memory {\n  memory: WebAssembly.Memory;\n\n  dataSegmentSizeInBytes: number;\n  dataSegmentByteStr: string;\n  heapBuffer: number; // Heap size limit in bytes\n  stackBuffer: number; // Stacks size limit in bytes\n\n  sharedWasmGlobalVariables: SharedWasmGlobalVariables;\n\n  static cnt = 0;\n\n  // Constructor to initiate the first runtime object\n  constructor(\n    dataSegmentByteStr: string, // The string of bytes (each byte is in the form \"\\\\XX\" where X is a digit in base-16) to initialize the data segment with, determined by processing initializers for data segment variables.\n    dataSegmentSizeInBytes: number,\n    heapBuffer?: number,\n    stackBuffer?: number\n  ) {\n    Memory.cnt++;\n    this.dataSegmentSizeInBytes = dataSegmentSizeInBytes;\n    this.dataSegmentByteStr = dataSegmentByteStr;\n    this.heapBuffer = heapBuffer ?? 1 * KB;\n    this.stackBuffer = stackBuffer ?? 1 * KB;\n\n    const totalMemory =\n      this.dataSegmentSizeInBytes + this.heapBuffer + this.stackBuffer;\n    const initialPages = calculateNumberOfPagesNeededForBytes(totalMemory);\n\n    this.memory = new WebAssembly.Memory({ initial: initialPages });\n\n    this.sharedWasmGlobalVariables = {\n      /**\n       * stackPointer set to the highest address\n       * basePointer set to the highest address\n       * heapPointer set to after data portion\n       */\n      stackPointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        WASM_PAGE_IN_HEX * initialPages\n      ),\n      basePointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        WASM_PAGE_IN_HEX * initialPages\n      ),\n      heapPointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        dataSegmentSizeInBytes + 4\n      ),\n    };\n\n    // Initiate the data segment that stores global and static values\n    const dataSegmentByteArray = parseByteStr(dataSegmentByteStr);\n    const view = new Uint8Array(this.memory.buffer);\n    for (let i = 0; i < dataSegmentByteArray.length; i++) {\n      view[i] = dataSegmentByteArray[i];\n    }\n  }\n\n  // sets the values for stack pointer, base pointer, heap pointer\n\n  // Coppies the current memory buffer and pointers on to Global Modules memory\n  writeToModuleMemory() {\n    const memoryView = new Uint8Array(this.memory.buffer);\n    const moduleView = new Uint8Array(Runtime.modules.memory.buffer);\n\n    if (memoryView.length !== moduleView.length) {\n      throw new Error(\n        `Memory size mismatch: interpreter memory length (${memoryView.length}) does not match module memory length (${moduleView.length})`\n      );\n    }\n\n    for (let i = 0; i < memoryView.byteLength; i++) {\n      moduleView[i] = memoryView[i];\n    }\n\n    Runtime.modules.sharedWasmGlobalVariables.basePointer.value =\n      this.sharedWasmGlobalVariables.basePointer.value;\n    Runtime.modules.sharedWasmGlobalVariables.heapPointer.value =\n      this.sharedWasmGlobalVariables.heapPointer.value;\n    Runtime.modules.sharedWasmGlobalVariables.stackPointer.value =\n      this.sharedWasmGlobalVariables.stackPointer.value;\n  }\n\n  // Create a new memory instance that has the same content as the modules memory\n  cloneModuleMemory(): Memory {\n    const resultMemory = this.clone();\n\n    const moduleView = new Uint8Array(Runtime.modules.memory.buffer);\n    const memoryView = new Uint8Array(resultMemory.memory.buffer);\n\n    if (memoryView.byteLength !== moduleView.byteLength) {\n      throw new Error(\n        `Memory size mismatch: interpreter memory length (${memoryView.length}) does not match module memory length (${moduleView.length})`\n      );\n    }\n\n    for (let i = 0; i < memoryView.byteLength; i++) {\n      memoryView[i] = moduleView[i];\n    }\n\n    resultMemory.sharedWasmGlobalVariables.basePointer.value =\n      Runtime.modules.sharedWasmGlobalVariables.basePointer.value;\n    resultMemory.sharedWasmGlobalVariables.heapPointer.value =\n      Runtime.modules.sharedWasmGlobalVariables.heapPointer.value;\n    resultMemory.sharedWasmGlobalVariables.stackPointer.value =\n      Runtime.modules.sharedWasmGlobalVariables.stackPointer.value;\n\n    return resultMemory;\n  }\n\n  setPointers(stackPointer: number, basePointer: number, heapPointer: number) {\n    if (heapPointer > stackPointer) {\n      throw new Error(\n        \"Segmentation fault: Heap pointer clashed with stack pointer\"\n      );\n    }\n\n    this.sharedWasmGlobalVariables = {\n      stackPointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        stackPointer\n      ),\n      basePointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        basePointer\n      ),\n      heapPointer: new WebAssembly.Global(\n        { value: WASM_ADDR_TYPE, mutable: true },\n        heapPointer\n      ),\n    };\n  }\n\n  stackFrameSetup(\n    sizeOfParams: number,\n    sizeOfLocals: number,\n    sizeOfReturn: number,\n    parameters: StashItem[]\n  ): Memory {\n    const newMemory = this.clone();\n    const totalSize = sizeOfParams + sizeOfLocals + sizeOfReturn;\n\n    const SP = this.sharedWasmGlobalVariables.stackPointer.value - totalSize;\n    const BP = this.sharedWasmGlobalVariables.stackPointer.value - sizeOfReturn;\n\n    newMemory.setPointers(\n      SP,\n      BP,\n      this.sharedWasmGlobalVariables.heapPointer.value\n    );\n\n    let offset = 0;\n    const writeParameters: MemoryWriteInterface[] = parameters.map(\n      (writeObject) => {\n        if (\n          writeObject.type !== \"IntegerConstant\" &&\n          writeObject.type !== \"FloatConstant\" &&\n          writeObject.type !== \"MemoryAddress\"\n        ) {\n          throw new Error(\n            `Did not expect ${writeObject.type} in stackFrameSetup`\n          );\n        }\n\n        const dataType: ScalarCDataType =\n          writeObject.type === \"MemoryAddress\"\n            ? \"pointer\"\n            : writeObject.dataType;\n\n        const size = getSizeOfScalarDataType(dataType);\n        offset -= size;\n\n        const writeAddress =\n          BigInt(offset) +\n          BigInt(newMemory.sharedWasmGlobalVariables.basePointer.value);\n\n        // if MemoryAddress convert it to a ConstantP\n        const writeValue = resolveValueToConstantP(writeObject);\n\n        // ConstantP is stored as ConstantP\n        return {\n          type: \"MemoryWriteInterface\",\n          address: writeAddress,\n          dataType: dataType,\n          value: writeValue,\n        };\n      }\n    );\n\n    return newMemory.write(writeParameters);\n  }\n\n  stackFrameTearDown(stackPointer: number, basePointer: number): Memory {\n    const newMemory = this.clone();\n    newMemory.setPointers(\n      stackPointer,\n      basePointer,\n      this.sharedWasmGlobalVariables.heapPointer.value\n    );\n\n    return newMemory;\n  }\n\n  checkOutOfBounds(address: bigint) {\n    return address < 0 || address >= this.memory.buffer.byteLength;\n  }\n\n  // function to write a data type with a value to the memory in the address\n  write(values: MemoryWriteInterface[]): Memory {\n    const newMemory = this.clone();\n    const newMemoryView = new Uint8Array(newMemory.memory.buffer);\n\n    for (const value of values) {\n      const bytestr = convertConstantToByteStr(value.value, value.dataType);\n      const byteArray = parseByteStr(bytestr);\n\n      if (this.checkOutOfBounds(value.address)) {\n        console.log(value.address);\n        console.log(byteArray.length);\n        console.log(bytestr);\n        console.log(value.dataType);\n        throw new Error(\"Memory out of bounds\");\n      }\n      for (\n        let i = 0;\n        i <\n        Math.min(\n          byteArray.length,\n          this.memory.buffer.byteLength - Number(value.address)\n        );\n        i++\n      ) {\n        newMemoryView[i + Number(value.address)] = byteArray[i];\n      }\n    }\n\n    return newMemory;\n  }\n\n  load(address: MemoryAddress, dataType: ScalarCDataType): StashItem {\n    // handles pointers\n    if (dataType === \"pointer\") {\n      // Load pointer value as \"unsigned int\" as they occupy the same amount of space\n      const size = primaryDataTypeSizes[\"unsigned int\"];\n      this.checkOutOfBounds(address.value);\n\n      const view = new Uint8Array(this.memory.buffer);\n      let value = 0n;\n\n      for (\n        let i = 0;\n        i <\n        Math.min(size, this.memory.buffer.byteLength - Number(address.value));\n        i++\n      ) {\n        value |= BigInt(view[Number(address.value) + i]) << BigInt(8 * i);\n      }\n\n      // returns a MemoryAddress instead of a ConstantP\n      return createMemoryAddress(value);\n    }\n\n    // handles the rest of the ScalarCDataTypes\n    const size = primaryDataTypeSizes[dataType];\n    this.checkOutOfBounds(address.value);\n\n    const view = new Uint8Array(this.memory.buffer);\n    if (isIntegerType(dataType)) {\n      let value = 0n;\n      for (\n        let i = 0;\n        i <\n        Math.min(size, this.memory.buffer.byteLength - Number(address.value));\n        i++\n      ) {\n        value |= BigInt(view[Number(address.value) + i]) << BigInt(8 * i);\n      }\n\n      const signBit = 1n << BigInt(size * 8 - 1);\n      const fullMask = 1n << BigInt(size * 8);\n\n      if (value & signBit) {\n        value = value - fullMask;\n      } else {\n        value = value;\n      }\n\n      return {\n        type: \"IntegerConstant\",\n        value: value,\n        dataType: dataType as IntegerDataType,\n        position: defaultPosition,\n      };\n    } else if (isFloatType(dataType)) {\n      const buffer = this.memory.buffer;\n      const offset = Number(address.value);\n      let floatValue;\n      if (dataType === \"float\") {\n        floatValue = new DataView(buffer).getFloat32(offset, true);\n      } else {\n        floatValue = new DataView(buffer).getFloat64(offset, true);\n      }\n      return {\n        type: \"FloatConstant\",\n        value: floatValue,\n        dataType: dataType as FloatDataType,\n        position: defaultPosition,\n      };\n    } else {\n      throw new Error(\"Unknown load value type\");\n    }\n  }\n\n  clone(): Memory {\n    return this;\n    // const clone = new Memory(\n    //   this.dataSegmentByteStr,\n    //   this.dataSegmentSizeInBytes,\n    //   this.heapBuffer,\n    //   this.stackBuffer\n    // )\n\n    // const originalView = new Uint8Array(this.memory.buffer);\n    // const cloneView = new Uint8Array(clone.memory.buffer);\n    // cloneView.set(originalView);\n\n    // clone.setPointers(\n    //   this.sharedWasmGlobalVariables.stackPointer.value,\n    //   this.sharedWasmGlobalVariables.basePointer.value,\n    //   this.sharedWasmGlobalVariables.heapPointer.value\n    // )\n\n    // return clone;\n  }\n\n  getFormattedMemoryView(start: number = 0, end?: number): string {\n    const memoryView = new Uint8Array(this.memory.buffer);\n    const length = end ?? memoryView.length;\n\n    const BP = Number(this.sharedWasmGlobalVariables.basePointer.value);\n    const SP = Number(this.sharedWasmGlobalVariables.stackPointer.value);\n    const HP = Number(this.sharedWasmGlobalVariables.heapPointer.value);\n\n    const result = \"\";\n    // result += \"=== Memory Layout (partial) ===\\n\";\n    // result += `Base Pointer (BP):  0x${BP.toString(10)} (${BP})\\n`;\n    // result += `Stack Pointer (SP): 0x${SP.toString(10)} (${SP})\\n`;\n    // result += `Heap Pointer (HP):  0x${HP.toString(10)} (${HP})\\n`;\n    // result += \"================================\\n\";\n\n    // const bytesPerRow = 16;\n    // for (let i = start; i < Math.min(length, memoryView.length); i += bytesPerRow) {\n    //   const bytes = memoryView.slice(i, i + bytesPerRow);\n    //   const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');\n    //   const ascii = Array.from(bytes).map(b => (b >= 32 && b < 127 ? String.fromCharCode(b) : '.')).join('');\n    //   result += `0x${i.toString(16).padStart(8, '0')}: ${hex.padEnd(3 * bytesPerRow)} | ${ascii}\\n`;\n    // }\n\n    return result;\n  }\n}\n","import { ScalarCDataType } from \"../common/types\";\nimport { MemoryAddressEntry } from \"../processor/memoryAddressMap\";\nimport { memoryManager } from \"../processor/memoryManager\";\nimport { Memory } from \"./memory\";\n\nexport class StackFrame {\n  public functionName: string;\n  public variablesMap: Map<string, MemoryAddressEntry> = new Map();\n\n  constructor(functionName: string, basePointer: number, memory: Memory) {\n    this.functionName = functionName;\n\n    const addressMap = memoryManager.getAddressMap();\n    const map = addressMap.getAddressMap();\n\n    map.forEach((entry, name) => {\n      const parts = name.split(\"::\");\n      const varName = parts[1];\n      const scope = parts[0];\n\n      let targetDataType : ScalarCDataType = \"signed int\";\n\n      if (entry.dataType.type == \"primary\") {\n        targetDataType = entry.dataType.primaryDataType\n      } else if(entry.dataType.type == \"pointer\") {\n        targetDataType = \"signed int\"\n      } else {\n        throw new Error(\"Cannot load: \" + entry.dataType + \" from memory\");\n      }\n\n      if (scope === functionName) {\n        const absoluteAddress = entry.offset + basePointer;\n        const value = memory.load(\n          {\n            type: \"MemoryAddress\",\n            value: BigInt(absoluteAddress),\n            hexValue: absoluteAddress.toString(16),\n          },\n          targetDataType\n        );\n        let targetValue = 0;\n\n        if (value.type == \"FunctionTableIndex\") {\n          targetValue = Number(value.index.value)\n        } else {\n          targetValue = Number(value.value)\n        }\n\n        this.variablesMap.set(varName, {\n          ...entry,\n          absoluteAddress,\n          value: Number(targetValue),\n        });\n      }\n\n    });\n  }\n}\n","export * from './instructions';\nexport * from './types';\n","import { CNodeP } from \"~src/processor/c-ast/core\";\n\nexport type CNodeType = CNodeP[\"type\"];\n"],"names":[],"version":3,"file":"index.js.map"}