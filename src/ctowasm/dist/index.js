import * as $hgUW1$process from "process";
import $hgUW1$bignumberjs from "bignumber.js";
import $hgUW1$wabt from "wabt";


function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
class $6cd02a3df715eddf$export$c3a9d7ff17e4f3ed {
    constructor(memory, functionTable, config, sharedWasmGlobalVariables){
        this.freeList = [];
        this.allocatedBlocks = new Map() // allocated memory blocks <address, size>
        ;
        this.memory = memory;
        this.functionTable = functionTable;
        this.config = config;
        this.sharedWasmGlobalVariables = sharedWasmGlobalVariables;
    }
    /**
   * Print to "stdout" by calling the printFunction defined in config.
   */ print(str) {
        this.config.printFunction(str);
    }
}


var $2d67dfdbe24056a5$exports = {};

var $2d67dfdbe24056a5$var$Module = (()=>{
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : undefined;
    return function(moduleArg = {}) {
        // include: shell.js
        // The Module object: Our interface to the outside world. We import
        // and export values on it. There are various ways Module can be used:
        // 1. Not defined. We create it here
        // 2. A function parameter, function(Module) { ..generated code.. }
        // 3. pre-run appended it, var Module = {}; ..generated code..
        // 4. External script tag defines var Module.
        // We need to check if Module already exists (e.g. case 3 above).
        // Substitution will be replaced with actual code on later stage of the build,
        // this way Closure Compiler will not mangle it (e.g. case 4. above).
        // Note that if you want to run closure, and also to use Module
        // after the generated code, you will need to define   var Module = {};
        // before the code. Then that object will be used in the code, and you
        // can continue to use Module afterwards as well.
        var Module = moduleArg;
        // Set up the promise that indicates the Module is initialized
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise((resolve, reject)=>{
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
        });
        [
            "_acos",
            "_asin",
            "_atan",
            "_cos",
            "_cosh",
            "_sin",
            "_sinh",
            "_tan",
            "_tanh",
            "_exp",
            "_log",
            "_log10",
            "_pow",
            "_sqrt",
            "_ceil",
            "_floor",
            "_memory",
            "_fflush",
            "___indirect_function_table",
            "onRuntimeInitialized"
        ].forEach((prop)=>{
            if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) Object.defineProperty(Module["ready"], prop, {
                get: ()=>abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
                set: ()=>abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
            });
        });
        // --pre-jses are emitted after the Module integration code, so that they can
        // refer to Module (if they choose; they can also define Module)
        // Sometimes an existing Module object exists with properties
        // meant to overwrite the default module functionality. Here
        // we collect those properties and reapply _after_ we configure
        // the current environment's defaults to avoid having to be so
        // defensive during initialization.
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow)=>{
            throw toThrow;
        };
        // Determine the runtime environment we are in. You can customize this by
        // setting the ENVIRONMENT setting at compile time (see settings.js).
        var ENVIRONMENT_IS_WEB = true;
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = false;
        var ENVIRONMENT_IS_SHELL = false;
        if (Module["ENVIRONMENT"]) throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
        // `/` should be present at the end if `scriptDirectory` is not empty
        var scriptDirectory = "";
        function locateFile(path) {
            if (Module["locateFile"]) return Module["locateFile"](path, scriptDirectory);
            return scriptDirectory + path;
        }
        // Hooks that are implemented differently in different runtime environments.
        var read_, readAsync, readBinary, setWindowTitle;
        if (ENVIRONMENT_IS_SHELL) {
            if (typeof $hgUW1$process == "object" && true || typeof window == "object" || typeof importScripts == "function") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
            if (typeof read != "undefined") read_ = read;
            readBinary = (f)=>{
                if (typeof readbuffer == "function") return new Uint8Array(readbuffer(f));
                let data = read(f, "binary");
                assert(typeof data == "object");
                return data;
            };
            readAsync = (f, onload, onerror)=>{
                setTimeout(()=>onload(readBinary(f)));
            };
            if (typeof clearTimeout == "undefined") globalThis.clearTimeout = (id)=>{};
            if (typeof setTimeout == "undefined") // spidermonkey lacks setTimeout but we use it above in readAsync.
            globalThis.setTimeout = (f)=>typeof f == "function" ? f() : abort();
            if (typeof scriptArgs != "undefined") arguments_ = scriptArgs;
            else if (typeof arguments != "undefined") arguments_ = arguments;
            if (typeof quit == "function") quit_ = (status, toThrow)=>{
                // Unlike node which has process.exitCode, d8 has no such mechanism. So we
                // have no way to set the exit code and then let the program exit with
                // that code when it naturally stops running (say, when all setTimeouts
                // have completed). For that reason, we must call `quit` - the only way to
                // set the exit code - but quit also halts immediately.  To increase
                // consistency with node (and the web) we schedule the actual quit call
                // using a setTimeout to give the current stack and any exception handlers
                // a chance to run.  This enables features such as addOnPostRun (which
                // expected to be able to run code after main returns).
                setTimeout(()=>{
                    if (!(toThrow instanceof ExitStatus)) {
                        let toLog = toThrow;
                        if (toThrow && typeof toThrow == "object" && toThrow.stack) toLog = [
                            toThrow,
                            toThrow.stack
                        ];
                        err(`exiting due to exception: ${toLog}`);
                    }
                    quit(status);
                });
                throw toThrow;
            };
            if (typeof print != "undefined") {
                // Prefer to use print/printErr where they exist, as they usually work better.
                if (typeof console == "undefined") console = /** @type{!Console} */ {};
                console.log = /** @type{!function(this:Console, ...*): undefined} */ print;
                console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ typeof printErr != "undefined" ? printErr : print;
            }
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) // Check worker, not web, since window could be polyfilled
            scriptDirectory = self.location.href;
            else if (typeof document != "undefined" && document.currentScript) // web
            scriptDirectory = document.currentScript.src;
            // When MODULARIZE, this JS may be executed later, after document.currentScript
            // is gone, so we saved it, and we use it here instead of any other info.
            if (_scriptDir) scriptDirectory = _scriptDir;
            // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
            // otherwise, slice off the final part of the url to find the script directory.
            // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
            // and scriptDirectory will correctly be replaced with an empty string.
            // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
            // they are removed because they could contain a slash.
            if (scriptDirectory.indexOf("blob:") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            else scriptDirectory = "";
            if (!(typeof window == "object" || typeof importScripts == "function")) throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
            // include: web_or_worker_shell_read.js
            read_ = (url)=>{
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(/** @type{!ArrayBuffer} */ xhr.response);
            };
            readAsync = (url, onload, onerror)=>{
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = ()=>{
                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                        // file URLs can return 0
                        onload(xhr.response);
                        return;
                    }
                    onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
            };
            setWindowTitle = (title)=>document.title = title;
        } else throw new Error("environment detection error");
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.error.bind(console);
        // Merge back in the overrides
        Object.assign(Module, moduleOverrides);
        // Free the object hierarchy contained in the overrides, this lets the GC
        // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
        moduleOverrides = null;
        checkIncomingModuleAPI();
        // Emit code to handle expected values on the Module object. This applies Module.x
        // to the proper local x. This has two benefits: first, we only emit it if it is
        // expected to arrive, and second, by using a local everywhere else that can be
        // minified.
        if (Module["arguments"]) arguments_ = Module["arguments"];
        legacyModuleProp("arguments", "arguments_");
        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        legacyModuleProp("thisProgram", "thisProgram");
        if (Module["quit"]) quit_ = Module["quit"];
        legacyModuleProp("quit", "quit_");
        // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
        // Assertions on removed incoming Module JS APIs.
        assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
        assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
        assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
        assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
        assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
        legacyModuleProp("asm", "wasmExports");
        legacyModuleProp("read", "read_");
        legacyModuleProp("readAsync", "readAsync");
        legacyModuleProp("readBinary", "readBinary");
        legacyModuleProp("setWindowTitle", "setWindowTitle");
        var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
        var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
        var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
        var FETCHFS = "FETCHFS is no longer included by default; build with -lfetchfs.js";
        var ICASEFS = "ICASEFS is no longer included by default; build with -licasefs.js";
        var JSFILEFS = "JSFILEFS is no longer included by default; build with -ljsfilefs.js";
        var OPFS = "OPFS is no longer included by default; build with -lopfs.js";
        var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";
        assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
        assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
        assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
        // end include: shell.js
        // include: preamble.js
        // === Preamble library stuff ===
        // Documentation for the public APIs defined in this file must be updated in:
        //    site/source/docs/api_reference/preamble.js.rst
        // A prebuilt local version of the documentation is available at:
        //    site/build/text/docs/api_reference/preamble.js.txt
        // You can also build docs locally as HTML or other formats in site/
        // An online HTML version (which may be of a different version of Emscripten)
        //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
        var wasmBinary;
        if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
        legacyModuleProp("wasmBinary", "wasmBinary");
        var noExitRuntime = Module["noExitRuntime"] || true;
        legacyModuleProp("noExitRuntime", "noExitRuntime");
        if (typeof WebAssembly != "object") abort("no native wasm support detected");
        // Wasm globals
        var wasmMemory;
        //========================================
        // Runtime essentials
        //========================================
        // whether we are quitting the application. no code should run after this.
        // set in exit() and abort()
        var ABORT = false;
        // set by exit() and abort().  Passed to 'onExit' handler.
        // NOTE: This is also used as the process return code code in shell environments
        // but only when noExitRuntime is false.
        var EXITSTATUS;
        /** @type {function(*, string=)} */ function assert(condition, text) {
            if (!condition) abort("Assertion failed" + (text ? ": " + text : ""));
        }
        // We used to include malloc/free by default in the past. Show a helpful error in
        // builds with assertions.
        function _malloc() {
            abort("malloc() called but not included in the build - add '_malloc' to EXPORTED_FUNCTIONS");
        }
        function _free() {
            // Show a helpful error since we used to include free by default in the past.
            abort("free() called but not included in the build - add '_free' to EXPORTED_FUNCTIONS");
        }
        // Memory management
        var HEAP, /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;
        function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
        }
        assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
        assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, "JS engine does not provide full typed array support");
        // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
        assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
        assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
        // include: runtime_init_table.js
        // In regular non-RELOCATABLE mode the table is exported
        // from the wasm module and this will be assigned once
        // the exports are available.
        var wasmTable;
        // end include: runtime_init_table.js
        // include: runtime_stack_check.js
        // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
        function writeStackCookie() {
            var max = _emscripten_stack_get_end();
            assert((max & 3) == 0);
            // If the stack ends at address zero we write our cookies 4 bytes into the
            // stack.  This prevents interference with SAFE_HEAP and ASAN which also
            // monitor writes to address zero.
            if (max == 0) max += 4;
            // The stack grow downwards towards _emscripten_stack_get_end.
            // We write cookies to the final two words in the stack and detect if they are
            // ever overwritten.
            HEAPU32[max >> 2] = 0x02135467;
            HEAPU32[max + 4 >> 2] = 0x89bacdfe;
            // Also test the global address 0 for integrity.
            HEAPU32[0] = 1668509029;
        }
        function checkStackCookie() {
            if (ABORT) return;
            var max = _emscripten_stack_get_end();
            // See writeStackCookie().
            if (max == 0) max += 4;
            var cookie1 = HEAPU32[max >> 2];
            var cookie2 = HEAPU32[max + 4 >> 2];
            if (cookie1 != 0x02135467 || cookie2 != 0x89bacdfe) abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
            // Also test the global address 0 for integrity.
            if (HEAPU32[0] != 0x63736d65 /* 'emsc' */ ) abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
        }
        // end include: runtime_stack_check.js
        // include: runtime_assertions.js
        // Endianness check
        (function() {
            var h16 = new Int16Array(1);
            var h8 = new Int8Array(h16.buffer);
            h16[0] = 0x6373;
            if (h8[0] !== 0x73 || h8[1] !== 0x63) throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
        })();
        // end include: runtime_assertions.js
        var __ATPRERUN__ = []; // functions called before the runtime is initialized
        var __ATINIT__ = []; // functions called during startup
        var __ATEXIT__ = []; // functions called during shutdown
        var __ATPOSTRUN__ = []; // functions called after the main() is called
        var runtimeInitialized = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
            if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function") Module["preRun"] = [
                    Module["preRun"]
                ];
                while(Module["preRun"].length)addOnPreRun(Module["preRun"].shift());
            }
            callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
            assert(!runtimeInitialized);
            runtimeInitialized = true;
            checkStackCookie();
            callRuntimeCallbacks(__ATINIT__);
        }
        function postRun() {
            checkStackCookie();
            if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function") Module["postRun"] = [
                    Module["postRun"]
                ];
                while(Module["postRun"].length)addOnPostRun(Module["postRun"].shift());
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
            __ATINIT__.unshift(cb);
        }
        function addOnExit(cb) {}
        function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
        }
        // include: runtime_math.js
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
        assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        // end include: runtime_math.js
        // A counter of dependencies for calling run(). If we need to
        // do asynchronous work before running, increment this and
        // decrement it. Incrementing must happen in a place like
        // Module.preRun (used by emcc to add file preloading).
        // Note that you can add dependencies in preRun, even though
        // it happens right before run - run will be postponed until
        // the dependencies are met.
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
        var runDependencyTracking = {};
        function getUniqueRunDependency(id) {
            var orig = id;
            while(true){
                if (!runDependencyTracking[id]) return id;
                id = orig + Math.random();
            }
        }
        function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
            if (id) {
                assert(!runDependencyTracking[id]);
                runDependencyTracking[id] = 1;
                if (runDependencyWatcher === null && typeof setInterval != "undefined") // Check for missing dependencies every few seconds
                runDependencyWatcher = setInterval(()=>{
                    if (ABORT) {
                        clearInterval(runDependencyWatcher);
                        runDependencyWatcher = null;
                        return;
                    }
                    var shown = false;
                    for(var dep in runDependencyTracking){
                        if (!shown) {
                            shown = true;
                            err("still waiting on run dependencies:");
                        }
                        err(`dependency: ${dep}`);
                    }
                    if (shown) err("(end of list)");
                }, 10000);
            } else err("warning: run dependency added without ID");
        }
        function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
            if (id) {
                assert(runDependencyTracking[id]);
                delete runDependencyTracking[id];
            } else err("warning: run dependency removed without ID");
            if (runDependencies == 0) {
                if (runDependencyWatcher !== null) {
                    clearInterval(runDependencyWatcher);
                    runDependencyWatcher = null;
                }
                if (dependenciesFulfilled) {
                    var callback = dependenciesFulfilled;
                    dependenciesFulfilled = null;
                    callback(); // can add another dependenciesFulfilled
                }
            }
        }
        /** @param {string|number=} what */ function abort(what) {
            if (Module["onAbort"]) Module["onAbort"](what);
            what = "Aborted(" + what + ")";
            // TODO(sbc): Should we remove printing and leave it up to whoever
            // catches the exception?
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            // Use a wasm runtime error, because a JS error might be seen as a foreign
            // exception, which means we'd run destructors on it. We need the error to
            // simply make the program stop.
            // FIXME This approach does not work in Wasm EH because it currently does not assume
            // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
            // a trap or not based on a hidden field within the object. So at the moment
            // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
            // allows this in the wasm spec.
            // Suppress closure compiler warning here. Closure compiler's builtin extern
            // defintion for WebAssembly.RuntimeError claims it takes no arguments even
            // though it can.
            // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
            /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            // Throw the error whether or not MODULARIZE is set because abort is used
            // in code paths apart from instantiation where an exception is expected
            // to be thrown when abort is called.
            throw e;
        }
        // include: memoryprofiler.js
        // end include: memoryprofiler.js
        // show errors on likely calls to FS when it was not included
        var FS = {
            error () {
                abort("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM");
            },
            init () {
                FS.error();
            },
            createDataFile () {
                FS.error();
            },
            createPreloadedFile () {
                FS.error();
            },
            createLazyFile () {
                FS.error();
            },
            open () {
                FS.error();
            },
            mkdev () {
                FS.error();
            },
            registerDevice () {
                FS.error();
            },
            analyzePath () {
                FS.error();
            },
            ErrnoError () {
                FS.error();
            }
        };
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        // include: URIUtils.js
        // Prefix of data URIs emitted by SINGLE_FILE and related options.
        var dataURIPrefix = "data:application/octet-stream;base64,";
        // Indicates whether filename is a base64 data URI.
        function isDataURI(filename) {
            // Prefix of data URIs emitted by SINGLE_FILE and related options.
            return filename.startsWith(dataURIPrefix);
        }
        // Indicates whether filename is delivered via file protocol (as opposed to http/https)
        function isFileURI(filename) {
            return filename.startsWith("file://");
        }
        // end include: URIUtils.js
        function createExportWrapper(name) {
            return function() {
                assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
                var f = wasmExports[name];
                assert(f, `exported native function \`${name}\` not found`);
                return f.apply(null, arguments);
            };
        }
        // include: runtime_exceptions.js
        // end include: runtime_exceptions.js
        var wasmBinaryFile;
        wasmBinaryFile = "data:application/octet-stream;base64,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";
        if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);
        function getBinarySync(file) {
            if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
            var binary = tryParseAsDataURI(file);
            if (binary) return binary;
            if (readBinary) return readBinary(file);
            throw "both async and sync fetching of the wasm failed";
        }
        function getBinaryPromise(binaryFile) {
            // Otherwise, getBinarySync should be able to get it synchronously
            return Promise.resolve().then(()=>getBinarySync(binaryFile));
        }
        function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary)=>{
                return WebAssembly.instantiate(binary, imports);
            }).then((instance)=>{
                return instance;
            }).then(receiver, (reason)=>{
                err(`failed to asynchronously prepare wasm: ${reason}`);
                // Warn on some common problems.
                if (isFileURI(wasmBinaryFile)) err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
                abort(reason);
            });
        }
        function instantiateAsync(binary, binaryFile, imports, callback) {
            return instantiateArrayBuffer(binaryFile, imports, callback);
        }
        // Create the wasm instance.
        // Receives the wasm imports, returns the exports.
        function createWasm() {
            // prepare imports
            var info = {
                env: wasmImports,
                wasi_snapshot_preview1: wasmImports
            };
            // Load the wasm module and create an instance of using native support in the JS engine.
            // handle a generated wasm instance, receiving its exports and
            // performing other necessary setup
            /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module1) {
                var exports = instance.exports;
                wasmExports = exports;
                wasmMemory = wasmExports["memory"];
                assert(wasmMemory, "memory not found in wasm exports");
                // This assertion doesn't hold when emscripten is run in --post-link
                // mode.
                // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
                //assert(wasmMemory.buffer.byteLength === 16777216);
                updateMemoryViews();
                wasmTable = wasmExports["__indirect_function_table"];
                assert(wasmTable, "table not found in wasm exports");
                addOnInit(wasmExports["__wasm_call_ctors"]);
                removeRunDependency("wasm-instantiate");
                return exports;
            }
            // wait for the pthread pool (if any)
            addRunDependency("wasm-instantiate");
            // Prefer streaming instantiation if available.
            // Async compilation can be confusing when an error on the page overwrites Module
            // (for example, if the order of elements is wrong, and the one defining Module is
            // later), so we save Module and check it later.
            var trueModule = Module;
            function receiveInstantiationResult(result) {
                // 'result' is a ResultObject object which has both the module and instance.
                // receiveInstance() will swap in the exports (to Module.asm) so they can be called
                assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
                trueModule = null;
                // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
                // When the regression is fixed, can restore the above PTHREADS-enabled path.
                receiveInstance(result["instance"]);
            }
            // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
            // to manually instantiate the Wasm module themselves. This allows pages to
            // run the instantiation parallel to any other async startup actions they are
            // performing.
            // Also pthreads and wasm workers initialize the wasm instance through this
            // path.
            if (Module["instantiateWasm"]) try {
                return Module["instantiateWasm"](info, receiveInstance);
            } catch (e) {
                err(`Module.instantiateWasm callback failed with error: ${e}`);
                // If instantiation fails, reject the module ready promise.
                readyPromiseReject(e);
            }
            // If instantiation fails, reject the module ready promise.
            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
            return {}; // no exports yet; we'll fill them in later
        }
        // Globals used by JS i64 conversions (see makeSetValue)
        var tempDouble;
        var tempI64;
        // include: runtime_debug.js
        function legacyModuleProp(prop, newName, incomming = true) {
            if (!Object.getOwnPropertyDescriptor(Module, prop)) Object.defineProperty(Module, prop, {
                configurable: true,
                get () {
                    let extra = incomming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : "";
                    abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);
                }
            });
        }
        function ignoredModuleProp(prop) {
            if (Object.getOwnPropertyDescriptor(Module, prop)) abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
        }
        // forcing the filesystem exports a few things by default
        function isExportedByForceFilesystem(name) {
            return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || // The old FS has some functionality that WasmFS lacks.
            name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
        }
        function missingGlobal(sym, msg) {
            if (typeof globalThis !== "undefined") Object.defineProperty(globalThis, sym, {
                configurable: true,
                get () {
                    warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
                    return undefined;
                }
            });
        }
        missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
        missingGlobal("asm", "Please use wasmExports instead");
        function missingLibrarySymbol(sym) {
            if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) Object.defineProperty(globalThis, sym, {
                configurable: true,
                get () {
                    // Can't `abort()` here because it would break code that does runtime
                    // checks.  e.g. `if (typeof SDL === 'undefined')`.
                    var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
                    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
                    // library.js, which means $name for a JS name with no prefix, or name
                    // for a JS name like _name.
                    var librarySymbol = sym;
                    if (!librarySymbol.startsWith("_")) librarySymbol = "$" + sym;
                    msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='" + librarySymbol + "')";
                    if (isExportedByForceFilesystem(sym)) msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                    warnOnce(msg);
                    return undefined;
                }
            });
            // Any symbol that is not included from the JS libary is also (by definition)
            // not exported on the Module object.
            unexportedRuntimeSymbol(sym);
        }
        function unexportedRuntimeSymbol(sym) {
            if (!Object.getOwnPropertyDescriptor(Module, sym)) Object.defineProperty(Module, sym, {
                configurable: true,
                get () {
                    var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)";
                    if (isExportedByForceFilesystem(sym)) msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                    abort(msg);
                }
            });
        }
        // Used by XXXXX_DEBUG settings to output debug messages.
        function dbg(text) {
            // TODO(sbc): Make this configurable somehow.  Its not always convenient for
            // logging to show up as warnings.
            console.warn.apply(console, arguments);
        }
        // end include: runtime_debug.js
        // === Body ===
        // end include: preamble.js
        /** @constructor */ function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
        }
        var callRuntimeCallbacks = (callbacks)=>{
            while(callbacks.length > 0)// Pass the module as the first argument.
            callbacks.shift()(Module);
        };
        /**
     * @param {number} ptr
     * @param {string} type
     */ function getValue(ptr, type = "i8") {
            if (type.endsWith("*")) type = "*";
            switch(type){
                case "i1":
                    return HEAP8[ptr >> 0];
                case "i8":
                    return HEAP8[ptr >> 0];
                case "i16":
                    return HEAP16[ptr >> 1];
                case "i32":
                    return HEAP32[ptr >> 2];
                case "i64":
                    abort("to do getValue(i64) use WASM_BIGINT");
                case "float":
                    return HEAPF32[ptr >> 2];
                case "double":
                    return HEAPF64[ptr >> 3];
                case "*":
                    return HEAPU32[ptr >> 2];
                default:
                    abort(`invalid type for getValue: ${type}`);
            }
        }
        var ptrToString = (ptr)=>{
            assert(typeof ptr === "number");
            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
            ptr >>>= 0;
            return "0x" + ptr.toString(16).padStart(8, "0");
        };
        /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */ function setValue(ptr, value, type = "i8") {
            if (type.endsWith("*")) type = "*";
            switch(type){
                case "i1":
                    HEAP8[ptr >> 0] = value;
                    break;
                case "i8":
                    HEAP8[ptr >> 0] = value;
                    break;
                case "i16":
                    HEAP16[ptr >> 1] = value;
                    break;
                case "i32":
                    HEAP32[ptr >> 2] = value;
                    break;
                case "i64":
                    abort("to do setValue(i64) use WASM_BIGINT");
                case "float":
                    HEAPF32[ptr >> 2] = value;
                    break;
                case "double":
                    HEAPF64[ptr >> 3] = value;
                    break;
                case "*":
                    HEAPU32[ptr >> 2] = value;
                    break;
                default:
                    abort(`invalid type for setValue: ${type}`);
            }
        }
        var warnOnce = (text)=>{
            if (!warnOnce.shown) warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
                warnOnce.shown[text] = 1;
                err(text);
            }
        };
        var getCFunc = (ident)=>{
            var func = Module["_" + ident]; // closure exported function
            assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
            return func;
        };
        var writeArrayToMemory = (array, buffer)=>{
            assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
            HEAP8.set(array, buffer);
        };
        var lengthBytesUTF8 = (str)=>{
            var len = 0;
            for(var i = 0; i < str.length; ++i){
                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                // unit, not a Unicode code point of the character! So decode
                // UTF16->UTF32->UTF8.
                // See http://unicode.org/faq/utf_bom.html#utf16-3
                var c = str.charCodeAt(i); // possibly a lead surrogate
                if (c <= 0x7f) len++;
                else if (c <= 0x7ff) len += 2;
                else if (c >= 0xd800 && c <= 0xdfff) {
                    len += 4;
                    ++i;
                } else len += 3;
            }
            return len;
        };
        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{
            assert(typeof str === "string");
            // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
            // undefined and false each don't write out any bytes.
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
            for(var i = 0; i < str.length; ++i){
                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                // unit, not a Unicode code point of the character! So decode
                // UTF16->UTF32->UTF8.
                // See http://unicode.org/faq/utf_bom.html#utf16-3
                // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
                // and https://www.ietf.org/rfc/rfc2279.txt
                // and https://tools.ietf.org/html/rfc3629
                var u = str.charCodeAt(i); // possibly a lead surrogate
                if (u >= 0xd800 && u <= 0xdfff) {
                    var u1 = str.charCodeAt(++i);
                    u = 0x10000 + ((u & 0x3ff) << 10) | u1 & 0x3ff;
                }
                if (u <= 0x7f) {
                    if (outIdx >= endIdx) break;
                    heap[outIdx++] = u;
                } else if (u <= 0x7ff) {
                    if (outIdx + 1 >= endIdx) break;
                    heap[outIdx++] = 0xc0 | u >> 6;
                    heap[outIdx++] = 0x80 | u & 63;
                } else if (u <= 0xffff) {
                    if (outIdx + 2 >= endIdx) break;
                    heap[outIdx++] = 0xe0 | u >> 12;
                    heap[outIdx++] = 0x80 | u >> 6 & 63;
                    heap[outIdx++] = 0x80 | u & 63;
                } else {
                    if (outIdx + 3 >= endIdx) break;
                    if (u > 0x10ffff) warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
                    heap[outIdx++] = 0xf0 | u >> 18;
                    heap[outIdx++] = 0x80 | u >> 12 & 63;
                    heap[outIdx++] = 0x80 | u >> 6 & 63;
                    heap[outIdx++] = 0x80 | u & 63;
                }
            }
            // Null-terminate the pointer to the buffer.
            heap[outIdx] = 0;
            return outIdx - startIdx;
        };
        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>{
            assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        };
        var stringToUTF8OnStack = (str)=>{
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8(str, ret, size);
            return ret;
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;
        /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */ var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead)=>{
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            // TextDecoder needs to know the byte length in advance, it doesn't stop on
            // null terminator by itself.  Also, use the length info to avoid running tiny
            // strings through TextDecoder, since .subarray() allocates garbage.
            // (As a tiny code save trick, compare endPtr against endIdx using a negation,
            // so that undefined means Infinity)
            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;
            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            var str = "";
            // If building with TextDecoder, we have already computed the string length
            // above, so test loop end condition against that
            while(idx < endPtr){
                // For UTF8 byte structure, see:
                // http://en.wikipedia.org/wiki/UTF-8#Description
                // https://www.ietf.org/rfc/rfc2279.txt
                // https://tools.ietf.org/html/rfc3629
                var u0 = heapOrArray[idx++];
                if (!(u0 & 0x80)) {
                    str += String.fromCharCode(u0);
                    continue;
                }
                var u1 = heapOrArray[idx++] & 63;
                if ((u0 & 0xe0) == 0xc0) {
                    str += String.fromCharCode((u0 & 31) << 6 | u1);
                    continue;
                }
                var u2 = heapOrArray[idx++] & 63;
                if ((u0 & 0xf0) == 0xe0) u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                else {
                    if ((u0 & 0xf8) != 0xf0) warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
                }
                if (u0 < 0x10000) str += String.fromCharCode(u0);
                else {
                    var ch = u0 - 0x10000;
                    str += String.fromCharCode(0xd800 | ch >> 10, 0xdc00 | ch & 0x3ff);
                }
            }
            return str;
        };
        /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */ var UTF8ToString = (ptr, maxBytesToRead)=>{
            assert(typeof ptr == "number");
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        };
        /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */ var ccall = (ident, returnType, argTypes, args, opts)=>{
            // For fast lookup of conversion functions
            var toC = {
                string: (str)=>{
                    var ret = 0;
                    if (str !== null && str !== undefined && str !== 0) // null string
                    // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
                    ret = stringToUTF8OnStack(str);
                    return ret;
                },
                array: (arr)=>{
                    var ret = stackAlloc(arr.length);
                    writeArrayToMemory(arr, ret);
                    return ret;
                }
            };
            function convertReturnValue(ret) {
                if (returnType === "string") return UTF8ToString(ret);
                if (returnType === "boolean") return Boolean(ret);
                return ret;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            assert(returnType !== "array", 'Return type should not be "array".');
            if (args) for(var i = 0; i < args.length; i++){
                var converter = toC[argTypes[i]];
                if (converter) {
                    if (stack === 0) stack = stackSave();
                    cArgs[i] = converter(args[i]);
                } else cArgs[i] = args[i];
            }
            var ret = func.apply(null, cArgs);
            function onDone(ret) {
                if (stack !== 0) stackRestore(stack);
                return convertReturnValue(ret);
            }
            ret = onDone(ret);
            return ret;
        };
        /**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */ var cwrap = (ident, returnType, argTypes, opts)=>{
            return function() {
                return ccall(ident, returnType, argTypes, arguments, opts);
            };
        };
        function checkIncomingModuleAPI() {
            ignoredModuleProp("fetchSettings");
        }
        var wasmImports = {};
        var wasmExports = createWasm();
        var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
        var ___errno_location = createExportWrapper("__errno_location");
        var _acos = Module["_acos"] = createExportWrapper("acos");
        var _asin = Module["_asin"] = createExportWrapper("asin");
        var _atan = Module["_atan"] = createExportWrapper("atan");
        var _ceil = Module["_ceil"] = createExportWrapper("ceil");
        var _cos = Module["_cos"] = createExportWrapper("cos");
        var _cosh = Module["_cosh"] = createExportWrapper("cosh");
        var _exp = Module["_exp"] = createExportWrapper("exp");
        var _fflush = Module["_fflush"] = createExportWrapper("fflush");
        var _floor = Module["_floor"] = createExportWrapper("floor");
        var _log = Module["_log"] = createExportWrapper("log");
        var _log10 = Module["_log10"] = createExportWrapper("log10");
        var _pow = Module["_pow"] = createExportWrapper("pow");
        var _sin = Module["_sin"] = createExportWrapper("sin");
        var _sinh = Module["_sinh"] = createExportWrapper("sinh");
        var _sqrt = Module["_sqrt"] = createExportWrapper("sqrt");
        var _tan = Module["_tan"] = createExportWrapper("tan");
        var _tanh = Module["_tanh"] = createExportWrapper("tanh");
        var _emscripten_stack_init = ()=>(_emscripten_stack_init = wasmExports["emscripten_stack_init"])();
        var _emscripten_stack_get_free = ()=>(_emscripten_stack_get_free = wasmExports["emscripten_stack_get_free"])();
        var _emscripten_stack_get_base = ()=>(_emscripten_stack_get_base = wasmExports["emscripten_stack_get_base"])();
        var _emscripten_stack_get_end = ()=>(_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();
        var stackSave = createExportWrapper("stackSave");
        var stackRestore = createExportWrapper("stackRestore");
        var stackAlloc = createExportWrapper("stackAlloc");
        var _emscripten_stack_get_current = ()=>(_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
        // include: postamble.js
        // === Auto-generated postamble setup entry stuff ===
        // include: base64Utils.js
        // Converts a string of base64 into a byte array.
        // Throws error on invalid input.
        function intArrayFromBase64(s) {
            try {
                var decoded = atob(s);
                var bytes = new Uint8Array(decoded.length);
                for(var i = 0; i < decoded.length; ++i)bytes[i] = decoded.charCodeAt(i);
                return bytes;
            } catch (_) {
                throw new Error("Converting base64 string to bytes failed.");
            }
        }
        // If filename is a base64 data URI, parses and returns data (Buffer on node,
        // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
        function tryParseAsDataURI(filename) {
            if (!isDataURI(filename)) return;
            return intArrayFromBase64(filename.slice(dataURIPrefix.length));
        }
        // end include: base64Utils.js
        Module["ccall"] = ccall;
        Module["cwrap"] = cwrap;
        var missingLibrarySymbols = [
            "writeI53ToI64",
            "writeI53ToI64Clamped",
            "writeI53ToI64Signaling",
            "writeI53ToU64Clamped",
            "writeI53ToU64Signaling",
            "readI53FromI64",
            "readI53FromU64",
            "convertI32PairToI53",
            "convertI32PairToI53Checked",
            "convertU32PairToI53",
            "zeroMemory",
            "exitJS",
            "getHeapMax",
            "abortOnCannotGrowMemory",
            "growMemory",
            "isLeapYear",
            "ydayFromDate",
            "arraySum",
            "addDays",
            "setErrNo",
            "inetPton4",
            "inetNtop4",
            "inetPton6",
            "inetNtop6",
            "readSockaddr",
            "writeSockaddr",
            "getHostByName",
            "initRandomFill",
            "randomFill",
            "getCallstack",
            "emscriptenLog",
            "convertPCtoSourceLocation",
            "readEmAsmArgs",
            "jstoi_q",
            "jstoi_s",
            "getExecutableName",
            "listenOnce",
            "autoResumeAudioContext",
            "dynCallLegacy",
            "getDynCaller",
            "dynCall",
            "handleException",
            "runtimeKeepalivePush",
            "runtimeKeepalivePop",
            "callUserCallback",
            "maybeExit",
            "safeSetTimeout",
            "asmjsMangle",
            "asyncLoad",
            "alignMemory",
            "mmapAlloc",
            "handleAllocatorInit",
            "HandleAllocator",
            "getNativeTypeSize",
            "STACK_SIZE",
            "STACK_ALIGN",
            "POINTER_SIZE",
            "ASSERTIONS",
            "uleb128Encode",
            "sigToWasmTypes",
            "generateFuncType",
            "convertJsFunctionToWasm",
            "getEmptyTableSlot",
            "updateTableMap",
            "getFunctionAddress",
            "addFunction",
            "removeFunction",
            "reallyNegative",
            "unSign",
            "strLen",
            "reSign",
            "formatString",
            "intArrayFromString",
            "intArrayToString",
            "AsciiToString",
            "stringToAscii",
            "UTF16ToString",
            "stringToUTF16",
            "lengthBytesUTF16",
            "UTF32ToString",
            "stringToUTF32",
            "lengthBytesUTF32",
            "stringToNewUTF8",
            "registerKeyEventCallback",
            "maybeCStringToJsString",
            "findEventTarget",
            "findCanvasEventTarget",
            "getBoundingClientRect",
            "fillMouseEventData",
            "registerMouseEventCallback",
            "registerWheelEventCallback",
            "registerUiEventCallback",
            "registerFocusEventCallback",
            "fillDeviceOrientationEventData",
            "registerDeviceOrientationEventCallback",
            "fillDeviceMotionEventData",
            "registerDeviceMotionEventCallback",
            "screenOrientation",
            "fillOrientationChangeEventData",
            "registerOrientationChangeEventCallback",
            "fillFullscreenChangeEventData",
            "registerFullscreenChangeEventCallback",
            "JSEvents_requestFullscreen",
            "JSEvents_resizeCanvasForFullscreen",
            "registerRestoreOldStyle",
            "hideEverythingExceptGivenElement",
            "restoreHiddenElements",
            "setLetterbox",
            "softFullscreenResizeWebGLRenderTarget",
            "doRequestFullscreen",
            "fillPointerlockChangeEventData",
            "registerPointerlockChangeEventCallback",
            "registerPointerlockErrorEventCallback",
            "requestPointerLock",
            "fillVisibilityChangeEventData",
            "registerVisibilityChangeEventCallback",
            "registerTouchEventCallback",
            "fillGamepadEventData",
            "registerGamepadEventCallback",
            "registerBeforeUnloadEventCallback",
            "fillBatteryEventData",
            "battery",
            "registerBatteryEventCallback",
            "setCanvasElementSize",
            "getCanvasElementSize",
            "demangle",
            "demangleAll",
            "jsStackTrace",
            "stackTrace",
            "getEnvStrings",
            "checkWasiClock",
            "flush_NO_FILESYSTEM",
            "wasiRightsToMuslOFlags",
            "wasiOFlagsToMuslOFlags",
            "createDyncallWrapper",
            "setImmediateWrapped",
            "clearImmediateWrapped",
            "polyfillSetImmediate",
            "getPromise",
            "makePromise",
            "idsToPromises",
            "makePromiseCallback",
            "ExceptionInfo",
            "findMatchingCatch",
            "setMainLoop",
            "getSocketFromFD",
            "getSocketAddress",
            "FS_createPreloadedFile",
            "FS_modeStringToFlags",
            "FS_getMode",
            "FS_stdin_getChar",
            "_setNetworkCallback",
            "heapObjectForWebGLType",
            "heapAccessShiftForWebGLHeap",
            "webgl_enable_ANGLE_instanced_arrays",
            "webgl_enable_OES_vertex_array_object",
            "webgl_enable_WEBGL_draw_buffers",
            "webgl_enable_WEBGL_multi_draw",
            "emscriptenWebGLGet",
            "computeUnpackAlignedImageSize",
            "colorChannelsInGlTextureFormat",
            "emscriptenWebGLGetTexPixelData",
            "__glGenObject",
            "emscriptenWebGLGetUniform",
            "webglGetUniformLocation",
            "webglPrepareUniformLocationsBeforeFirstUse",
            "webglGetLeftBracePos",
            "emscriptenWebGLGetVertexAttrib",
            "__glGetActiveAttribOrUniform",
            "writeGLArray",
            "registerWebGlEventCallback",
            "runAndAbortIfError",
            "SDL_unicode",
            "SDL_ttfContext",
            "SDL_audio",
            "GLFW_Window",
            "ALLOC_NORMAL",
            "ALLOC_STACK",
            "allocate",
            "writeStringToMemory",
            "writeAsciiToMemory"
        ];
        missingLibrarySymbols.forEach(missingLibrarySymbol);
        var unexportedSymbols = [
            "run",
            "addOnPreRun",
            "addOnInit",
            "addOnPreMain",
            "addOnExit",
            "addOnPostRun",
            "addRunDependency",
            "removeRunDependency",
            "FS_createFolder",
            "FS_createPath",
            "FS_createDataFile",
            "FS_createLazyFile",
            "FS_createLink",
            "FS_createDevice",
            "FS_readFile",
            "FS_unlink",
            "out",
            "err",
            "callMain",
            "abort",
            "keepRuntimeAlive",
            "wasmMemory",
            "wasmTable",
            "wasmExports",
            "stackAlloc",
            "stackSave",
            "stackRestore",
            "getTempRet0",
            "setTempRet0",
            "writeStackCookie",
            "checkStackCookie",
            "intArrayFromBase64",
            "tryParseAsDataURI",
            "ptrToString",
            "ENV",
            "MONTH_DAYS_REGULAR",
            "MONTH_DAYS_LEAP",
            "MONTH_DAYS_REGULAR_CUMULATIVE",
            "MONTH_DAYS_LEAP_CUMULATIVE",
            "ERRNO_CODES",
            "ERRNO_MESSAGES",
            "DNS",
            "Protocols",
            "Sockets",
            "timers",
            "warnOnce",
            "UNWIND_CACHE",
            "readEmAsmArgsArray",
            "getCFunc",
            "freeTableIndexes",
            "functionsInTableMap",
            "setValue",
            "getValue",
            "PATH",
            "PATH_FS",
            "UTF8Decoder",
            "UTF8ArrayToString",
            "UTF8ToString",
            "stringToUTF8Array",
            "stringToUTF8",
            "lengthBytesUTF8",
            "UTF16Decoder",
            "stringToUTF8OnStack",
            "writeArrayToMemory",
            "JSEvents",
            "specialHTMLTargets",
            "currentFullscreenStrategy",
            "restoreOldWindowedStyle",
            "ExitStatus",
            "promiseMap",
            "uncaughtExceptionCount",
            "exceptionLast",
            "exceptionCaught",
            "Browser",
            "wget",
            "SYSCALLS",
            "preloadPlugins",
            "FS_stdin_getChar_buffer",
            "FS",
            "MEMFS",
            "TTY",
            "PIPEFS",
            "SOCKFS",
            "tempFixedLengthArray",
            "miniTempWebGLFloatBuffers",
            "miniTempWebGLIntBuffers",
            "GL",
            "emscripten_webgl_power_preferences",
            "AL",
            "GLUT",
            "EGL",
            "GLEW",
            "IDBStore",
            "SDL",
            "SDL_gfx",
            "GLFW",
            "allocateUTF8",
            "allocateUTF8OnStack"
        ];
        unexportedSymbols.forEach(unexportedRuntimeSymbol);
        var calledRun;
        dependenciesFulfilled = function runCaller() {
            // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
        };
        function stackCheckInit() {
            // This is normally called automatically during __wasm_call_ctors but need to
            // get these values before even running any of the ctors so we call it redundantly
            // here.
            _emscripten_stack_init();
            // TODO(sbc): Move writeStackCookie to native to to avoid this.
            writeStackCookie();
        }
        function run() {
            if (runDependencies > 0) return;
            stackCheckInit();
            preRun();
            // a preRun added a dependency, run will be called later
            if (runDependencies > 0) return;
            function doRun() {
                // run may have just been called through dependencies being fulfilled just in this very frame,
                // or while the async setStatus time below was happening
                if (calledRun) return;
                calledRun = true;
                Module["calledRun"] = true;
                if (ABORT) return;
                initRuntime();
                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
                assert(!Module["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
                postRun();
            }
            if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function() {
                    setTimeout(function() {
                        Module["setStatus"]("");
                    }, 1);
                    doRun();
                }, 1);
            } else doRun();
            checkStackCookie();
        }
        function checkUnflushedContent() {
            // Compiler settings do not allow exiting the runtime, so flushing
            // the streams is not possible. but in ASSERTIONS mode we check
            // if there was something to flush, and if so tell the user they
            // should request that the runtime be exitable.
            // Normally we would not even include flush() at all, but in ASSERTIONS
            // builds we do so just for this check, and here we see if there is any
            // content to flush, that is, we check if there would have been
            // something a non-ASSERTIONS build would have not seen.
            // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
            // mode (which has its own special function for this; otherwise, all
            // the code is inside libc)
            var oldOut = out;
            var oldErr = err;
            var has = false;
            out = err = (x)=>{
                has = true;
            };
            try {
                // it doesn't matter if it fails
                _fflush(0);
            } catch (e) {}
            out = oldOut;
            err = oldErr;
            if (has) {
                warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.");
                warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");
            }
        }
        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function") Module["preInit"] = [
                Module["preInit"]
            ];
            while(Module["preInit"].length > 0)Module["preInit"].pop()();
        }
        run();
        // end include: postamble.js
        return moduleArg.ready;
    };
})();
$2d67dfdbe24056a5$exports = $2d67dfdbe24056a5$var$Module;


const $86d8fc41b01ee307$export$4c861b99fa6eb6d1 = "math";
class $86d8fc41b01ee307$export$e43f9f8d6b56002e extends (0, $6cd02a3df715eddf$export$c3a9d7ff17e4f3ed) {
    constructor(memory, functionTable, config, sharedWasmGlobalVariables){
        super(memory, functionTable, config, sharedWasmGlobalVariables);
        this.heapAddress = this.sharedWasmGlobalVariables.heapPointer.value;
        this.moduleDeclaredStructs = [];
        this.instantiate = async ()=>{
            const mathModule = await (0, (/*@__PURE__*/$parcel$interopDefault($2d67dfdbe24056a5$exports)))();
            // need to set the jsFunctions of all moduleFunctions here
            this.moduleFunctions.acos.jsFunction = mathModule._acos;
            this.moduleFunctions.asin.jsFunction = mathModule._asin;
            this.moduleFunctions.atan.jsFunction = mathModule._atan;
            this.moduleFunctions.cos.jsFunction = mathModule._cos;
            this.moduleFunctions.cosh.jsFunction = mathModule._cosh;
            this.moduleFunctions.sin.jsFunction = mathModule._sin;
            this.moduleFunctions.sinh.jsFunction = mathModule._sinh;
            this.moduleFunctions.tanh.jsFunction = mathModule._tanh;
            this.moduleFunctions.exp.jsFunction = mathModule._exp;
            this.moduleFunctions.log.jsFunction = mathModule._log;
            this.moduleFunctions.log10.jsFunction = mathModule._log10;
            this.moduleFunctions.pow.jsFunction = mathModule._pow;
            this.moduleFunctions.sqrt.jsFunction = mathModule._sqrt;
            this.moduleFunctions.ceil.jsFunction = mathModule._ceil;
            this.moduleFunctions.floor.jsFunction = mathModule._floor;
            this.moduleFunctions.tan.jsFunction = mathModule._tan;
        };
        this.moduleFunctions = {
            acos: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            asin: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            atan: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            cos: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            cosh: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            sin: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            sinh: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            tan: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            tanh: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            exp: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            log: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            log10: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            pow: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        },
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            sqrt: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            ceil: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            },
            floor: {
                parentImportedObject: $86d8fc41b01ee307$export$4c861b99fa6eb6d1,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>{}
            }
        };
    }
}


const $a66eff878276b6cd$export$f99aee9990253649 = {
    type: "void"
};


/**
 * The js functions used for memory related imported functions - malloc, free etc.
 */ 
/**
 * Contains a set of common utility functions used across modules.
 */ /**
 * A collection of constant objects and values.
 * These constants are used across compiler modules.
 */ const $cd849de488b21116$export$75f214c74b100eb7 = 4; // number of bytes of a wasm address
const $cd849de488b21116$export$11182fd140e7ea9f = $cd849de488b21116$export$75f214c74b100eb7; // size of a pointer in bytes - should be same as WASM_ADDR_SIZE
const $cd849de488b21116$export$f089f2422e95b42b = "unsigned int"; // implmentation-defined
const $cd849de488b21116$export$882db9e1117e2725 = "signed int"; // defined type for difference between pointers
const $cd849de488b21116$export$bfaa7c08c18ee972 = "unsigned int"; // type equivalent to pointer for this compiler implementation
const $cd849de488b21116$export$58b6502def2a4d77 = "signed int"; // the datatype that enum directly corresponds to in this compiler implementation
const $cd849de488b21116$export$1e75eda4edae07f4 = 1024; // number of bytes in 1 KB
const $cd849de488b21116$export$6c8528ef4d2c6a36 = 0x10000;



/**
 * Defiinition of various utility functions relating to manaaging Wasm data types.
 */ 
/**
 * This file contains all the error classes that can be thrown by the compiler.
 */ function $28ac839a9eca26f5$var$generateCompilationMessage(message, sourceCode, position) {
    let errorMessage = `${message}\n${position.start.line} | `;
    let currLine = position.start.line;
    for(let i = position.start.offset; i < position.end.offset; ++i)if (sourceCode[i] === "\n") errorMessage += `\n${++currLine} | `;
    else errorMessage += sourceCode[i];
    errorMessage += "\n";
    return errorMessage;
}
/**
 * Generates a compilation error message with positional information.
 * @param message
 * @param sourceCode
 * @param position
 * @returns
 */ function $28ac839a9eca26f5$var$generateCompilationErrorMessage(message, sourceCode, position) {
    return `Error: ${$28ac839a9eca26f5$var$generateCompilationMessage(message, sourceCode, position)}`;
}
function $28ac839a9eca26f5$export$9a24d8f7b932fdc5(message, sourceCode, position) {
    return `Warning: ${$28ac839a9eca26f5$var$generateCompilationMessage(message, sourceCode, position)}`;
}
class $28ac839a9eca26f5$export$53d7a5fe44e5fb7e extends Error {
    constructor(message, position){
        super();
        this.message = message;
        this.position = position ?? null;
    }
    addPositionInfo(position) {
        this.position = position;
    }
    /**
   * Add sourcecode and generate full error message with position info if available.
   * @param sourceCode preprocessed C program where comments are removed
   * @param position
   */ generateCompilationErrorMessage(sourceCode) {
        if (this.position !== null) this.message = $28ac839a9eca26f5$var$generateCompilationErrorMessage(this.message, sourceCode, this.position);
        else this.message = `Error: ${this.message}\n`;
        return this.message;
    }
}
class $28ac839a9eca26f5$export$f7dd392e51e3b514 extends Error {
    constructor(sourceCode, errors){
        super(errors.map((e)=>$28ac839a9eca26f5$var$generateCompilationErrorMessage(e.message, sourceCode, e.position)).join("\n"));
    }
}
class $28ac839a9eca26f5$export$f75c42204311f6de extends $28ac839a9eca26f5$export$53d7a5fe44e5fb7e {
    constructor(message, position){
        super(message, position);
    }
}
class $28ac839a9eca26f5$export$ab953dcdb8db4c8a extends $28ac839a9eca26f5$export$53d7a5fe44e5fb7e {
    constructor(message, position){
        super(message, position);
    }
}
class $28ac839a9eca26f5$export$1a55918bd746edde extends Error {
    constructor(message){
        super("Translation Error: " + message);
    }
}
class $28ac839a9eca26f5$export$565260f5d002fcc9 extends Error {
    constructor(message){
        super("WAT Generator Error: " + message);
    }
}
class $28ac839a9eca26f5$export$bd0820eb8444fcd9 extends Error {
    constructor(message){
        super("Unsupported Feature Error: " + message);
    }
}
function $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2(obj) {
    const clone = structuredClone(obj);
    function recursionHelper(obj) {
        if (typeof obj !== "object" && !Array.isArray(obj) || obj === null) return;
        for (const fieldName of Object.keys(obj))if (typeof obj[fieldName] === "bigint") obj[fieldName] = obj[fieldName].toString() + "n"; // stringify bigints first
        else recursionHelper(obj[fieldName]);
    }
    recursionHelper(clone);
    return JSON.stringify(clone, null, 2);
}



const $38f155c1835676cf$export$7d84eeb8f844a735 = {
    ["unsigned char"]: "i32",
    ["signed char"]: "i32",
    ["unsigned short"]: "i32",
    ["signed short"]: "i32",
    ["unsigned int"]: "i32",
    ["signed int"]: "i32",
    ["unsigned long"]: "i64",
    ["signed long"]: "i64",
    ["float"]: "f32",
    ["double"]: "f64"
};
function $38f155c1835676cf$export$ef36b8ec4b08a62a(scalarType) {
    if (scalarType === "pointer") return 0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee;
    else return $38f155c1835676cf$export$7d84eeb8f844a735[scalarType];
}
function $38f155c1835676cf$var$getNeededNumericConversionInstruction(from, to, signage) {
    if (from === "i32" && to === "i64") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from i32 to i64");
        else if (signage === "signed") return "i64.extend_i32_s";
        else return "i64.extend_i32_u";
    } else if (from === "i64" && to === "i32") return "i32.wrap_i64";
    else if (from === "f32" && to === "f64") return "f64.promote_f32";
    else if (from === "f64" && to === "f32") return "f32.demote_f64";
    else if (from === "i32" && to === "f32") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from i32 to f32");
        else if (signage === "signed") return "f32.convert_i32_s";
        else return "f32.convert_i32_u";
    } else if (from === "i64" && to === "f32") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from i64 to f32");
        else if (signage === "signed") return "f32.convert_i64_s";
        else return "f32.convert_i64_u";
    } else if (from === "i32" && to === "f64") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from i32 to f64");
        else if (signage === "signed") return "f64.convert_i32_s";
        else return "f64.convert_i32_u";
    } else if (from === "i64" && to === "f64") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from i64 to f64");
        else if (signage === "signed") return "f64.convert_i64_s";
        else return "f64.convert_i64_u";
    } else if (from === "f32" && to === "i32") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from f32 to i32");
        else if (signage === "signed") return "i32.trunc_f32_s";
        else return "i32.trunc_f32_u";
    } else if (from === "f64" && to === "i32") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from f64 to i32");
        else if (signage === "signed") return "i32.trunc_f64_s";
        else return "i32.trunc_f64_u";
    } else if (from === "f32" && to === "i64") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from f32 to i64");
        else if (signage === "signed") return "i64.trunc_f32_s";
        else return "i64.trunc_f32_u";
    } else if (from === "f64" && to === "i64") {
        if (typeof signage === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Missing sign information for numeric conversion from f64 to i64");
        else if (signage === "signed") return "i64.trunc_f64_s";
        else return "i64.trunc_f64_u";
    } else // should not happen
    throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`Unhandled numeric conversion between wasm types: ${from} to ${to}`);
}
function $38f155c1835676cf$export$73a7428322d21b13(from, to, translatedExpression) {
    const fromWasmType = $38f155c1835676cf$export$ef36b8ec4b08a62a(from);
    const toWasmType = $38f155c1835676cf$export$ef36b8ec4b08a62a(to);
    // sanity checks
    if (typeof toWasmType === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`getTypeConversionWrapper: undefined variableWasmType: original type: ${to}`);
    if (typeof fromWasmType === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`getTypeConversionWrapper: undefined valueWasmType: original type: ${from}`);
    if (toWasmType === fromWasmType) // same wasm type already. no need any numeric conversion, and C implicit conversion rules will be adhered to
    return translatedExpression;
    if ((0, $7f0b08f9e0a6f0f6$export$671a30a0694c3dec)(from) || from === "pointer") return {
        type: "NumericWrapper",
        instruction: $38f155c1835676cf$var$getNeededNumericConversionInstruction(fromWasmType, toWasmType, "unsigned"),
        expr: translatedExpression
    };
    else if ((0, $7f0b08f9e0a6f0f6$export$a2c4a82997e90594)(from)) return {
        type: "NumericWrapper",
        instruction: $38f155c1835676cf$var$getNeededNumericConversionInstruction(fromWasmType, toWasmType, "signed"),
        expr: translatedExpression
    };
    else // for float types, conversion should be signed
    return {
        type: "NumericWrapper",
        instruction: $38f155c1835676cf$var$getNeededNumericConversionInstruction(fromWasmType, toWasmType, "signed"),
        expr: translatedExpression
    };
}
function $38f155c1835676cf$export$76e37b29c165f299(constant) {
    if (constant.type === "IntegerConstant") return {
        type: "IntegerConst",
        wasmDataType: $38f155c1835676cf$export$7d84eeb8f844a735[constant.dataType],
        value: constant.value
    };
    else return {
        type: "FloatConst",
        wasmDataType: $38f155c1835676cf$export$7d84eeb8f844a735[constant.dataType],
        value: constant.value
    };
}



const $c5715c2f7f6b98cf$export$ef20ba4f3355ff1e = "param_";
const $c5715c2f7f6b98cf$export$c1ad5496a9a8d12e = 65536;
const $c5715c2f7f6b98cf$export$2759f7980f8ec3ee = "i32"; // the wasm type of addresses
const $c5715c2f7f6b98cf$export$df4ab72b1e4510c8 = $c5715c2f7f6b98cf$export$2759f7980f8ec3ee + ".add"; // insruction to use when adding wasm address
const $c5715c2f7f6b98cf$export$3f6970ce58672623 = $c5715c2f7f6b98cf$export$2759f7980f8ec3ee + ".sub";
const $c5715c2f7f6b98cf$export$6e15290d86208c69 = $c5715c2f7f6b98cf$export$2759f7980f8ec3ee + ".mul";
const $c5715c2f7f6b98cf$export$4b578d52d7815c56 = $c5715c2f7f6b98cf$export$2759f7980f8ec3ee + ".div_u";
const $c5715c2f7f6b98cf$export$9ffda923fea6cead = $c5715c2f7f6b98cf$export$2759f7980f8ec3ee + ".le_u";
const $c5715c2f7f6b98cf$export$d6012d5d08a99bd4 = $c5715c2f7f6b98cf$export$2759f7980f8ec3ee + ".lt_u";
const $c5715c2f7f6b98cf$export$f332087f5348159c = "sp"; // points to the topmost byte of the stack
const $c5715c2f7f6b98cf$export$a2134755a9a05802 = "bp";
const $c5715c2f7f6b98cf$export$cebe03d4d7130569 = "hp"; // points to the address of first byte after heap
const $c5715c2f7f6b98cf$export$9d26cc9a87da5961 = "r1"; // general purpose register
const $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa = "r2";
const $c5715c2f7f6b98cf$export$c9ffbac498cd6b64 = "ri64"; // gpr for i64 type
const $c5715c2f7f6b98cf$export$481ea1bf91221f3c = "rf32"; // gpr for f32 type
const $c5715c2f7f6b98cf$export$def4b9b37a9e587e = "rf64"; // gpr for f64 type
const $c5715c2f7f6b98cf$export$62a6d2b2e5cfb51b = {
    type: "GlobalGet",
    name: $c5715c2f7f6b98cf$export$a2134755a9a05802
};
const $c5715c2f7f6b98cf$export$95807c60f4cb0d7f = {
    type: "GlobalGet",
    name: $c5715c2f7f6b98cf$export$f332087f5348159c
};
const $c5715c2f7f6b98cf$export$54a1bcb476b045d3 = {
    type: "GlobalGet",
    name: $c5715c2f7f6b98cf$export$cebe03d4d7130569
};
const $c5715c2f7f6b98cf$var$reg1GetNode = {
    type: "GlobalGet",
    name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
};
// Returns the wasm ast node for setting base pointer to the value of an expression
function $c5715c2f7f6b98cf$var$getBasePointerSetNode(value) {
    return {
        type: "GlobalSet",
        name: $c5715c2f7f6b98cf$export$a2134755a9a05802,
        value: value
    };
}
function $c5715c2f7f6b98cf$var$getStackPointerSetNode(value) {
    return {
        type: "GlobalSet",
        name: $c5715c2f7f6b98cf$export$f332087f5348159c,
        value: value
    };
}
// Returns the wasm ast node for setting base pointer to the value of an expression
function $c5715c2f7f6b98cf$var$getReg1SetNode(value) {
    return {
        type: "GlobalSet",
        name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961,
        value: value
    };
}
function $c5715c2f7f6b98cf$export$c1919866a208f5c9(value) {
    return {
        type: "GlobalSet",
        name: $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa,
        value: value
    };
}
function $c5715c2f7f6b98cf$export$18a8b2078a28c8a6(primaryDataObject) {
    return {
        dataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(primaryDataObject.dataType),
        offset: primaryDataObject.offset,
        size: (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(primaryDataObject.dataType)
    };
}
function $c5715c2f7f6b98cf$export$bacc11ce78317fe7(registerPointer, operator, operand) {
    return {
        type: "BinaryExpression",
        instruction: operator === "+" ? $c5715c2f7f6b98cf$export$df4ab72b1e4510c8 : $c5715c2f7f6b98cf$export$3f6970ce58672623,
        leftExpr: {
            type: "GlobalGet",
            name: registerPointer
        },
        rightExpr: {
            type: "IntegerConst",
            wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
            value: BigInt(operand)
        }
    };
}
function $c5715c2f7f6b98cf$export$3cd54ce42da7cee7(pointer, incVal) {
    return {
        type: "GlobalSet",
        name: pointer,
        value: $c5715c2f7f6b98cf$export$bacc11ce78317fe7(pointer, "+", incVal)
    };
}
function $c5715c2f7f6b98cf$export$cf1dacee6dd21bf0(pointer, decVal) {
    return {
        type: "GlobalSet",
        name: pointer,
        value: $c5715c2f7f6b98cf$export$bacc11ce78317fe7(pointer, "-", decVal)
    };
}
function $c5715c2f7f6b98cf$export$706753d3eb71dffe(functionDetails) {
    return [
        // bring the stack pointer back down to end of previous stack frame
        $c5715c2f7f6b98cf$var$getStackPointerSetNode({
            type: "BinaryExpression",
            instruction: $c5715c2f7f6b98cf$export$df4ab72b1e4510c8,
            leftExpr: $c5715c2f7f6b98cf$export$62a6d2b2e5cfb51b,
            rightExpr: {
                type: "IntegerConst",
                wasmDataType: "i32",
                value: BigInt((0, $cd849de488b21116$export$75f214c74b100eb7) + functionDetails.sizeOfReturn)
            }
        }),
        // set base pointer to base pointer of prv frame
        $c5715c2f7f6b98cf$var$getBasePointerSetNode({
            type: "MemoryLoad",
            addr: $c5715c2f7f6b98cf$export$62a6d2b2e5cfb51b,
            wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
            numOfBytes: (0, $cd849de488b21116$export$75f214c74b100eb7)
        })
    ];
}
function $c5715c2f7f6b98cf$export$3bca4f7b01025682(allocationSize) {
    return {
        type: "SelectionStatement",
        condition: {
            type: "BooleanExpression",
            expr: {
                type: "BinaryExpression",
                instruction: $c5715c2f7f6b98cf$export$9ffda923fea6cead,
                leftExpr: {
                    type: "BinaryExpression",
                    instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                    leftExpr: {
                        type: "GlobalGet",
                        name: $c5715c2f7f6b98cf$export$f332087f5348159c
                    },
                    rightExpr: {
                        type: "IntegerConst",
                        wasmDataType: "i32",
                        value: BigInt(allocationSize)
                    }
                },
                rightExpr: $c5715c2f7f6b98cf$export$54a1bcb476b045d3
            },
            wasmDataType: "i32"
        },
        actions: [
            // expand the memory since not enough space
            // save the last address of linear memory in REG_1
            {
                type: "GlobalSet",
                name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961,
                value: {
                    type: "BinaryExpression",
                    instruction: $c5715c2f7f6b98cf$export$6e15290d86208c69,
                    leftExpr: {
                        type: "MemorySize"
                    },
                    rightExpr: {
                        type: "IntegerConst",
                        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
                        value: BigInt($c5715c2f7f6b98cf$export$c1ad5496a9a8d12e)
                    }
                }
            },
            // save address of last item in memory to REG_2
            {
                type: "GlobalSet",
                name: $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa,
                value: {
                    type: "BinaryExpression",
                    instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                    leftExpr: {
                        type: "GlobalGet",
                        name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
                    },
                    rightExpr: {
                        type: "IntegerConst",
                        value: 1n,
                        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee
                    }
                }
            },
            // save the size of stack in REG_1
            {
                type: "GlobalSet",
                name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961,
                value: {
                    type: "BinaryExpression",
                    instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                    leftExpr: {
                        type: "GlobalGet",
                        name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
                    },
                    rightExpr: $c5715c2f7f6b98cf$export$95807c60f4cb0d7f
                }
            },
            // expand the memory since not enough space
            {
                type: "MemoryGrow",
                pagesToGrowBy: {
                    type: "IntegerConst",
                    wasmDataType: "i32",
                    value: BigInt(Math.ceil(allocationSize / $c5715c2f7f6b98cf$export$c1ad5496a9a8d12e))
                }
            },
            // set stack pointer to target stack pointer adddress
            $c5715c2f7f6b98cf$var$getStackPointerSetNode({
                type: "BinaryExpression",
                instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                leftExpr: {
                    type: "BinaryExpression",
                    instruction: $c5715c2f7f6b98cf$export$6e15290d86208c69,
                    leftExpr: {
                        type: "MemorySize"
                    },
                    rightExpr: {
                        type: "IntegerConst",
                        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
                        value: BigInt($c5715c2f7f6b98cf$export$c1ad5496a9a8d12e)
                    }
                },
                rightExpr: {
                    type: "GlobalGet",
                    name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
                }
            }),
            // set REG_1 to the last address of new memory
            {
                type: "GlobalSet",
                name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961,
                value: {
                    type: "BinaryExpression",
                    instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                    leftExpr: {
                        type: "BinaryExpression",
                        instruction: $c5715c2f7f6b98cf$export$6e15290d86208c69,
                        leftExpr: {
                            type: "MemorySize"
                        },
                        rightExpr: {
                            type: "IntegerConst",
                            wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
                            value: BigInt($c5715c2f7f6b98cf$export$c1ad5496a9a8d12e)
                        }
                    },
                    rightExpr: {
                        type: "IntegerConst",
                        value: 1n,
                        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee
                    }
                }
            },
            // copy the stack memory to the end, get REG_1 to below stack pointer
            {
                type: "Block",
                label: "memcopy_block",
                body: [
                    {
                        type: "Loop",
                        label: "memcopy_loop",
                        body: [
                            {
                                type: "BranchIf",
                                label: "memcopy_block",
                                condition: {
                                    type: "BooleanExpression",
                                    expr: {
                                        type: "BinaryExpression",
                                        instruction: $c5715c2f7f6b98cf$export$d6012d5d08a99bd4,
                                        leftExpr: {
                                            type: "GlobalGet",
                                            name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
                                        },
                                        rightExpr: $c5715c2f7f6b98cf$export$95807c60f4cb0d7f
                                    },
                                    wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee
                                }
                            },
                            // load item addressed by REG_2 to addr of REG_1
                            {
                                type: "MemoryStore",
                                addr: {
                                    type: "GlobalGet",
                                    name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
                                },
                                value: {
                                    type: "MemoryLoad",
                                    addr: {
                                        type: "GlobalGet",
                                        name: $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa
                                    },
                                    wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
                                    numOfBytes: (0, $cd849de488b21116$export$75f214c74b100eb7)
                                },
                                wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
                                numOfBytes: (0, $cd849de488b21116$export$75f214c74b100eb7)
                            },
                            // decrement REG_1
                            {
                                type: "GlobalSet",
                                name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961,
                                value: {
                                    type: "BinaryExpression",
                                    instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                                    leftExpr: {
                                        type: "GlobalGet",
                                        name: $c5715c2f7f6b98cf$export$9d26cc9a87da5961
                                    },
                                    rightExpr: {
                                        type: "IntegerConst",
                                        value: 1n,
                                        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee
                                    }
                                }
                            },
                            // decrement REG_2
                            {
                                type: "GlobalSet",
                                name: $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa,
                                value: {
                                    type: "BinaryExpression",
                                    instruction: $c5715c2f7f6b98cf$export$3f6970ce58672623,
                                    leftExpr: {
                                        type: "GlobalGet",
                                        name: $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa
                                    },
                                    rightExpr: {
                                        type: "IntegerConst",
                                        value: 1n,
                                        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee
                                    }
                                }
                            },
                            {
                                type: "Branch",
                                label: "memcopy_loop"
                            }
                        ]
                    }
                ]
            }
        ],
        elseStatements: []
    };
}
function $c5715c2f7f6b98cf$export$c70596a3916eac5a(functionDetails, functionArgs) {
    const statements = [];
    const totalStackSpaceRequired = functionDetails.sizeOfParams + functionDetails.sizeOfReturn + (0, $cd849de488b21116$export$75f214c74b100eb7);
    statements.push($c5715c2f7f6b98cf$export$3bca4f7b01025682(totalStackSpaceRequired));
    //allocate space for Return type on stack (if have)
    if (functionDetails.sizeOfReturn > 0) statements.push($c5715c2f7f6b98cf$export$cf1dacee6dd21bf0($c5715c2f7f6b98cf$export$f332087f5348159c, functionDetails.sizeOfReturn));
    //allocate space for BP on stack
    statements.push($c5715c2f7f6b98cf$export$cf1dacee6dd21bf0($c5715c2f7f6b98cf$export$f332087f5348159c, (0, $cd849de488b21116$export$75f214c74b100eb7)));
    //store BP of previous frame
    statements.push({
        type: "MemoryStore",
        addr: $c5715c2f7f6b98cf$export$95807c60f4cb0d7f,
        value: $c5715c2f7f6b98cf$export$62a6d2b2e5cfb51b,
        wasmDataType: $c5715c2f7f6b98cf$export$2759f7980f8ec3ee,
        numOfBytes: (0, $cd849de488b21116$export$75f214c74b100eb7)
    });
    // allocate space for and set the values of each param
    // args are already in correct order for loading into the stack from high to low address
    for(let i = 0; i < functionDetails.parameters.length; ++i){
        statements.push($c5715c2f7f6b98cf$export$cf1dacee6dd21bf0($c5715c2f7f6b98cf$export$f332087f5348159c, (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(functionDetails.parameters[i].dataType)));
        const param = functionDetails.parameters[i];
        statements.push({
            type: "MemoryStore",
            addr: $c5715c2f7f6b98cf$export$95807c60f4cb0d7f,
            value: functionArgs[i],
            wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(param.dataType),
            numOfBytes: (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(param.dataType)
        });
    }
    // set BP to be sp + size of params
    statements.push($c5715c2f7f6b98cf$var$getBasePointerSetNode($c5715c2f7f6b98cf$export$bacc11ce78317fe7("sp", "+", functionDetails.sizeOfParams)));
    return statements;
}


const $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7 = {
    ["unsigned char"]: 1,
    ["signed char"]: 1,
    ["unsigned short"]: 2,
    ["signed short"]: 2,
    ["unsigned int"]: 4,
    ["signed int"]: 4,
    ["unsigned long"]: 8,
    ["signed long"]: 8,
    ["float"]: 4,
    ["double"]: 8
};
function $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd(dataType) {
    if (dataType === "pointer") return 0, $cd849de488b21116$export$11182fd140e7ea9f;
    return $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7[dataType];
}
function $7f0b08f9e0a6f0f6$export$a2c4a82997e90594(dataType) {
    return dataType === "signed char" || dataType === "signed short" || dataType === "signed int" || dataType === "signed long";
}
function $7f0b08f9e0a6f0f6$export$671a30a0694c3dec(dataType) {
    return dataType === "unsigned char" || dataType === "unsigned short" || dataType === "unsigned int" || dataType === "unsigned long";
}
function $7f0b08f9e0a6f0f6$export$4a7e02d8ef2dc77a(dataType) {
    return dataType === "float" || dataType === "double";
}
function $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff(dataType) {
    return $7f0b08f9e0a6f0f6$export$671a30a0694c3dec(dataType) || $7f0b08f9e0a6f0f6$export$a2c4a82997e90594(dataType);
}
function $7f0b08f9e0a6f0f6$export$614ff3cc3ef6eda9(node) {
    return node.type === "IntegerConstant" || node.type === "FloatConstant";
}
function $7f0b08f9e0a6f0f6$export$7f687b7d9f9da81c(numBytes) {
    return Math.floor(numBytes / (0, $c5715c2f7f6b98cf$export$c1ad5496a9a8d12e)) + 1;
}


function $3ac97f2b8e0968e3$export$256c5083f7280829(float) {
    if (float === Infinity) return "inf";
    else if (float === -Infinity) return "-inf";
    let floatStr = float.toString(16);
    if (floatStr[0] === "-") floatStr = "-0x" + floatStr.slice(1, floatStr.length);
    else floatStr = "0x" + floatStr;
    const bigNumber = new (0, $hgUW1$bignumberjs)(floatStr);
    return bigNumber.toFixed(6);
}
function $3ac97f2b8e0968e3$export$2edb4c5e685898c(buffer, strAddress) {
    const uInt8Arr = new Uint8Array(buffer);
    let str = "";
    let i = strAddress;
    while(uInt8Arr[i] !== 0)// keep recording chars until null terminator
    str += String.fromCharCode(uInt8Arr[i++]);
    return str;
}
function $3ac97f2b8e0968e3$export$2c83bc90724c8db(funcName, config) {
    if (!config.externalFunctions || !(funcName in config.externalFunctions)) throw Error(`External function ${funcName} not provided in compiler configs`);
    return config.externalFunctions[funcName];
}
function $3ac97f2b8e0968e3$export$248c04ac7669aab(memory, bytesRequested, sharedWasmGlobalVariables) {
    const stackPointer = sharedWasmGlobalVariables.stackPointer;
    const heapPointer = sharedWasmGlobalVariables.heapPointer;
    const basePointer = sharedWasmGlobalVariables.basePointer;
    const freeSpace = stackPointer.value - heapPointer.value;
    if (freeSpace < bytesRequested) {
        // need to grow memory
        const additionalPagesNeeded = (0, $7f0b08f9e0a6f0f6$export$7f687b7d9f9da81c)(bytesRequested - freeSpace);
        const stackSegmentSize = memory.buffer.byteLength - stackPointer.value;
        const oldMemorySize = memory.buffer.byteLength;
        memory.grow(additionalPagesNeeded);
        // need to copy stack segment starting from the end of the new memory buffer
        const memoryView = new Uint8Array(memory.buffer);
        for(let i = 0; i < stackSegmentSize; i++)memoryView[memoryView.length - i - 1] = memoryView[oldMemorySize - i - 1];
        // set base pointer
        const bpOffsetFromSp = basePointer.value - stackPointer.value;
        // set stack pointer
        stackPointer.value = memoryView.length - stackSegmentSize;
        // set base pointer
        basePointer.value = stackPointer.value + bpOffsetFromSp;
    }
}
function $3ac97f2b8e0968e3$export$fb335f2aba6331c0(sharedWasmGlobalVariables) {
    for (const [name, value] of Object.entries(sharedWasmGlobalVariables))console.log(`${name}: ${value.value}`);
}


function $613cdf755255ca13$export$29e067376189ea75({ memory: memory, sharedWasmGlobalVariables: sharedWasmGlobalVariables, bytesRequested: bytesRequested, allocatedBlocks: allocatedBlocks, freeList: freeList }) {
    // see if freeList has any deallocated memory blocks
    // simple first fit algorithm
    let i = 0;
    let foundBlock = false;
    for(; i < freeList.length; ++i){
        const block = freeList[i];
        if (block.size >= bytesRequested) {
            foundBlock = true;
            break;
        }
    }
    // a block was found in the free list
    if (foundBlock) {
        const block = freeList[i];
        freeList.splice(i, 1);
        if (block.size > bytesRequested) {
            const splitBlock = {
                address: block.address + bytesRequested,
                size: block.size - bytesRequested
            };
            freeList.push(splitBlock);
        }
        allocatedBlocks.set(block.address, bytesRequested);
        return block.address;
    }
    // no suitable block on the free list, need to expand heap
    (0, $3ac97f2b8e0968e3$export$248c04ac7669aab)(memory, bytesRequested, sharedWasmGlobalVariables);
    // enlarge heap segment
    const address = sharedWasmGlobalVariables.heapPointer.value;
    sharedWasmGlobalVariables.heapPointer.value += bytesRequested;
    allocatedBlocks.set(address, bytesRequested);
    return address;
}
function $613cdf755255ca13$export$1cbb47981abc8e99({ address: address, freeList: freeList, allocatedBlocks: allocatedBlocks }) {
    // shrink heap segment
    const sizeOfBlock = allocatedBlocks.get(address);
    if (typeof sizeOfBlock === "undefined") throw new Error("free(): No allocated block with given address");
    // add the freed memory block to freeList
    freeList.push({
        address: address,
        size: sizeOfBlock
    });
    allocatedBlocks.delete(address);
}
function $613cdf755255ca13$export$f20b082bde795e9c(memory, heapAddress, heapPointer) {
    const memoryView = new Uint8Array(memory.buffer, heapAddress, heapPointer - heapAddress);
    console.log(memoryView);
}
function $613cdf755255ca13$export$cadc733140a75d88(memory, stackPointer) {
    const memoryView = new Uint8Array(memory.buffer, stackPointer, memory.buffer.byteLength - stackPointer);
    console.log(memoryView);
}


/**
 * Contains utility function related to setting up a stack frame to wrap wasm function calls made from the JS runtime.
 */ 


function $c7e8373de86f19b2$export$2e2bcd8739ae039(memory, functionTable, functionPtr, sharedWasmGlobalVariables, stackFrameArgs, returnTypes) {
    const sizeOfReturns = returnTypes.reduce((prv, curr)=>prv + (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(curr), 0);
    // instantiate stack frame
    const stackFrameSize = $c7e8373de86f19b2$var$loadStackFrame(memory, sharedWasmGlobalVariables, stackFrameArgs, sizeOfReturns);
    // call the function pointed to be functionPtr
    functionTable.get(functionPtr)();
    const stackFrameReturnObjectView = new DataView(memory.buffer, sharedWasmGlobalVariables.basePointer.value + (0, $cd849de488b21116$export$75f214c74b100eb7), sizeOfReturns);
    const returnValues = [];
    let currOffset = 0;
    for (const returnType of returnTypes){
        switch(returnType){
            case "double":
                returnValues.push(stackFrameReturnObjectView.getFloat64(currOffset, true));
                break;
            case "float":
                returnValues.push(stackFrameReturnObjectView.getFloat32(currOffset, true));
                break;
            case "signed char":
                returnValues.push(stackFrameReturnObjectView.getInt8(currOffset));
                break;
            case "unsigned char":
            case "pointer":
                returnValues.push(stackFrameReturnObjectView.getUint8(currOffset));
                break;
            case "signed short":
                returnValues.push(stackFrameReturnObjectView.getInt16(currOffset, true));
                break;
            case "unsigned short":
                returnValues.push(stackFrameReturnObjectView.getUint16(currOffset, true));
                break;
            case "signed int":
                returnValues.push(stackFrameReturnObjectView.getInt32(currOffset, true));
                break;
            case "unsigned int":
                returnValues.push(stackFrameReturnObjectView.getUint32(currOffset, true));
                break;
            case "signed long":
                returnValues.push(stackFrameReturnObjectView.getBigInt64(currOffset, true));
                break;
            case "unsigned long":
                returnValues.push(stackFrameReturnObjectView.getBigUint64(currOffset, true));
                break;
        }
        currOffset += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(returnType);
    }
    // extract return value
    $c7e8373de86f19b2$var$tearDownStackFrame(memory, stackFrameSize, sharedWasmGlobalVariables.stackPointer, sharedWasmGlobalVariables.basePointer);
    return returnValues;
}
function $c7e8373de86f19b2$var$loadStackFrame(memory, sharedWasmGlobalVariables, stackFrameArgs, sizeOfReturn) {
    const totalArgsSize = stackFrameArgs.reduce((prv, curr)=>prv + (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(curr.type), 0);
    const bytesNeeded = totalArgsSize + sizeOfReturn + (0, $cd849de488b21116$export$75f214c74b100eb7); // need to add base pointer
    (0, $3ac97f2b8e0968e3$export$248c04ac7669aab)(memory, bytesNeeded, sharedWasmGlobalVariables);
    const stackFrameDataView = new DataView(memory.buffer, sharedWasmGlobalVariables.stackPointer.value - bytesNeeded, bytesNeeded);
    // fill in old bp
    stackFrameDataView.setUint32(totalArgsSize, sharedWasmGlobalVariables.basePointer.value, true);
    // fill in param values
    let currOffset = bytesNeeded - sizeOfReturn - (0, $cd849de488b21116$export$75f214c74b100eb7);
    for (const arg of stackFrameArgs){
        currOffset -= (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(arg.type);
        switch(arg.type){
            case "double":
                stackFrameDataView.setFloat64(currOffset, Number(arg.value), true);
                break;
            case "float":
                stackFrameDataView.setFloat32(currOffset, Number(arg.value), true);
                break;
            case "signed char":
                stackFrameDataView.setInt8(currOffset, Number(arg.value));
                break;
            case "unsigned char":
            case "pointer":
                stackFrameDataView.setUint8(currOffset, Number(arg.value));
                break;
            case "signed short":
                stackFrameDataView.setInt16(currOffset, Number(arg.value), true);
                break;
            case "unsigned short":
                stackFrameDataView.setUint16(currOffset, Number(arg.value), true);
                break;
            case "signed int":
                stackFrameDataView.setInt32(currOffset, Number(arg.value), true);
                break;
            case "unsigned int":
                stackFrameDataView.setUint32(currOffset, Number(arg.value), true);
                break;
            case "signed long":
                stackFrameDataView.setBigInt64(currOffset, BigInt(arg.value), true);
                break;
            case "unsigned long":
                stackFrameDataView.setBigUint64(currOffset, BigInt(arg.value), true);
                break;
        }
    }
    // set the value of bp
    sharedWasmGlobalVariables.basePointer.value = sharedWasmGlobalVariables.stackPointer.value - sizeOfReturn - (0, $cd849de488b21116$export$75f214c74b100eb7);
    // set the value of sp
    sharedWasmGlobalVariables.stackPointer.value = sharedWasmGlobalVariables.stackPointer.value - bytesNeeded;
    return bytesNeeded;
}
function $c7e8373de86f19b2$var$tearDownStackFrame(memory, stackFrameSize, stackPointer, basePointer) {
    stackPointer.value += stackFrameSize;
    const dataView = new DataView(memory.buffer, basePointer.value, (0, $cd849de488b21116$export$75f214c74b100eb7));
    basePointer.value = dataView.getUint32(0, true);
}




const $bfc7d64527c49a6c$export$ce74ff4d218f3ff2 = "pix_n_flix";
class $bfc7d64527c49a6c$export$38ad991a41a6bc0d extends (0, $6cd02a3df715eddf$export$c3a9d7ff17e4f3ed) {
    constructor(memory, functionTable, config, sharedWasmGlobalVariables){
        super(memory, functionTable, config, sharedWasmGlobalVariables);
        this.sharedWasmGlobalVariables = sharedWasmGlobalVariables;
        this.moduleDeclaredStructs = [];
        this.moduleFunctions = {
            use_image_url: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "primary",
                                primaryDataType: "signed char"
                            }
                        }
                    ],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: (strAddress)=>{
                    const url = (0, $3ac97f2b8e0968e3$export$2edb4c5e685898c)(memory.buffer, strAddress);
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("use_image_url", config)(url);
                }
            },
            use_video_url: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "primary",
                                primaryDataType: "signed char"
                            }
                        }
                    ],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: (strAddress)=>{
                    const url = (0, $3ac97f2b8e0968e3$export$2edb4c5e685898c)(memory.buffer, strAddress);
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("use_video_url", config)(url);
                }
            },
            // prints an unsigned int (4 bytes and smaller)
            start: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: ()=>{
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("start", config)();
                }
            },
            image_height: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed int"
                    }
                },
                jsFunction: ()=>(0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("image_height", config)()
            },
            image_width: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed int"
                    }
                },
                jsFunction: ()=>(0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("image_width", config)()
            },
            set_dimensions: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed int"
                        },
                        {
                            type: "primary",
                            primaryDataType: "signed int"
                        }
                    ],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: (width, height)=>{
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("set_dimensions", config)(width, height);
                }
            },
            install_filter: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "function",
                                parameters: [
                                    {
                                        type: "pointer",
                                        pointeeType: {
                                            type: "array",
                                            elementDataType: {
                                                type: "array",
                                                elementDataType: {
                                                    type: "primary",
                                                    primaryDataType: "signed char"
                                                },
                                                numElements: {
                                                    type: "IntegerConstant",
                                                    value: 4n,
                                                    suffix: null,
                                                    position: {
                                                        start: {
                                                            line: 0,
                                                            offset: 0,
                                                            column: 0
                                                        },
                                                        end: {
                                                            line: 0,
                                                            offset: 0,
                                                            column: 0
                                                        }
                                                    }
                                                }
                                            },
                                            numElements: {
                                                type: "IntegerConstant",
                                                value: 400n,
                                                suffix: null,
                                                position: {
                                                    start: {
                                                        line: 0,
                                                        offset: 0,
                                                        column: 0
                                                    },
                                                    end: {
                                                        line: 0,
                                                        offset: 0,
                                                        column: 0
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    {
                                        type: "pointer",
                                        pointeeType: {
                                            type: "array",
                                            elementDataType: {
                                                type: "array",
                                                elementDataType: {
                                                    type: "primary",
                                                    primaryDataType: "signed char"
                                                },
                                                numElements: {
                                                    type: "IntegerConstant",
                                                    value: 4n,
                                                    suffix: null,
                                                    position: {
                                                        start: {
                                                            line: 0,
                                                            offset: 0,
                                                            column: 0
                                                        },
                                                        end: {
                                                            line: 0,
                                                            offset: 0,
                                                            column: 0
                                                        }
                                                    }
                                                }
                                            },
                                            numElements: {
                                                type: "IntegerConstant",
                                                value: 400n,
                                                suffix: null,
                                                position: {
                                                    start: {
                                                        line: 0,
                                                        offset: 0,
                                                        column: 0
                                                    },
                                                    end: {
                                                        line: 0,
                                                        offset: 0,
                                                        column: 0
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    {
                                        type: "primary",
                                        primaryDataType: "signed int"
                                    },
                                    {
                                        type: "primary",
                                        primaryDataType: "signed int"
                                    }
                                ],
                                returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                            }
                        }
                    ],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: (funcPtr)=>{
                    const filter = (src, dest)=>{
                        const memSize = src.length * src[0].length * src[0][0].length;
                        // allocate buffers on the heap
                        const srcAddress = (0, $613cdf755255ca13$export$29e067376189ea75)({
                            memory: memory,
                            sharedWasmGlobalVariables: sharedWasmGlobalVariables,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks,
                            bytesRequested: memSize
                        });
                        const destAddress = (0, $613cdf755255ca13$export$29e067376189ea75)({
                            memory: memory,
                            sharedWasmGlobalVariables: sharedWasmGlobalVariables,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks,
                            bytesRequested: memSize
                        });
                        // copy the values in
                        let currAddress = 0;
                        const srcArr = new Uint8Array(memory.buffer, srcAddress, memSize);
                        for(let i = 0; i < src.length; ++i){
                            for(let j = 0; j < src[0].length; ++j)for(let k = 0; k < src[0][0].length; ++k)srcArr[currAddress++] = src[i][j][k];
                        }
                        const stackFrameArgs = [
                            {
                                value: BigInt(srcAddress),
                                type: "unsigned int"
                            },
                            {
                                value: BigInt(destAddress),
                                type: "unsigned int"
                            },
                            {
                                value: BigInt(src.length),
                                type: "unsigned int"
                            },
                            {
                                value: BigInt(src[0].length),
                                type: "unsigned int"
                            }
                        ];
                        // call the function pointer
                        (0, $c7e8373de86f19b2$export$2e2bcd8739ae039)(memory, functionTable, funcPtr, sharedWasmGlobalVariables, stackFrameArgs, []);
                        // copy the values out
                        const destArr = new Uint8Array(memory.buffer, destAddress, memSize);
                        currAddress = 0;
                        for(let i = 0; i < dest.length; ++i){
                            for(let j = 0; j < dest[0].length; ++j)for(let k = 0; k < dest[0][0].length; ++k)dest[i][j][k] = destArr[currAddress++];
                        }
                        // free both buffers
                        (0, $613cdf755255ca13$export$1cbb47981abc8e99)({
                            address: srcAddress,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks
                        });
                        (0, $613cdf755255ca13$export$1cbb47981abc8e99)({
                            address: destAddress,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks
                        });
                    };
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("install_filter", config)(filter);
                }
            },
            reset_filter: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: ()=>{
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("reset_filter", config)();
                }
            },
            set_fps: {
                parentImportedObject: $bfc7d64527c49a6c$export$ce74ff4d218f3ff2,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed int"
                        }
                    ],
                    returnType: (0, $a66eff878276b6cd$export$f99aee9990253649)
                },
                jsFunction: ()=>{
                    (0, $3ac97f2b8e0968e3$export$2c83bc90724c8db)("set_fps", config)();
                }
            }
        };
    }
}






const $440955131cb280ee$export$ebb1fb55387f71a9 = "source_stdlib";
class $440955131cb280ee$export$427d0ee15bade0f5 extends (0, $6cd02a3df715eddf$export$c3a9d7ff17e4f3ed) {
    constructor(memory, functionTable, config, sharedWasmGlobalVariables){
        super(memory, functionTable, config, sharedWasmGlobalVariables);
        this.heapAddress = this.sharedWasmGlobalVariables.heapPointer.value;
        this.moduleDeclaredStructs = [];
        this.moduleFunctions = {
            print_int: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed int"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (int)=>{
                    // to print the correct int (4 bytes), need to handle signage
                    if (int > Math.pow(2, 32) - 1) // negative number
                    this.print((-int).toString());
                    else this.print(int.toString());
                }
            },
            // prints an unsigned int (4 bytes and smaller)
            print_int_unsigned: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "unsigned int"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (val)=>{
                    // need to intepret val as unsigned 4 byte int
                    if (val < 0) this.print((val + Math.pow(2, 32)).toString());
                    else this.print(val.toString());
                }
            },
            // prints a char (signed) as a character
            print_char: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed char"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (char)=>{
                    // signed int overflow is undefined, no need to worry about handling that
                    this.print(String.fromCharCode(char));
                }
            },
            // print a signed long type (8 bytes)
            print_long: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed long"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (long)=>{
                    // to prlong the correct long (4 bytes), need to handle signage
                    if (long > 2n ** 64n - 1n) // negative number
                    this.print((-long).toString());
                    else this.print(long.toString());
                }
            },
            // print an usigned long type (8 bytes)
            print_long_unsigned: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "unsigned long"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (val)=>{
                    // need to intepret val as unsigned 8 byte unsigned int
                    if (val < 0) this.print((BigInt(val) + 2n ** 64n).toString());
                    else this.print(val.toString());
                }
            },
            print_float: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "float"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (float)=>this.print((0, $3ac97f2b8e0968e3$export$256c5083f7280829)(float))
            },
            print_double: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "double"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (float)=>this.print((0, $3ac97f2b8e0968e3$export$256c5083f7280829)(float))
            },
            // for printing the value of pointers. behaves the same as print_int_unsigned
            print_address: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "void"
                            }
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (val)=>{
                    // need to intepret val as unsigned 4 byte int
                    if (val < 0) this.print((val + Math.pow(2, 32)).toString());
                    else this.print(val.toString());
                }
            },
            // print a C style string
            print_string: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "primary",
                                primaryDataType: "signed char",
                                isConst: true
                            }
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (strAddress)=>{
                    const str = (0, $3ac97f2b8e0968e3$export$2edb4c5e685898c)(memory.buffer, strAddress);
                    this.print(str);
                }
            },
            malloc: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: (0, $cd849de488b21116$export$f089f2422e95b42b)
                        }
                    ],
                    returnType: {
                        type: "pointer",
                        pointeeType: {
                            type: "void"
                        }
                    }
                },
                jsFunction: (numBytes)=>(0, $613cdf755255ca13$export$29e067376189ea75)({
                        memory: this.memory,
                        sharedWasmGlobalVariables: this.sharedWasmGlobalVariables,
                        freeList: this.freeList,
                        allocatedBlocks: this.allocatedBlocks,
                        bytesRequested: numBytes
                    })
            },
            free: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "void"
                            }
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (address)=>(0, $613cdf755255ca13$export$1cbb47981abc8e99)({
                        address: address,
                        freeList: this.freeList,
                        allocatedBlocks: this.allocatedBlocks
                    })
            },
            print_heap: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: ()=>(0, $613cdf755255ca13$export$f20b082bde795e9c)(this.memory, this.heapAddress, this.sharedWasmGlobalVariables.heapPointer.value)
            },
            print_stack: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: ()=>(0, $613cdf755255ca13$export$cadc733140a75d88)(this.memory, this.sharedWasmGlobalVariables.stackPointer.value)
            },
            // only works in browser environment, node.js support can be added in future
            prompt_int: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed int"
                    }
                },
                jsFunction: ()=>prompt("Enter a signed integer")
            },
            prompt_long: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed long"
                    }
                },
                jsFunction: ()=>prompt("Enter a long signed integer")
            },
            // only works in browser environment, node.js support can be added in future
            prompt_float: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "float"
                    }
                },
                jsFunction: ()=>prompt("Enter a float")
            },
            prompt_double: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: ()=>prompt("Enter a double")
            },
            // only works in browser environment, node.js support can be added in future
            prompt_string: {
                parentImportedObject: $440955131cb280ee$export$ebb1fb55387f71a9,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "primary",
                                primaryDataType: "signed char"
                            }
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (strAddr)=>{
                    const str = prompt("Enter a string");
                    const encoder = new TextEncoder();
                    const strBuffer = new Uint8Array(this.memory.buffer, strAddr);
                    if (str === null) {
                        strBuffer[0] = 0;
                        return;
                    }
                    const buf = encoder.encode(str);
                    for(let i = 0; i < str.length; ++i)strBuffer[i] = buf[i];
                    strBuffer[str.length] = 0;
                }
            }
        };
    }
}




var $29a92bc69495d5cc$exports = {};

var $29a92bc69495d5cc$var$Module = (()=>{
    var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : undefined;
    return function(moduleArg = {}) {
        // include: shell.js
        // The Module object: Our interface to the outside world. We import
        // and export values on it. There are various ways Module can be used:
        // 1. Not defined. We create it here
        // 2. A function parameter, function(Module) { ..generated code.. }
        // 3. pre-run appended it, var Module = {}; ..generated code..
        // 4. External script tag defines var Module.
        // We need to check if Module already exists (e.g. case 3 above).
        // Substitution will be replaced with actual code on later stage of the build,
        // this way Closure Compiler will not mangle it (e.g. case 4. above).
        // Note that if you want to run closure, and also to use Module
        // after the generated code, you will need to define   var Module = {};
        // before the code. Then that object will be used in the code, and you
        // can continue to use Module afterwards as well.
        var Module = moduleArg;
        // Set up the promise that indicates the Module is initialized
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise((resolve, reject)=>{
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
        });
        [
            "_atoi",
            "_atof",
            "_abs",
            "_labs",
            "_rand",
            "_bsearch",
            "_qsort",
            "_srand",
            "_free",
            "_malloc",
            "_memory",
            "_fflush",
            "___indirect_function_table",
            "onRuntimeInitialized"
        ].forEach((prop)=>{
            if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) Object.defineProperty(Module["ready"], prop, {
                get: ()=>abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
                set: ()=>abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
            });
        });
        // --pre-jses are emitted after the Module integration code, so that they can
        // refer to Module (if they choose; they can also define Module)
        // Sometimes an existing Module object exists with properties
        // meant to overwrite the default module functionality. Here
        // we collect those properties and reapply _after_ we configure
        // the current environment's defaults to avoid having to be so
        // defensive during initialization.
        var moduleOverrides = Object.assign({}, Module);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow)=>{
            throw toThrow;
        };
        // Determine the runtime environment we are in. You can customize this by
        // setting the ENVIRONMENT setting at compile time (see settings.js).
        var ENVIRONMENT_IS_WEB = true;
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = false;
        var ENVIRONMENT_IS_SHELL = false;
        if (Module["ENVIRONMENT"]) throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
        // `/` should be present at the end if `scriptDirectory` is not empty
        var scriptDirectory = "";
        function locateFile(path) {
            if (Module["locateFile"]) return Module["locateFile"](path, scriptDirectory);
            return scriptDirectory + path;
        }
        // Hooks that are implemented differently in different runtime environments.
        var read_, readAsync, readBinary, setWindowTitle;
        if (ENVIRONMENT_IS_SHELL) {
            if (typeof $hgUW1$process == "object" && true || typeof window == "object" || typeof importScripts == "function") throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
            if (typeof read != "undefined") read_ = read;
            readBinary = (f)=>{
                if (typeof readbuffer == "function") return new Uint8Array(readbuffer(f));
                let data = read(f, "binary");
                assert(typeof data == "object");
                return data;
            };
            readAsync = (f, onload, onerror)=>{
                setTimeout(()=>onload(readBinary(f)));
            };
            if (typeof clearTimeout == "undefined") globalThis.clearTimeout = (id)=>{};
            if (typeof setTimeout == "undefined") // spidermonkey lacks setTimeout but we use it above in readAsync.
            globalThis.setTimeout = (f)=>typeof f == "function" ? f() : abort();
            if (typeof scriptArgs != "undefined") arguments_ = scriptArgs;
            else if (typeof arguments != "undefined") arguments_ = arguments;
            if (typeof quit == "function") quit_ = (status, toThrow)=>{
                // Unlike node which has process.exitCode, d8 has no such mechanism. So we
                // have no way to set the exit code and then let the program exit with
                // that code when it naturally stops running (say, when all setTimeouts
                // have completed). For that reason, we must call `quit` - the only way to
                // set the exit code - but quit also halts immediately.  To increase
                // consistency with node (and the web) we schedule the actual quit call
                // using a setTimeout to give the current stack and any exception handlers
                // a chance to run.  This enables features such as addOnPostRun (which
                // expected to be able to run code after main returns).
                setTimeout(()=>{
                    if (!(toThrow instanceof ExitStatus)) {
                        let toLog = toThrow;
                        if (toThrow && typeof toThrow == "object" && toThrow.stack) toLog = [
                            toThrow,
                            toThrow.stack
                        ];
                        err(`exiting due to exception: ${toLog}`);
                    }
                    quit(status);
                });
                throw toThrow;
            };
            if (typeof print != "undefined") {
                // Prefer to use print/printErr where they exist, as they usually work better.
                if (typeof console == "undefined") console = /** @type{!Console} */ {};
                console.log = /** @type{!function(this:Console, ...*): undefined} */ print;
                console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ typeof printErr != "undefined" ? printErr : print;
            }
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) // Check worker, not web, since window could be polyfilled
            scriptDirectory = self.location.href;
            else if (typeof document != "undefined" && document.currentScript) // web
            scriptDirectory = document.currentScript.src;
            // When MODULARIZE, this JS may be executed later, after document.currentScript
            // is gone, so we saved it, and we use it here instead of any other info.
            if (_scriptDir) scriptDirectory = _scriptDir;
            // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
            // otherwise, slice off the final part of the url to find the script directory.
            // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
            // and scriptDirectory will correctly be replaced with an empty string.
            // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
            // they are removed because they could contain a slash.
            if (scriptDirectory.indexOf("blob:") !== 0) scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            else scriptDirectory = "";
            if (!(typeof window == "object" || typeof importScripts == "function")) throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
            // include: web_or_worker_shell_read.js
            read_ = (url)=>{
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) readBinary = (url)=>{
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(/** @type{!ArrayBuffer} */ xhr.response);
            };
            readAsync = (url, onload, onerror)=>{
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = ()=>{
                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                        // file URLs can return 0
                        onload(xhr.response);
                        return;
                    }
                    onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
            };
            setWindowTitle = (title)=>document.title = title;
        } else throw new Error("environment detection error");
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.error.bind(console);
        // Merge back in the overrides
        Object.assign(Module, moduleOverrides);
        // Free the object hierarchy contained in the overrides, this lets the GC
        // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
        moduleOverrides = null;
        checkIncomingModuleAPI();
        // Emit code to handle expected values on the Module object. This applies Module.x
        // to the proper local x. This has two benefits: first, we only emit it if it is
        // expected to arrive, and second, by using a local everywhere else that can be
        // minified.
        if (Module["arguments"]) arguments_ = Module["arguments"];
        legacyModuleProp("arguments", "arguments_");
        if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
        legacyModuleProp("thisProgram", "thisProgram");
        if (Module["quit"]) quit_ = Module["quit"];
        legacyModuleProp("quit", "quit_");
        // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
        // Assertions on removed incoming Module JS APIs.
        assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
        assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
        assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
        assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
        assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
        assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
        legacyModuleProp("asm", "wasmExports");
        legacyModuleProp("read", "read_");
        legacyModuleProp("readAsync", "readAsync");
        legacyModuleProp("readBinary", "readBinary");
        legacyModuleProp("setWindowTitle", "setWindowTitle");
        var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
        var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
        var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
        var FETCHFS = "FETCHFS is no longer included by default; build with -lfetchfs.js";
        var ICASEFS = "ICASEFS is no longer included by default; build with -licasefs.js";
        var JSFILEFS = "JSFILEFS is no longer included by default; build with -ljsfilefs.js";
        var OPFS = "OPFS is no longer included by default; build with -lopfs.js";
        var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";
        assert(!ENVIRONMENT_IS_WORKER, "worker environment detected but not enabled at build time.  Add 'worker' to `-sENVIRONMENT` to enable.");
        assert(!ENVIRONMENT_IS_NODE, "node environment detected but not enabled at build time.  Add 'node' to `-sENVIRONMENT` to enable.");
        assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
        // end include: shell.js
        // include: preamble.js
        // === Preamble library stuff ===
        // Documentation for the public APIs defined in this file must be updated in:
        //    site/source/docs/api_reference/preamble.js.rst
        // A prebuilt local version of the documentation is available at:
        //    site/build/text/docs/api_reference/preamble.js.txt
        // You can also build docs locally as HTML or other formats in site/
        // An online HTML version (which may be of a different version of Emscripten)
        //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html
        var wasmBinary;
        if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
        legacyModuleProp("wasmBinary", "wasmBinary");
        var noExitRuntime = Module["noExitRuntime"] || true;
        legacyModuleProp("noExitRuntime", "noExitRuntime");
        if (typeof WebAssembly != "object") abort("no native wasm support detected");
        // Wasm globals
        var wasmMemory;
        //========================================
        // Runtime essentials
        //========================================
        // whether we are quitting the application. no code should run after this.
        // set in exit() and abort()
        var ABORT = false;
        // set by exit() and abort().  Passed to 'onExit' handler.
        // NOTE: This is also used as the process return code code in shell environments
        // but only when noExitRuntime is false.
        var EXITSTATUS;
        /** @type {function(*, string=)} */ function assert(condition, text) {
            if (!condition) abort("Assertion failed" + (text ? ": " + text : ""));
        }
        // We used to include malloc/free by default in the past. Show a helpful error in
        // builds with assertions.
        // Memory management
        var HEAP, /** @type {!Int8Array} */ HEAP8, /** @type {!Uint8Array} */ HEAPU8, /** @type {!Int16Array} */ HEAP16, /** @type {!Uint16Array} */ HEAPU16, /** @type {!Int32Array} */ HEAP32, /** @type {!Uint32Array} */ HEAPU32, /** @type {!Float32Array} */ HEAPF32, /** @type {!Float64Array} */ HEAPF64;
        function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
        }
        assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
        assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, "JS engine does not provide full typed array support");
        // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY
        assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
        assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
        // include: runtime_init_table.js
        // In regular non-RELOCATABLE mode the table is exported
        // from the wasm module and this will be assigned once
        // the exports are available.
        var wasmTable;
        // end include: runtime_init_table.js
        // include: runtime_stack_check.js
        // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
        function writeStackCookie() {
            var max = _emscripten_stack_get_end();
            assert((max & 3) == 0);
            // If the stack ends at address zero we write our cookies 4 bytes into the
            // stack.  This prevents interference with SAFE_HEAP and ASAN which also
            // monitor writes to address zero.
            if (max == 0) max += 4;
            // The stack grow downwards towards _emscripten_stack_get_end.
            // We write cookies to the final two words in the stack and detect if they are
            // ever overwritten.
            HEAPU32[max >> 2] = 0x02135467;
            HEAPU32[max + 4 >> 2] = 0x89bacdfe;
            // Also test the global address 0 for integrity.
            HEAPU32[0] = 1668509029;
        }
        function checkStackCookie() {
            if (ABORT) return;
            var max = _emscripten_stack_get_end();
            // See writeStackCookie().
            if (max == 0) max += 4;
            var cookie1 = HEAPU32[max >> 2];
            var cookie2 = HEAPU32[max + 4 >> 2];
            if (cookie1 != 0x02135467 || cookie2 != 0x89bacdfe) abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
            // Also test the global address 0 for integrity.
            if (HEAPU32[0] != 0x63736d65 /* 'emsc' */ ) abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
        }
        // end include: runtime_stack_check.js
        // include: runtime_assertions.js
        // Endianness check
        (function() {
            var h16 = new Int16Array(1);
            var h8 = new Int8Array(h16.buffer);
            h16[0] = 0x6373;
            if (h8[0] !== 0x73 || h8[1] !== 0x63) throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
        })();
        // end include: runtime_assertions.js
        var __ATPRERUN__ = []; // functions called before the runtime is initialized
        var __ATINIT__ = []; // functions called during startup
        var __ATEXIT__ = []; // functions called during shutdown
        var __ATPOSTRUN__ = []; // functions called after the main() is called
        var runtimeInitialized = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
            if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function") Module["preRun"] = [
                    Module["preRun"]
                ];
                while(Module["preRun"].length)addOnPreRun(Module["preRun"].shift());
            }
            callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
            assert(!runtimeInitialized);
            runtimeInitialized = true;
            checkStackCookie();
            callRuntimeCallbacks(__ATINIT__);
        }
        function postRun() {
            checkStackCookie();
            if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function") Module["postRun"] = [
                    Module["postRun"]
                ];
                while(Module["postRun"].length)addOnPostRun(Module["postRun"].shift());
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
            __ATINIT__.unshift(cb);
        }
        function addOnExit(cb) {}
        function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
        }
        // include: runtime_math.js
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc
        assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
        // end include: runtime_math.js
        // A counter of dependencies for calling run(). If we need to
        // do asynchronous work before running, increment this and
        // decrement it. Incrementing must happen in a place like
        // Module.preRun (used by emcc to add file preloading).
        // Note that you can add dependencies in preRun, even though
        // it happens right before run - run will be postponed until
        // the dependencies are met.
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
        var runDependencyTracking = {};
        function getUniqueRunDependency(id) {
            var orig = id;
            while(true){
                if (!runDependencyTracking[id]) return id;
                id = orig + Math.random();
            }
        }
        function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
            if (id) {
                assert(!runDependencyTracking[id]);
                runDependencyTracking[id] = 1;
                if (runDependencyWatcher === null && typeof setInterval != "undefined") // Check for missing dependencies every few seconds
                runDependencyWatcher = setInterval(()=>{
                    if (ABORT) {
                        clearInterval(runDependencyWatcher);
                        runDependencyWatcher = null;
                        return;
                    }
                    var shown = false;
                    for(var dep in runDependencyTracking){
                        if (!shown) {
                            shown = true;
                            err("still waiting on run dependencies:");
                        }
                        err(`dependency: ${dep}`);
                    }
                    if (shown) err("(end of list)");
                }, 10000);
            } else err("warning: run dependency added without ID");
        }
        function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) Module["monitorRunDependencies"](runDependencies);
            if (id) {
                assert(runDependencyTracking[id]);
                delete runDependencyTracking[id];
            } else err("warning: run dependency removed without ID");
            if (runDependencies == 0) {
                if (runDependencyWatcher !== null) {
                    clearInterval(runDependencyWatcher);
                    runDependencyWatcher = null;
                }
                if (dependenciesFulfilled) {
                    var callback = dependenciesFulfilled;
                    dependenciesFulfilled = null;
                    callback(); // can add another dependenciesFulfilled
                }
            }
        }
        /** @param {string|number=} what */ function abort(what) {
            if (Module["onAbort"]) Module["onAbort"](what);
            what = "Aborted(" + what + ")";
            // TODO(sbc): Should we remove printing and leave it up to whoever
            // catches the exception?
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            // Use a wasm runtime error, because a JS error might be seen as a foreign
            // exception, which means we'd run destructors on it. We need the error to
            // simply make the program stop.
            // FIXME This approach does not work in Wasm EH because it currently does not assume
            // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
            // a trap or not based on a hidden field within the object. So at the moment
            // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
            // allows this in the wasm spec.
            // Suppress closure compiler warning here. Closure compiler's builtin extern
            // defintion for WebAssembly.RuntimeError claims it takes no arguments even
            // though it can.
            // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
            /** @suppress {checkTypes} */ var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            // Throw the error whether or not MODULARIZE is set because abort is used
            // in code paths apart from instantiation where an exception is expected
            // to be thrown when abort is called.
            throw e;
        }
        // include: memoryprofiler.js
        // end include: memoryprofiler.js
        // show errors on likely calls to FS when it was not included
        var FS = {
            error () {
                abort("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM");
            },
            init () {
                FS.error();
            },
            createDataFile () {
                FS.error();
            },
            createPreloadedFile () {
                FS.error();
            },
            createLazyFile () {
                FS.error();
            },
            open () {
                FS.error();
            },
            mkdev () {
                FS.error();
            },
            registerDevice () {
                FS.error();
            },
            analyzePath () {
                FS.error();
            },
            ErrnoError () {
                FS.error();
            }
        };
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        // include: URIUtils.js
        // Prefix of data URIs emitted by SINGLE_FILE and related options.
        var dataURIPrefix = "data:application/octet-stream;base64,";
        // Indicates whether filename is a base64 data URI.
        function isDataURI(filename) {
            // Prefix of data URIs emitted by SINGLE_FILE and related options.
            return filename.startsWith(dataURIPrefix);
        }
        // Indicates whether filename is delivered via file protocol (as opposed to http/https)
        function isFileURI(filename) {
            return filename.startsWith("file://");
        }
        // end include: URIUtils.js
        function createExportWrapper(name) {
            return function() {
                assert(runtimeInitialized, `native function \`${name}\` called before runtime initialization`);
                var f = wasmExports[name];
                assert(f, `exported native function \`${name}\` not found`);
                return f.apply(null, arguments);
            };
        }
        // include: runtime_exceptions.js
        // end include: runtime_exceptions.js
        var wasmBinaryFile;
        wasmBinaryFile = "data:application/octet-stream;base64,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WQ0BCyAAECwiAkF/Sg0BIAAoAgQhASAAKAIsIQILIABCfzcDcCAAIAE2AmggACAEIAIgAWusfDcDeEF/DwsgBEIBfCEEIAAoAgQhASAAKAIIIQMCQCAAKQNwIgVCAFENACAFIAR9IgUgAyABa6xZDQAgASAFp2ohAwsgACADNgJoIAAgBCAAKAIsIgMgAWusfDcDeAJAIAEgA0sNACABQX9qIAI6AAALIAILEAAgAEEgRiAAQXdqQQVJcgvgAQIDfwJ+IwBBEGsiAiQAAkACQCABvCIDQf////8HcSIEQYCAgHxqQf////cHSw0AIAStQhmGQoCAgICAgIDAP3whBUIAIQYMAQsCQCAEQYCAgPwHSQ0AIAOtQhmGQoCAgICAgMD//wCEIQVCACEGDAELAkAgBA0AQgAhBkIAIQUMAQsgAiAErUIAIARnIgRB0QBqECMgAkEIaikDAEKAgICAgIDAAIVBif8AIARrrUIwhoQhBSACKQMAIQYLIAAgBjcDACAAIAUgA0GAgICAeHGtQiCGhDcDCCACQRBqJAALjAECAn8CfiMAQRBrIgIkAAJAAkAgAQ0AQgAhBEIAIQUMAQsgAiABIAFBH3UiA3MgA2siA61CACADZyIDQdEAahAjIAJBCGopAwBCgICAgICAwACFQZ6AASADa61CMIZ8IAFBgICAgHhxrUIghoQhBSACKQMAIQQLIAAgBDcDACAAIAU3AwggAkEQaiQAC5QLAgV/D34jAEHgAGsiBSQAIARC////////P4MhCiAEIAKFQoCAgICAgICAgH+DIQsgAkL///////8/gyIMQiCIIQ0gBEIwiKdB//8BcSEGAkACQAJAIAJCMIinQf//AXEiB0GBgH5qQYKAfkkNAEEAIQggBkGBgH5qQYGAfksNAQsCQCABUCACQv///////////wCDIg5CgICAgICAwP//AFQgDkKAgICAgIDA//8AURsNACACQoCAgICAgCCEIQsMAgsCQCADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURsNACAEQoCAgICAgCCEIQsgAyEBDAILAkAgASAOQoCAgICAgMD//wCFhEIAUg0AAkAgAyAChFBFDQBCgICAgICA4P//ACELQgAhAQwDCyALQoCAgICAgMD//wCEIQtCACEBDAILAkAgAyACQoCAgICAgMD//wCFhEIAUg0AIAEgDoQhAkIAIQECQCACUEUNAEKAgICAgIDg//8AIQsMAwsgC0KAgICAgIDA//8AhCELDAILAkAgASAOhEIAUg0AQgAhAQwCCwJAIAMgAoRCAFINAEIAIQEMAgtBACEIAkAgDkL///////8/Vg0AIAVB0ABqIAEgDCABIAwgDFAiCBt5IAhBBnStfKciCEFxahAjQRAgCGshCCAFQdgAaikDACIMQiCIIQ0gBSkDUCEBCyACQv///////z9WDQAgBUHAAGogAyAKIAMgCiAKUCIJG3kgCUEGdK18pyIJQXFqECMgCCAJa0EQaiEIIAVByABqKQMAIQogBSkDQCEDCyADQg+GIg5CgID+/w+DIgIgAUIgiCIEfiIPIA5CIIgiDiABQv////8PgyIBfnwiEEIghiIRIAIgAX58IhIgEVStIAIgDEL/////D4MiDH4iEyAOIAR+fCIRIANCMYggCkIPhiIUhEL/////D4MiAyABfnwiCiAQQiCIIBAgD1StQiCGhHwiDyACIA1CgIAEhCIQfiIVIA4gDH58Ig0gFEIgiEKAgICACIQiAiABfnwiFCADIAR+fCIWQiCGfCIXfCEBIAcgBmogCGpBgYB/aiEGAkACQCACIAR+IhggDiAQfnwiBCAYVK0gBCADIAx+fCIOIARUrXwgAiAQfnwgDiARIBNUrSAKIBFUrXx8IgQgDlStfCADIBB+IgMgAiAMfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgFkIgiCANIBVUrSAUIA1UrXwgFiAUVK18QiCGhHwiBCACVK18IAQgDyAKVK0gFyAPVK18fCICIARUrXwiBEKAgICAgIDAAINQDQAgBkEBaiEGDAELIBJCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIBJCAYYhEiADIAFCAYaEIQELAkAgBkH//wFIDQAgC0KAgICAgIDA//8AhCELQgAhAQwBCwJAAkAgBkEASg0AAkBBASAGayIHQf8ASw0AIAVBMGogEiABIAZB/wBqIgYQIyAFQSBqIAIgBCAGECMgBUEQaiASIAEgBxAkIAUgAiAEIAcQJCAFKQMgIAUpAxCEIAUpAzAgBUEwakEIaikDAIRCAFKthCESIAVBIGpBCGopAwAgBUEQakEIaikDAIQhASAFQQhqKQMAIQQgBSkDACECDAILQgAhAQwCCyAGrUIwhiAEQv///////z+DhCEECyAEIAuEIQsCQCASUCABQn9VIAFCgICAgICAgICAf1EbDQAgCyACQgF8IgFQrXwhCwwBCwJAIBIgAUKAgICAgICAgIB/hYRCAFENACACIQEMAQsgCyACIAJCAYN8IgEgAlStfCELCyAAIAE3AwAgACALNwMIIAVB4ABqJAALBABBAAsEAEEAC98KAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCQJAAkACQCABUCIGIAJC////////////AIMiCkKAgICAgIDAgIB/fEKAgICAgIDAgIB/VCAKUBsNACADQgBSIAlCgICAgICAwICAf3wiC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCwJAIAYgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhBCABIQMMAgsCQCADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEEDAILAkAgASAKQoCAgICAgMD//wCFhEIAUg0AQoCAgICAgOD//wAgAiADIAGFIAQgAoVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQECQCABIAqEQgBSDQAgAyAJhEIAUg0CIAMgAYMhAyAEIAKDIQQMAgsgAyAJhFBFDQAgASEDIAIhBAwBCyADIAEgAyABViAJIApWIAkgClEbIgcbIQkgBCACIAcbIgtC////////P4MhCiACIAQgBxsiAkIwiKdB//8BcSEIAkAgC0IwiKdB//8BcSIGDQAgBUHgAGogCSAKIAkgCiAKUCIGG3kgBkEGdK18pyIGQXFqECNBECAGayEGIAVB6ABqKQMAIQogBSkDYCEJCyABIAMgBxshAyACQv///////z+DIQQCQCAIDQAgBUHQAGogAyAEIAMgBCAEUCIHG3kgB0EGdK18pyIHQXFqECNBECAHayEIIAVB2ABqKQMAIQQgBSkDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEBIApCA4YgCUI9iIQhBCADQgOGIQogCyAChSEDAkAgBiAIRg0AAkAgBiAIayIHQf8ATQ0AQgAhAUIBIQoMAQsgBUHAAGogCiABQYABIAdrECMgBUEwaiAKIAEgBxAkIAUpAzAgBSkDQCAFQcAAakEIaikDAIRCAFKthCEKIAVBMGpBCGopAwAhAQsgBEKAgICAgICABIQhDCAJQgOGIQkCQAJAIANCf1UNAEIAIQNCACEEIAkgCoUgDCABhYRQDQIgCSAKfSECIAwgAX0gCSAKVK19IgRC/////////wNWDQEgBUEgaiACIAQgAiAEIARQIgcbeSAHQQZ0rXynQXRqIgcQIyAGIAdrIQYgBUEoaikDACEEIAUpAyAhAgwBCyABIAx8IAogCXwiAiAKVK18IgRCgICAgICAgAiDUA0AIAJCAYggBEI/hoQgCkIBg4QhAiAGQQFqIQYgBEIBiCEECyALQoCAgICAgICAgH+DIQoCQCAGQf//AUgNACAKQoCAgICAgMD//wCEIQRCACEDDAELQQAhBwJAAkAgBkEATA0AIAYhBwwBCyAFQRBqIAIgBCAGQf8AahAjIAUgAiAEQQEgBmsQJCAFKQMAIAUpAxAgBUEQakEIaikDAIRCAFKthCECIAVBCGopAwAhBAsgAkIDiCAEQj2GhCEDIAetQjCGIARCA4hC////////P4OEIAqEIQQgAqdBB3EhBgJAAkACQAJAAkAQMw4DAAECAwsgBCADIAZBBEutfCIKIANUrXwhBAJAIAZBBEYNACAKIQMMAwsgBCAKQgGDIgEgCnwiAyABVK18IQQMAwsgBCADIApCAFIgBkEAR3GtfCIKIANUrXwhBCAKIQMMAQsgBCADIApQIAZBAEdxrXwiCiADVK18IQQgCiEDCyAGRQ0BCxA0GgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC40CAgJ/A34jAEEQayICJAACQAJAIAG9IgRC////////////AIMiBUKAgICAgICAeHxC/////////+//AFYNACAFQjyGIQYgBUIEiEKAgICAgICAgDx8IQUMAQsCQCAFQoCAgICAgID4/wBUDQAgBEI8hiEGIARCBIhCgICAgICAwP//AIQhBQwBCwJAIAVQRQ0AQgAhBkIAIQUMAQsgAiAFQgAgBKdnQSBqIAVCIIinZyAFQoCAgIAQVBsiA0ExahAjIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvgAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNAEF/IQQgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LQX8hBCAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQL2AECAX8CfkF/IQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQACQCACIACEIAYgBYSEUEUNAEEADwsCQCADIAGDQgBTDQAgACACVCABIANTIAEgA1EbDQEgACAChSABIAOFhEIAUg8LIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAuuAQACQAJAIAFBgAhIDQAgAEQAAAAAAADgf6IhAAJAIAFB/w9PDQAgAUGBeGohAQwCCyAARAAAAAAAAOB/oiEAIAFB/RcgAUH9F0gbQYJwaiEBDAELIAFBgXhKDQAgAEQAAAAAAABgA6IhAAJAIAFBuHBNDQAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEobQZIPaiEBCyAAIAFB/wdqrUI0hr+iCzUAIAAgATcDACAAIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGIAJC////////P4OENwMIC3ECAX8CfiMAQRBrIgIkAAJAAkAgAQ0AQgAhA0IAIQQMAQsgAiABrUIAIAFnIgFB0QBqECMgAkEIaikDAEKAgICAgIDAAIVBnoABIAFrrUIwhnwhBCACKQMAIQMLIAAgAzcDACAAIAQ3AwggAkEQaiQAC0cBAX8jAEEQayIFJAAgBSABIAIgAyAEQoCAgICAgICAgH+FEDUgBSkDACEEIAAgBUEIaikDADcDCCAAIAQ3AwAgBUEQaiQAC+ICAQF/IwBB0ABrIgQkAAJAAkAgA0GAgAFIDQAgBEEgaiABIAJCAEKAgICAgICA//8AEDIgBEEgakEIaikDACECIAQpAyAhAQJAIANB//8BTw0AIANBgYB/aiEDDAILIARBEGogASACQgBCgICAgICAgP//ABAyIANB/f8CIANB/f8CSBtBgoB+aiEDIARBEGpBCGopAwAhAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEHAAGogASACQgBCgICAgICAgDkQMiAEQcAAakEIaikDACECIAQpA0AhAQJAIANB9IB+TQ0AIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQMiADQeiBfSADQeiBfUobQZr+AWohAyAEQTBqQQhqKQMAIQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQMiAAIARBCGopAwA3AwggACAEKQMANwMAIARB0ABqJAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCICIAFCIIgiBH58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAR+fCIDQiCIfCADQv////8PgyACIAF+fCIBQiCIfDcDCCAAIAFCIIYgBUL/////D4OENwMAC9IQAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQCACQjCIp0H//wFxIgdBgYB+akGCgH5JDQBBACEIIAZBgYB+akGBgH5LDQELAkAgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbDQAgAkKAgICAgIAghCEMDAILAkAgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbDQAgBEKAgICAgIAghCEMIAMhAQwCCwJAIAEgDUKAgICAgIDA//8AhYRCAFINAAJAIAMgAkKAgICAgIDA//8AhYRQRQ0AQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCwJAIAMgAkKAgICAgIDA//8AhYRCAFINAEIAIQEMAgsCQCABIA2EQgBSDQBCgICAgICA4P//ACAMIAMgAoRQGyEMQgAhAQwCCwJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQcACaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQI0EQIAhrIQggBUHIAmopAwAhCyAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAKIAMgCiAKUCIJG3kgCUEGdK18pyIJQXFqECMgCSAIakFwaiEIIAVBuAJqKQMAIQogBSkDsAIhAwsgBUGgAmogA0IxiCAKQoCAgICAgMAAhCIOQg+GhCICQgBCgICAgLDmvIL1ACACfSIEQgAQPiAFQZACakIAIAVBoAJqQQhqKQMAfUIAIARCABA+IAVBgAJqIAUpA5ACQj+IIAVBkAJqQQhqKQMAQgGGhCIEQgAgAkIAED4gBUHwAWogBEIAQgAgBUGAAmpBCGopAwB9QgAQPiAFQeABaiAFKQPwAUI/iCAFQfABakEIaikDAEIBhoQiBEIAIAJCABA+IAVB0AFqIARCAEIAIAVB4AFqQQhqKQMAfUIAED4gBUHAAWogBSkD0AFCP4ggBUHQAWpBCGopAwBCAYaEIgRCACACQgAQPiAFQbABaiAEQgBCACAFQcABakEIaikDAH1CABA+IAVBoAFqIAJCACAFKQOwAUI/iCAFQbABakEIaikDAEIBhoRCf3wiBEIAED4gBUGQAWogA0IPhkIAIARCABA+IAVB8ABqIARCAEIAIAVBoAFqQQhqKQMAIAUpA6ABIgogBUGQAWpBCGopAwB8IgIgClStfCACQgFWrXx9QgAQPiAFQYABakIBIAJ9QgAgBEIAED4gCCAHIAZraiEGAkACQCAFKQNwIg9CAYYiECAFKQOAAUI/iCAFQYABakEIaikDACIRQgGGhHwiDUKZk398IhJCIIgiAiALQoCAgICAgMAAhCITQgGGIhRCIIgiBH4iFSABQgGGIhZCIIgiCiAFQfAAakEIaikDAEIBhiAPQj+IhCARQj+IfCANIBBUrXwgEiANVK18Qn98Ig9CIIgiDX58IhAgFVStIBAgD0L/////D4MiDyABQj+IIhcgC0IBhoRC/////w+DIgt+fCIRIBBUrXwgDSAEfnwgDyAEfiIVIAsgDX58IhAgFVStQiCGIBBCIIiEfCARIBBCIIZ8IhAgEVStfCAQIBJC/////w+DIhIgC34iFSACIAp+fCIRIBVUrSARIA8gFkL+////D4MiFX58IhggEVStfHwiESAQVK18IBEgEiAEfiIQIBUgDX58IgQgAiALfnwiDSAPIAp+fCIPQiCIIAQgEFStIA0gBFStfCAPIA1UrXxCIIaEfCIEIBFUrXwgBCAYIAIgFX4iAiASIAp+fCIKQiCIIAogAlStQiCGhHwiAiAYVK0gAiAPQiCGfCACVK18fCICIARUrXwiBEL/////////AFYNACAUIBeEIRMgBUHQAGogAiAEIAMgDhA+IAFCMYYgBUHQAGpBCGopAwB9IAUpA1AiAUIAUq19IQ0gBkH+/wBqIQZCACABfSEKDAELIAVB4ABqIAJCAYggBEI/hoQiAiAEQgGIIgQgAyAOED4gAUIwhiAFQeAAakEIaikDAH0gBSkDYCIKQgBSrX0hDSAGQf//AGohBkIAIAp9IQogASEWCwJAIAZB//8BSA0AIAxCgICAgICAwP//AIQhDEIAIQEMAQsCQAJAIAZBAUgNACANQgGGIApCP4iEIQ0gBq1CMIYgBEL///////8/g4QhDyAKQgGGIQQMAQsCQCAGQY9/Sg0AQgAhAQwCCyAFQcAAaiACIARBASAGaxAkIAVBMGogFiATIAZB8ABqECMgBUEgaiADIA4gBSkDQCICIAVBwABqQQhqKQMAIg8QPiAFQTBqQQhqKQMAIAVBIGpBCGopAwBCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiAVStfSENIAQgAX0hBAsgBUEQaiADIA5CA0IAED4gBSADIA5CBUIAED4gDyACIAJCAYMiASAEfCIEIANWIA0gBCABVK18IgEgDlYgASAOURutfCIDIAJUrXwiAiADIAJCgICAgICAwP//AFQgBCAFKQMQViABIAVBEGpBCGopAwAiAlYgASACURtxrXwiAiADVK18IgMgAiADQoCAgICAgMD//wBUIAQgBSkDAFYgASAFQQhqKQMAIgRWIAEgBFEbca18IgEgAlStfCAMhCEMCyAAIAE3AwAgACAMNwMIIAVB0AJqJAALSwIBfgJ/IAFC////////P4MhAgJAAkAgAUIwiKdB//8BcSIDQf//AUYNAEEEIQQgAw0BQQJBAyACIACEUBsPCyACIACEUCEECyAEC8kGAgR/A34jAEGAAWsiBSQAAkACQAJAIAMgBEIAQgAQN0UNACADIAQQQCEGIAJCMIinIgdB//8BcSIIQf//AUYNACAGDQELIAVBEGogASACIAMgBBAyIAUgBSkDECIEIAVBEGpBCGopAwAiAyAEIAMQPyAFQQhqKQMAIQIgBSkDACEEDAELAkAgASACQv///////////wCDIgkgAyAEQv///////////wCDIgoQN0EASg0AAkAgASAJIAMgChA3RQ0AIAEhBAwCCyAFQfAAaiABIAJCAEIAEDIgBUH4AGopAwAhAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGAkACQCAIRQ0AIAEhBAwBCyAFQeAAaiABIAlCAEKAgICAgIDAu8AAEDIgBUHoAGopAwAiCUIwiKdBiH9qIQggBSkDYCEECwJAIAYNACAFQdAAaiADIApCAEKAgICAgIDAu8AAEDIgBUHYAGopAwAiCkIwiKdBiH9qIQYgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCELIAlC////////P4NCgICAgICAwACEIQkCQCAIIAZMDQADQAJAAkAgCSALfSAEIANUrX0iCkIAUw0AAkAgCiAEIAN9IgSEQgBSDQAgBUEgaiABIAJCAEIAEDIgBUEoaikDACECIAUpAyAhBAwFCyAKQgGGIARCP4iEIQkMAQsgCUIBhiAEQj+IhCEJCyAEQgGGIQQgCEF/aiIIIAZKDQALIAYhCAsCQAJAIAkgC30gBCADVK19IgpCAFkNACAJIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEDIgBUE4aikDACECIAUpAzAhBAwBCwJAIApC////////P1YNAANAIARCP4ghAyAIQX9qIQggBEIBhiEEIAMgCkIBhoQiCkKAgICAgIDAAFQNAAsLIAdBgIACcSEGAkAgCEEASg0AIAVBwABqIAQgCkL///////8/gyAIQfgAaiAGcq1CMIaEQgBCgICAgICAwMM/EDIgBUHIAGopAwAhAiAFKQNAIQQMAQsgCkL///////8/gyAIIAZyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQACxwAIAAgAkL///////////8AgzcDCCAAIAE3AwAL+QgCBX8DfiMAQTBrIgQkAEIAIQkCQAJAIAJBAksNACACQQJ0IgJBzIAEaigCACEFIAJBwIAEaigCACEGA0ACQAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARAuIQILIAIQLw0AC0EBIQcCQAJAIAJBVWoOAwABAAELQX9BASACQS1GGyEHAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEC4hAgtBACEIAkACQAJAA0AgAkEgciAIQYCABGosAABHDQECQCAIQQZLDQACQCABKAIEIgIgASgCaEYNACABIAJBAWo2AgQgAi0AACECDAELIAEQLiECCyAIQQFqIghBCEcNAAwCCwALAkAgCEEDRg0AIAhBCEYNASADRQ0CIAhBBEkNAiAIQQhGDQELAkAgASkDcCIJQgBTDQAgASABKAIEQX9qNgIECyADRQ0AIAhBBEkNACAJQgBTIQIDQAJAIAINACABIAEoAgRBf2o2AgQLIAhBf2oiCEEDSw0ACwsgBCAHskMAAIB/lBAwIARBCGopAwAhCiAEKQMAIQkMAgsCQAJAAkAgCA0AQQAhCANAIAJBIHIgCEGJgARqLAAARw0BAkAgCEEBSw0AAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEC4hAgsgCEEBaiIIQQNHDQAMAgsACwJAAkAgCA4EAAEBAgELAkAgAkEwRw0AAkACQCABKAIEIgggASgCaEYNACABIAhBAWo2AgQgCC0AACEIDAELIAEQLiEICwJAIAhBX3FB2ABHDQAgBEEQaiABIAYgBSAHIAMQRCAEQRhqKQMAIQogBCkDECEJDAYLIAEpA3BCAFMNACABIAEoAgRBf2o2AgQLIARBIGogASACIAYgBSAHIAMQRSAEQShqKQMAIQogBCkDICEJDAQLQgAhCQJAIAEpA3BCAFMNACABIAEoAgRBf2o2AgQLEB9BHDYCAAwBCwJAAkAgASgCBCICIAEoAmhGDQAgASACQQFqNgIEIAItAAAhAgwBCyABEC4hAgsCQAJAIAJBKEcNAEEBIQgMAQtCACEJQoCAgICAgOD//wAhCiABKQNwQgBTDQMgASABKAIEQX9qNgIEDAMLA0ACQAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARAuIQILIAJBv39qIQcCQAJAIAJBUGpBCkkNACAHQRpJDQAgAkGff2ohByACQd8ARg0AIAdBGk8NAQsgCEEBaiEIDAELC0KAgICAgIDg//8AIQogAkEpRg0CAkAgASkDcCILQgBTDQAgASABKAIEQX9qNgIECwJAAkAgA0UNACAIDQFCACEJDAQLEB9BHDYCAEIAIQkMAQsDQAJAIAtCAFMNACABIAEoAgRBf2o2AgQLQgAhCSAIQX9qIggNAAwDCwALIAEgCRAtC0IAIQoLIAAgCTcDACAAIAo3AwggBEEwaiQAC5gPAgh/B34jAEGwA2siBiQAAkACQCABKAIEIgcgASgCaEYNACABIAdBAWo2AgQgBy0AACEHDAELIAEQLiEHC0EAIQhCACEOQQAhCQJAAkACQANAAkAgB0EwRg0AIAdBLkcNBCABKAIEIgcgASgCaEYNAiABIAdBAWo2AgQgBy0AACEHDAMLAkAgASgCBCIHIAEoAmhGDQBBASEJIAEgB0EBajYCBCAHLQAAIQcMAQtBASEJIAEQLiEHDAALAAsgARAuIQcLQQEhCEIAIQ4gB0EwRw0AA0ACQAJAIAEoAgQiByABKAJoRg0AIAEgB0EBajYCBCAHLQAAIQcMAQsgARAuIQcLIA5Cf3whDiAHQTBGDQALQQEhCEEBIQkLQoCAgICAgMD/PyEPQQAhCkIAIRBCACERQgAhEkEAIQtCACETAkADQCAHQSByIQwCQAJAIAdBUGoiDUEKSQ0AAkAgB0EuRg0AIAxBn39qQQVLDQQLIAdBLkcNACAIDQNBASEIIBMhDgwBCyAMQal/aiANIAdBOUobIQcCQAJAIBNCB1UNACAHIApBBHRqIQoMAQsCQCATQhxWDQAgBkEwaiAHEDEgBkEgaiASIA9CAEKAgICAgIDA/T8QMiAGQRBqIAYpAzAgBkEwakEIaikDACAGKQMgIhIgBkEgakEIaikDACIPEDIgBiAGKQMQIAZBEGpBCGopAwAgECAREDUgBkEIaikDACERIAYpAwAhEAwBCyAHRQ0AIAsNACAGQdAAaiASIA9CAEKAgICAgICA/z8QMiAGQcAAaiAGKQNQIAZB0ABqQQhqKQMAIBAgERA1IAZBwABqQQhqKQMAIRFBASELIAYpA0AhEAsgE0IBfCETQQEhCQsCQCABKAIEIgcgASgCaEYNACABIAdBAWo2AgQgBy0AACEHDAELIAEQLiEHDAALAAsCQAJAIAkNAAJAAkACQCABKQNwQgBTDQAgASABKAIEIgdBf2o2AgQgBUUNASABIAdBfmo2AgQgCEUNAiABIAdBfWo2AgQMAgsgBQ0BCyABQgAQLQsgBkHgAGogBLdEAAAAAAAAAACiEDYgBkHoAGopAwAhEyAGKQNgIRAMAQsCQCATQgdVDQAgEyEPA0AgCkEEdCEKIA9CAXwiD0IIUg0ACwsCQAJAAkACQCAHQV9xQdAARw0AIAEgBRBGIg9CgICAgICAgICAf1INAwJAIAVFDQAgASkDcEJ/VQ0CDAMLQgAhECABQgAQLUIAIRMMBAtCACEPIAEpA3BCAFMNAgsgASABKAIEQX9qNgIEC0IAIQ8LAkAgCg0AIAZB8ABqIAS3RAAAAAAAAAAAohA2IAZB+ABqKQMAIRMgBikDcCEQDAELAkAgDiATIAgbQgKGIA98QmB8IhNBACADa61XDQAQH0HEADYCACAGQaABaiAEEDEgBkGQAWogBikDoAEgBkGgAWpBCGopAwBCf0L///////+///8AEDIgBkGAAWogBikDkAEgBkGQAWpBCGopAwBCf0L///////+///8AEDIgBkGAAWpBCGopAwAhEyAGKQOAASEQDAELAkAgEyADQZ5+aqxTDQACQCAKQX9MDQADQCAGQaADaiAQIBFCAEKAgICAgIDA/79/EDUgECARQgBCgICAgICAgP8/EDghByAGQZADaiAQIBEgBikDoAMgECAHQX9KIgcbIAZBoANqQQhqKQMAIBEgBxsQNSATQn98IRMgBkGQA2pBCGopAwAhESAGKQOQAyEQIApBAXQgB3IiCkF/Sg0ACwsCQAJAIBMgA6x9QiB8Ig6nIgdBACAHQQBKGyACIA4gAq1TGyIHQfEASA0AIAZBgANqIAQQMSAGQYgDaikDACEOQgAhDyAGKQOAAyESQgAhFAwBCyAGQeACakQAAAAAAADwP0GQASAHaxA5EDYgBkHQAmogBBAxIAZB8AJqIAYpA+ACIAZB4AJqQQhqKQMAIAYpA9ACIhIgBkHQAmpBCGopAwAiDhA6IAZB8AJqQQhqKQMAIRQgBikD8AIhDwsgBkHAAmogCiAKQQFxRSAHQSBIIBAgEUIAQgAQN0EAR3FxIgdqEDsgBkGwAmogEiAOIAYpA8ACIAZBwAJqQQhqKQMAEDIgBkGQAmogBikDsAIgBkGwAmpBCGopAwAgDyAUEDUgBkGgAmogEiAOQgAgECAHG0IAIBEgBxsQMiAGQYACaiAGKQOgAiAGQaACakEIaikDACAGKQOQAiAGQZACakEIaikDABA1IAZB8AFqIAYpA4ACIAZBgAJqQQhqKQMAIA8gFBA8AkAgBikD8AEiECAGQfABakEIaikDACIRQgBCABA3DQAQH0HEADYCAAsgBkHgAWogECARIBOnED0gBkHgAWpBCGopAwAhEyAGKQPgASEQDAELEB9BxAA2AgAgBkHQAWogBBAxIAZBwAFqIAYpA9ABIAZB0AFqQQhqKQMAQgBCgICAgICAwAAQMiAGQbABaiAGKQPAASAGQcABakEIaikDAEIAQoCAgICAgMAAEDIgBkGwAWpBCGopAwAhEyAGKQOwASEQCyAAIBA3AwAgACATNwMIIAZBsANqJAALuR8DC38GfgF8IwBBkMYAayIHJABBACEIQQAgBGsiCSADayEKQgAhEkEAIQsCQAJAAkADQAJAIAJBMEYNACACQS5HDQQgASgCBCICIAEoAmhGDQIgASACQQFqNgIEIAItAAAhAgwDCwJAIAEoAgQiAiABKAJoRg0AQQEhCyABIAJBAWo2AgQgAi0AACECDAELQQEhCyABEC4hAgwACwALIAEQLiECC0EBIQhCACESIAJBMEcNAANAAkACQCABKAIEIgIgASgCaEYNACABIAJBAWo2AgQgAi0AACECDAELIAEQLiECCyASQn98IRIgAkEwRg0AC0EBIQtBASEIC0EAIQwgB0EANgKQBiACQVBqIQ0CQAJAAkACQAJAAkACQCACQS5GIg4NAEIAIRMgDUEJTQ0AQQAhD0EAIRAMAQtCACETQQAhEEEAIQ9BACEMA0ACQAJAIA5BAXFFDQACQCAIDQAgEyESQQEhCAwCCyALRSEODAQLIBNCAXwhEwJAIA9B/A9KDQAgB0GQBmogD0ECdGohDgJAIBBFDQAgAiAOKAIAQQpsakFQaiENCyAMIBOnIAJBMEYbIQwgDiANNgIAQQEhC0EAIBBBAWoiAiACQQlGIgIbIRAgDyACaiEPDAELIAJBMEYNACAHIAcoAoBGQQFyNgKARkHcjwEhDAsCQAJAIAEoAgQiAiABKAJoRg0AIAEgAkEBajYCBCACLQAAIQIMAQsgARAuIQILIAJBUGohDSACQS5GIg4NACANQQpJDQALCyASIBMgCBshEgJAIAtFDQAgAkFfcUHFAEcNAAJAIAEgBhBGIhRCgICAgICAgICAf1INACAGRQ0EQgAhFCABKQNwQgBTDQAgASABKAIEQX9qNgIECyAUIBJ8IRIMBAsgC0UhDiACQQBIDQELIAEpA3BCAFMNACABIAEoAgRBf2o2AgQLIA5FDQEQH0EcNgIAC0IAIRMgAUIAEC1CACESDAELAkAgBygCkAYiAQ0AIAcgBbdEAAAAAAAAAACiEDYgB0EIaikDACESIAcpAwAhEwwBCwJAIBNCCVUNACASIBNSDQACQCADQR5KDQAgASADdg0BCyAHQTBqIAUQMSAHQSBqIAEQOyAHQRBqIAcpAzAgB0EwakEIaikDACAHKQMgIAdBIGpBCGopAwAQMiAHQRBqQQhqKQMAIRIgBykDECETDAELAkAgEiAJQQF2rVcNABAfQcQANgIAIAdB4ABqIAUQMSAHQdAAaiAHKQNgIAdB4ABqQQhqKQMAQn9C////////v///ABAyIAdBwABqIAcpA1AgB0HQAGpBCGopAwBCf0L///////+///8AEDIgB0HAAGpBCGopAwAhEiAHKQNAIRMMAQsCQCASIARBnn5qrFkNABAfQcQANgIAIAdBkAFqIAUQMSAHQYABaiAHKQOQASAHQZABakEIaikDAEIAQoCAgICAgMAAEDIgB0HwAGogBykDgAEgB0GAAWpBCGopAwBCAEKAgICAgIDAABAyIAdB8ABqQQhqKQMAIRIgBykDcCETDAELAkAgEEUNAAJAIBBBCEoNACAHQZAGaiAPQQJ0aiICKAIAIQEDQCABQQpsIQEgEEEBaiIQQQlHDQALIAIgATYCAAsgD0EBaiEPCyASpyEQAkAgDEEJTg0AIAwgEEoNACAQQRFKDQACQCAQQQlHDQAgB0HAAWogBRAxIAdBsAFqIAcoApAGEDsgB0GgAWogBykDwAEgB0HAAWpBCGopAwAgBykDsAEgB0GwAWpBCGopAwAQMiAHQaABakEIaikDACESIAcpA6ABIRMMAgsCQCAQQQhKDQAgB0GQAmogBRAxIAdBgAJqIAcoApAGEDsgB0HwAWogBykDkAIgB0GQAmpBCGopAwAgBykDgAIgB0GAAmpBCGopAwAQMiAHQeABakEIIBBrQQJ0QaCABGooAgAQMSAHQdABaiAHKQPwASAHQfABakEIaikDACAHKQPgASAHQeABakEIaikDABA/IAdB0AFqQQhqKQMAIRIgBykD0AEhEwwCCyAHKAKQBiEBAkAgAyAQQX1sakEbaiICQR5KDQAgASACdg0BCyAHQeACaiAFEDEgB0HQAmogARA7IAdBwAJqIAcpA+ACIAdB4AJqQQhqKQMAIAcpA9ACIAdB0AJqQQhqKQMAEDIgB0GwAmogEEECdEH4/wNqKAIAEDEgB0GgAmogBykDwAIgB0HAAmpBCGopAwAgBykDsAIgB0GwAmpBCGopAwAQMiAHQaACakEIaikDACESIAcpA6ACIRMMAQsDQCAHQZAGaiAPIg5Bf2oiD0ECdGooAgBFDQALQQAhDAJAAkAgEEEJbyIBDQBBACENDAELQQAhDSABQQlqIAEgEEEASBshCQJAAkAgDg0AQQAhDgwBC0GAlOvcA0EIIAlrQQJ0QaCABGooAgAiC20hBkEAIQJBACEBQQAhDQNAIAdBkAZqIAFBAnRqIg8gDygCACIPIAtuIgggAmoiAjYCACANQQFqQf8PcSANIAEgDUYgAkVxIgIbIQ0gEEF3aiAQIAIbIRAgBiAPIAggC2xrbCECIAFBAWoiASAORw0ACyACRQ0AIAdBkAZqIA5BAnRqIAI2AgAgDkEBaiEOCyAQIAlrQQlqIRALA0AgB0GQBmogDUECdGohBgJAA0ACQCAQQSRIDQAgEEEkRw0CIAYoAgBB0en5BE8NAgsgDkH/D2ohD0EAIQsDQCAOIQICQAJAIAdBkAZqIA9B/w9xIgFBAnRqIg41AgBCHYYgC618IhJCgZTr3ANaDQBBACELDAELIBIgEkKAlOvcA4AiE0KAlOvcA359IRIgE6chCwsgDiASpyIPNgIAIAIgAiACIAEgDxsgASANRhsgASACQX9qQf8PcSIIRxshDiABQX9qIQ8gASANRw0ACyAMQWNqIQwgAiEOIAtFDQALAkACQCANQX9qQf8PcSINIAJGDQAgAiEODAELIAdBkAZqIAJB/g9qQf8PcUECdGoiASABKAIAIAdBkAZqIAhBAnRqKAIAcjYCACAIIQ4LIBBBCWohECAHQZAGaiANQQJ0aiALNgIADAELCwJAA0AgDkEBakH/D3EhESAHQZAGaiAOQX9qQf8PcUECdGohCQNAQQlBASAQQS1KGyEPAkADQCANIQtBACEBAkACQANAIAEgC2pB/w9xIgIgDkYNASAHQZAGaiACQQJ0aigCACICIAFBAnRBkIAEaigCACINSQ0BIAIgDUsNAiABQQFqIgFBBEcNAAsLIBBBJEcNAEIAIRJBACEBQgAhEwNAAkAgASALakH/D3EiAiAORw0AIA5BAWpB/w9xIg5BAnQgB0GQBmpqQXxqQQA2AgALIAdBgAZqIAdBkAZqIAJBAnRqKAIAEDsgB0HwBWogEiATQgBCgICAgOWat47AABAyIAdB4AVqIAcpA/AFIAdB8AVqQQhqKQMAIAcpA4AGIAdBgAZqQQhqKQMAEDUgB0HgBWpBCGopAwAhEyAHKQPgBSESIAFBAWoiAUEERw0ACyAHQdAFaiAFEDEgB0HABWogEiATIAcpA9AFIAdB0AVqQQhqKQMAEDIgB0HABWpBCGopAwAhE0IAIRIgBykDwAUhFCAMQfEAaiINIARrIgFBACABQQBKGyADIAEgA0giCBsiAkHwAEwNAkIAIRVCACEWQgAhFwwFCyAPIAxqIQwgDiENIAsgDkYNAAtBgJTr3AMgD3YhCEF/IA90QX9zIQZBACEBIAshDQNAIAdBkAZqIAtBAnRqIgIgAigCACICIA92IAFqIgE2AgAgDUEBakH/D3EgDSALIA1GIAFFcSIBGyENIBBBd2ogECABGyEQIAIgBnEgCGwhASALQQFqQf8PcSILIA5HDQALIAFFDQECQCARIA1GDQAgB0GQBmogDkECdGogATYCACARIQ4MAwsgCSAJKAIAQQFyNgIADAELCwsgB0GQBWpEAAAAAAAA8D9B4QEgAmsQORA2IAdBsAVqIAcpA5AFIAdBkAVqQQhqKQMAIBQgExA6IAdBsAVqQQhqKQMAIRcgBykDsAUhFiAHQYAFakQAAAAAAADwP0HxACACaxA5EDYgB0GgBWogFCATIAcpA4AFIAdBgAVqQQhqKQMAEEEgB0HwBGogFCATIAcpA6AFIhIgB0GgBWpBCGopAwAiFRA8IAdB4ARqIBYgFyAHKQPwBCAHQfAEakEIaikDABA1IAdB4ARqQQhqKQMAIRMgBykD4AQhFAsCQCALQQRqQf8PcSIPIA5GDQACQAJAIAdBkAZqIA9BAnRqKAIAIg9B/8m17gFLDQACQCAPDQAgC0EFakH/D3EgDkYNAgsgB0HwA2ogBbdEAAAAAAAA0D+iEDYgB0HgA2ogEiAVIAcpA/ADIAdB8ANqQQhqKQMAEDUgB0HgA2pBCGopAwAhFSAHKQPgAyESDAELAkAgD0GAyrXuAUYNACAHQdAEaiAFt0QAAAAAAADoP6IQNiAHQcAEaiASIBUgBykD0AQgB0HQBGpBCGopAwAQNSAHQcAEakEIaikDACEVIAcpA8AEIRIMAQsgBbchGAJAIAtBBWpB/w9xIA5HDQAgB0GQBGogGEQAAAAAAADgP6IQNiAHQYAEaiASIBUgBykDkAQgB0GQBGpBCGopAwAQNSAHQYAEakEIaikDACEVIAcpA4AEIRIMAQsgB0GwBGogGEQAAAAAAADoP6IQNiAHQaAEaiASIBUgBykDsAQgB0GwBGpBCGopAwAQNSAHQaAEakEIaikDACEVIAcpA6AEIRILIAJB7wBKDQAgB0HQA2ogEiAVQgBCgICAgICAwP8/EEEgBykD0AMgB0HQA2pBCGopAwBCAEIAEDcNACAHQcADaiASIBVCAEKAgICAgIDA/z8QNSAHQcADakEIaikDACEVIAcpA8ADIRILIAdBsANqIBQgEyASIBUQNSAHQaADaiAHKQOwAyAHQbADakEIaikDACAWIBcQPCAHQaADakEIaikDACETIAcpA6ADIRQCQCANQf////8HcSAKQX5qTA0AIAdBkANqIBQgExBCIAdBgANqIBQgE0IAQoCAgICAgID/PxAyIAcpA5ADIAdBkANqQQhqKQMAQgBCgICAgICAgLjAABA4IQ0gB0GAA2pBCGopAwAgEyANQX9KIg4bIRMgBykDgAMgFCAOGyEUIBIgFUIAQgAQNyELAkAgDCAOaiIMQe4AaiAKSg0AIAggAiABRyANQQBIcnEgC0EAR3FFDQELEB9BxAA2AgALIAdB8AJqIBQgEyAMED0gB0HwAmpBCGopAwAhEiAHKQPwAiETCyAAIBI3AwggACATNwMAIAdBkMYAaiQAC78EAgR/AX4CQAJAIAAoAgQiAiAAKAJoRg0AIAAgAkEBajYCBCACLQAAIQMMAQsgABAuIQMLAkACQAJAAkACQCADQVVqDgMAAQABCwJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgA0EtRiEEIAJBRmohBSABRQ0BIAVBdUsNASAAKQNwQgBTDQIgACAAKAIEQX9qNgIEDAILIANBRmohBUEAIQQgAyECCyAFQXZJDQBCACEGAkAgAkFQakEKTw0AQQAhAwNAIAIgA0EKbGohAwJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgA0FQaiEDAkAgAkFQaiIFQQlLDQAgA0HMmbPmAEgNAQsLIAOsIQYgBUEKTw0AA0AgAq0gBkIKfnwhBgJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgBkJQfCEGAkAgAkFQaiIDQQlLDQAgBkKuj4XXx8LrowFTDQELCyADQQpPDQADQAJAAkAgACgCBCICIAAoAmhGDQAgACACQQFqNgIEIAItAAAhAgwBCyAAEC4hAgsgAkFQakEKSQ0ACwsCQCAAKQNwQgBTDQAgACAAKAIEQX9qNgIEC0IAIAZ9IAYgBBshBgwBC0KAgICAgICAgIB/IQYgACkDcEIAUw0AIAAgACgCBEF/ajYCBEKAgICAgICAgIB/DwsgBgviAwICfwJ+IwBBIGsiAiQAAkACQCABQv///////////wCDIgRCgICAgICAwP9DfCAEQoCAgICAgMCAvH98Wg0AIABCPIggAUIEhoQhBAJAIABC//////////8PgyIAQoGAgICAgICACFQNACAEQoGAgICAgICAwAB8IQUMAgsgBEKAgICAgICAgMAAfCEFIABCgICAgICAgIAIUg0BIAUgBEIBg3whBQwBCwJAIABQIARCgICAgICAwP//AFQgBEKAgICAgIDA//8AURsNACAAQjyIIAFCBIaEQv////////8Dg0KAgICAgICA/P8AhCEFDAELQoCAgICAgID4/wAhBSAEQv///////7//wwBWDQBCACEFIARCMIinIgNBkfcASQ0AIAJBEGogACABQv///////z+DQoCAgICAgMAAhCIEIANB/4h/ahAjIAIgACAEQYH4ACADaxAkIAIpAwAiBEI8iCACQQhqKQMAQgSGhCEFAkAgBEL//////////w+DIAIpAxAgAkEQakEIaikDAIRCAFKthCIEQoGAgICAgICACFQNACAFQgF8IQUMAQsgBEKAgICAgICAgAhSDQAgBUIBgyAFfCEFCyACQSBqJAAgBSABQoCAgICAgICAgH+DhL8LhAECAX8CfiMAQaABayIEJAAgBCABNgI8IAQgATYCFCAEQX82AhggBEEQakIAEC0gBCAEQRBqIANBARBDIARBCGopAwAhBSAEKQMAIQYCQCACRQ0AIAIgASAEKAIUIAQoAogBaiAEKAI8a2o2AgALIAAgBTcDCCAAIAY3AwAgBEGgAWokAAszAgF/AXwjAEEQayICJAAgAiAAIAFBARBIIAIpAwAgAkEIaikDABBHIQMgAkEQaiQAIAMLCAAgAEEAEEkLtAIBA38CQCAADQBBACEBAkBBACgC5IQERQ0AQQAoAuSEBBBLIQELAkBBACgC5IQERQ0AQQAoAuSEBBBLIAFyIQELAkAQJygCACIARQ0AA0BBACECAkAgACgCTEEASA0AIAAQKSECCwJAIAAoAhQgACgCHEYNACAAEEsgAXIhAQsCQCACRQ0AIAAQKgsgACgCOCIADQALCxAoIAEPC0EAIQICQCAAKAJMQQBIDQAgABApIQILAkACQAJAIAAoAhQgACgCHEYNACAAQQBBACAAKAIkEQIAGiAAKAIUDQBBfyEBIAINAQwCCwJAIAAoAgQiASAAKAIIIgNGDQAgACABIANrrEEBIAAoAigRGwAaC0EAIQEgAEEANgIcIABCADcDECAAQgA3AgQgAkUNAQsgABAqCyABCwoAIABBUGpBCkkLjAEBBX8DQCAAIgFBAWohACABLAAAEC8NAAtBACECQQAhA0EAIQQCQAJAAkAgASwAACIFQVVqDgMBAgACC0EBIQMLIAAsAAAhBSAAIQEgAyEECwJAIAUQTEUNAANAIAJBCmwgASwAAGtBMGohAiABLAABIQAgAUEBaiEBIAAQTA0ACwsgAkEAIAJrIAQbCwtrAgBBgIAEC1hpbmZpbml0eQBuYW4AAAAA0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AEHYgAQLBHACAQA=";
        if (!isDataURI(wasmBinaryFile)) wasmBinaryFile = locateFile(wasmBinaryFile);
        function getBinarySync(file) {
            if (file == wasmBinaryFile && wasmBinary) return new Uint8Array(wasmBinary);
            var binary = tryParseAsDataURI(file);
            if (binary) return binary;
            if (readBinary) return readBinary(file);
            throw "both async and sync fetching of the wasm failed";
        }
        function getBinaryPromise(binaryFile) {
            // Otherwise, getBinarySync should be able to get it synchronously
            return Promise.resolve().then(()=>getBinarySync(binaryFile));
        }
        function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary)=>{
                return WebAssembly.instantiate(binary, imports);
            }).then((instance)=>{
                return instance;
            }).then(receiver, (reason)=>{
                err(`failed to asynchronously prepare wasm: ${reason}`);
                // Warn on some common problems.
                if (isFileURI(wasmBinaryFile)) err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
                abort(reason);
            });
        }
        function instantiateAsync(binary, binaryFile, imports, callback) {
            return instantiateArrayBuffer(binaryFile, imports, callback);
        }
        // Create the wasm instance.
        // Receives the wasm imports, returns the exports.
        function createWasm() {
            // prepare imports
            var info = {
                env: wasmImports,
                wasi_snapshot_preview1: wasmImports
            };
            // Load the wasm module and create an instance of using native support in the JS engine.
            // handle a generated wasm instance, receiving its exports and
            // performing other necessary setup
            /** @param {WebAssembly.Module=} module*/ function receiveInstance(instance, module1) {
                var exports = instance.exports;
                wasmExports = exports;
                wasmMemory = wasmExports["memory"];
                Module["wasmMemory"] = wasmMemory;
                assert(wasmMemory, "memory not found in wasm exports");
                // This assertion doesn't hold when emscripten is run in --post-link
                // mode.
                // TODO(sbc): Read INITIAL_MEMORY out of the wasm file in post-link mode.
                //assert(wasmMemory.buffer.byteLength === 16777216);
                updateMemoryViews();
                wasmTable = wasmExports["__indirect_function_table"];
                assert(wasmTable, "table not found in wasm exports");
                addOnInit(wasmExports["__wasm_call_ctors"]);
                removeRunDependency("wasm-instantiate");
                return exports;
            }
            // wait for the pthread pool (if any)
            addRunDependency("wasm-instantiate");
            // Prefer streaming instantiation if available.
            // Async compilation can be confusing when an error on the page overwrites Module
            // (for example, if the order of elements is wrong, and the one defining Module is
            // later), so we save Module and check it later.
            var trueModule = Module;
            function receiveInstantiationResult(result) {
                // 'result' is a ResultObject object which has both the module and instance.
                // receiveInstance() will swap in the exports (to Module.asm) so they can be called
                assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
                trueModule = null;
                // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
                // When the regression is fixed, can restore the above PTHREADS-enabled path.
                receiveInstance(result["instance"]);
            }
            // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
            // to manually instantiate the Wasm module themselves. This allows pages to
            // run the instantiation parallel to any other async startup actions they are
            // performing.
            // Also pthreads and wasm workers initialize the wasm instance through this
            // path.
            if (Module["instantiateWasm"]) try {
                return Module["instantiateWasm"](info, receiveInstance);
            } catch (e) {
                err(`Module.instantiateWasm callback failed with error: ${e}`);
                // If instantiation fails, reject the module ready promise.
                readyPromiseReject(e);
            }
            // If instantiation fails, reject the module ready promise.
            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
            return {}; // no exports yet; we'll fill them in later
        }
        // Globals used by JS i64 conversions (see makeSetValue)
        var tempDouble;
        var tempI64;
        // include: runtime_debug.js
        function legacyModuleProp(prop, newName, incomming = true) {
            if (!Object.getOwnPropertyDescriptor(Module, prop)) Object.defineProperty(Module, prop, {
                configurable: true,
                get () {
                    let extra = incomming ? " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)" : "";
                    abort(`\`Module.${prop}\` has been replaced by \`${newName}\`` + extra);
                }
            });
        }
        function ignoredModuleProp(prop) {
            if (Object.getOwnPropertyDescriptor(Module, prop)) abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
        }
        // forcing the filesystem exports a few things by default
        function isExportedByForceFilesystem(name) {
            return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || // The old FS has some functionality that WasmFS lacks.
            name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
        }
        function missingGlobal(sym, msg) {
            if (typeof globalThis !== "undefined") Object.defineProperty(globalThis, sym, {
                configurable: true,
                get () {
                    warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
                    return undefined;
                }
            });
        }
        missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
        missingGlobal("asm", "Please use wasmExports instead");
        function missingLibrarySymbol(sym) {
            if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) Object.defineProperty(globalThis, sym, {
                configurable: true,
                get () {
                    // Can't `abort()` here because it would break code that does runtime
                    // checks.  e.g. `if (typeof SDL === 'undefined')`.
                    var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
                    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in
                    // library.js, which means $name for a JS name with no prefix, or name
                    // for a JS name like _name.
                    var librarySymbol = sym;
                    if (!librarySymbol.startsWith("_")) librarySymbol = "$" + sym;
                    msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='" + librarySymbol + "')";
                    if (isExportedByForceFilesystem(sym)) msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                    warnOnce(msg);
                    return undefined;
                }
            });
            // Any symbol that is not included from the JS libary is also (by definition)
            // not exported on the Module object.
            unexportedRuntimeSymbol(sym);
        }
        function unexportedRuntimeSymbol(sym) {
            if (!Object.getOwnPropertyDescriptor(Module, sym)) Object.defineProperty(Module, sym, {
                configurable: true,
                get () {
                    var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)";
                    if (isExportedByForceFilesystem(sym)) msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                    abort(msg);
                }
            });
        }
        // Used by XXXXX_DEBUG settings to output debug messages.
        function dbg(text) {
            // TODO(sbc): Make this configurable somehow.  Its not always convenient for
            // logging to show up as warnings.
            console.warn.apply(console, arguments);
        }
        // end include: runtime_debug.js
        // === Body ===
        // end include: preamble.js
        /** @constructor */ function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
        }
        var callRuntimeCallbacks = (callbacks)=>{
            while(callbacks.length > 0)// Pass the module as the first argument.
            callbacks.shift()(Module);
        };
        /**
     * @param {number} ptr
     * @param {string} type
     */ function getValue(ptr, type = "i8") {
            if (type.endsWith("*")) type = "*";
            switch(type){
                case "i1":
                    return HEAP8[ptr >> 0];
                case "i8":
                    return HEAP8[ptr >> 0];
                case "i16":
                    return HEAP16[ptr >> 1];
                case "i32":
                    return HEAP32[ptr >> 2];
                case "i64":
                    abort("to do getValue(i64) use WASM_BIGINT");
                case "float":
                    return HEAPF32[ptr >> 2];
                case "double":
                    return HEAPF64[ptr >> 3];
                case "*":
                    return HEAPU32[ptr >> 2];
                default:
                    abort(`invalid type for getValue: ${type}`);
            }
        }
        var ptrToString = (ptr)=>{
            assert(typeof ptr === "number");
            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
            ptr >>>= 0;
            return "0x" + ptr.toString(16).padStart(8, "0");
        };
        /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */ function setValue(ptr, value, type = "i8") {
            if (type.endsWith("*")) type = "*";
            switch(type){
                case "i1":
                    HEAP8[ptr >> 0] = value;
                    break;
                case "i8":
                    HEAP8[ptr >> 0] = value;
                    break;
                case "i16":
                    HEAP16[ptr >> 1] = value;
                    break;
                case "i32":
                    HEAP32[ptr >> 2] = value;
                    break;
                case "i64":
                    abort("to do setValue(i64) use WASM_BIGINT");
                case "float":
                    HEAPF32[ptr >> 2] = value;
                    break;
                case "double":
                    HEAPF64[ptr >> 3] = value;
                    break;
                case "*":
                    HEAPU32[ptr >> 2] = value;
                    break;
                default:
                    abort(`invalid type for setValue: ${type}`);
            }
        }
        var warnOnce = (text)=>{
            if (!warnOnce.shown) warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
                warnOnce.shown[text] = 1;
                err(text);
            }
        };
        var _emscripten_memcpy_big = (dest, src, num)=>HEAPU8.copyWithin(dest, src, src + num);
        var getHeapMax = ()=>HEAPU8.length;
        var abortOnCannotGrowMemory = (requestedSize)=>{
            abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);
        };
        var _emscripten_resize_heap = (requestedSize)=>{
            var oldSize = HEAPU8.length;
            // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
            requestedSize >>>= 0;
            abortOnCannotGrowMemory(requestedSize);
        };
        var getCFunc = (ident)=>{
            var func = Module["_" + ident]; // closure exported function
            assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
            return func;
        };
        var writeArrayToMemory = (array, buffer)=>{
            assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
            HEAP8.set(array, buffer);
        };
        var lengthBytesUTF8 = (str)=>{
            var len = 0;
            for(var i = 0; i < str.length; ++i){
                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                // unit, not a Unicode code point of the character! So decode
                // UTF16->UTF32->UTF8.
                // See http://unicode.org/faq/utf_bom.html#utf16-3
                var c = str.charCodeAt(i); // possibly a lead surrogate
                if (c <= 0x7f) len++;
                else if (c <= 0x7ff) len += 2;
                else if (c >= 0xd800 && c <= 0xdfff) {
                    len += 4;
                    ++i;
                } else len += 3;
            }
            return len;
        };
        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{
            assert(typeof str === "string");
            // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
            // undefined and false each don't write out any bytes.
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
            for(var i = 0; i < str.length; ++i){
                // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
                // unit, not a Unicode code point of the character! So decode
                // UTF16->UTF32->UTF8.
                // See http://unicode.org/faq/utf_bom.html#utf16-3
                // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
                // and https://www.ietf.org/rfc/rfc2279.txt
                // and https://tools.ietf.org/html/rfc3629
                var u = str.charCodeAt(i); // possibly a lead surrogate
                if (u >= 0xd800 && u <= 0xdfff) {
                    var u1 = str.charCodeAt(++i);
                    u = 0x10000 + ((u & 0x3ff) << 10) | u1 & 0x3ff;
                }
                if (u <= 0x7f) {
                    if (outIdx >= endIdx) break;
                    heap[outIdx++] = u;
                } else if (u <= 0x7ff) {
                    if (outIdx + 1 >= endIdx) break;
                    heap[outIdx++] = 0xc0 | u >> 6;
                    heap[outIdx++] = 0x80 | u & 63;
                } else if (u <= 0xffff) {
                    if (outIdx + 2 >= endIdx) break;
                    heap[outIdx++] = 0xe0 | u >> 12;
                    heap[outIdx++] = 0x80 | u >> 6 & 63;
                    heap[outIdx++] = 0x80 | u & 63;
                } else {
                    if (outIdx + 3 >= endIdx) break;
                    if (u > 0x10ffff) warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
                    heap[outIdx++] = 0xf0 | u >> 18;
                    heap[outIdx++] = 0x80 | u >> 12 & 63;
                    heap[outIdx++] = 0x80 | u >> 6 & 63;
                    heap[outIdx++] = 0x80 | u & 63;
                }
            }
            // Null-terminate the pointer to the buffer.
            heap[outIdx] = 0;
            return outIdx - startIdx;
        };
        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>{
            assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        };
        var stringToUTF8OnStack = (str)=>{
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8(str, ret, size);
            return ret;
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;
        /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */ var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead)=>{
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            // TextDecoder needs to know the byte length in advance, it doesn't stop on
            // null terminator by itself.  Also, use the length info to avoid running tiny
            // strings through TextDecoder, since .subarray() allocates garbage.
            // (As a tiny code save trick, compare endPtr against endIdx using a negation,
            // so that undefined means Infinity)
            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;
            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            var str = "";
            // If building with TextDecoder, we have already computed the string length
            // above, so test loop end condition against that
            while(idx < endPtr){
                // For UTF8 byte structure, see:
                // http://en.wikipedia.org/wiki/UTF-8#Description
                // https://www.ietf.org/rfc/rfc2279.txt
                // https://tools.ietf.org/html/rfc3629
                var u0 = heapOrArray[idx++];
                if (!(u0 & 0x80)) {
                    str += String.fromCharCode(u0);
                    continue;
                }
                var u1 = heapOrArray[idx++] & 63;
                if ((u0 & 0xe0) == 0xc0) {
                    str += String.fromCharCode((u0 & 31) << 6 | u1);
                    continue;
                }
                var u2 = heapOrArray[idx++] & 63;
                if ((u0 & 0xf0) == 0xe0) u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                else {
                    if ((u0 & 0xf8) != 0xf0) warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
                }
                if (u0 < 0x10000) str += String.fromCharCode(u0);
                else {
                    var ch = u0 - 0x10000;
                    str += String.fromCharCode(0xd800 | ch >> 10, 0xdc00 | ch & 0x3ff);
                }
            }
            return str;
        };
        /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */ var UTF8ToString = (ptr, maxBytesToRead)=>{
            assert(typeof ptr == "number");
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        };
        /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */ var ccall = (ident, returnType, argTypes, args, opts)=>{
            // For fast lookup of conversion functions
            var toC = {
                string: (str)=>{
                    var ret = 0;
                    if (str !== null && str !== undefined && str !== 0) // null string
                    // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
                    ret = stringToUTF8OnStack(str);
                    return ret;
                },
                array: (arr)=>{
                    var ret = stackAlloc(arr.length);
                    writeArrayToMemory(arr, ret);
                    return ret;
                }
            };
            function convertReturnValue(ret) {
                if (returnType === "string") return UTF8ToString(ret);
                if (returnType === "boolean") return Boolean(ret);
                return ret;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            assert(returnType !== "array", 'Return type should not be "array".');
            if (args) for(var i = 0; i < args.length; i++){
                var converter = toC[argTypes[i]];
                if (converter) {
                    if (stack === 0) stack = stackSave();
                    cArgs[i] = converter(args[i]);
                } else cArgs[i] = args[i];
            }
            var ret = func.apply(null, cArgs);
            function onDone(ret) {
                if (stack !== 0) stackRestore(stack);
                return convertReturnValue(ret);
            }
            ret = onDone(ret);
            return ret;
        };
        /**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */ var cwrap = (ident, returnType, argTypes, opts)=>{
            return function() {
                return ccall(ident, returnType, argTypes, arguments, opts);
            };
        };
        var stringToNewUTF8 = (str)=>{
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret) stringToUTF8(str, ret, size);
            return ret;
        };
        var uleb128Encode = (n, target)=>{
            assert(n < 16384);
            if (n < 128) target.push(n);
            else target.push(n % 128 | 128, n >> 7);
        };
        var sigToWasmTypes = (sig)=>{
            assert(!sig.includes("j"), "i64 not permitted in function signatures when WASM_BIGINT is disabled");
            var typeNames = {
                i: "i32",
                j: "i64",
                f: "f32",
                d: "f64",
                p: "i32"
            };
            var type = {
                parameters: [],
                results: sig[0] == "v" ? [] : [
                    typeNames[sig[0]]
                ]
            };
            for(var i = 1; i < sig.length; ++i){
                assert(sig[i] in typeNames, "invalid signature char: " + sig[i]);
                type.parameters.push(typeNames[sig[i]]);
            }
            return type;
        };
        var generateFuncType = (sig, target)=>{
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = {
                i: 0x7f,
                p: 0x7f,
                j: 0x7e,
                f: 0x7d,
                d: 0x7c
            };
            // Parameters, length + signatures
            target.push(0x60 /* form: func */ );
            uleb128Encode(sigParam.length, target);
            for(var i = 0; i < sigParam.length; ++i){
                assert(sigParam[i] in typeCodes, "invalid signature char: " + sigParam[i]);
                target.push(typeCodes[sigParam[i]]);
            }
            // Return values, length + signatures
            // With no multi-return in MVP, either 0 (void) or 1 (anything else)
            if (sigRet == "v") target.push(0x00);
            else target.push(0x01, typeCodes[sigRet]);
        };
        var convertJsFunctionToWasm = (func, sig)=>{
            assert(!sig.includes("j"), "i64 not permitted in function signatures when WASM_BIGINT is disabled");
            // If the type reflection proposal is available, use the new
            // "WebAssembly.Function" constructor.
            // Otherwise, construct a minimal wasm module importing the JS function and
            // re-exporting it.
            if (typeof WebAssembly.Function == "function") return new WebAssembly.Function(sigToWasmTypes(sig), func);
            // The module is static, with the exception of the type section, which is
            // generated based on the signature passed in.
            var typeSectionBody = [
                0x01
            ];
            generateFuncType(sig, typeSectionBody);
            // Rest of the module is static
            var bytes = [
                0x00,
                0x61,
                0x73,
                0x6d,
                0x01,
                0x00,
                0x00,
                0x00,
                0x01
            ];
            // Write the overall length of the type section followed by the body
            uleb128Encode(typeSectionBody.length, bytes);
            bytes.push.apply(bytes, typeSectionBody);
            // The rest of the module is static
            bytes.push(0x02, 0x07, // (import "e" "f" (func 0 (type 0)))
            0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00, 0x07, 0x05, // (export "f" (func 0 (type 0)))
            0x01, 0x01, 0x66, 0x00, 0x00);
            // We can compile this wasm module synchronously because it is very small.
            // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
            var module1 = new WebAssembly.Module(new Uint8Array(bytes));
            var instance = new WebAssembly.Instance(module1, {
                e: {
                    f: func
                }
            });
            var wrappedFunc = instance.exports["f"];
            return wrappedFunc;
        };
        var wasmTableMirror = [];
        var getWasmTableEntry = (funcPtr)=>{
            var func = wasmTableMirror[funcPtr];
            if (!func) {
                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
            }
            assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
            return func;
        };
        var updateTableMap = (offset, count)=>{
            if (functionsInTableMap) for(var i = offset; i < offset + count; i++){
                var item = getWasmTableEntry(i);
                // Ignore null values.
                if (item) functionsInTableMap.set(item, i);
            }
        };
        var functionsInTableMap = undefined;
        var getFunctionAddress = (func)=>{
            // First, create the map if this is the first use.
            if (!functionsInTableMap) {
                functionsInTableMap = new WeakMap();
                updateTableMap(0, wasmTable.length);
            }
            return functionsInTableMap.get(func) || 0;
        };
        var freeTableIndexes = [];
        var getEmptyTableSlot = ()=>{
            // Reuse a free index if there is one, otherwise grow.
            if (freeTableIndexes.length) return freeTableIndexes.pop();
            // Grow the table
            try {
                wasmTable.grow(1);
            } catch (err) {
                if (!(err instanceof RangeError)) throw err;
                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
        };
        var setWasmTableEntry = (idx, func)=>{
            wasmTable.set(idx, func);
            // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overriden to return wrapped
            // functions so we need to call it here to retrieve the potential wrapper correctly
            // instead of just storing 'func' directly into wasmTableMirror
            wasmTableMirror[idx] = wasmTable.get(idx);
        };
        /** @param {string=} sig */ var addFunction = (func, sig)=>{
            assert(typeof func != "undefined");
            // Check if the function is already in the table, to ensure each function
            // gets a unique index.
            var rtn = getFunctionAddress(func);
            if (rtn) return rtn;
            // It's not in the table, add it now.
            var ret = getEmptyTableSlot();
            // Set the new value.
            try {
                // Attempting to call this with JS function will cause of table.set() to fail
                setWasmTableEntry(ret, func);
            } catch (err) {
                if (!(err instanceof TypeError)) throw err;
                assert(typeof sig != "undefined", "Missing signature argument to addFunction: " + func);
                var wrapped = convertJsFunctionToWasm(func, sig);
                setWasmTableEntry(ret, wrapped);
            }
            functionsInTableMap.set(func, ret);
            return ret;
        };
        function checkIncomingModuleAPI() {
            ignoredModuleProp("fetchSettings");
        }
        var wasmImports = {
            emscripten_memcpy_big: _emscripten_memcpy_big,
            emscripten_resize_heap: _emscripten_resize_heap
        };
        var wasmExports = createWasm();
        var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
        var ___errno_location = createExportWrapper("__errno_location");
        var _abs = Module["_abs"] = createExportWrapper("abs");
        var _atof = Module["_atof"] = createExportWrapper("atof");
        var _atoi = Module["_atoi"] = createExportWrapper("atoi");
        var _bsearch = Module["_bsearch"] = createExportWrapper("bsearch");
        var _fflush = Module["_fflush"] = createExportWrapper("fflush");
        var _labs = Module["_labs"] = createExportWrapper("labs");
        var _qsort = Module["_qsort"] = createExportWrapper("qsort");
        var _srand = Module["_srand"] = createExportWrapper("srand");
        var _rand = Module["_rand"] = createExportWrapper("rand");
        var _malloc = Module["_malloc"] = createExportWrapper("malloc");
        var _free = Module["_free"] = createExportWrapper("free");
        var _emscripten_stack_init = ()=>(_emscripten_stack_init = wasmExports["emscripten_stack_init"])();
        var _emscripten_stack_get_free = ()=>(_emscripten_stack_get_free = wasmExports["emscripten_stack_get_free"])();
        var _emscripten_stack_get_base = ()=>(_emscripten_stack_get_base = wasmExports["emscripten_stack_get_base"])();
        var _emscripten_stack_get_end = ()=>(_emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"])();
        var stackSave = createExportWrapper("stackSave");
        var stackRestore = createExportWrapper("stackRestore");
        var stackAlloc = createExportWrapper("stackAlloc");
        var _emscripten_stack_get_current = ()=>(_emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"])();
        // include: postamble.js
        // === Auto-generated postamble setup entry stuff ===
        // include: base64Utils.js
        // Converts a string of base64 into a byte array.
        // Throws error on invalid input.
        function intArrayFromBase64(s) {
            try {
                var decoded = atob(s);
                var bytes = new Uint8Array(decoded.length);
                for(var i = 0; i < decoded.length; ++i)bytes[i] = decoded.charCodeAt(i);
                return bytes;
            } catch (_) {
                throw new Error("Converting base64 string to bytes failed.");
            }
        }
        // If filename is a base64 data URI, parses and returns data (Buffer on node,
        // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
        function tryParseAsDataURI(filename) {
            if (!isDataURI(filename)) return;
            return intArrayFromBase64(filename.slice(dataURIPrefix.length));
        }
        // end include: base64Utils.js
        Module["wasmMemory"] = wasmMemory;
        Module["ccall"] = ccall;
        Module["cwrap"] = cwrap;
        Module["addFunction"] = addFunction;
        Module["stringToNewUTF8"] = stringToNewUTF8;
        var missingLibrarySymbols = [
            "writeI53ToI64",
            "writeI53ToI64Clamped",
            "writeI53ToI64Signaling",
            "writeI53ToU64Clamped",
            "writeI53ToU64Signaling",
            "readI53FromI64",
            "readI53FromU64",
            "convertI32PairToI53",
            "convertI32PairToI53Checked",
            "convertU32PairToI53",
            "zeroMemory",
            "exitJS",
            "growMemory",
            "isLeapYear",
            "ydayFromDate",
            "arraySum",
            "addDays",
            "setErrNo",
            "inetPton4",
            "inetNtop4",
            "inetPton6",
            "inetNtop6",
            "readSockaddr",
            "writeSockaddr",
            "getHostByName",
            "initRandomFill",
            "randomFill",
            "getCallstack",
            "emscriptenLog",
            "convertPCtoSourceLocation",
            "readEmAsmArgs",
            "jstoi_q",
            "jstoi_s",
            "getExecutableName",
            "listenOnce",
            "autoResumeAudioContext",
            "dynCallLegacy",
            "getDynCaller",
            "dynCall",
            "handleException",
            "runtimeKeepalivePush",
            "runtimeKeepalivePop",
            "callUserCallback",
            "maybeExit",
            "safeSetTimeout",
            "asmjsMangle",
            "asyncLoad",
            "alignMemory",
            "mmapAlloc",
            "handleAllocatorInit",
            "HandleAllocator",
            "getNativeTypeSize",
            "STACK_SIZE",
            "STACK_ALIGN",
            "POINTER_SIZE",
            "ASSERTIONS",
            "removeFunction",
            "reallyNegative",
            "unSign",
            "strLen",
            "reSign",
            "formatString",
            "intArrayFromString",
            "intArrayToString",
            "AsciiToString",
            "stringToAscii",
            "UTF16ToString",
            "stringToUTF16",
            "lengthBytesUTF16",
            "UTF32ToString",
            "stringToUTF32",
            "lengthBytesUTF32",
            "registerKeyEventCallback",
            "maybeCStringToJsString",
            "findEventTarget",
            "findCanvasEventTarget",
            "getBoundingClientRect",
            "fillMouseEventData",
            "registerMouseEventCallback",
            "registerWheelEventCallback",
            "registerUiEventCallback",
            "registerFocusEventCallback",
            "fillDeviceOrientationEventData",
            "registerDeviceOrientationEventCallback",
            "fillDeviceMotionEventData",
            "registerDeviceMotionEventCallback",
            "screenOrientation",
            "fillOrientationChangeEventData",
            "registerOrientationChangeEventCallback",
            "fillFullscreenChangeEventData",
            "registerFullscreenChangeEventCallback",
            "JSEvents_requestFullscreen",
            "JSEvents_resizeCanvasForFullscreen",
            "registerRestoreOldStyle",
            "hideEverythingExceptGivenElement",
            "restoreHiddenElements",
            "setLetterbox",
            "softFullscreenResizeWebGLRenderTarget",
            "doRequestFullscreen",
            "fillPointerlockChangeEventData",
            "registerPointerlockChangeEventCallback",
            "registerPointerlockErrorEventCallback",
            "requestPointerLock",
            "fillVisibilityChangeEventData",
            "registerVisibilityChangeEventCallback",
            "registerTouchEventCallback",
            "fillGamepadEventData",
            "registerGamepadEventCallback",
            "registerBeforeUnloadEventCallback",
            "fillBatteryEventData",
            "battery",
            "registerBatteryEventCallback",
            "setCanvasElementSize",
            "getCanvasElementSize",
            "demangle",
            "demangleAll",
            "jsStackTrace",
            "stackTrace",
            "getEnvStrings",
            "checkWasiClock",
            "flush_NO_FILESYSTEM",
            "wasiRightsToMuslOFlags",
            "wasiOFlagsToMuslOFlags",
            "createDyncallWrapper",
            "setImmediateWrapped",
            "clearImmediateWrapped",
            "polyfillSetImmediate",
            "getPromise",
            "makePromise",
            "idsToPromises",
            "makePromiseCallback",
            "ExceptionInfo",
            "findMatchingCatch",
            "setMainLoop",
            "getSocketFromFD",
            "getSocketAddress",
            "FS_createPreloadedFile",
            "FS_modeStringToFlags",
            "FS_getMode",
            "FS_stdin_getChar",
            "_setNetworkCallback",
            "heapObjectForWebGLType",
            "heapAccessShiftForWebGLHeap",
            "webgl_enable_ANGLE_instanced_arrays",
            "webgl_enable_OES_vertex_array_object",
            "webgl_enable_WEBGL_draw_buffers",
            "webgl_enable_WEBGL_multi_draw",
            "emscriptenWebGLGet",
            "computeUnpackAlignedImageSize",
            "colorChannelsInGlTextureFormat",
            "emscriptenWebGLGetTexPixelData",
            "__glGenObject",
            "emscriptenWebGLGetUniform",
            "webglGetUniformLocation",
            "webglPrepareUniformLocationsBeforeFirstUse",
            "webglGetLeftBracePos",
            "emscriptenWebGLGetVertexAttrib",
            "__glGetActiveAttribOrUniform",
            "writeGLArray",
            "registerWebGlEventCallback",
            "runAndAbortIfError",
            "SDL_unicode",
            "SDL_ttfContext",
            "SDL_audio",
            "GLFW_Window",
            "ALLOC_NORMAL",
            "ALLOC_STACK",
            "allocate",
            "writeStringToMemory",
            "writeAsciiToMemory"
        ];
        missingLibrarySymbols.forEach(missingLibrarySymbol);
        var unexportedSymbols = [
            "run",
            "addOnPreRun",
            "addOnInit",
            "addOnPreMain",
            "addOnExit",
            "addOnPostRun",
            "addRunDependency",
            "removeRunDependency",
            "FS_createFolder",
            "FS_createPath",
            "FS_createDataFile",
            "FS_createLazyFile",
            "FS_createLink",
            "FS_createDevice",
            "FS_readFile",
            "FS_unlink",
            "out",
            "err",
            "callMain",
            "abort",
            "keepRuntimeAlive",
            "wasmTable",
            "wasmExports",
            "stackAlloc",
            "stackSave",
            "stackRestore",
            "getTempRet0",
            "setTempRet0",
            "writeStackCookie",
            "checkStackCookie",
            "intArrayFromBase64",
            "tryParseAsDataURI",
            "ptrToString",
            "getHeapMax",
            "abortOnCannotGrowMemory",
            "ENV",
            "MONTH_DAYS_REGULAR",
            "MONTH_DAYS_LEAP",
            "MONTH_DAYS_REGULAR_CUMULATIVE",
            "MONTH_DAYS_LEAP_CUMULATIVE",
            "ERRNO_CODES",
            "ERRNO_MESSAGES",
            "DNS",
            "Protocols",
            "Sockets",
            "timers",
            "warnOnce",
            "UNWIND_CACHE",
            "readEmAsmArgsArray",
            "getCFunc",
            "uleb128Encode",
            "sigToWasmTypes",
            "generateFuncType",
            "convertJsFunctionToWasm",
            "freeTableIndexes",
            "functionsInTableMap",
            "getEmptyTableSlot",
            "updateTableMap",
            "getFunctionAddress",
            "setValue",
            "getValue",
            "PATH",
            "PATH_FS",
            "UTF8Decoder",
            "UTF8ArrayToString",
            "UTF8ToString",
            "stringToUTF8Array",
            "stringToUTF8",
            "lengthBytesUTF8",
            "UTF16Decoder",
            "stringToUTF8OnStack",
            "writeArrayToMemory",
            "JSEvents",
            "specialHTMLTargets",
            "currentFullscreenStrategy",
            "restoreOldWindowedStyle",
            "ExitStatus",
            "promiseMap",
            "uncaughtExceptionCount",
            "exceptionLast",
            "exceptionCaught",
            "Browser",
            "wget",
            "SYSCALLS",
            "preloadPlugins",
            "FS_stdin_getChar_buffer",
            "FS",
            "MEMFS",
            "TTY",
            "PIPEFS",
            "SOCKFS",
            "tempFixedLengthArray",
            "miniTempWebGLFloatBuffers",
            "miniTempWebGLIntBuffers",
            "GL",
            "emscripten_webgl_power_preferences",
            "AL",
            "GLUT",
            "EGL",
            "GLEW",
            "IDBStore",
            "SDL",
            "SDL_gfx",
            "GLFW",
            "allocateUTF8",
            "allocateUTF8OnStack"
        ];
        unexportedSymbols.forEach(unexportedRuntimeSymbol);
        var calledRun;
        dependenciesFulfilled = function runCaller() {
            // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
        };
        function stackCheckInit() {
            // This is normally called automatically during __wasm_call_ctors but need to
            // get these values before even running any of the ctors so we call it redundantly
            // here.
            _emscripten_stack_init();
            // TODO(sbc): Move writeStackCookie to native to to avoid this.
            writeStackCookie();
        }
        function run() {
            if (runDependencies > 0) return;
            stackCheckInit();
            preRun();
            // a preRun added a dependency, run will be called later
            if (runDependencies > 0) return;
            function doRun() {
                // run may have just been called through dependencies being fulfilled just in this very frame,
                // or while the async setStatus time below was happening
                if (calledRun) return;
                calledRun = true;
                Module["calledRun"] = true;
                if (ABORT) return;
                initRuntime();
                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
                assert(!Module["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
                postRun();
            }
            if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function() {
                    setTimeout(function() {
                        Module["setStatus"]("");
                    }, 1);
                    doRun();
                }, 1);
            } else doRun();
            checkStackCookie();
        }
        function checkUnflushedContent() {
            // Compiler settings do not allow exiting the runtime, so flushing
            // the streams is not possible. but in ASSERTIONS mode we check
            // if there was something to flush, and if so tell the user they
            // should request that the runtime be exitable.
            // Normally we would not even include flush() at all, but in ASSERTIONS
            // builds we do so just for this check, and here we see if there is any
            // content to flush, that is, we check if there would have been
            // something a non-ASSERTIONS build would have not seen.
            // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
            // mode (which has its own special function for this; otherwise, all
            // the code is inside libc)
            var oldOut = out;
            var oldErr = err;
            var has = false;
            out = err = (x)=>{
                has = true;
            };
            try {
                // it doesn't matter if it fails
                _fflush(0);
            } catch (e) {}
            out = oldOut;
            err = oldErr;
            if (has) {
                warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.");
                warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");
            }
        }
        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function") Module["preInit"] = [
                Module["preInit"]
            ];
            while(Module["preInit"].length > 0)Module["preInit"].pop()();
        }
        run();
        // end include: postamble.js
        return moduleArg.ready;
    };
})();
$29a92bc69495d5cc$exports = $29a92bc69495d5cc$var$Module;





const $5f81b95dd4cda0c4$export$fdedc1bc2083472e = "utility";
class $5f81b95dd4cda0c4$export$5d03ec76d52e4a5d extends (0, $6cd02a3df715eddf$export$c3a9d7ff17e4f3ed) {
    constructor(memory, functionTable, config, sharedWasmGlobalVariables){
        super(memory, functionTable, config, sharedWasmGlobalVariables);
        // functions whose value is be filled later after this.instantiate() is called.
        this.stringToNewUTF8 = ()=>{};
        this.addFunction = ()=>{};
        this.malloc = ()=>{};
        this.free = ()=>{};
        this.atof = ()=>{};
        this.atoi = ()=>{};
        this.atol = ()=>{};
        this.abs = ()=>{};
        this.labs = ()=>{};
        this.rand = ()=>{};
        this.srand = ()=>{};
        this.qsort = ()=>{};
        this.heapAddress = this.sharedWasmGlobalVariables.heapPointer.value;
        this.moduleDeclaredStructs = [];
        this.instantiate = async ()=>{
            const utilityModule = await (0, (/*@__PURE__*/$parcel$interopDefault($29a92bc69495d5cc$exports)))();
            // need to set the jsFunctions of all moduleFunctions here
            this.stringToNewUTF8 = utilityModule.stringToNewUTF8;
            this.addFunction = utilityModule.addFunction;
            this.malloc = utilityModule._malloc;
            this.free = utilityModule._free;
            this.atof = utilityModule._atof;
            this.atoi = utilityModule._atoi;
            this.atol = utilityModule._atol;
            this.abs = utilityModule._abs;
            this.labs = utilityModule._labs;
            this.rand = utilityModule._rand;
            this.srand = utilityModule._srand;
            this.qsort = utilityModule._qsort;
            this.emscriptenMemory = utilityModule.wasmMemory;
        };
        this.moduleFunctions = {
            atof: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                isConst: true,
                                type: "primary",
                                primaryDataType: "signed char"
                            }
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "double"
                    }
                },
                jsFunction: (strAddress)=>{
                    const str = (0, $3ac97f2b8e0968e3$export$2edb4c5e685898c)(memory.buffer, strAddress);
                    const strPtr = this.stringToNewUTF8(str);
                    const floatVal = this.atof(strPtr);
                    this.free(strPtr);
                    return floatVal;
                }
            },
            atoi: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                isConst: true,
                                type: "primary",
                                primaryDataType: "signed char"
                            }
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed int"
                    }
                },
                jsFunction: (strAddress)=>{
                    const str = (0, $3ac97f2b8e0968e3$export$2edb4c5e685898c)(memory.buffer, strAddress);
                    const strPtr = this.stringToNewUTF8(str);
                    const intVal = this.atoi(strPtr);
                    this.free(strPtr);
                    return intVal;
                }
            },
            atol: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                isConst: true,
                                type: "primary",
                                primaryDataType: "signed char"
                            }
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed long"
                    }
                },
                jsFunction: (strAddress)=>{
                    const str = (0, $3ac97f2b8e0968e3$export$2edb4c5e685898c)(memory.buffer, strAddress);
                    const strPtr = this.stringToNewUTF8(str);
                    const intVal = this.atol(strPtr);
                    this.free(strPtr);
                    return intVal;
                }
            },
            abs: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed int"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed int"
                    }
                },
                jsFunction: (val)=>{
                    return this.abs(val);
                }
            },
            labs: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "signed long"
                        }
                    ],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed long"
                    }
                },
                jsFunction: (val)=>{
                    return this.labs(val);
                }
            },
            rand: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [],
                    returnType: {
                        type: "primary",
                        primaryDataType: "signed int"
                    }
                },
                jsFunction: ()=>{
                    return this.rand();
                }
            },
            srand: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "primary",
                            primaryDataType: "unsigned int"
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (val)=>{
                    this.srand(val);
                }
            },
            qsort: {
                parentImportedObject: $5f81b95dd4cda0c4$export$fdedc1bc2083472e,
                functionType: {
                    type: "function",
                    parameters: [
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "void"
                            }
                        },
                        {
                            type: "primary",
                            primaryDataType: (0, $cd849de488b21116$export$f089f2422e95b42b)
                        },
                        {
                            type: "primary",
                            primaryDataType: (0, $cd849de488b21116$export$f089f2422e95b42b)
                        },
                        {
                            type: "pointer",
                            pointeeType: {
                                type: "function",
                                parameters: [
                                    {
                                        type: "pointer",
                                        pointeeType: {
                                            type: "void"
                                        },
                                        isConst: true
                                    },
                                    {
                                        type: "pointer",
                                        pointeeType: {
                                            type: "void"
                                        },
                                        isConst: true
                                    }
                                ],
                                returnType: {
                                    type: "primary",
                                    primaryDataType: "signed int"
                                }
                            }
                        }
                    ],
                    returnType: {
                        type: "void"
                    }
                },
                jsFunction: (ptr, count, size, funcPtr)=>{
                    const sortFn = (a, b)=>{
                        // need to allocate and copy a and b pointer objects to our memory (they are pointers to emscripten memory)
                        const copiedAAddr = (0, $613cdf755255ca13$export$29e067376189ea75)({
                            memory: memory,
                            sharedWasmGlobalVariables: sharedWasmGlobalVariables,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks,
                            bytesRequested: size
                        });
                        const copiedBAddr = (0, $613cdf755255ca13$export$29e067376189ea75)({
                            memory: memory,
                            sharedWasmGlobalVariables: sharedWasmGlobalVariables,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks,
                            bytesRequested: size
                        });
                        const copiedABuff = new Uint8Array(this.memory.buffer, copiedAAddr, size);
                        const copiedBBuff = new Uint8Array(this.memory.buffer, copiedBAddr, size);
                        const origABuff = new Uint8Array(this.emscriptenMemory.buffer, a, size);
                        const origBBuff = new Uint8Array(this.emscriptenMemory.buffer, b, size);
                        for(let i = 0; i < size; ++i){
                            copiedABuff[i] = origABuff[i];
                            copiedBBuff[i] = origBBuff[i];
                        }
                        // a and b are pointers to objects in memory
                        const stackFrameArgs = [
                            {
                                value: BigInt(copiedAAddr),
                                type: "unsigned int"
                            },
                            {
                                value: BigInt(copiedBAddr),
                                type: "unsigned int"
                            }
                        ];
                        // call the function pointer
                        const result = (0, $c7e8373de86f19b2$export$2e2bcd8739ae039)(memory, functionTable, funcPtr, sharedWasmGlobalVariables, stackFrameArgs, [
                            "signed int"
                        ])[0];
                        (0, $613cdf755255ca13$export$1cbb47981abc8e99)({
                            address: copiedAAddr,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks
                        });
                        (0, $613cdf755255ca13$export$1cbb47981abc8e99)({
                            address: copiedBAddr,
                            freeList: this.freeList,
                            allocatedBlocks: this.allocatedBlocks
                        });
                        return result;
                    };
                    // create funcPtr for the emscripten compiled module - 2nd arg is the function siganture,
                    // see https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html
                    // section on "Calling JavaScript functions as function pointers from C"
                    const emscriptenFuncPtr = this.addFunction(sortFn, "iii");
                    const memSize = count * size;
                    // allocate space in emscripten module memory space
                    const copiedObjectAddress = this.malloc(memSize);
                    // copy contents from our memory space to the emscripten memory
                    const srcBuffer = new Uint8Array(this.memory.buffer, ptr, memSize);
                    const destBuffer = new Uint8Array(this.emscriptenMemory.buffer, copiedObjectAddress, memSize);
                    for(let i = 0; i < memSize; ++i)destBuffer[i] = srcBuffer[i];
                    // perform the sorting operation
                    this.qsort(copiedObjectAddress, count, size, emscriptenFuncPtr);
                    // copy sorted result back into our memory
                    for(let i = 0; i < memSize; ++i)srcBuffer[i] = destBuffer[i];
                    // free buffer from emscriptens memory
                    this.free(copiedObjectAddress);
                }
            }
        };
    }
}



const $d6c6ee2ce4472628$var$defaultModulesGlobalConfig = {
    printFunction: (str)=>console.log(str)
};
class $d6c6ee2ce4472628$export$2e2bcd8739ae039 {
    constructor(memory, functionTable, config){
        this.memory = memory ?? new WebAssembly.Memory({
            initial: 0
        });
        this.functionTable = functionTable ?? new WebAssembly.Table({
            element: "anyfunc",
            initial: 0
        });
        this.config = config ? {
            ...config
        } : $d6c6ee2ce4472628$var$defaultModulesGlobalConfig;
        this.sharedWasmGlobalVariables = {
            stackPointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, 0),
            basePointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, 0),
            heapPointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, 0)
        };
        this.modules = {
            [(0, $440955131cb280ee$export$ebb1fb55387f71a9)]: new (0, $440955131cb280ee$export$427d0ee15bade0f5)(this.memory, this.functionTable, this.config, this.sharedWasmGlobalVariables),
            [(0, $bfc7d64527c49a6c$export$ce74ff4d218f3ff2)]: new (0, $bfc7d64527c49a6c$export$38ad991a41a6bc0d)(this.memory, this.functionTable, this.config, this.sharedWasmGlobalVariables),
            [(0, $86d8fc41b01ee307$export$4c861b99fa6eb6d1)]: new (0, $86d8fc41b01ee307$export$e43f9f8d6b56002e)(this.memory, this.functionTable, this.config, this.sharedWasmGlobalVariables),
            [(0, $5f81b95dd4cda0c4$export$fdedc1bc2083472e)]: new (0, $5f81b95dd4cda0c4$export$5d03ec76d52e4a5d)(this.memory, this.functionTable, this.config, this.sharedWasmGlobalVariables)
        };
    }
    setStackPointerValue(value) {
        this.sharedWasmGlobalVariables.stackPointer.value = value;
    }
    setBasePointerValue(value) {
        this.sharedWasmGlobalVariables.basePointer.value = value;
    }
    setHeapPointerValue(value) {
        this.sharedWasmGlobalVariables.heapPointer.value = value;
    }
    setMemory(numberOfPages) {
        this.memory = new WebAssembly.Memory({
            initial: numberOfPages
        });
    }
    /**
   * Returns the object that can be used as argument to Webassembly.instantiate.
   * @param importedModules the names of all modules that are being imported and used in a particular compiled wasm output file.
   */ async createWasmImportsObject(importedModules) {
        const imports = {
            js: {
                mem: this.memory,
                function_table: this.functionTable,
                sp: this.sharedWasmGlobalVariables.stackPointer,
                hp: this.sharedWasmGlobalVariables.heapPointer,
                bp: this.sharedWasmGlobalVariables.basePointer
            }
        };
        for (const moduleName of importedModules){
            const module = this.modules[moduleName];
            const moduleImportObject = {};
            if (typeof this.modules[moduleName].instantiate !== "undefined") await this.modules[moduleName].instantiate();
            Object.keys(this.modules[moduleName].moduleFunctions).map((moduleFunctionName)=>{
                moduleImportObject[moduleFunctionName] = module.moduleFunctions[moduleFunctionName].jsFunction;
            });
            imports[moduleName] = moduleImportObject;
        }
        return imports;
    }
}


/**
 * Compiler for C to webassembly
 */ 
var $270755782b82f804$exports = {};
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
"use strict";
function $270755782b82f804$var$peg$subclass(child, parent) {
    function C() {
        this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
}
function $270755782b82f804$var$peg$SyntaxError(message, expected, found, location) {
    var self = Error.call(this, message);
    // istanbul ignore next Check is a necessary evil to support older environments
    if (Object.setPrototypeOf) Object.setPrototypeOf(self, $270755782b82f804$var$peg$SyntaxError.prototype);
    self.expected = expected;
    self.found = found;
    self.location = location;
    self.name = "SyntaxError";
    return self;
}
$270755782b82f804$var$peg$subclass($270755782b82f804$var$peg$SyntaxError, Error);
function $270755782b82f804$var$peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
$270755782b82f804$var$peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
        var src = null;
        var k;
        for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
            var e = this.location.end;
            var filler = $270755782b82f804$var$peg$padEnd("", offset_s.line.toString().length, " ");
            var line = src[s.line - 1];
            var last = s.line === e.line ? e.column : line.length + 1;
            var hatLen = last - s.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + $270755782b82f804$var$peg$padEnd("", s.column - 1, " ") + $270755782b82f804$var$peg$padEnd("", hatLen, "^");
        } else str += "\n at " + loc;
    }
    return str;
};
$270755782b82f804$var$peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
            return "any character";
        },
        end: function() {
            return "end of input";
        },
        other: function(expectation) {
            return expectation.description;
        }
    };
    function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
            for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
            }
            descriptions.length = j;
        }
        switch(descriptions.length){
            case 1:
                return descriptions[0];
            case 2:
                return descriptions[0] + " or " + descriptions[1];
            default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
    }
    function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function $270755782b82f804$var$peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$source = options.grammarSource;
    var peg$startRuleFunctions = {
        program: peg$parseprogram
    };
    var peg$startRuleFunction = peg$parseprogram;
    var peg$c0 = "\\\n";
    var peg$c1 = "//";
    var peg$c2 = "/*";
    var peg$c3 = '"';
    var peg$c4 = "\n";
    var peg$c5 = "*/";
    var peg$c6 = '\\"';
    var peg$r0 = /^[ \t\n\v\f]/;
    var peg$e0 = peg$literalExpectation("\\\n", false);
    var peg$e1 = peg$literalExpectation("//", false);
    var peg$e2 = peg$literalExpectation("/*", false);
    var peg$e3 = peg$literalExpectation('"', false);
    var peg$e4 = peg$anyExpectation();
    var peg$e5 = peg$literalExpectation("\n", false);
    var peg$e6 = peg$literalExpectation("*/", false);
    var peg$e7 = peg$literalExpectation('\\"', false);
    var peg$e8 = peg$classExpectation([
        " ",
        "	",
        "\n",
        "\v",
        "\f"
    ], false, false);
    var peg$f0 = function(matches) {
        return matches.join("");
    };
    var peg$f1 = function(comment) {
        return " ".repeat(comment.length);
    };
    var peg$f2 = function() {
        thisParser.falseNewlinePositions.push(location().start.offset);
        return "";
    };
    var peg$f3 = function() {
        return "";
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$resultsCache = {};
    var peg$result;
    if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
        return peg$savedPos;
    }
    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos
        };
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
    }
    function peg$literalExpectation(text, ignoreCase) {
        return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        if (offset && peg$source && typeof peg$source.offset === "function") {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
        return new $270755782b82f804$var$peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new $270755782b82f804$var$peg$SyntaxError($270755782b82f804$var$peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parseprogram() {
        var s0, s1, s2;
        var key = peg$currPos * 8 + 0;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsepreprocess_match();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsepreprocess_match();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepreprocess_match() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 8 + 1;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsecomment();
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedouble_quoted_string();
            if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
            else s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c0) {
                    s1 = peg$c0;
                    peg$currPos += 2;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e0);
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f2();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = [];
                    s2 = peg$currPos;
                    s3 = peg$currPos;
                    peg$silentFails++;
                    if (input.substr(peg$currPos, 2) === peg$c1) {
                        s4 = peg$c1;
                        peg$currPos += 2;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e1);
                    }
                    peg$silentFails--;
                    if (s4 === peg$FAILED) s3 = undefined;
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$currPos;
                        peg$silentFails++;
                        if (input.substr(peg$currPos, 2) === peg$c2) {
                            s5 = peg$c2;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e2);
                        }
                        peg$silentFails--;
                        if (s5 === peg$FAILED) s4 = undefined;
                        else {
                            peg$currPos = s4;
                            s4 = peg$FAILED;
                        }
                        if (s4 !== peg$FAILED) {
                            s5 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 2) === peg$c0) {
                                s6 = peg$c0;
                                peg$currPos += 2;
                            } else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e0);
                            }
                            peg$silentFails--;
                            if (s6 === peg$FAILED) s5 = undefined;
                            else {
                                peg$currPos = s5;
                                s5 = peg$FAILED;
                            }
                            if (s5 !== peg$FAILED) {
                                s6 = peg$currPos;
                                peg$silentFails++;
                                if (input.charCodeAt(peg$currPos) === 34) {
                                    s7 = peg$c3;
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e3);
                                }
                                peg$silentFails--;
                                if (s7 === peg$FAILED) s6 = undefined;
                                else {
                                    peg$currPos = s6;
                                    s6 = peg$FAILED;
                                }
                                if (s6 !== peg$FAILED) {
                                    if (input.length > peg$currPos) {
                                        s7 = input.charAt(peg$currPos);
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e4);
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s3 = [
                                            s3,
                                            s4,
                                            s5,
                                            s6,
                                            s7
                                        ];
                                        s2 = s3;
                                    } else {
                                        peg$currPos = s2;
                                        s2 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                        s1.push(s2);
                        s2 = peg$currPos;
                        s3 = peg$currPos;
                        peg$silentFails++;
                        if (input.substr(peg$currPos, 2) === peg$c1) {
                            s4 = peg$c1;
                            peg$currPos += 2;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e1);
                        }
                        peg$silentFails--;
                        if (s4 === peg$FAILED) s3 = undefined;
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$currPos;
                            peg$silentFails++;
                            if (input.substr(peg$currPos, 2) === peg$c2) {
                                s5 = peg$c2;
                                peg$currPos += 2;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e2);
                            }
                            peg$silentFails--;
                            if (s5 === peg$FAILED) s4 = undefined;
                            else {
                                peg$currPos = s4;
                                s4 = peg$FAILED;
                            }
                            if (s4 !== peg$FAILED) {
                                s5 = peg$currPos;
                                peg$silentFails++;
                                if (input.substr(peg$currPos, 2) === peg$c0) {
                                    s6 = peg$c0;
                                    peg$currPos += 2;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e0);
                                }
                                peg$silentFails--;
                                if (s6 === peg$FAILED) s5 = undefined;
                                else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$currPos;
                                    peg$silentFails++;
                                    if (input.charCodeAt(peg$currPos) === 34) {
                                        s7 = peg$c3;
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e3);
                                    }
                                    peg$silentFails--;
                                    if (s7 === peg$FAILED) s6 = undefined;
                                    else {
                                        peg$currPos = s6;
                                        s6 = peg$FAILED;
                                    }
                                    if (s6 !== peg$FAILED) {
                                        if (input.length > peg$currPos) {
                                            s7 = input.charAt(peg$currPos);
                                            peg$currPos++;
                                        } else {
                                            s7 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e4);
                                        }
                                        if (s7 !== peg$FAILED) {
                                            s3 = [
                                                s3,
                                                s4,
                                                s5,
                                                s6,
                                                s7
                                            ];
                                            s2 = s3;
                                        } else {
                                            peg$currPos = s2;
                                            s2 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s2;
                                        s2 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s2;
                                    s2 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s2;
                                s2 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    }
                    else s1 = peg$FAILED;
                    if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
                    else s0 = s1;
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsecomment() {
        var s0;
        var key = peg$currPos * 8 + 2;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsesingle_line_comment();
        if (s0 === peg$FAILED) s0 = peg$parsemulti_line_comment();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsesingle_line_comment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 8 + 3;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 10) {
                s5 = peg$c4;
                peg$currPos++;
            } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e5);
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) s4 = undefined;
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e4);
                }
                if (s5 !== peg$FAILED) {
                    s4 = [
                        s4,
                        s5
                    ];
                    s3 = s4;
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 10) {
                    s5 = peg$c4;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e5);
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) s4 = undefined;
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e4);
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            s1 = [
                s1,
                s2
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsemulti_line_comment() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 8 + 4;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c2) {
            s1 = peg$c2;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e2);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 2) === peg$c5) {
                s5 = peg$c5;
                peg$currPos += 2;
            } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e6);
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) s4 = undefined;
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e4);
                }
                if (s5 !== peg$FAILED) {
                    s4 = [
                        s4,
                        s5
                    ];
                    s3 = s4;
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 2) === peg$c5) {
                    s5 = peg$c5;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e6);
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) s4 = undefined;
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                    if (input.length > peg$currPos) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e4);
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (input.substr(peg$currPos, 2) === peg$c5) {
                s3 = peg$c5;
                peg$currPos += 2;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e6);
            }
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedouble_quoted_string() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 8 + 5;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c3;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e3);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
                s5 = peg$c3;
                peg$currPos++;
            } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e3);
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) s4 = undefined;
            else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c6) {
                    s5 = peg$c6;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e7);
                }
                if (s5 === peg$FAILED) {
                    if (input.length > peg$currPos) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e4);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s4 = [
                        s4,
                        s5
                    ];
                    s3 = s4;
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 34) {
                    s5 = peg$c3;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e3);
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) s4 = undefined;
                else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c6) {
                        s5 = peg$c6;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e7);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.length > peg$currPos) {
                            s5 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e4);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c3;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e3);
            }
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsebackslash_newline() {
        var s0, s1;
        var key = peg$currPos * 8 + 6;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c0) {
            s1 = peg$c0;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e0);
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f3();
        }
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsewhitespace() {
        var s0, s1;
        var key = peg$currPos * 8 + 7;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e8);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$r0.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e8);
            }
        }
        else s0 = peg$FAILED;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    const thisParser = this;
    // positions of "\\\n" in the program
    thisParser.falseNewlinePositions = [];
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
$270755782b82f804$exports = {
    SyntaxError: $270755782b82f804$var$peg$SyntaxError,
    parse: $270755782b82f804$var$peg$parse
};


var $1470c0288d19cc19$exports = {};
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
"use strict";
function $1470c0288d19cc19$var$peg$subclass(child, parent) {
    function C() {
        this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
}
function $1470c0288d19cc19$var$peg$SyntaxError(message, expected, found, location) {
    var self = Error.call(this, message);
    // istanbul ignore next Check is a necessary evil to support older environments
    if (Object.setPrototypeOf) Object.setPrototypeOf(self, $1470c0288d19cc19$var$peg$SyntaxError.prototype);
    self.expected = expected;
    self.found = found;
    self.location = location;
    self.name = "SyntaxError";
    return self;
}
$1470c0288d19cc19$var$peg$subclass($1470c0288d19cc19$var$peg$SyntaxError, Error);
function $1470c0288d19cc19$var$peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
$1470c0288d19cc19$var$peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
        var src = null;
        var k;
        for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
            var e = this.location.end;
            var filler = $1470c0288d19cc19$var$peg$padEnd("", offset_s.line.toString().length, " ");
            var line = src[s.line - 1];
            var last = s.line === e.line ? e.column : line.length + 1;
            var hatLen = last - s.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + $1470c0288d19cc19$var$peg$padEnd("", s.column - 1, " ") + $1470c0288d19cc19$var$peg$padEnd("", hatLen, "^");
        } else str += "\n at " + loc;
    }
    return str;
};
$1470c0288d19cc19$var$peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
            return "any character";
        },
        end: function() {
            return "end of input";
        },
        other: function(expectation) {
            return expectation.description;
        }
    };
    function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
            for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
            }
            descriptions.length = j;
        }
        switch(descriptions.length){
            case 1:
                return descriptions[0];
            case 2:
                return descriptions[0] + " or " + descriptions[1];
            default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
    }
    function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function $1470c0288d19cc19$var$peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$source = options.grammarSource;
    var peg$startRuleFunctions = {
        program: peg$parseprogram
    };
    var peg$startRuleFunction = peg$parseprogram;
    var peg$c0 = "@";
    var peg$c1 = "#include <";
    var peg$c2 = ">";
    var peg$c3 = "_Static_assert";
    var peg$c4 = "_Thread_local";
    var peg$c5 = "_Imaginary";
    var peg$c6 = "_Noreturn";
    var peg$c7 = "continue";
    var peg$c8 = "register";
    var peg$c9 = "restrict";
    var peg$c10 = "unsigned";
    var peg$c11 = "volatile";
    var peg$c12 = "_Alignas";
    var peg$c13 = "_Alignof";
    var peg$c14 = "_Complex";
    var peg$c15 = "_Generic";
    var peg$c16 = "default";
    var peg$c17 = "typedef";
    var peg$c18 = "_Atomic";
    var peg$c19 = "extern";
    var peg$c20 = "inline";
    var peg$c21 = "double";
    var peg$c22 = "return";
    var peg$c23 = "signed";
    var peg$c24 = "sizeof";
    var peg$c25 = "static";
    var peg$c26 = "struct";
    var peg$c27 = "switch";
    var peg$c28 = "break";
    var peg$c29 = "float";
    var peg$c30 = "const";
    var peg$c31 = "short";
    var peg$c32 = "union";
    var peg$c33 = "while";
    var peg$c34 = "_Bool";
    var peg$c35 = "auto";
    var peg$c36 = "case";
    var peg$c37 = "char";
    var peg$c38 = "goto";
    var peg$c39 = "long";
    var peg$c40 = "else";
    var peg$c41 = "enum";
    var peg$c42 = "void";
    var peg$c43 = "for";
    var peg$c44 = "int";
    var peg$c45 = "if";
    var peg$c46 = "do";
    var peg$c47 = "0";
    var peg$c48 = "0x";
    var peg$c49 = "0X";
    var peg$c50 = "u";
    var peg$c51 = "U";
    var peg$c52 = "l";
    var peg$c53 = "L";
    var peg$c54 = "ll";
    var peg$c55 = "LL";
    var peg$c56 = ".";
    var peg$c57 = "e";
    var peg$c58 = "E";
    var peg$c59 = "+";
    var peg$c60 = "-";
    var peg$c61 = "'";
    var peg$c62 = "\\'";
    var peg$c63 = '\\"';
    var peg$c64 = "\\?";
    var peg$c65 = "\\\\";
    var peg$c66 = "\\a";
    var peg$c67 = "\\b";
    var peg$c68 = "\\f";
    var peg$c69 = "\\r";
    var peg$c70 = "\\n";
    var peg$c71 = "\\t";
    var peg$c72 = "\\v";
    var peg$c73 = "\\";
    var peg$c74 = "\\x";
    var peg$c75 = '"';
    var peg$c76 = "%:%:";
    var peg$c77 = "...";
    var peg$c78 = "<<=";
    var peg$c79 = ">>=";
    var peg$c80 = "++";
    var peg$c81 = "--";
    var peg$c82 = "+=";
    var peg$c83 = "-=";
    var peg$c84 = "*=";
    var peg$c85 = "/=";
    var peg$c86 = "%=";
    var peg$c87 = "&=";
    var peg$c88 = "^=";
    var peg$c89 = "|=";
    var peg$c90 = "==";
    var peg$c91 = "!=";
    var peg$c92 = "<=";
    var peg$c93 = ">=";
    var peg$c94 = ">>";
    var peg$c95 = "<<";
    var peg$c96 = "->";
    var peg$c97 = "&&";
    var peg$c98 = "||";
    var peg$c99 = "##";
    var peg$c100 = "%:";
    var peg$c101 = "<:";
    var peg$c102 = ":>";
    var peg$c103 = "<%";
    var peg$c104 = "%>";
    var peg$c105 = "[";
    var peg$c106 = "]";
    var peg$c107 = "(";
    var peg$c108 = ")";
    var peg$c109 = "{";
    var peg$c110 = "}";
    var peg$c111 = "&";
    var peg$c112 = "*";
    var peg$c113 = "~";
    var peg$c114 = "!";
    var peg$c115 = "/";
    var peg$c116 = "%";
    var peg$c117 = "<";
    var peg$c118 = "^";
    var peg$c119 = "|";
    var peg$c120 = "?";
    var peg$c121 = ":";
    var peg$c122 = ";";
    var peg$c123 = "=";
    var peg$c124 = ",";
    var peg$c125 = "#";
    var peg$r0 = /^[ \t\n\v\f]/;
    var peg$r1 = /^[a-z0-9!"#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
    var peg$r2 = /^[a-z_]/i;
    var peg$r3 = /^[a-z0-9_]/i;
    var peg$r4 = /^[1-9]/;
    var peg$r5 = /^[0-9]/;
    var peg$r6 = /^[0-7]/;
    var peg$r7 = /^[0-9A-F]/i;
    var peg$r8 = /^[fl]/i;
    var peg$r9 = /^[a-z0-9!'#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
    var peg$e0 = peg$otherExpectation("separator");
    var peg$e1 = peg$classExpectation([
        " ",
        "	",
        "\n",
        "\v",
        "\f"
    ], false, false);
    var peg$e2 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "!",
        '"',
        "#",
        "%",
        "&",
        "(",
        ")",
        "*",
        "+",
        [
            ",",
            "."
        ],
        "/",
        ":",
        " ",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "^",
        "_",
        "{",
        "|",
        "}",
        "~",
        "	",
        "\v",
        "\f"
    ], false, true);
    var peg$e3 = peg$literalExpectation("@", false);
    var peg$e4 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        "_"
    ], false, true);
    var peg$e5 = peg$literalExpectation("#include <", false);
    var peg$e6 = peg$literalExpectation(">", false);
    var peg$e7 = peg$literalExpectation("_Static_assert", false);
    var peg$e8 = peg$literalExpectation("_Thread_local", false);
    var peg$e9 = peg$literalExpectation("_Imaginary", false);
    var peg$e10 = peg$literalExpectation("_Noreturn", false);
    var peg$e11 = peg$literalExpectation("continue", false);
    var peg$e12 = peg$literalExpectation("register", false);
    var peg$e13 = peg$literalExpectation("restrict", false);
    var peg$e14 = peg$literalExpectation("unsigned", false);
    var peg$e15 = peg$literalExpectation("volatile", false);
    var peg$e16 = peg$literalExpectation("_Alignas", false);
    var peg$e17 = peg$literalExpectation("_Alignof", false);
    var peg$e18 = peg$literalExpectation("_Complex", false);
    var peg$e19 = peg$literalExpectation("_Generic", false);
    var peg$e20 = peg$literalExpectation("default", false);
    var peg$e21 = peg$literalExpectation("typedef", false);
    var peg$e22 = peg$literalExpectation("_Atomic", false);
    var peg$e23 = peg$literalExpectation("extern", false);
    var peg$e24 = peg$literalExpectation("inline", false);
    var peg$e25 = peg$literalExpectation("double", false);
    var peg$e26 = peg$literalExpectation("return", false);
    var peg$e27 = peg$literalExpectation("signed", false);
    var peg$e28 = peg$literalExpectation("sizeof", false);
    var peg$e29 = peg$literalExpectation("static", false);
    var peg$e30 = peg$literalExpectation("struct", false);
    var peg$e31 = peg$literalExpectation("switch", false);
    var peg$e32 = peg$literalExpectation("break", false);
    var peg$e33 = peg$literalExpectation("float", false);
    var peg$e34 = peg$literalExpectation("const", false);
    var peg$e35 = peg$literalExpectation("short", false);
    var peg$e36 = peg$literalExpectation("union", false);
    var peg$e37 = peg$literalExpectation("while", false);
    var peg$e38 = peg$literalExpectation("_Bool", false);
    var peg$e39 = peg$literalExpectation("auto", false);
    var peg$e40 = peg$literalExpectation("case", false);
    var peg$e41 = peg$literalExpectation("char", false);
    var peg$e42 = peg$literalExpectation("goto", false);
    var peg$e43 = peg$literalExpectation("long", false);
    var peg$e44 = peg$literalExpectation("else", false);
    var peg$e45 = peg$literalExpectation("enum", false);
    var peg$e46 = peg$literalExpectation("void", false);
    var peg$e47 = peg$literalExpectation("for", false);
    var peg$e48 = peg$literalExpectation("int", false);
    var peg$e49 = peg$literalExpectation("if", false);
    var peg$e50 = peg$literalExpectation("do", false);
    var peg$e51 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "_"
    ], false, true);
    var peg$e52 = peg$literalExpectation("0", false);
    var peg$e53 = peg$classExpectation([
        [
            "1",
            "9"
        ]
    ], false, false);
    var peg$e54 = peg$classExpectation([
        [
            "0",
            "9"
        ]
    ], false, false);
    var peg$e55 = peg$classExpectation([
        [
            "0",
            "7"
        ]
    ], false, false);
    var peg$e56 = peg$literalExpectation("0x", false);
    var peg$e57 = peg$literalExpectation("0X", false);
    var peg$e58 = peg$classExpectation([
        [
            "0",
            "9"
        ],
        [
            "A",
            "F"
        ]
    ], false, true);
    var peg$e59 = peg$literalExpectation("u", false);
    var peg$e60 = peg$literalExpectation("U", false);
    var peg$e61 = peg$literalExpectation("l", false);
    var peg$e62 = peg$literalExpectation("L", false);
    var peg$e63 = peg$literalExpectation("ll", false);
    var peg$e64 = peg$literalExpectation("LL", false);
    var peg$e65 = peg$literalExpectation(".", false);
    var peg$e66 = peg$literalExpectation("e", false);
    var peg$e67 = peg$literalExpectation("E", false);
    var peg$e68 = peg$literalExpectation("+", false);
    var peg$e69 = peg$literalExpectation("-", false);
    var peg$e70 = peg$classExpectation([
        "f",
        "l"
    ], false, true);
    var peg$e71 = peg$literalExpectation("'", false);
    var peg$e72 = peg$literalExpectation("\\'", false);
    var peg$e73 = peg$literalExpectation('\\"', false);
    var peg$e74 = peg$literalExpectation("\\?", false);
    var peg$e75 = peg$literalExpectation("\\\\", false);
    var peg$e76 = peg$literalExpectation("\\a", false);
    var peg$e77 = peg$literalExpectation("\\b", false);
    var peg$e78 = peg$literalExpectation("\\f", false);
    var peg$e79 = peg$literalExpectation("\\r", false);
    var peg$e80 = peg$literalExpectation("\\n", false);
    var peg$e81 = peg$literalExpectation("\\t", false);
    var peg$e82 = peg$literalExpectation("\\v", false);
    var peg$e83 = peg$literalExpectation("\\", false);
    var peg$e84 = peg$literalExpectation("\\x", false);
    var peg$e85 = peg$literalExpectation('"', false);
    var peg$e86 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "!",
        "'",
        "#",
        "%",
        "&",
        "(",
        ")",
        "*",
        "+",
        [
            ",",
            "."
        ],
        "/",
        ":",
        " ",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "^",
        "_",
        "{",
        "|",
        "}",
        "~",
        "	",
        "\v",
        "\f"
    ], false, true);
    var peg$e87 = peg$literalExpectation("%:%:", false);
    var peg$e88 = peg$literalExpectation("...", false);
    var peg$e89 = peg$literalExpectation("<<=", false);
    var peg$e90 = peg$literalExpectation(">>=", false);
    var peg$e91 = peg$literalExpectation("++", false);
    var peg$e92 = peg$literalExpectation("--", false);
    var peg$e93 = peg$literalExpectation("+=", false);
    var peg$e94 = peg$literalExpectation("-=", false);
    var peg$e95 = peg$literalExpectation("*=", false);
    var peg$e96 = peg$literalExpectation("/=", false);
    var peg$e97 = peg$literalExpectation("%=", false);
    var peg$e98 = peg$literalExpectation("&=", false);
    var peg$e99 = peg$literalExpectation("^=", false);
    var peg$e100 = peg$literalExpectation("|=", false);
    var peg$e101 = peg$literalExpectation("==", false);
    var peg$e102 = peg$literalExpectation("!=", false);
    var peg$e103 = peg$literalExpectation("<=", false);
    var peg$e104 = peg$literalExpectation(">=", false);
    var peg$e105 = peg$literalExpectation(">>", false);
    var peg$e106 = peg$literalExpectation("<<", false);
    var peg$e107 = peg$literalExpectation("->", false);
    var peg$e108 = peg$literalExpectation("&&", false);
    var peg$e109 = peg$literalExpectation("||", false);
    var peg$e110 = peg$literalExpectation("##", false);
    var peg$e111 = peg$literalExpectation("%:", false);
    var peg$e112 = peg$literalExpectation("<:", false);
    var peg$e113 = peg$literalExpectation(":>", false);
    var peg$e114 = peg$literalExpectation("<%", false);
    var peg$e115 = peg$literalExpectation("%>", false);
    var peg$e116 = peg$literalExpectation("[", false);
    var peg$e117 = peg$literalExpectation("]", false);
    var peg$e118 = peg$literalExpectation("(", false);
    var peg$e119 = peg$literalExpectation(")", false);
    var peg$e120 = peg$literalExpectation("{", false);
    var peg$e121 = peg$literalExpectation("}", false);
    var peg$e122 = peg$literalExpectation("&", false);
    var peg$e123 = peg$literalExpectation("*", false);
    var peg$e124 = peg$literalExpectation("~", false);
    var peg$e125 = peg$literalExpectation("!", false);
    var peg$e126 = peg$literalExpectation("/", false);
    var peg$e127 = peg$literalExpectation("%", false);
    var peg$e128 = peg$literalExpectation("<", false);
    var peg$e129 = peg$literalExpectation("^", false);
    var peg$e130 = peg$literalExpectation("|", false);
    var peg$e131 = peg$literalExpectation("?", false);
    var peg$e132 = peg$literalExpectation(":", false);
    var peg$e133 = peg$literalExpectation(";", false);
    var peg$e134 = peg$literalExpectation("=", false);
    var peg$e135 = peg$literalExpectation(",", false);
    var peg$e136 = peg$literalExpectation("#", false);
    var peg$f0 = function(matches) {
        return matches.join("");
    };
    var peg$f1 = function(token) {
        addTokenPosition(token);
        return token + " ";
    };
    var peg$f2 = function() {
        return "";
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$resultsCache = {};
    var peg$result;
    if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
        return peg$savedPos;
    }
    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos
        };
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
    }
    function peg$literalExpectation(text, ignoreCase) {
        return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        if (offset && peg$source && typeof peg$source.offset === "function") {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
        return new $1470c0288d19cc19$var$peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new $1470c0288d19cc19$var$peg$SyntaxError($1470c0288d19cc19$var$peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parseprogram() {
        var s0, s1, s2;
        var key = peg$currPos * 36 + 0;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsepreprocess_match();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsepreprocess_match();
        }
        peg$savedPos = s0;
        s1 = peg$f0(s1);
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepreprocess_match() {
        var s0, s1, s2;
        var key = peg$currPos * 36 + 1;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsetoken();
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f1(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                s2 = peg$parse_();
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f2();
            }
            s0 = s1;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parse_() {
        var s0, s1;
        var key = peg$currPos * 36 + 2;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        peg$silentFails++;
        s0 = [];
        if (peg$r0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$r0.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
        }
        else s0 = peg$FAILED;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e0);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsesource_character_set() {
        var s0, s1;
        var key = peg$currPos * 36 + 3;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r1.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e2);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        if (s0 === peg$FAILED) s0 = peg$parseextended_source_character_set();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseextended_source_character_set() {
        var s0;
        var key = peg$currPos * 36 + 4;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 64) {
            s0 = peg$c0;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e3);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetoken() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 5;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parseinclude();
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsekeyword();
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                if (peg$r2.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e4);
                }
                peg$silentFails--;
                if (s3 === peg$FAILED) s2 = undefined;
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) s0 = s1;
                else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$parseidentifier();
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseconstant();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$currPos;
                        peg$silentFails++;
                        if (peg$r2.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e4);
                        }
                        peg$silentFails--;
                        if (s3 === peg$FAILED) s2 = undefined;
                        else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                        if (s2 !== peg$FAILED) s0 = s1;
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$parsestring_literal();
                        if (s0 === peg$FAILED) s0 = peg$parsepunctuator();
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinclude() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 6;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c1) {
            s1 = peg$c1;
            peg$currPos += 10;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e5);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifier();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                    s3 = peg$c2;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e6);
                }
                if (s3 !== peg$FAILED) {
                    s1 = [
                        s1,
                        s2,
                        s3
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsekeyword() {
        var s0;
        var key = peg$currPos * 36 + 7;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 14) === peg$c3) {
            s0 = peg$c3;
            peg$currPos += 14;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e7);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c4) {
                s0 = peg$c4;
                peg$currPos += 13;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e8);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c5) {
                    s0 = peg$c5;
                    peg$currPos += 10;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e9);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c6) {
                        s0 = peg$c6;
                        peg$currPos += 9;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e10);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c7) {
                            s0 = peg$c7;
                            peg$currPos += 8;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e11);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c8) {
                                s0 = peg$c8;
                                peg$currPos += 8;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e12);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c9) {
                                    s0 = peg$c9;
                                    peg$currPos += 8;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e13);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 8) === peg$c10) {
                                        s0 = peg$c10;
                                        peg$currPos += 8;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e14);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 8) === peg$c11) {
                                            s0 = peg$c11;
                                            peg$currPos += 8;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e15);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 8) === peg$c12) {
                                                s0 = peg$c12;
                                                peg$currPos += 8;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e16);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c13) {
                                                    s0 = peg$c13;
                                                    peg$currPos += 8;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e17);
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 8) === peg$c14) {
                                                        s0 = peg$c14;
                                                        peg$currPos += 8;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e18);
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 8) === peg$c15) {
                                                            s0 = peg$c15;
                                                            peg$currPos += 8;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$e19);
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 7) === peg$c16) {
                                                                s0 = peg$c16;
                                                                peg$currPos += 7;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$e20);
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 7) === peg$c17) {
                                                                    s0 = peg$c17;
                                                                    peg$currPos += 7;
                                                                } else {
                                                                    s0 = peg$FAILED;
                                                                    if (peg$silentFails === 0) peg$fail(peg$e21);
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 7) === peg$c18) {
                                                                        s0 = peg$c18;
                                                                        peg$currPos += 7;
                                                                    } else {
                                                                        s0 = peg$FAILED;
                                                                        if (peg$silentFails === 0) peg$fail(peg$e22);
                                                                    }
                                                                    if (s0 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 6) === peg$c19) {
                                                                            s0 = peg$c19;
                                                                            peg$currPos += 6;
                                                                        } else {
                                                                            s0 = peg$FAILED;
                                                                            if (peg$silentFails === 0) peg$fail(peg$e23);
                                                                        }
                                                                        if (s0 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 6) === peg$c20) {
                                                                                s0 = peg$c20;
                                                                                peg$currPos += 6;
                                                                            } else {
                                                                                s0 = peg$FAILED;
                                                                                if (peg$silentFails === 0) peg$fail(peg$e24);
                                                                            }
                                                                            if (s0 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 6) === peg$c21) {
                                                                                    s0 = peg$c21;
                                                                                    peg$currPos += 6;
                                                                                } else {
                                                                                    s0 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) peg$fail(peg$e25);
                                                                                }
                                                                                if (s0 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 6) === peg$c22) {
                                                                                        s0 = peg$c22;
                                                                                        peg$currPos += 6;
                                                                                    } else {
                                                                                        s0 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) peg$fail(peg$e26);
                                                                                    }
                                                                                    if (s0 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 6) === peg$c23) {
                                                                                            s0 = peg$c23;
                                                                                            peg$currPos += 6;
                                                                                        } else {
                                                                                            s0 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) peg$fail(peg$e27);
                                                                                        }
                                                                                        if (s0 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 6) === peg$c24) {
                                                                                                s0 = peg$c24;
                                                                                                peg$currPos += 6;
                                                                                            } else {
                                                                                                s0 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) peg$fail(peg$e28);
                                                                                            }
                                                                                            if (s0 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 6) === peg$c25) {
                                                                                                    s0 = peg$c25;
                                                                                                    peg$currPos += 6;
                                                                                                } else {
                                                                                                    s0 = peg$FAILED;
                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e29);
                                                                                                }
                                                                                                if (s0 === peg$FAILED) {
                                                                                                    if (input.substr(peg$currPos, 6) === peg$c26) {
                                                                                                        s0 = peg$c26;
                                                                                                        peg$currPos += 6;
                                                                                                    } else {
                                                                                                        s0 = peg$FAILED;
                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e30);
                                                                                                    }
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                        if (input.substr(peg$currPos, 6) === peg$c27) {
                                                                                                            s0 = peg$c27;
                                                                                                            peg$currPos += 6;
                                                                                                        } else {
                                                                                                            s0 = peg$FAILED;
                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e31);
                                                                                                        }
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                            if (input.substr(peg$currPos, 5) === peg$c28) {
                                                                                                                s0 = peg$c28;
                                                                                                                peg$currPos += 5;
                                                                                                            } else {
                                                                                                                s0 = peg$FAILED;
                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e32);
                                                                                                            }
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                if (input.substr(peg$currPos, 5) === peg$c29) {
                                                                                                                    s0 = peg$c29;
                                                                                                                    peg$currPos += 5;
                                                                                                                } else {
                                                                                                                    s0 = peg$FAILED;
                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e33);
                                                                                                                }
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                    if (input.substr(peg$currPos, 5) === peg$c30) {
                                                                                                                        s0 = peg$c30;
                                                                                                                        peg$currPos += 5;
                                                                                                                    } else {
                                                                                                                        s0 = peg$FAILED;
                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e34);
                                                                                                                    }
                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                        if (input.substr(peg$currPos, 5) === peg$c31) {
                                                                                                                            s0 = peg$c31;
                                                                                                                            peg$currPos += 5;
                                                                                                                        } else {
                                                                                                                            s0 = peg$FAILED;
                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e35);
                                                                                                                        }
                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                            if (input.substr(peg$currPos, 5) === peg$c32) {
                                                                                                                                s0 = peg$c32;
                                                                                                                                peg$currPos += 5;
                                                                                                                            } else {
                                                                                                                                s0 = peg$FAILED;
                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e36);
                                                                                                                            }
                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                if (input.substr(peg$currPos, 5) === peg$c33) {
                                                                                                                                    s0 = peg$c33;
                                                                                                                                    peg$currPos += 5;
                                                                                                                                } else {
                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e37);
                                                                                                                                }
                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                    if (input.substr(peg$currPos, 5) === peg$c34) {
                                                                                                                                        s0 = peg$c34;
                                                                                                                                        peg$currPos += 5;
                                                                                                                                    } else {
                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e38);
                                                                                                                                    }
                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                        if (input.substr(peg$currPos, 4) === peg$c35) {
                                                                                                                                            s0 = peg$c35;
                                                                                                                                            peg$currPos += 4;
                                                                                                                                        } else {
                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e39);
                                                                                                                                        }
                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                            if (input.substr(peg$currPos, 4) === peg$c36) {
                                                                                                                                                s0 = peg$c36;
                                                                                                                                                peg$currPos += 4;
                                                                                                                                            } else {
                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e40);
                                                                                                                                            }
                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                if (input.substr(peg$currPos, 4) === peg$c37) {
                                                                                                                                                    s0 = peg$c37;
                                                                                                                                                    peg$currPos += 4;
                                                                                                                                                } else {
                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e41);
                                                                                                                                                }
                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                    if (input.substr(peg$currPos, 4) === peg$c38) {
                                                                                                                                                        s0 = peg$c38;
                                                                                                                                                        peg$currPos += 4;
                                                                                                                                                    } else {
                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e42);
                                                                                                                                                    }
                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                        if (input.substr(peg$currPos, 4) === peg$c39) {
                                                                                                                                                            s0 = peg$c39;
                                                                                                                                                            peg$currPos += 4;
                                                                                                                                                        } else {
                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e43);
                                                                                                                                                        }
                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                            if (input.substr(peg$currPos, 4) === peg$c40) {
                                                                                                                                                                s0 = peg$c40;
                                                                                                                                                                peg$currPos += 4;
                                                                                                                                                            } else {
                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e44);
                                                                                                                                                            }
                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                if (input.substr(peg$currPos, 4) === peg$c41) {
                                                                                                                                                                    s0 = peg$c41;
                                                                                                                                                                    peg$currPos += 4;
                                                                                                                                                                } else {
                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e45);
                                                                                                                                                                }
                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                    if (input.substr(peg$currPos, 4) === peg$c42) {
                                                                                                                                                                        s0 = peg$c42;
                                                                                                                                                                        peg$currPos += 4;
                                                                                                                                                                    } else {
                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e46);
                                                                                                                                                                    }
                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                        if (input.substr(peg$currPos, 3) === peg$c43) {
                                                                                                                                                                            s0 = peg$c43;
                                                                                                                                                                            peg$currPos += 3;
                                                                                                                                                                        } else {
                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e47);
                                                                                                                                                                        }
                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                            if (input.substr(peg$currPos, 3) === peg$c44) {
                                                                                                                                                                                s0 = peg$c44;
                                                                                                                                                                                peg$currPos += 3;
                                                                                                                                                                            } else {
                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e48);
                                                                                                                                                                            }
                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                if (input.substr(peg$currPos, 2) === peg$c45) {
                                                                                                                                                                                    s0 = peg$c45;
                                                                                                                                                                                    peg$currPos += 2;
                                                                                                                                                                                } else {
                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e49);
                                                                                                                                                                                }
                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                    if (input.substr(peg$currPos, 2) === peg$c46) {
                                                                                                                                                                                        s0 = peg$c46;
                                                                                                                                                                                        peg$currPos += 2;
                                                                                                                                                                                    } else {
                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e50);
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseidentifier() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 8;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r2.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e4);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$r3.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e51);
            }
            while(s3 !== peg$FAILED){
                s2.push(s3);
                if (peg$r3.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e51);
                }
            }
            s1 = [
                s1,
                s2
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseconstant() {
        var s0;
        var key = peg$currPos * 36 + 9;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsedecimal_floating_constant();
        if (s0 === peg$FAILED) {
            s0 = peg$parseinteger_constant();
            if (s0 === peg$FAILED) {
                s0 = peg$parseidentifier();
                if (s0 === peg$FAILED) s0 = peg$parsecharacter_constant();
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinteger_constant() {
        var s0, s1, s2;
        var key = peg$currPos * 36 + 10;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedecimal_constant();
        if (s1 === peg$FAILED) {
            s1 = peg$parseoctal_constant();
            if (s1 === peg$FAILED) {
                s1 = peg$parsehexadecimal_constant();
                if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 48) {
                        s1 = peg$c47;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e52);
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseinteger_suffix();
            if (s2 === peg$FAILED) s2 = null;
            s1 = [
                s1,
                s2
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedecimal_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 11;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsenonzero_digit();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsedigit();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsedigit();
            }
            s1 = [
                s1,
                s2
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsenonzero_digit() {
        var s0, s1;
        var key = peg$currPos * 36 + 12;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r4.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e53);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedigit() {
        var s0, s1;
        var key = peg$currPos * 36 + 13;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r5.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e54);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseoctal_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 14;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c47;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e52);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseoctal_digit();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parseoctal_digit();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseoctal_digit() {
        var s0, s1;
        var key = peg$currPos * 36 + 15;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r6.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e55);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 16;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsehexadecimal_prefix();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsehexadecimal_digit();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsehexadecimal_digit();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_prefix() {
        var s0;
        var key = peg$currPos * 36 + 17;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 2) === peg$c48) {
            s0 = peg$c48;
            peg$currPos += 2;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e56);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c49) {
                s0 = peg$c49;
                peg$currPos += 2;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e57);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_digit() {
        var s0, s1;
        var key = peg$currPos * 36 + 18;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r7.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e58);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinteger_suffix() {
        var s0, s1, s2;
        var key = peg$currPos * 36 + 19;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseunsigned_suffix();
        if (s1 !== peg$FAILED) {
            s2 = peg$parselong_long_suffix();
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseunsigned_suffix();
            if (s1 !== peg$FAILED) {
                s2 = peg$parselong_suffix();
                if (s2 === peg$FAILED) s2 = null;
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parselong_long_suffix();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseunsigned_suffix();
                    if (s2 === peg$FAILED) s2 = null;
                    s1 = [
                        s1,
                        s2
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parselong_suffix();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseunsigned_suffix();
                        if (s2 === peg$FAILED) s2 = null;
                        s1 = [
                            s1,
                            s2
                        ];
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseunsigned_suffix() {
        var s0;
        var key = peg$currPos * 36 + 20;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 117) {
            s0 = peg$c50;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e59);
        }
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 85) {
                s0 = peg$c51;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e60);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselong_suffix() {
        var s0;
        var key = peg$currPos * 36 + 21;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 108) {
            s0 = peg$c52;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e61);
        }
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 76) {
                s0 = peg$c53;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e62);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselong_long_suffix() {
        var s0;
        var key = peg$currPos * 36 + 22;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 2) === peg$c54) {
            s0 = peg$c54;
            peg$currPos += 2;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e63);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c55) {
                s0 = peg$c55;
                peg$currPos += 2;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e64);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedecimal_floating_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 23;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsefractional_constant();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseexponent_part();
            if (s2 === peg$FAILED) s2 = null;
            s3 = peg$parsefloating_suffix();
            if (s3 === peg$FAILED) s3 = null;
            s1 = [
                s1,
                s2,
                s3
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedigit();
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                s2 = peg$parsedigit();
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                s2 = peg$parseexponent_part();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsefloating_suffix();
                    if (s3 === peg$FAILED) s3 = null;
                    s1 = [
                        s1,
                        s2,
                        s3
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefractional_constant() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 36 + 24;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedigit();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsedigit();
        }
        if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c56;
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e65);
        }
        if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsedigit();
            if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsedigit();
            }
            else s3 = peg$FAILED;
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedigit();
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                s2 = peg$parsedigit();
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                    s2 = peg$c56;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e65);
                }
                if (s2 !== peg$FAILED) {
                    s1 = [
                        s1,
                        s2
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseexponent_part() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 36 + 25;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
            s1 = peg$c57;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e66);
        }
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
                s1 = peg$c58;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e67);
            }
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
                s2 = peg$c59;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e68);
            }
            if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                    s2 = peg$c60;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e69);
                }
            }
            if (s2 === peg$FAILED) s2 = null;
            s3 = [];
            s4 = peg$parsedigit();
            if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsedigit();
            }
            else s3 = peg$FAILED;
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefloating_suffix() {
        var s0;
        var key = peg$currPos * 36 + 26;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (peg$r8.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e70);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsecharacter_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 27;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c61;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e71);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsec_char();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                    s3 = peg$c61;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e71);
                }
                if (s3 !== peg$FAILED) {
                    s1 = [
                        s1,
                        s2,
                        s3
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsec_char() {
        var s0;
        var key = peg$currPos * 36 + 28;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (peg$r1.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e2);
        }
        if (s0 === peg$FAILED) s0 = peg$parseescape_sequence();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseescape_sequence() {
        var s0;
        var key = peg$currPos * 36 + 29;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsesimple_escape_sequence();
        if (s0 === peg$FAILED) {
            s0 = peg$parseoctal_escape_sequence();
            if (s0 === peg$FAILED) s0 = peg$parsehexadecimal_escape_sequence();
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsesimple_escape_sequence() {
        var s0;
        var key = peg$currPos * 36 + 30;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 2) === peg$c62) {
            s0 = peg$c62;
            peg$currPos += 2;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e72);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c63) {
                s0 = peg$c63;
                peg$currPos += 2;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e73);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c64) {
                    s0 = peg$c64;
                    peg$currPos += 2;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e74);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c65) {
                        s0 = peg$c65;
                        peg$currPos += 2;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e75);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c66) {
                            s0 = peg$c66;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e76);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c67) {
                                s0 = peg$c67;
                                peg$currPos += 2;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e77);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c68) {
                                    s0 = peg$c68;
                                    peg$currPos += 2;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e78);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c69) {
                                        s0 = peg$c69;
                                        peg$currPos += 2;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e79);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c70) {
                                            s0 = peg$c70;
                                            peg$currPos += 2;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e80);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c71) {
                                                s0 = peg$c71;
                                                peg$currPos += 2;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e81);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 2) === peg$c72) {
                                                    s0 = peg$c72;
                                                    peg$currPos += 2;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e82);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseoctal_escape_sequence() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 36 + 31;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c73;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e83);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parseoctal_digit();
            while(s4 !== peg$FAILED){
                s3.push(s4);
                if (s3.length >= 3) s4 = peg$FAILED;
                else s4 = peg$parseoctal_digit();
            }
            if (s3.length < 1) {
                peg$currPos = s2;
                s2 = peg$FAILED;
            } else s2 = s3;
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_escape_sequence() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 36 + 32;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c74) {
            s1 = peg$c74;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e84);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsehexadecimal_digit();
            while(s4 !== peg$FAILED){
                s3.push(s4);
                if (s3.length >= 2) s4 = peg$FAILED;
                else s4 = peg$parsehexadecimal_digit();
            }
            if (s3.length < 1) {
                peg$currPos = s2;
                s2 = peg$FAILED;
            } else s2 = s3;
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestring_literal() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 36 + 33;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c75;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e85);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parses_char();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parses_char();
            }
            if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c75;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e85);
            }
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parses_char() {
        var s0;
        var key = peg$currPos * 36 + 34;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (peg$r9.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e86);
        }
        if (s0 === peg$FAILED) s0 = peg$parseescape_sequence();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepunctuator() {
        var s0;
        var key = peg$currPos * 36 + 35;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 4) === peg$c76) {
            s0 = peg$c76;
            peg$currPos += 4;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e87);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c77) {
                s0 = peg$c77;
                peg$currPos += 3;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e88);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c78) {
                    s0 = peg$c78;
                    peg$currPos += 3;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e89);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c79) {
                        s0 = peg$c79;
                        peg$currPos += 3;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e90);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c80) {
                            s0 = peg$c80;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e91);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c81) {
                                s0 = peg$c81;
                                peg$currPos += 2;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e92);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c82) {
                                    s0 = peg$c82;
                                    peg$currPos += 2;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e93);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c83) {
                                        s0 = peg$c83;
                                        peg$currPos += 2;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e94);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c84) {
                                            s0 = peg$c84;
                                            peg$currPos += 2;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e95);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c85) {
                                                s0 = peg$c85;
                                                peg$currPos += 2;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e96);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 2) === peg$c86) {
                                                    s0 = peg$c86;
                                                    peg$currPos += 2;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e97);
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 2) === peg$c87) {
                                                        s0 = peg$c87;
                                                        peg$currPos += 2;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e98);
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 2) === peg$c88) {
                                                            s0 = peg$c88;
                                                            peg$currPos += 2;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$e99);
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 2) === peg$c89) {
                                                                s0 = peg$c89;
                                                                peg$currPos += 2;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$e100);
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 2) === peg$c90) {
                                                                    s0 = peg$c90;
                                                                    peg$currPos += 2;
                                                                } else {
                                                                    s0 = peg$FAILED;
                                                                    if (peg$silentFails === 0) peg$fail(peg$e101);
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 2) === peg$c91) {
                                                                        s0 = peg$c91;
                                                                        peg$currPos += 2;
                                                                    } else {
                                                                        s0 = peg$FAILED;
                                                                        if (peg$silentFails === 0) peg$fail(peg$e102);
                                                                    }
                                                                    if (s0 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 2) === peg$c92) {
                                                                            s0 = peg$c92;
                                                                            peg$currPos += 2;
                                                                        } else {
                                                                            s0 = peg$FAILED;
                                                                            if (peg$silentFails === 0) peg$fail(peg$e103);
                                                                        }
                                                                        if (s0 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 2) === peg$c93) {
                                                                                s0 = peg$c93;
                                                                                peg$currPos += 2;
                                                                            } else {
                                                                                s0 = peg$FAILED;
                                                                                if (peg$silentFails === 0) peg$fail(peg$e104);
                                                                            }
                                                                            if (s0 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 2) === peg$c94) {
                                                                                    s0 = peg$c94;
                                                                                    peg$currPos += 2;
                                                                                } else {
                                                                                    s0 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) peg$fail(peg$e105);
                                                                                }
                                                                                if (s0 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 2) === peg$c95) {
                                                                                        s0 = peg$c95;
                                                                                        peg$currPos += 2;
                                                                                    } else {
                                                                                        s0 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) peg$fail(peg$e106);
                                                                                    }
                                                                                    if (s0 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 2) === peg$c96) {
                                                                                            s0 = peg$c96;
                                                                                            peg$currPos += 2;
                                                                                        } else {
                                                                                            s0 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) peg$fail(peg$e107);
                                                                                        }
                                                                                        if (s0 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 2) === peg$c97) {
                                                                                                s0 = peg$c97;
                                                                                                peg$currPos += 2;
                                                                                            } else {
                                                                                                s0 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) peg$fail(peg$e108);
                                                                                            }
                                                                                            if (s0 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 2) === peg$c98) {
                                                                                                    s0 = peg$c98;
                                                                                                    peg$currPos += 2;
                                                                                                } else {
                                                                                                    s0 = peg$FAILED;
                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e109);
                                                                                                }
                                                                                                if (s0 === peg$FAILED) {
                                                                                                    if (input.substr(peg$currPos, 2) === peg$c99) {
                                                                                                        s0 = peg$c99;
                                                                                                        peg$currPos += 2;
                                                                                                    } else {
                                                                                                        s0 = peg$FAILED;
                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e110);
                                                                                                    }
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                        if (input.substr(peg$currPos, 2) === peg$c100) {
                                                                                                            s0 = peg$c100;
                                                                                                            peg$currPos += 2;
                                                                                                        } else {
                                                                                                            s0 = peg$FAILED;
                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e111);
                                                                                                        }
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                            if (input.substr(peg$currPos, 2) === peg$c101) {
                                                                                                                s0 = peg$c101;
                                                                                                                peg$currPos += 2;
                                                                                                            } else {
                                                                                                                s0 = peg$FAILED;
                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e112);
                                                                                                            }
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                if (input.substr(peg$currPos, 2) === peg$c102) {
                                                                                                                    s0 = peg$c102;
                                                                                                                    peg$currPos += 2;
                                                                                                                } else {
                                                                                                                    s0 = peg$FAILED;
                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e113);
                                                                                                                }
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                    if (input.substr(peg$currPos, 2) === peg$c103) {
                                                                                                                        s0 = peg$c103;
                                                                                                                        peg$currPos += 2;
                                                                                                                    } else {
                                                                                                                        s0 = peg$FAILED;
                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e114);
                                                                                                                    }
                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                        if (input.substr(peg$currPos, 2) === peg$c104) {
                                                                                                                            s0 = peg$c104;
                                                                                                                            peg$currPos += 2;
                                                                                                                        } else {
                                                                                                                            s0 = peg$FAILED;
                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e115);
                                                                                                                        }
                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                            if (input.charCodeAt(peg$currPos) === 91) {
                                                                                                                                s0 = peg$c105;
                                                                                                                                peg$currPos++;
                                                                                                                            } else {
                                                                                                                                s0 = peg$FAILED;
                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e116);
                                                                                                                            }
                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                if (input.charCodeAt(peg$currPos) === 93) {
                                                                                                                                    s0 = peg$c106;
                                                                                                                                    peg$currPos++;
                                                                                                                                } else {
                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e117);
                                                                                                                                }
                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                    if (input.charCodeAt(peg$currPos) === 40) {
                                                                                                                                        s0 = peg$c107;
                                                                                                                                        peg$currPos++;
                                                                                                                                    } else {
                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e118);
                                                                                                                                    }
                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                        if (input.charCodeAt(peg$currPos) === 41) {
                                                                                                                                            s0 = peg$c108;
                                                                                                                                            peg$currPos++;
                                                                                                                                        } else {
                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e119);
                                                                                                                                        }
                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                            if (input.charCodeAt(peg$currPos) === 123) {
                                                                                                                                                s0 = peg$c109;
                                                                                                                                                peg$currPos++;
                                                                                                                                            } else {
                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e120);
                                                                                                                                            }
                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                if (input.charCodeAt(peg$currPos) === 125) {
                                                                                                                                                    s0 = peg$c110;
                                                                                                                                                    peg$currPos++;
                                                                                                                                                } else {
                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e121);
                                                                                                                                                }
                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 46) {
                                                                                                                                                        s0 = peg$c56;
                                                                                                                                                        peg$currPos++;
                                                                                                                                                    } else {
                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e65);
                                                                                                                                                    }
                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 38) {
                                                                                                                                                            s0 = peg$c111;
                                                                                                                                                            peg$currPos++;
                                                                                                                                                        } else {
                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e122);
                                                                                                                                                        }
                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 42) {
                                                                                                                                                                s0 = peg$c112;
                                                                                                                                                                peg$currPos++;
                                                                                                                                                            } else {
                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e123);
                                                                                                                                                            }
                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 43) {
                                                                                                                                                                    s0 = peg$c59;
                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                } else {
                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e68);
                                                                                                                                                                }
                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 45) {
                                                                                                                                                                        s0 = peg$c60;
                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                    } else {
                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e69);
                                                                                                                                                                    }
                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 126) {
                                                                                                                                                                            s0 = peg$c113;
                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                        } else {
                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e124);
                                                                                                                                                                        }
                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 33) {
                                                                                                                                                                                s0 = peg$c114;
                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                            } else {
                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e125);
                                                                                                                                                                            }
                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 47) {
                                                                                                                                                                                    s0 = peg$c115;
                                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                                } else {
                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e126);
                                                                                                                                                                                }
                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 37) {
                                                                                                                                                                                        s0 = peg$c116;
                                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                                    } else {
                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e127);
                                                                                                                                                                                    }
                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 60) {
                                                                                                                                                                                            s0 = peg$c117;
                                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                                        } else {
                                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e128);
                                                                                                                                                                                        }
                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 62) {
                                                                                                                                                                                                s0 = peg$c2;
                                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e6);
                                                                                                                                                                                            }
                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 94) {
                                                                                                                                                                                                    s0 = peg$c118;
                                                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e129);
                                                                                                                                                                                                }
                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 124) {
                                                                                                                                                                                                        s0 = peg$c119;
                                                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e130);
                                                                                                                                                                                                    }
                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 63) {
                                                                                                                                                                                                            s0 = peg$c120;
                                                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e131);
                                                                                                                                                                                                        }
                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 58) {
                                                                                                                                                                                                                s0 = peg$c121;
                                                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e132);
                                                                                                                                                                                                            }
                                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 59) {
                                                                                                                                                                                                                    s0 = peg$c122;
                                                                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e133);
                                                                                                                                                                                                                }
                                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 61) {
                                                                                                                                                                                                                        s0 = peg$c123;
                                                                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e134);
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 44) {
                                                                                                                                                                                                                            s0 = peg$c124;
                                                                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e135);
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 35) {
                                                                                                                                                                                                                                s0 = peg$c125;
                                                                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e136);
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    const thisParser = this;
    thisParser.tokenPositions = new Map();
    // length of the output string of the lexer
    let outputLength = 0;
    /**
   * Returns the location of the token, adjusted for "\\\n" that were removed by the preprocessor.
   */ function getAdjustedTokenLocation() {
        const FALSE_NEWLINE_CHAR_LENGTH = 2;
        const adjustedLocation = location();
        let numOfFalseNewlinesBefStart = 0;
        let numOfFalseNewlinesBefEnd = 0;
        for (const falseNewlinePosition of thisParser.falseNewlinePositions){
            if (falseNewlinePosition > adjustedLocation.end.offset) break;
            numOfFalseNewlinesBefEnd++;
            if (falseNewlinePosition < adjustedLocation.start.offset) numOfFalseNewlinesBefStart++;
        }
        adjustedLocation.start.offset += FALSE_NEWLINE_CHAR_LENGTH * numOfFalseNewlinesBefStart;
        adjustedLocation.start.line += numOfFalseNewlinesBefStart;
        adjustedLocation.end.offset += FALSE_NEWLINE_CHAR_LENGTH * numOfFalseNewlinesBefEnd;
        adjustedLocation.end.line += numOfFalseNewlinesBefEnd;
        return adjustedLocation;
    }
    function addTokenPosition(token) {
        const tokenPosition = getAdjustedTokenLocation();
        for(let i = 0; i < token.length; ++i)thisParser.tokenPositions.set(outputLength + i, tokenPosition);
        outputLength += token.length + 1;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
$1470c0288d19cc19$exports = {
    SyntaxError: $1470c0288d19cc19$var$peg$SyntaxError,
    parse: $1470c0288d19cc19$var$peg$parse
};


var $998a69218af07240$exports = {};
// Generated by Peggy 3.0.2.
//
// https://peggyjs.org/
"use strict";
function $998a69218af07240$var$peg$subclass(child, parent) {
    function C() {
        this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
}
function $998a69218af07240$var$peg$SyntaxError(message, expected, found, location) {
    var self = Error.call(this, message);
    // istanbul ignore next Check is a necessary evil to support older environments
    if (Object.setPrototypeOf) Object.setPrototypeOf(self, $998a69218af07240$var$peg$SyntaxError.prototype);
    self.expected = expected;
    self.found = found;
    self.location = location;
    self.name = "SyntaxError";
    return self;
}
$998a69218af07240$var$peg$subclass($998a69218af07240$var$peg$SyntaxError, Error);
function $998a69218af07240$var$peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
$998a69218af07240$var$peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
        var src = null;
        var k;
        for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
            var e = this.location.end;
            var filler = $998a69218af07240$var$peg$padEnd("", offset_s.line.toString().length, " ");
            var line = src[s.line - 1];
            var last = s.line === e.line ? e.column : line.length + 1;
            var hatLen = last - s.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + $998a69218af07240$var$peg$padEnd("", s.column - 1, " ") + $998a69218af07240$var$peg$padEnd("", hatLen, "^");
        } else str += "\n at " + loc;
    }
    return str;
};
$998a69218af07240$var$peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
            return "any character";
        },
        end: function() {
            return "end of input";
        },
        other: function(expectation) {
            return expectation.description;
        }
    };
    function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
            for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
            }
            descriptions.length = j;
        }
        switch(descriptions.length){
            case 1:
                return descriptions[0];
            case 2:
                return descriptions[0] + " or " + descriptions[1];
            default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
    }
    function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function $998a69218af07240$var$peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$source = options.grammarSource;
    var peg$startRuleFunctions = {
        program: peg$parseprogram
    };
    var peg$startRuleFunction = peg$parseprogram;
    var peg$c0 = " ";
    var peg$c1 = "{";
    var peg$c2 = "}";
    var peg$c3 = "return";
    var peg$c4 = ";";
    var peg$c5 = "break";
    var peg$c6 = "continue";
    var peg$c7 = "do";
    var peg$c8 = "while";
    var peg$c9 = "(";
    var peg$c10 = ")";
    var peg$c11 = "for";
    var peg$c12 = "if";
    var peg$c13 = "else";
    var peg$c14 = "switch";
    var peg$c15 = "default";
    var peg$c16 = ":";
    var peg$c17 = "case";
    var peg$c18 = "const";
    var peg$c19 = "auto";
    var peg$c20 = "static";
    var peg$c21 = "typedef";
    var peg$c22 = "void";
    var peg$c23 = "char";
    var peg$c24 = "int";
    var peg$c25 = "float";
    var peg$c26 = "double";
    var peg$c27 = "long";
    var peg$c28 = "short";
    var peg$c29 = "signed";
    var peg$c30 = "unsigned";
    var peg$c31 = ",";
    var peg$c32 = "=";
    var peg$c33 = "*";
    var peg$c34 = "[";
    var peg$c35 = "]";
    var peg$c36 = "struct";
    var peg$c37 = "enum";
    var peg$c38 = "+=";
    var peg$c39 = "-=";
    var peg$c40 = "*=";
    var peg$c41 = "/=";
    var peg$c42 = "%=";
    var peg$c43 = "<<=";
    var peg$c44 = ">>=";
    var peg$c45 = "&=";
    var peg$c46 = "^=";
    var peg$c47 = "|=";
    var peg$c48 = "?";
    var peg$c49 = "||";
    var peg$c50 = "&&";
    var peg$c51 = "|";
    var peg$c52 = "^";
    var peg$c53 = "&";
    var peg$c54 = "!=";
    var peg$c55 = "==";
    var peg$c56 = "<=";
    var peg$c57 = ">=";
    var peg$c58 = "<";
    var peg$c59 = ">";
    var peg$c60 = "<<";
    var peg$c61 = ">>";
    var peg$c62 = "+";
    var peg$c63 = "-";
    var peg$c64 = "/";
    var peg$c65 = "%";
    var peg$c66 = "++";
    var peg$c67 = "--";
    var peg$c68 = "!";
    var peg$c69 = "~";
    var peg$c70 = "sizeof";
    var peg$c71 = ".";
    var peg$c72 = "->";
    var peg$c73 = "@";
    var peg$c74 = "#include <";
    var peg$c75 = "_Static_assert";
    var peg$c76 = "_Thread_local";
    var peg$c77 = "_Imaginary";
    var peg$c78 = "_Noreturn";
    var peg$c79 = "register";
    var peg$c80 = "restrict";
    var peg$c81 = "volatile";
    var peg$c82 = "_Alignas";
    var peg$c83 = "_Alignof";
    var peg$c84 = "_Complex";
    var peg$c85 = "_Generic";
    var peg$c86 = "_Atomic";
    var peg$c87 = "extern";
    var peg$c88 = "inline";
    var peg$c89 = "union";
    var peg$c90 = "_Bool";
    var peg$c91 = "goto";
    var peg$c92 = "0";
    var peg$c93 = "0x";
    var peg$c94 = "0X";
    var peg$c95 = "u";
    var peg$c96 = "U";
    var peg$c97 = "l";
    var peg$c98 = "L";
    var peg$c99 = "ll";
    var peg$c100 = "LL";
    var peg$c101 = "e";
    var peg$c102 = "E";
    var peg$c103 = "'";
    var peg$c104 = "\\'";
    var peg$c105 = '\\"';
    var peg$c106 = "\\?";
    var peg$c107 = "\\\\";
    var peg$c108 = "\\a";
    var peg$c109 = "\\b";
    var peg$c110 = "\\f";
    var peg$c111 = "\\r";
    var peg$c112 = "\\n";
    var peg$c113 = "\\t";
    var peg$c114 = "\\v";
    var peg$c115 = "\\";
    var peg$c116 = "\\x";
    var peg$c117 = '"';
    var peg$c118 = "%:%:";
    var peg$c119 = "...";
    var peg$c120 = "##";
    var peg$c121 = "%:";
    var peg$c122 = "<:";
    var peg$c123 = ":>";
    var peg$c124 = "<%";
    var peg$c125 = "%>";
    var peg$c126 = "#";
    var peg$r0 = /^[a-z0-9!'"#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
    var peg$r1 = /^[a-z_]/i;
    var peg$r2 = /^[a-z0-9_]/i;
    var peg$r3 = /^[1-9]/;
    var peg$r4 = /^[0-9]/;
    var peg$r5 = /^[0-7]/;
    var peg$r6 = /^[0-9A-F]/i;
    var peg$r7 = /^[fl]/i;
    var peg$r8 = /^[a-z0-9!"#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
    var peg$r9 = /^[a-z0-9!'#%&()*+,-.\/: ;<=>?[\]\^_{|}~\t\v\f]/i;
    var peg$e0 = peg$otherExpectation("token separator");
    var peg$e1 = peg$literalExpectation(" ", false);
    var peg$e2 = peg$otherExpectation("block");
    var peg$e3 = peg$literalExpectation("{", false);
    var peg$e4 = peg$literalExpectation("}", false);
    var peg$e5 = peg$literalExpectation("return", false);
    var peg$e6 = peg$literalExpectation(";", false);
    var peg$e7 = peg$literalExpectation("break", false);
    var peg$e8 = peg$literalExpectation("continue", false);
    var peg$e9 = peg$literalExpectation("do", false);
    var peg$e10 = peg$literalExpectation("while", false);
    var peg$e11 = peg$literalExpectation("(", false);
    var peg$e12 = peg$literalExpectation(")", false);
    var peg$e13 = peg$literalExpectation("for", false);
    var peg$e14 = peg$literalExpectation("if", false);
    var peg$e15 = peg$literalExpectation("else", false);
    var peg$e16 = peg$literalExpectation("switch", false);
    var peg$e17 = peg$literalExpectation("default", false);
    var peg$e18 = peg$literalExpectation(":", false);
    var peg$e19 = peg$literalExpectation("case", false);
    var peg$e20 = peg$literalExpectation("const", false);
    var peg$e21 = peg$literalExpectation("auto", false);
    var peg$e22 = peg$literalExpectation("static", false);
    var peg$e23 = peg$literalExpectation("typedef", false);
    var peg$e24 = peg$literalExpectation("void", false);
    var peg$e25 = peg$literalExpectation("char", false);
    var peg$e26 = peg$literalExpectation("int", false);
    var peg$e27 = peg$literalExpectation("float", false);
    var peg$e28 = peg$literalExpectation("double", false);
    var peg$e29 = peg$literalExpectation("long", false);
    var peg$e30 = peg$literalExpectation("short", false);
    var peg$e31 = peg$literalExpectation("signed", false);
    var peg$e32 = peg$literalExpectation("unsigned", false);
    var peg$e33 = peg$literalExpectation(",", false);
    var peg$e34 = peg$literalExpectation("=", false);
    var peg$e35 = peg$literalExpectation("*", false);
    var peg$e36 = peg$literalExpectation("[", false);
    var peg$e37 = peg$literalExpectation("]", false);
    var peg$e38 = peg$literalExpectation("struct", false);
    var peg$e39 = peg$literalExpectation("enum", false);
    var peg$e40 = peg$literalExpectation("+=", false);
    var peg$e41 = peg$literalExpectation("-=", false);
    var peg$e42 = peg$literalExpectation("*=", false);
    var peg$e43 = peg$literalExpectation("/=", false);
    var peg$e44 = peg$literalExpectation("%=", false);
    var peg$e45 = peg$literalExpectation("<<=", false);
    var peg$e46 = peg$literalExpectation(">>=", false);
    var peg$e47 = peg$literalExpectation("&=", false);
    var peg$e48 = peg$literalExpectation("^=", false);
    var peg$e49 = peg$literalExpectation("|=", false);
    var peg$e50 = peg$literalExpectation("?", false);
    var peg$e51 = peg$literalExpectation("||", false);
    var peg$e52 = peg$literalExpectation("&&", false);
    var peg$e53 = peg$literalExpectation("|", false);
    var peg$e54 = peg$literalExpectation("^", false);
    var peg$e55 = peg$literalExpectation("&", false);
    var peg$e56 = peg$literalExpectation("!=", false);
    var peg$e57 = peg$literalExpectation("==", false);
    var peg$e58 = peg$literalExpectation("<=", false);
    var peg$e59 = peg$literalExpectation(">=", false);
    var peg$e60 = peg$literalExpectation("<", false);
    var peg$e61 = peg$literalExpectation(">", false);
    var peg$e62 = peg$literalExpectation("<<", false);
    var peg$e63 = peg$literalExpectation(">>", false);
    var peg$e64 = peg$literalExpectation("+", false);
    var peg$e65 = peg$literalExpectation("-", false);
    var peg$e66 = peg$literalExpectation("/", false);
    var peg$e67 = peg$literalExpectation("%", false);
    var peg$e68 = peg$literalExpectation("++", false);
    var peg$e69 = peg$literalExpectation("--", false);
    var peg$e70 = peg$literalExpectation("!", false);
    var peg$e71 = peg$literalExpectation("~", false);
    var peg$e72 = peg$literalExpectation("sizeof", false);
    var peg$e73 = peg$literalExpectation(".", false);
    var peg$e74 = peg$literalExpectation("->", false);
    var peg$e75 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "!",
        "'",
        '"',
        "#",
        "%",
        "&",
        "(",
        ")",
        "*",
        "+",
        [
            ",",
            "."
        ],
        "/",
        ":",
        " ",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "^",
        "_",
        "{",
        "|",
        "}",
        "~",
        "	",
        "\v",
        "\f"
    ], false, true);
    var peg$e76 = peg$literalExpectation("@", false);
    var peg$e77 = peg$literalExpectation("#include <", false);
    var peg$e78 = peg$literalExpectation("_Static_assert", false);
    var peg$e79 = peg$literalExpectation("_Thread_local", false);
    var peg$e80 = peg$literalExpectation("_Imaginary", false);
    var peg$e81 = peg$literalExpectation("_Noreturn", false);
    var peg$e82 = peg$literalExpectation("register", false);
    var peg$e83 = peg$literalExpectation("restrict", false);
    var peg$e84 = peg$literalExpectation("volatile", false);
    var peg$e85 = peg$literalExpectation("_Alignas", false);
    var peg$e86 = peg$literalExpectation("_Alignof", false);
    var peg$e87 = peg$literalExpectation("_Complex", false);
    var peg$e88 = peg$literalExpectation("_Generic", false);
    var peg$e89 = peg$literalExpectation("_Atomic", false);
    var peg$e90 = peg$literalExpectation("extern", false);
    var peg$e91 = peg$literalExpectation("inline", false);
    var peg$e92 = peg$literalExpectation("union", false);
    var peg$e93 = peg$literalExpectation("_Bool", false);
    var peg$e94 = peg$literalExpectation("goto", false);
    var peg$e95 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        "_"
    ], false, true);
    var peg$e96 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "_"
    ], false, true);
    var peg$e97 = peg$literalExpectation("0", false);
    var peg$e98 = peg$classExpectation([
        [
            "1",
            "9"
        ]
    ], false, false);
    var peg$e99 = peg$classExpectation([
        [
            "0",
            "9"
        ]
    ], false, false);
    var peg$e100 = peg$classExpectation([
        [
            "0",
            "7"
        ]
    ], false, false);
    var peg$e101 = peg$literalExpectation("0x", false);
    var peg$e102 = peg$literalExpectation("0X", false);
    var peg$e103 = peg$classExpectation([
        [
            "0",
            "9"
        ],
        [
            "A",
            "F"
        ]
    ], false, true);
    var peg$e104 = peg$literalExpectation("u", false);
    var peg$e105 = peg$literalExpectation("U", false);
    var peg$e106 = peg$literalExpectation("l", false);
    var peg$e107 = peg$literalExpectation("L", false);
    var peg$e108 = peg$literalExpectation("ll", false);
    var peg$e109 = peg$literalExpectation("LL", false);
    var peg$e110 = peg$literalExpectation("e", false);
    var peg$e111 = peg$literalExpectation("E", false);
    var peg$e112 = peg$classExpectation([
        "f",
        "l"
    ], false, true);
    var peg$e113 = peg$literalExpectation("'", false);
    var peg$e114 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "!",
        '"',
        "#",
        "%",
        "&",
        "(",
        ")",
        "*",
        "+",
        [
            ",",
            "."
        ],
        "/",
        ":",
        " ",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "^",
        "_",
        "{",
        "|",
        "}",
        "~",
        "	",
        "\v",
        "\f"
    ], false, true);
    var peg$e115 = peg$literalExpectation("\\'", false);
    var peg$e116 = peg$literalExpectation('\\"', false);
    var peg$e117 = peg$literalExpectation("\\?", false);
    var peg$e118 = peg$literalExpectation("\\\\", false);
    var peg$e119 = peg$literalExpectation("\\a", false);
    var peg$e120 = peg$literalExpectation("\\b", false);
    var peg$e121 = peg$literalExpectation("\\f", false);
    var peg$e122 = peg$literalExpectation("\\r", false);
    var peg$e123 = peg$literalExpectation("\\n", false);
    var peg$e124 = peg$literalExpectation("\\t", false);
    var peg$e125 = peg$literalExpectation("\\v", false);
    var peg$e126 = peg$literalExpectation("\\", false);
    var peg$e127 = peg$literalExpectation("\\x", false);
    var peg$e128 = peg$literalExpectation('"', false);
    var peg$e129 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "0",
            "9"
        ],
        "!",
        "'",
        "#",
        "%",
        "&",
        "(",
        ")",
        "*",
        "+",
        [
            ",",
            "."
        ],
        "/",
        ":",
        " ",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "^",
        "_",
        "{",
        "|",
        "}",
        "~",
        "	",
        "\v",
        "\f"
    ], false, true);
    var peg$e130 = peg$literalExpectation("%:%:", false);
    var peg$e131 = peg$literalExpectation("...", false);
    var peg$e132 = peg$literalExpectation("##", false);
    var peg$e133 = peg$literalExpectation("%:", false);
    var peg$e134 = peg$literalExpectation("<:", false);
    var peg$e135 = peg$literalExpectation(":>", false);
    var peg$e136 = peg$literalExpectation("<%", false);
    var peg$e137 = peg$literalExpectation("%>", false);
    var peg$e138 = peg$literalExpectation("#", false);
    var peg$f0 = function(includedModules, rootNode) {
        rootNode.includedModules = includedModules;
        return {
            compilationErrors: compilationErrors,
            warnings: warnings,
            rootNode: rootNode
        };
    };
    var peg$f1 = function(rootNode) {
        rootNode.includedModules = [];
        return {
            compilationErrors: compilationErrors,
            warnings: warnings,
            rootNode: rootNode
        };
    };
    var peg$f2 = function(items) {
        return createRootNode(items);
    };
    var peg$f3 = function(declarationSpecifier, declarator, body) {
        return generateFunctionDefinitionNode([
            declarationSpecifier
        ], declarator, body);
    };
    var peg$f4 = function(declarationSpecifiers, declarator, body) {
        return generateFunctionDefinitionNode(declarationSpecifiers, declarator, body);
    };
    var peg$f5 = function(statements) {
        return createBlockNode(statements);
    };
    var peg$f6 = function() {
        return createBlockNode([]);
    };
    var peg$f7 = function(expr) {
        return generateNode("ReturnStatement", {
            value: expr === null ? undefined : expr
        });
    };
    var peg$f8 = function() {
        return generateNode("BreakStatement");
    };
    var peg$f9 = function() {
        return generateNode("ContinueStatement");
    };
    var peg$f10 = function(body, condition) {
        return generateNode("DoWhileLoop", {
            condition: condition,
            body: body
        });
    };
    var peg$f11 = function(condition, body) {
        return generateNode("WhileLoop", {
            condition: condition,
            body: body
        });
    };
    var peg$f12 = function(clause, condition, update, body) {
        return generateNode("ForLoop", {
            clause: clause === null ? null : {
                type: "Expression",
                value: clause
            },
            condition: condition,
            update: update,
            body: body
        });
    };
    var peg$f13 = function(clause, condition, update, body) {
        return createDeclarationForLoopNode(clause, condition, update, body);
    };
    var peg$f14 = function(condition, ifStatement, elseStatement) {
        return generateNode("SelectionStatement", {
            condition: condition,
            ifStatement: ifStatement,
            elseStatement: elseStatement
        });
    };
    var peg$f15 = function(condition, ifStatement) {
        return generateNode("SelectionStatement", {
            condition: condition,
            ifStatement: ifStatement
        });
    };
    var peg$f16 = function(targetExpression, cases, defaultStatements) {
        return createSwitchStatementNode(targetExpression, cases, defaultStatements ?? []);
    };
    var peg$f17 = function(targetExpression, defaultStatements) {
        return createSwitchStatementNode(targetExpression, [], defaultStatements);
    };
    var peg$f18 = function(targetExpression) {
        return createSwitchStatementNode(targetExpression, [], []);
    };
    var peg$f19 = function(targetExpression) {
        warn("Statement will never be executed");
        return createSwitchStatementNode(targetExpression, [], []);
    };
    var peg$f20 = function() {
        return [];
    };
    var peg$f21 = function(conditionMatch, statements) {
        return generateNode("SwitchStatementCase", {
            conditionMatch: conditionMatch,
            statements: statements
        });
    };
    var peg$f22 = function(conditionMatch) {
        return generateNode("SwitchStatementCase", {
            conditionMatch: conditionMatch,
            statements: []
        });
    };
    var peg$f23 = function(declarationSpecifier, initDeclarators) {
        return processDeclaration([
            declarationSpecifier
        ], initDeclarators);
    };
    var peg$f24 = function(declarationSpecifiers, initDeclarators) {
        return processDeclaration(declarationSpecifiers, initDeclarators);
    };
    var peg$f25 = function(declarationSpecifiers, initDeclarators) {
        return processDeclaration(declarationSpecifiers, initDeclarators);
    };
    var peg$f26 = function(declarationSpecifiers) {
        return processDeclarationWithoutDeclarator(declarationSpecifiers);
    };
    var peg$f27 = function(specifier) {
        return generateNode("TypeSpecifier", {
            specifier: specifier
        });
    };
    var peg$f28 = function() {
        return generateNode("TypeQualifier", {
            qualifier: "const"
        });
    };
    var peg$f29 = function(specifier) {
        return generateNode("StorageClassSpecifier", {
            specifier: specifier
        });
    };
    var peg$f30 = function() {
        return {
            type: "TypeDefSpecifier"
        };
    };
    var peg$f31 = function(specifier) {
        return generateNode("PrimaryTypeSpecifier", {
            specifier: specifier
        });
    };
    var peg$f32 = function(specifier) {
        return generateNode("StructTypeSpecifier", {
            specifier: specifier
        });
    };
    var peg$f33 = function(specifier) {
        return generateNode("PrimaryDataTypeLengthSpecifier", {
            specifier: specifier
        });
    };
    var peg$f34 = function(specifier) {
        return generateNode("IntegerSignSpecifier", {
            specifier: specifier
        });
    };
    var peg$f35 = function() {
        return generateNode("VoidTypeSpecifier");
    };
    var peg$f36 = function(specifier) {
        return generateNode("EnumTypeSpecifier", {
            specifier: specifier
        });
    };
    var peg$f37 = function(typeName) {
        return generateNode("UserNamedTypeSpecifier", {
            typeName: typeName
        });
    };
    var peg$f38 = function(name) {
        return isIdentifierAType(name);
    };
    var peg$f39 = function(name) {
        return name;
    };
    var peg$f40 = function(declarator, initializer) {
        return {
            ...declarator,
            initializer: initializer
        };
    };
    var peg$f41 = function(pointers, directDeclarator) {
        return createPointerDeclaratorNode(pointers, directDeclarator);
    };
    var peg$f42 = function(directDeclarator) {
        return directDeclarator;
    };
    var peg$f43 = function(qualifier) {
        return {
            type: "pointer",
            isConst: qualifier !== null
        };
    };
    var peg$f44 = function(value) {
        return createInitializerSingle(value);
    };
    var peg$f45 = function(list) {
        return createInitializerList(list);
    };
    var peg$f46 = function(directDeclarator, declaratorSuffixes) {
        return evaluateDeclaratorSuffixes(directDeclarator, declaratorSuffixes);
    };
    var peg$f47 = function(directDeclarator) {
        return evaluateDeclaratorSuffixes(directDeclarator, []);
    };
    var peg$f48 = function(symbolName) {
        return {
            type: "SymbolDeclarator",
            symbolName: symbolName
        };
    };
    var peg$f49 = function(parameters) {
        return createFunctionDeclarator(parameters);
    };
    var peg$f50 = function() {
        return createFunctionDeclarator();
    };
    var peg$f51 = function(numElements) {
        return {
            type: "ArrayDeclarator",
            numElements: numElements !== null ? numElements : undefined
        };
    };
    var peg$f52 = function(tag, fieldDeclarations) {
        return generateNode(tag === null ? "AnonymousStruct" : "NamedStructDefinition", createStructSpecifier(fieldDeclarations, tag));
    };
    var peg$f53 = function(tag) {
        return generateNode(tag === null ? "AnonymousStruct" : "NamedStructDefinition", createEmptyStructSpecifier(tag));
    };
    var peg$f54 = function(tag) {
        return generateNode("NamedStructReference", {
            tag: tag
        });
    };
    var peg$f55 = function(declarations) {
        return unpackStructDeclarations(declarations);
    };
    var peg$f56 = function(specifier, declarators) {
        return processStructDeclaration([
            specifier
        ], declarators);
    };
    var peg$f57 = function(specifiers, declarators) {
        return processStructDeclaration(specifiers, declarators);
    };
    var peg$f58 = function(specifier) {
        return {
            type: "TypeSpecifier",
            specifier: specifier
        };
    };
    var peg$f59 = function(tag, enumerators) {
        return generateNode("NamedDefinedEnum", {
            tag: tag,
            enumerators: enumerators
        });
    };
    var peg$f60 = function(enumerators) {
        return generateNode("AnonymousEnum", {
            enumerators: enumerators
        });
    };
    var peg$f61 = function(tag) {
        return generateNode("NamedEnumReference", {
            tag: tag
        });
    };
    var peg$f62 = function(name, value) {
        return {
            name: name,
            value: value
        };
    };
    var peg$f63 = function(name) {
        return {
            name: name
        };
    };
    var peg$f64 = function(parameters) {
        return unpackParameters(parameters);
    };
    var peg$f65 = function(declarationSpecifier, declarator) {
        return processParameterDeclaration([
            declarationSpecifier
        ], declarator);
    };
    var peg$f66 = function(declarationSpecifiers, declarator) {
        return processParameterDeclaration(declarationSpecifiers, declarator);
    };
    var peg$f67 = function(declarationSpecifiers, abstractDeclarator) {
        return processParameterDeclaration(declarationSpecifiers, abstractDeclarator);
    };
    var peg$f68 = function(declarationSpecifiers) {
        return processParameterDeclaration(declarationSpecifiers, null);
    };
    var peg$f69 = function(pointers, directAbstractDeclarator) {
        return createPointerDeclaratorNode(pointers, directAbstractDeclarator);
    };
    var peg$f70 = function(pointers) {
        return createPointerDeclaratorNode(pointers, {
            type: "AbstractDeclarator"
        });
    };
    var peg$f71 = function(directAbstractDeclarator) {
        return directAbstractDeclarator;
    };
    var peg$f72 = function(directAbstractDeclarator, declaratorSuffixes) {
        return evaluateDeclaratorSuffixes(directAbstractDeclarator, declaratorSuffixes);
    };
    var peg$f73 = function(declaratorSuffixes) {
        return evaluateDeclaratorSuffixes({
            type: "AbstractDeclarator"
        }, declaratorSuffixes);
    };
    var peg$f74 = function(expressions) {
        return generateNode("CommaSeparatedExpressions", {
            expressions: expressions
        });
    };
    var peg$f75 = function(lvalue, assignmentOperator, assignedExpression) {
        return createAssignmentNode(lvalue, assignedExpression, assignmentOperator);
    };
    var peg$f76 = function(condition, trueExpression, falseExpression) {
        return generateNode("ConditionalExpression", {
            condition: condition,
            trueExpression: trueExpression,
            falseExpression: falseExpression
        });
    };
    var peg$f77 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f78 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f79 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f80 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f81 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f82 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f83 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f84 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f85 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f86 = function(firstExpr, tail) {
        return createLeftToRightBinaryExpressionTree(firstExpr, tail);
    };
    var peg$f87 = function(operations, firstExpr) {
        return createPrefixExpressionNode(firstExpr, operations);
    };
    var peg$f88 = function(operator) {
        return {
            type: "PrefixExpression",
            operator: operator
        };
    };
    var peg$f89 = function(operator) {
        return {
            type: "PrefixExpression",
            operator: operator
        };
    };
    var peg$f90 = function(operator) {
        return {
            type: "PointerDereference"
        };
    };
    var peg$f91 = function() {
        return {
            type: "AddressOfExpression"
        };
    };
    var peg$f92 = function() {
        return {
            type: "SizeOfExpression",
            subtype: "expression"
        };
    };
    var peg$f93 = function(firstExpr, operations) {
        return createPostfixExpressionNode(firstExpr, operations);
    };
    var peg$f94 = function(operator) {
        return generateNode("PostfixExpression", {
            operator: operator
        });
    };
    var peg$f95 = function(args) {
        return generateNode("FunctionCall", {
            args: args
        });
    };
    var peg$f96 = function() {
        return generateNode("FunctionCall", {
            args: []
        });
    };
    var peg$f97 = function(index) {
        return generateNode("ArrayElementExpr", {
            index: index
        });
    };
    var peg$f98 = function(fieldTag) {
        return generateNode("StructMemberAccess", {
            fieldTag: fieldTag
        });
    };
    var peg$f99 = function(fieldTag) {
        return generateNode("StructPointerMemberAccess", {
            fieldTag: fieldTag
        });
    };
    var peg$f100 = function(dataType) {
        return createSizeOfDataTypeExpression(dataType);
    };
    var peg$f101 = function(name) {
        return isIdentifierAType(name);
    };
    var peg$f102 = function(name) {
        return generateNode("IdentifierExpression", {
            name: name
        });
    };
    var peg$f103 = function(specifiers, declarator) {
        return generateDataTypeFromSpecifierAndAbstractDeclarators(specifiers, declarator);
    };
    var peg$f104 = function(identifier) {
        addIncludedModuleDefinitions(identifier);
        return identifier;
    };
    var peg$f105 = function(str) {
        return isStringAKeyword(str) ? false : true;
    };
    var peg$f106 = function(str) {
        return str;
    };
    var peg$f107 = function(value, suffix) {
        return generateIntegerConstant(value, suffix);
    };
    var peg$f108 = function(value) {
        return "0o" + value;
    };
    var peg$f109 = function(value, suffix) {
        return generateFloatConstant(value, suffix);
    };
    var peg$f110 = function(value, suffix) {
        return generateFloatConstant(value, suffix);
    };
    var peg$f111 = function(name) {
        return isIdentifierAType(name);
    };
    var peg$f112 = function(name) {
        return name;
    };
    var peg$f113 = function(value) {
        return generateNode("IntegerConstant", {
            value: BigInt(value)
        });
    };
    var peg$f114 = function(char) {
        return char.charCodeAt(0);
    };
    var peg$f115 = function(char) {
        return char.charCodeAt(0);
    };
    var peg$f116 = function() {
        return 39;
    };
    var peg$f117 = function() {
        return 34;
    };
    var peg$f118 = function() {
        return 63;
    };
    var peg$f119 = function() {
        return 92;
    };
    var peg$f120 = function() {
        return 7;
    };
    var peg$f121 = function() {
        return 8;
    };
    var peg$f122 = function() {
        return 12;
    };
    var peg$f123 = function() {
        return 13;
    };
    var peg$f124 = function() {
        return 10;
    };
    var peg$f125 = function() {
        return 9;
    };
    var peg$f126 = function() {
        return 11;
    };
    var peg$f127 = function(value) {
        return parseInt(value, 8);
    };
    var peg$f128 = function(value) {
        return parseInt(value, 16);
    };
    var peg$f129 = function(chars) {
        chars.push(0);
        return generateNode("StringLiteral", {
            chars: chars
        });
    };
    var peg$f130 = function(char) {
        return char.charCodeAt(0);
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$resultsCache = {};
    var peg$result;
    if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
        return peg$savedPos;
    }
    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos
        };
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
    }
    function peg$literalExpectation(text, ignoreCase) {
        return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        if (offset && peg$source && typeof peg$source.offset === "function") {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
        return new $998a69218af07240$var$peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new $998a69218af07240$var$peg$SyntaxError($998a69218af07240$var$peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parseprogram() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 0;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parseinclude();
        while(s3 !== peg$FAILED){
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                s4 = peg$parseinclude();
                if (s4 === peg$FAILED) {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                } else s3 = s4;
            } else s3 = s4;
        }
        if (s2.length < 1) {
            peg$currPos = s1;
            s1 = peg$FAILED;
        } else s1 = s2;
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsetranslation_unit();
                s4 = peg$parse_();
                if (s4 === peg$FAILED) s4 = null;
                peg$savedPos = s0;
                s0 = peg$f0(s1, s3);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetranslation_unit();
            s2 = peg$parse_();
            if (s2 === peg$FAILED) s2 = null;
            peg$savedPos = s0;
            s0 = peg$f1(s1);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parse_() {
        var s0, s1;
        var key = peg$currPos * 105 + 1;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 32) {
            s0 = peg$c0;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e1);
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e0);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetranslation_unit() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 2;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsefunction_definition();
        if (s2 === peg$FAILED) s2 = peg$parsedeclaration();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s3 = peg$parsefunction_definition();
                if (s3 === peg$FAILED) s3 = peg$parsedeclaration();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        peg$savedPos = s0;
        s1 = peg$f2(s1);
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefunction_definition() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 3;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedeclaration_specifier();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsedeclarator();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsecompound_statement();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f3(s1, s3, s5);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedeclaration_specifiers();
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsedeclarator();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parsecompound_statement();
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f4(s1, s3, s5);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestatement() {
        var s0;
        var key = peg$currPos * 105 + 4;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parseiteration_statement();
        if (s0 === peg$FAILED) {
            s0 = peg$parsecompound_statement();
            if (s0 === peg$FAILED) {
                s0 = peg$parsejump_statement();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseexpression_statement();
                    if (s0 === peg$FAILED) s0 = peg$parseselection_statement();
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsecompound_statement() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 5;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        peg$silentFails++;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c1;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e3);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseblock_item_list();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                            s5 = peg$c2;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e4);
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f5(s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
                s1 = peg$c1;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e3);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                        s3 = peg$c2;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e4);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f6();
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e2);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseblock_item_list() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 6;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseblock_item();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s3 = peg$parseblock_item();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseblock_item() {
        var s0;
        var key = peg$currPos * 105 + 7;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsestatement();
        if (s0 === peg$FAILED) s0 = peg$parsedeclaration();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsejump_statement() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 8;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c3) {
            s1 = peg$c3;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e5);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseexpression();
                if (s4 !== peg$FAILED) s2 = s4;
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) s2 = null;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                    s4 = peg$c4;
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e6);
                }
                if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f7(s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c5) {
                s1 = peg$c5;
                peg$currPos += 5;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e7);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 59) {
                        s3 = peg$c4;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e6);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f8();
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 8) === peg$c6) {
                    s1 = peg$c6;
                    peg$currPos += 8;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e8);
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                            s3 = peg$c4;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e6);
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f9();
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseexpression_statement() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 9;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseexpression();
        if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) s1 = s2;
            else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
        } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) s1 = null;
        if (input.charCodeAt(peg$currPos) === 59) {
            s2 = peg$c4;
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e6);
        }
        if (s2 !== peg$FAILED) s0 = s1;
        else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseiteration_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
        var key = peg$currPos * 105 + 10;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c7) {
            s1 = peg$c7;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e9);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsestatement();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c8) {
                            s5 = peg$c8;
                            peg$currPos += 5;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e10);
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 40) {
                                    s7 = peg$c9;
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e11);
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parse_();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseexpression();
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$parse_();
                                            if (s10 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 41) {
                                                    s11 = peg$c10;
                                                    peg$currPos++;
                                                } else {
                                                    s11 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e12);
                                                }
                                                if (s11 !== peg$FAILED) {
                                                    s12 = peg$parse_();
                                                    if (s12 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 59) {
                                                            s13 = peg$c4;
                                                            peg$currPos++;
                                                        } else {
                                                            s13 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$e6);
                                                        }
                                                        if (s13 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s0 = peg$f10(s3, s9);
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c8) {
                s1 = peg$c8;
                peg$currPos += 5;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e10);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s3 = peg$c9;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e11);
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseexpression();
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 41) {
                                        s7 = peg$c10;
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e12);
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s8 = peg$parse_();
                                        if (s8 !== peg$FAILED) {
                                            s9 = peg$parsestatement();
                                            if (s9 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s0 = peg$f11(s5, s9);
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c11) {
                    s1 = peg$c11;
                    peg$currPos += 3;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e13);
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 40) {
                            s3 = peg$c9;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e11);
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 !== peg$FAILED) {
                                s5 = peg$currPos;
                                s6 = peg$parseexpression();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parse_();
                                    if (s7 !== peg$FAILED) s5 = s6;
                                    else {
                                        peg$currPos = s5;
                                        s5 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s5;
                                    s5 = peg$FAILED;
                                }
                                if (s5 === peg$FAILED) s5 = null;
                                if (input.charCodeAt(peg$currPos) === 59) {
                                    s6 = peg$c4;
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e6);
                                }
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parse_();
                                    if (s7 !== peg$FAILED) {
                                        s8 = peg$currPos;
                                        s9 = peg$parseexpression();
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$parse_();
                                            if (s10 !== peg$FAILED) s8 = s9;
                                            else {
                                                peg$currPos = s8;
                                                s8 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s8;
                                            s8 = peg$FAILED;
                                        }
                                        if (s8 === peg$FAILED) s8 = null;
                                        if (input.charCodeAt(peg$currPos) === 59) {
                                            s9 = peg$c4;
                                            peg$currPos++;
                                        } else {
                                            s9 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e6);
                                        }
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$parse_();
                                            if (s10 !== peg$FAILED) {
                                                s11 = peg$currPos;
                                                s12 = peg$parseexpression();
                                                if (s12 !== peg$FAILED) {
                                                    s13 = peg$parse_();
                                                    if (s13 !== peg$FAILED) s11 = s12;
                                                    else {
                                                        peg$currPos = s11;
                                                        s11 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s11;
                                                    s11 = peg$FAILED;
                                                }
                                                if (s11 === peg$FAILED) s11 = null;
                                                if (input.charCodeAt(peg$currPos) === 41) {
                                                    s12 = peg$c10;
                                                    peg$currPos++;
                                                } else {
                                                    s12 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e12);
                                                }
                                                if (s12 !== peg$FAILED) {
                                                    s13 = peg$parse_();
                                                    if (s13 !== peg$FAILED) {
                                                        s14 = peg$parsestatement();
                                                        if (s14 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s0 = peg$f12(s5, s8, s11, s14);
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 3) === peg$c11) {
                        s1 = peg$c11;
                        peg$currPos += 3;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e13);
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 40) {
                                s3 = peg$c9;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e11);
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parsedeclaration();
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$currPos;
                                            s8 = peg$parseexpression();
                                            if (s8 !== peg$FAILED) {
                                                s9 = peg$parse_();
                                                if (s9 !== peg$FAILED) s7 = s8;
                                                else {
                                                    peg$currPos = s7;
                                                    s7 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s7;
                                                s7 = peg$FAILED;
                                            }
                                            if (s7 === peg$FAILED) s7 = null;
                                            if (input.charCodeAt(peg$currPos) === 59) {
                                                s8 = peg$c4;
                                                peg$currPos++;
                                            } else {
                                                s8 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e6);
                                            }
                                            if (s8 !== peg$FAILED) {
                                                s9 = peg$parse_();
                                                if (s9 !== peg$FAILED) {
                                                    s10 = peg$currPos;
                                                    s11 = peg$parseexpression();
                                                    if (s11 !== peg$FAILED) {
                                                        s12 = peg$parse_();
                                                        if (s12 !== peg$FAILED) s10 = s11;
                                                        else {
                                                            peg$currPos = s10;
                                                            s10 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s10;
                                                        s10 = peg$FAILED;
                                                    }
                                                    if (s10 === peg$FAILED) s10 = null;
                                                    if (input.charCodeAt(peg$currPos) === 41) {
                                                        s11 = peg$c10;
                                                        peg$currPos++;
                                                    } else {
                                                        s11 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e12);
                                                    }
                                                    if (s11 !== peg$FAILED) {
                                                        s12 = peg$parse_();
                                                        if (s12 !== peg$FAILED) {
                                                            s13 = peg$parsestatement();
                                                            if (s13 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s0 = peg$f13(s5, s7, s10, s13);
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseselection_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
        var key = peg$currPos * 105 + 11;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c12) {
            s1 = peg$c12;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e14);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                    s3 = peg$c9;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e11);
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseexpression();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                    s7 = peg$c10;
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e12);
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parse_();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parsestatement();
                                        if (s9 !== peg$FAILED) {
                                            s10 = peg$parse_();
                                            if (s10 !== peg$FAILED) {
                                                if (input.substr(peg$currPos, 4) === peg$c13) {
                                                    s11 = peg$c13;
                                                    peg$currPos += 4;
                                                } else {
                                                    s11 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e15);
                                                }
                                                if (s11 !== peg$FAILED) {
                                                    s12 = peg$parse_();
                                                    if (s12 !== peg$FAILED) {
                                                        s13 = peg$parsestatement();
                                                        if (s13 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s0 = peg$f14(s5, s9, s13);
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c12) {
                s1 = peg$c12;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e14);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s3 = peg$c9;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e11);
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseexpression();
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 41) {
                                        s7 = peg$c10;
                                        peg$currPos++;
                                    } else {
                                        s7 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e12);
                                    }
                                    if (s7 !== peg$FAILED) {
                                        s8 = peg$parse_();
                                        if (s8 !== peg$FAILED) {
                                            s9 = peg$parsestatement();
                                            if (s9 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s0 = peg$f15(s5, s9);
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c14) {
                    s1 = peg$c14;
                    peg$currPos += 6;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e16);
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 40) {
                            s3 = peg$c9;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e11);
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseexpression();
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$parse_();
                                    if (s6 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s7 = peg$c10;
                                            peg$currPos++;
                                        } else {
                                            s7 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e12);
                                        }
                                        if (s7 !== peg$FAILED) {
                                            s8 = peg$parse_();
                                            if (s8 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 123) {
                                                    s9 = peg$c1;
                                                    peg$currPos++;
                                                } else {
                                                    s9 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e3);
                                                }
                                                if (s9 !== peg$FAILED) {
                                                    s10 = peg$parse_();
                                                    if (s10 !== peg$FAILED) {
                                                        s11 = peg$currPos;
                                                        s12 = [];
                                                        s13 = peg$parseswitch_statement_case();
                                                        while(s13 !== peg$FAILED){
                                                            s12.push(s13);
                                                            s13 = peg$currPos;
                                                            s14 = peg$parse_();
                                                            if (s14 !== peg$FAILED) {
                                                                s14 = peg$parseswitch_statement_case();
                                                                if (s14 === peg$FAILED) {
                                                                    peg$currPos = s13;
                                                                    s13 = peg$FAILED;
                                                                } else s13 = s14;
                                                            } else s13 = s14;
                                                        }
                                                        if (s12.length < 1) {
                                                            peg$currPos = s11;
                                                            s11 = peg$FAILED;
                                                        } else s11 = s12;
                                                        if (s11 !== peg$FAILED) {
                                                            s12 = peg$currPos;
                                                            s13 = peg$parse_();
                                                            if (s13 !== peg$FAILED) {
                                                                s14 = peg$parseswitch_default_case();
                                                                if (s14 !== peg$FAILED) s12 = s14;
                                                                else {
                                                                    peg$currPos = s12;
                                                                    s12 = peg$FAILED;
                                                                }
                                                            } else {
                                                                peg$currPos = s12;
                                                                s12 = peg$FAILED;
                                                            }
                                                            if (s12 === peg$FAILED) s12 = null;
                                                            s13 = peg$parse_();
                                                            if (s13 !== peg$FAILED) {
                                                                if (input.charCodeAt(peg$currPos) === 125) {
                                                                    s14 = peg$c2;
                                                                    peg$currPos++;
                                                                } else {
                                                                    s14 = peg$FAILED;
                                                                    if (peg$silentFails === 0) peg$fail(peg$e4);
                                                                }
                                                                if (s14 !== peg$FAILED) {
                                                                    peg$savedPos = s0;
                                                                    s0 = peg$f16(s5, s11, s12);
                                                                } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 6) === peg$c14) {
                        s1 = peg$c14;
                        peg$currPos += 6;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e16);
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 40) {
                                s3 = peg$c9;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e11);
                            }
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    s5 = peg$parseexpression();
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 !== peg$FAILED) {
                                            if (input.charCodeAt(peg$currPos) === 41) {
                                                s7 = peg$c10;
                                                peg$currPos++;
                                            } else {
                                                s7 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e12);
                                            }
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parse_();
                                                if (s8 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 123) {
                                                        s9 = peg$c1;
                                                        peg$currPos++;
                                                    } else {
                                                        s9 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e3);
                                                    }
                                                    if (s9 !== peg$FAILED) {
                                                        s10 = peg$parse_();
                                                        if (s10 !== peg$FAILED) {
                                                            s11 = peg$parseswitch_default_case();
                                                            if (s11 !== peg$FAILED) {
                                                                s12 = peg$parse_();
                                                                if (s12 !== peg$FAILED) {
                                                                    if (input.charCodeAt(peg$currPos) === 125) {
                                                                        s13 = peg$c2;
                                                                        peg$currPos++;
                                                                    } else {
                                                                        s13 = peg$FAILED;
                                                                        if (peg$silentFails === 0) peg$fail(peg$e4);
                                                                    }
                                                                    if (s13 !== peg$FAILED) {
                                                                        peg$savedPos = s0;
                                                                        s0 = peg$f17(s5, s11);
                                                                    } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$FAILED;
                                                                    }
                                                                } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 6) === peg$c14) {
                            s1 = peg$c14;
                            peg$currPos += 6;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e16);
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 40) {
                                    s3 = peg$c9;
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e11);
                                }
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parse_();
                                    if (s4 !== peg$FAILED) {
                                        s5 = peg$parseexpression();
                                        if (s5 !== peg$FAILED) {
                                            s6 = peg$parse_();
                                            if (s6 !== peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 41) {
                                                    s7 = peg$c10;
                                                    peg$currPos++;
                                                } else {
                                                    s7 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e12);
                                                }
                                                if (s7 !== peg$FAILED) {
                                                    s8 = peg$parse_();
                                                    if (s8 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 123) {
                                                            s9 = peg$c1;
                                                            peg$currPos++;
                                                        } else {
                                                            s9 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$e3);
                                                        }
                                                        if (s9 !== peg$FAILED) {
                                                            s10 = peg$parse_();
                                                            if (s10 !== peg$FAILED) {
                                                                if (input.charCodeAt(peg$currPos) === 125) {
                                                                    s11 = peg$c2;
                                                                    peg$currPos++;
                                                                } else {
                                                                    s11 = peg$FAILED;
                                                                    if (peg$silentFails === 0) peg$fail(peg$e4);
                                                                }
                                                                if (s11 !== peg$FAILED) {
                                                                    peg$savedPos = s0;
                                                                    s0 = peg$f18(s5);
                                                                } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 6) === peg$c14) {
                                s1 = peg$c14;
                                peg$currPos += 6;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e16);
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 40) {
                                        s3 = peg$c9;
                                        peg$currPos++;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e11);
                                    }
                                    if (s3 !== peg$FAILED) {
                                        s4 = peg$parse_();
                                        if (s4 !== peg$FAILED) {
                                            s5 = peg$parseexpression();
                                            if (s5 !== peg$FAILED) {
                                                s6 = peg$parse_();
                                                if (s6 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 41) {
                                                        s7 = peg$c10;
                                                        peg$currPos++;
                                                    } else {
                                                        s7 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e12);
                                                    }
                                                    if (s7 !== peg$FAILED) {
                                                        s8 = peg$parse_();
                                                        if (s8 !== peg$FAILED) {
                                                            s9 = peg$parsestatement();
                                                            if (s9 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s0 = peg$f19(s5);
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseswitch_default_case() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 12;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c15) {
            s1 = peg$c15;
            peg$currPos += 7;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e17);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                    s3 = peg$c16;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e18);
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseblock_item_list();
                        if (s5 !== peg$FAILED) s0 = s5;
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 7) === peg$c15) {
                s1 = peg$c15;
                peg$currPos += 7;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e17);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                        s3 = peg$c16;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e18);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f20();
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseswitch_statement_case() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 13;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c17) {
            s1 = peg$c17;
            peg$currPos += 4;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e19);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseconditional_expression();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 58) {
                            s5 = peg$c16;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e18);
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseblock_item_list();
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f21(s3, s7);
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c17) {
                s1 = peg$c17;
                peg$currPos += 4;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e19);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseconditional_expression();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 58) {
                                s5 = peg$c16;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e18);
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f22(s3);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedeclaration() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 14;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedeclaration_specifier();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseinit_declarator_list();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                            s5 = peg$c4;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e6);
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f23(s1, s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsedeclaration_specifier();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                if (s2.length >= 2) s3 = peg$FAILED;
                else {
                    s3 = peg$currPos;
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s4 = peg$parsedeclaration_specifier();
                        if (s4 === peg$FAILED) {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        } else s3 = s4;
                    } else s3 = s4;
                }
            }
            if (s2.length < 2) {
                peg$currPos = s1;
                s1 = peg$FAILED;
            } else s1 = s2;
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseinit_declarator_list();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                                s5 = peg$c4;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e6);
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f24(s1, s3);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsedeclaration_specifiers();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseinit_declarator_list();
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 59) {
                                    s5 = peg$c4;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e6);
                                }
                                if (s5 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f25(s1, s3);
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsedeclaration_specifiers();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                                s3 = peg$c4;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e6);
                            }
                            if (s3 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f26(s1);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedeclaration_specifiers() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 15;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedeclaration_specifier();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s3 = peg$parsedeclaration_specifier();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedeclaration_specifier() {
        var s0, s1;
        var key = peg$currPos * 105 + 16;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsetype_qualifier();
        if (s0 === peg$FAILED) {
            s0 = peg$parsestorage_class_specifier();
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsetype_specifier();
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f27(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) s0 = peg$parsetypedef_specifier();
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetype_qualifier() {
        var s0, s1;
        var key = peg$currPos * 105 + 17;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c18) {
            s1 = peg$c18;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e20);
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f28();
        }
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestorage_class_specifier() {
        var s0, s1;
        var key = peg$currPos * 105 + 18;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c19) {
            s1 = peg$c19;
            peg$currPos += 4;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e21);
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c20) {
                s1 = peg$c20;
                peg$currPos += 6;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e22);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f29(s1);
        }
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetypedef_specifier() {
        var s0, s1;
        var key = peg$currPos * 105 + 19;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 7) === peg$c21) {
            s1 = peg$c21;
            peg$currPos += 7;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e23);
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f30();
        }
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetype_specifier() {
        var s0, s1;
        var key = peg$currPos * 105 + 20;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseprimary_data_type_specifier();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f31(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsestruct_specifier();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f32(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseprimary_data_type_length_specifier();
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f33(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseinteger_sign_type_specifier();
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f34(s1);
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 4) === peg$c22) {
                            s1 = peg$c22;
                            peg$currPos += 4;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e24);
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f35();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parseenum_specifier();
                            if (s1 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$f36(s1);
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$parsetypedef_name();
                                if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$f37(s1);
                                }
                                s0 = s1;
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseprimary_data_type_specifier() {
        var s0;
        var key = peg$currPos * 105 + 21;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 4) === peg$c23) {
            s0 = peg$c23;
            peg$currPos += 4;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e25);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c24) {
                s0 = peg$c24;
                peg$currPos += 3;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e26);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c25) {
                    s0 = peg$c25;
                    peg$currPos += 5;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e27);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c26) {
                        s0 = peg$c26;
                        peg$currPos += 6;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e28);
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseprimary_data_type_length_specifier() {
        var s0;
        var key = peg$currPos * 105 + 22;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 4) === peg$c27) {
            s0 = peg$c27;
            peg$currPos += 4;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e29);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c28) {
                s0 = peg$c28;
                peg$currPos += 5;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e30);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinteger_sign_type_specifier() {
        var s0;
        var key = peg$currPos * 105 + 23;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 6) === peg$c29) {
            s0 = peg$c29;
            peg$currPos += 6;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e31);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c30) {
                s0 = peg$c30;
                peg$currPos += 8;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e32);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetypedef_name() {
        var s0, s1, s2;
        var key = peg$currPos * 105 + 24;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s2 = peg$f38(s1);
            if (s2) s2 = undefined;
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f39(s1);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinit_declarator_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 105 + 25;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseinit_declarator();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c31;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5,
                            s6
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                s3 = peg$parseinit_declarator();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinit_declarator() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 26;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedeclarator();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                    s3 = peg$c32;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e34);
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseinitializer();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f40(s1, s5);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsedeclarator();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedeclarator() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 27;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsepointer();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsedirect_declarator();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f41(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedirect_declarator();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f42(s1);
            }
            s0 = s1;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepointer() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 28;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsepointer_with_qualifier();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s3 = peg$parsepointer_with_qualifier();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepointer_with_qualifier() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 29;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 42) {
            s1 = peg$c33;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e35);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = [];
                s6 = peg$parsetype_qualifier();
                while(s6 !== peg$FAILED){
                    s5.push(s6);
                    s6 = peg$currPos;
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                        s7 = peg$parsetype_qualifier();
                        if (s7 === peg$FAILED) {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        } else s6 = s7;
                    } else s6 = s7;
                }
                if (s5.length < 1) {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                } else s4 = s5;
                if (s4 !== peg$FAILED) s2 = s4;
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) s2 = null;
            peg$savedPos = s0;
            s0 = peg$f43(s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinitializer() {
        var s0, s1;
        var key = peg$currPos * 105 + 30;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parselist_initializer();
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseassignment_expression();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f44(s1);
            }
            s0 = s1;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselist_initializer() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        var key = peg$currPos * 105 + 31;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c1;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e3);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$parseinitializer();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$currPos;
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 44) {
                            s8 = peg$c31;
                            peg$currPos++;
                        } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e33);
                        }
                        if (s8 !== peg$FAILED) {
                            s9 = peg$parse_();
                            if (s9 !== peg$FAILED) {
                                s7 = [
                                    s7,
                                    s8,
                                    s9
                                ];
                                s6 = s7;
                            } else {
                                peg$currPos = s6;
                                s6 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s6;
                            s6 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s6;
                        s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                        s6 = peg$parseinitializer();
                        if (s6 === peg$FAILED) {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        } else s5 = s6;
                    } else s5 = s6;
                }
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) s3 = s4;
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) s3 = null;
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c31;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s5 = [
                            s5,
                            s6
                        ];
                        s4 = s5;
                    } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
                if (s4 === peg$FAILED) s4 = null;
                if (input.charCodeAt(peg$currPos) === 125) {
                    s5 = peg$c2;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e4);
                }
                if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f45(s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedirect_declarator() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 105 + 32;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedirect_declarator_helper();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$parsefunction_declarator_suffix();
                if (s5 === peg$FAILED) s5 = peg$parsearray_declarator_suffix();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s6 = peg$parsefunction_declarator_suffix();
                        if (s6 === peg$FAILED) s6 = peg$parsearray_declarator_suffix();
                        if (s6 === peg$FAILED) {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        } else s5 = s6;
                    } else s5 = s6;
                }
                if (s4.length < 1) {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                } else s3 = s4;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f46(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedirect_declarator_helper();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f47(s1);
            }
            s0 = s1;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedirect_declarator_helper() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 33;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f48(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c9;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e11);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsedeclarator();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s5 = peg$c10;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e12);
                            }
                            if (s5 !== peg$FAILED) s0 = s3;
                            else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefunction_declarator_suffix() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 34;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c9;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseparameter_list();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s5 = peg$c10;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e12);
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f49(s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c9;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e11);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s3 = peg$c10;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e12);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f50();
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsearray_declarator_suffix() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 35;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c34;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e36);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseassignment_expression();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) s3 = s4;
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) s3 = null;
                if (input.charCodeAt(peg$currPos) === 93) {
                    s4 = peg$c35;
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e37);
                }
                if (s4 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f51(s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestruct_specifier() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        var key = peg$currPos * 105 + 36;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c36) {
            s1 = peg$c36;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e38);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseidentifier();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) s3 = s4;
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) s3 = null;
                if (input.charCodeAt(peg$currPos) === 123) {
                    s4 = peg$c1;
                    peg$currPos++;
                } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e3);
                }
                if (s4 !== peg$FAILED) {
                    s5 = peg$parse_();
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parsestruct_declaration_list();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parse_();
                            if (s7 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 125) {
                                    s8 = peg$c2;
                                    peg$currPos++;
                                } else {
                                    s8 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e4);
                                }
                                if (s8 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f52(s3, s6);
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 6) === peg$c36) {
                s1 = peg$c36;
                peg$currPos += 6;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e38);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    s4 = peg$parseidentifier();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parse_();
                        if (s5 !== peg$FAILED) s3 = s4;
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) s3 = null;
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s4 = peg$c1;
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e3);
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parse_();
                        if (s5 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                                s6 = peg$c2;
                                peg$currPos++;
                            } else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e4);
                            }
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f53(s3);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c36) {
                    s1 = peg$c36;
                    peg$currPos += 6;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e38);
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseidentifier();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f54(s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestruct_declaration_list() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 37;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parsestruct_declaration();
        while(s3 !== peg$FAILED){
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                s4 = peg$parsestruct_declaration();
                if (s4 === peg$FAILED) {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                } else s3 = s4;
            } else s3 = s4;
        }
        if (s2.length < 1) {
            peg$currPos = s1;
            s1 = peg$FAILED;
        } else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f55(s1);
        }
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestruct_declaration() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 38;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsespecifier_qualifier_list_item();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsestruct_declarator_list();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 59) {
                            s5 = peg$c4;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e6);
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f56(s1, s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsespecifier_qualifier_list();
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsestruct_declarator_list();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 59) {
                                s5 = peg$c4;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e6);
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f57(s1, s3);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsespecifier_qualifier_list() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 39;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsespecifier_qualifier_list_item();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s3 = peg$parsespecifier_qualifier_list_item();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsespecifier_qualifier_list_item() {
        var s0, s1;
        var key = peg$currPos * 105 + 40;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsetype_specifier();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f58(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) s0 = peg$parsetype_qualifier();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestruct_declarator_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 105 + 41;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedeclarator();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c31;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5,
                            s6
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                s3 = peg$parsedeclarator();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseenum_specifier() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        var key = peg$currPos * 105 + 42;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 4) === peg$c37) {
            s1 = peg$c37;
            peg$currPos += 4;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e39);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseidentifier();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 123) {
                            s5 = peg$c1;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e3);
                        }
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parseenumerator_list();
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parse_();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 44) {
                                            s10 = peg$c31;
                                            peg$currPos++;
                                        } else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e33);
                                        }
                                        if (s10 !== peg$FAILED) {
                                            s11 = peg$parse_();
                                            if (s11 !== peg$FAILED) {
                                                s10 = [
                                                    s10,
                                                    s11
                                                ];
                                                s9 = s10;
                                            } else {
                                                peg$currPos = s9;
                                                s9 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s9;
                                            s9 = peg$FAILED;
                                        }
                                        if (s9 === peg$FAILED) s9 = null;
                                        if (input.charCodeAt(peg$currPos) === 125) {
                                            s10 = peg$c2;
                                            peg$currPos++;
                                        } else {
                                            s10 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e4);
                                        }
                                        if (s10 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s0 = peg$f59(s3, s7);
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c37) {
                s1 = peg$c37;
                peg$currPos += 4;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e39);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 123) {
                        s3 = peg$c1;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e3);
                    }
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseenumerator_list();
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 44) {
                                        s8 = peg$c31;
                                        peg$currPos++;
                                    } else {
                                        s8 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e33);
                                    }
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parse_();
                                        if (s9 !== peg$FAILED) {
                                            s8 = [
                                                s8,
                                                s9
                                            ];
                                            s7 = s8;
                                        } else {
                                            peg$currPos = s7;
                                            s7 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s7;
                                        s7 = peg$FAILED;
                                    }
                                    if (s7 === peg$FAILED) s7 = null;
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s8 = peg$c2;
                                        peg$currPos++;
                                    } else {
                                        s8 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e4);
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f60(s5);
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 4) === peg$c37) {
                    s1 = peg$c37;
                    peg$currPos += 4;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e39);
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseidentifier();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f61(s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseenumerator_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 105 + 43;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseenumerator();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c31;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5,
                            s6
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                s3 = peg$parseenumerator();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseenumerator() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 44;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseenumeration_constant();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                    s3 = peg$c32;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e34);
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseconditional_expression();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f62(s1, s5);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseenumeration_constant();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f63(s1);
            }
            s0 = s1;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseparameter_list() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 45;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parseparameter_declaration();
        while(s3 !== peg$FAILED){
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c31;
                    peg$currPos++;
                } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                        s5 = [
                            s5,
                            s6,
                            s7
                        ];
                        s4 = s5;
                    } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                s4 = peg$parseparameter_declaration();
                if (s4 === peg$FAILED) {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                } else s3 = s4;
            } else s3 = s4;
        }
        if (s2.length < 1) {
            peg$currPos = s1;
            s1 = peg$FAILED;
        } else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f64(s1);
        }
        s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseparameter_declaration() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 46;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedeclaration_specifier();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsedeclarator();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f65(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedeclaration_specifiers();
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsedeclarator();
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f66(s1, s3);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsedeclaration_specifiers();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseabstract_declarator();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f67(s1, s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parsedeclaration_specifiers();
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f68(s1);
                    }
                    s0 = s1;
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseabstract_declarator() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 47;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsepointer();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsedirect_abstract_declarator();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f69(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsepointer();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f70(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsedirect_abstract_declarator();
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f71(s1);
                }
                s0 = s1;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedirect_abstract_declarator() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 105 + 48;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsedirect_abstract_declarator_helper();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$parsefunction_declarator_suffix();
                if (s5 === peg$FAILED) s5 = peg$parsearray_declarator_suffix();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$currPos;
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s6 = peg$parsefunction_declarator_suffix();
                        if (s6 === peg$FAILED) s6 = peg$parsearray_declarator_suffix();
                        if (s6 === peg$FAILED) {
                            peg$currPos = s5;
                            s5 = peg$FAILED;
                        } else s5 = s6;
                    } else s5 = s6;
                }
                if (s4.length < 1) {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                } else s3 = s4;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f72(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsefunction_declarator_suffix();
            if (s3 === peg$FAILED) s3 = peg$parsearray_declarator_suffix();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    s4 = peg$parsefunction_declarator_suffix();
                    if (s4 === peg$FAILED) s4 = peg$parsearray_declarator_suffix();
                    if (s4 === peg$FAILED) {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    } else s3 = s4;
                } else s3 = s4;
            }
            if (s2.length < 1) {
                peg$currPos = s1;
                s1 = peg$FAILED;
            } else s1 = s2;
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f73(s1);
            }
            s0 = s1;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedirect_abstract_declarator_helper() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 49;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c9;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseabstract_declarator();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s5 = peg$c10;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e12);
                        }
                        if (s5 !== peg$FAILED) s0 = s3;
                        else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseexpression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 50;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parseassignment_expression();
        while(s3 !== peg$FAILED){
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                    s6 = peg$c31;
                    peg$currPos++;
                } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                        s5 = [
                            s5,
                            s6,
                            s7
                        ];
                        s4 = s5;
                    } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                }
            } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
                s4 = peg$parseassignment_expression();
                if (s4 === peg$FAILED) {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                } else s3 = s4;
            } else s3 = s4;
        }
        if (s2.length < 2) {
            peg$currPos = s1;
            s1 = peg$FAILED;
        } else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f74(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) s0 = peg$parseassignment_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseassignment_expression() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 51;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseunary_expression();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseassignment_operator();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseassignment_expression();
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f75(s1, s3, s5);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parseconditional_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseassignment_operator() {
        var s0;
        var key = peg$currPos * 105 + 52;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 2) === peg$c38) {
            s0 = peg$c38;
            peg$currPos += 2;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e40);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c39) {
                s0 = peg$c39;
                peg$currPos += 2;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e41);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c40) {
                    s0 = peg$c40;
                    peg$currPos += 2;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e42);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c41) {
                        s0 = peg$c41;
                        peg$currPos += 2;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e43);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c42) {
                            s0 = peg$c42;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e44);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 3) === peg$c43) {
                                s0 = peg$c43;
                                peg$currPos += 3;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e45);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 3) === peg$c44) {
                                    s0 = peg$c44;
                                    peg$currPos += 3;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e46);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c45) {
                                        s0 = peg$c45;
                                        peg$currPos += 2;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e47);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c46) {
                                            s0 = peg$c46;
                                            peg$currPos += 2;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e48);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c47) {
                                                s0 = peg$c47;
                                                peg$currPos += 2;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e49);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 61) {
                                                    s0 = peg$c32;
                                                    peg$currPos++;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e34);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseconditional_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        var key = peg$currPos * 105 + 53;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parselogical_or_expression();
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 63) {
                    s3 = peg$c48;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e50);
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseexpression();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 58) {
                                    s7 = peg$c16;
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e18);
                                }
                                if (s7 !== peg$FAILED) {
                                    s8 = peg$parse_();
                                    if (s8 !== peg$FAILED) {
                                        s9 = peg$parseconditional_expression();
                                        if (s9 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s0 = peg$f76(s1, s5, s9);
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parselogical_or_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselogical_or_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 54;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parselogical_and_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c49) {
                    s5 = peg$c49;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e51);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parselogical_and_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c49) {
                        s5 = peg$c49;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e51);
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parselogical_and_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f77(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parselogical_and_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselogical_and_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 55;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsebitwise_or_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c50) {
                    s5 = peg$c50;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e52);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsebitwise_or_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c50) {
                        s5 = peg$c50;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e52);
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsebitwise_or_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f78(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsebitwise_or_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsebitwise_or_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 56;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsebitwise_xor_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 124) {
                    s5 = peg$c51;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e53);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsebitwise_xor_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 124) {
                        s5 = peg$c51;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e53);
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsebitwise_xor_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f79(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsebitwise_xor_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsebitwise_xor_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 57;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsebitwise_and_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 94) {
                    s5 = peg$c52;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e54);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsebitwise_and_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 94) {
                        s5 = peg$c52;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e54);
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsebitwise_and_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f80(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsebitwise_and_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsebitwise_and_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 58;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseequality_relational_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 38) {
                    s5 = peg$c53;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e55);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseequality_relational_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 38) {
                        s5 = peg$c53;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e55);
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseequality_relational_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f81(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parseequality_relational_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseequality_relational_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 59;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parserelative_relational_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c54) {
                    s5 = peg$c54;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e56);
                }
                if (s5 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c55) {
                        s5 = peg$c55;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e57);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parserelative_relational_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c54) {
                        s5 = peg$c54;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e56);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c55) {
                            s5 = peg$c55;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e57);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parserelative_relational_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f82(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parserelative_relational_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parserelative_relational_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 60;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsebitwise_shift_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c56) {
                    s5 = peg$c56;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e58);
                }
                if (s5 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c57) {
                        s5 = peg$c57;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e59);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 60) {
                            s5 = peg$c58;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e60);
                        }
                        if (s5 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 62) {
                                s5 = peg$c59;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e61);
                            }
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsebitwise_shift_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c56) {
                        s5 = peg$c56;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e58);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c57) {
                            s5 = peg$c57;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e59);
                        }
                        if (s5 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 60) {
                                s5 = peg$c58;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e60);
                            }
                            if (s5 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 62) {
                                    s5 = peg$c59;
                                    peg$currPos++;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e61);
                                }
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsebitwise_shift_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f83(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsebitwise_shift_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsebitwise_shift_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 61;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseadd_subtract_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c60) {
                    s5 = peg$c60;
                    peg$currPos += 2;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e62);
                }
                if (s5 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c61) {
                        s5 = peg$c61;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e63);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseadd_subtract_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c60) {
                        s5 = peg$c60;
                        peg$currPos += 2;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e62);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c61) {
                            s5 = peg$c61;
                            peg$currPos += 2;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e63);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseadd_subtract_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f84(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parseadd_subtract_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseadd_subtract_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 62;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsemultiply_divide_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 43) {
                    s5 = peg$c62;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e64);
                }
                if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s5 = peg$c63;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e65);
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsemultiply_divide_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 43) {
                        s5 = peg$c62;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e64);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 45) {
                            s5 = peg$c63;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e65);
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parsemultiply_divide_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f85(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsemultiply_divide_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsemultiply_divide_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 63;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseunary_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 42) {
                    s5 = peg$c33;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e35);
                }
                if (s5 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 47) {
                        s5 = peg$c64;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e66);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 37) {
                            s5 = peg$c65;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e67);
                        }
                    }
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parseunary_expression();
                        if (s7 !== peg$FAILED) s3 = [
                            s5,
                            s7
                        ];
                        else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 42) {
                        s5 = peg$c33;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e35);
                    }
                    if (s5 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 47) {
                            s5 = peg$c64;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e66);
                        }
                        if (s5 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 37) {
                                s5 = peg$c65;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e67);
                            }
                        }
                    }
                    if (s5 !== peg$FAILED) {
                        s6 = peg$parse_();
                        if (s6 !== peg$FAILED) {
                            s7 = peg$parseunary_expression();
                            if (s7 !== peg$FAILED) s3 = [
                                s5,
                                s7
                            ];
                            else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f86(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parseunary_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseunary_expression() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 64;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parseprefix_operation();
        if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) s2 = s3;
            else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parseprefix_operation();
            if (s3 !== peg$FAILED) {
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) s2 = s3;
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) {
            s2 = peg$parsepostfix_expression();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f87(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsepostfix_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseprefix_operation() {
        var s0, s1;
        var key = peg$currPos * 105 + 65;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c66) {
            s1 = peg$c66;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e68);
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c67) {
                s1 = peg$c67;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e69);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f88(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
                s1 = peg$c62;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e64);
            }
            if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c63;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e65);
                }
                if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 33) {
                        s1 = peg$c68;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e70);
                    }
                    if (s1 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 126) {
                            s1 = peg$c69;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e71);
                        }
                    }
                }
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f89(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 42) {
                    s1 = peg$c33;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e35);
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f90(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 38) {
                        s1 = peg$c53;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e55);
                    }
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f91();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 6) === peg$c70) {
                            s1 = peg$c70;
                            peg$currPos += 6;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e72);
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f92();
                        }
                        s0 = s1;
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepostfix_expression() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 66;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseprimary_expression();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                s5 = peg$parsepostfix_operation();
                if (s5 !== peg$FAILED) s3 = s5;
                else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$parse_();
                if (s4 !== peg$FAILED) {
                    s5 = peg$parsepostfix_operation();
                    if (s5 !== peg$FAILED) s3 = s5;
                    else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f93(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parseprimary_expression();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepostfix_operation() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 67;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c66) {
            s1 = peg$c66;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e68);
        }
        if (s1 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c67) {
                s1 = peg$c67;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e69);
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f94(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
                s1 = peg$c9;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e11);
            }
            if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsefunction_argument_list();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 41) {
                                s5 = peg$c10;
                                peg$currPos++;
                            } else {
                                s5 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e12);
                            }
                            if (s5 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f95(s3);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 40) {
                    s1 = peg$c9;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e11);
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parse_();
                    if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s3 = peg$c10;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e12);
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f96();
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 91) {
                        s1 = peg$c34;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e36);
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                            s3 = peg$parseexpression();
                            if (s3 !== peg$FAILED) {
                                s4 = peg$parse_();
                                if (s4 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 93) {
                                        s5 = peg$c35;
                                        peg$currPos++;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e37);
                                    }
                                    if (s5 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f97(s3);
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 46) {
                            s1 = peg$c71;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e73);
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parseidentifier();
                                if (s3 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f98(s3);
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 2) === peg$c72) {
                                s1 = peg$c72;
                                peg$currPos += 2;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e74);
                            }
                            if (s1 !== peg$FAILED) {
                                s2 = peg$parse_();
                                if (s2 !== peg$FAILED) {
                                    s3 = peg$parseidentifier();
                                    if (s3 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s0 = peg$f99(s3);
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefunction_argument_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        var key = peg$currPos * 105 + 68;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseassignment_expression();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                    s5 = peg$c31;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e33);
                }
                if (s5 !== peg$FAILED) {
                    s6 = peg$parse_();
                    if (s6 !== peg$FAILED) {
                        s4 = [
                            s4,
                            s5,
                            s6
                        ];
                        s3 = s4;
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                }
            } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
                s3 = peg$parseassignment_expression();
                if (s3 === peg$FAILED) {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                } else s2 = s3;
            } else s2 = s3;
        }
        if (s1.length < 1) {
            peg$currPos = s0;
            s0 = peg$FAILED;
        } else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseprimary_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        var key = peg$currPos * 105 + 69;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c70) {
            s1 = peg$c70;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e72);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                    s3 = peg$c9;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e11);
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parsetype_name();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 41) {
                                    s7 = peg$c10;
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e12);
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s0 = peg$f100(s5);
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseidentifier();
            if (s1 !== peg$FAILED) {
                peg$savedPos = peg$currPos;
                s2 = peg$f101(s1);
                if (s2) s2 = peg$FAILED;
                else s2 = undefined;
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f102(s1);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$parseconstant();
                if (s0 === peg$FAILED) {
                    s0 = peg$parsestring_literal();
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 40) {
                            s1 = peg$c9;
                            peg$currPos++;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e11);
                        }
                        if (s1 !== peg$FAILED) {
                            s2 = peg$parse_();
                            if (s2 !== peg$FAILED) {
                                s3 = peg$parseexpression();
                                if (s3 !== peg$FAILED) {
                                    s4 = peg$parse_();
                                    if (s4 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s5 = peg$c10;
                                            peg$currPos++;
                                        } else {
                                            s5 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e12);
                                        }
                                        if (s5 !== peg$FAILED) s0 = s3;
                                        else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetype_name() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 70;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsespecifier_qualifier_list();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
                s4 = peg$parseabstract_declarator();
                if (s4 !== peg$FAILED) s2 = s4;
                else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) s2 = null;
            peg$savedPos = s0;
            s0 = peg$f103(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsesource_character_set() {
        var s0, s1;
        var key = peg$currPos * 105 + 71;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e75);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        if (s0 === peg$FAILED) s0 = peg$parseextended_source_character_set();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseextended_source_character_set() {
        var s0;
        var key = peg$currPos * 105 + 72;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 64) {
            s0 = peg$c73;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e76);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsetoken() {
        var s0;
        var key = peg$currPos * 105 + 73;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parseinclude();
        if (s0 === peg$FAILED) {
            s0 = peg$parsekeyword();
            if (s0 === peg$FAILED) {
                s0 = peg$parseidentifier();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseconstant();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parsestring_literal();
                        if (s0 === peg$FAILED) s0 = peg$parsepunctuator();
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinclude() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 74;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 10) === peg$c74) {
            s1 = peg$c74;
            peg$currPos += 10;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e77);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseidentifier();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                    s3 = peg$c59;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e61);
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f104(s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsekeyword() {
        var s0;
        var key = peg$currPos * 105 + 75;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 14) === peg$c75) {
            s0 = peg$c75;
            peg$currPos += 14;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e78);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 13) === peg$c76) {
                s0 = peg$c76;
                peg$currPos += 13;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e79);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 10) === peg$c77) {
                    s0 = peg$c77;
                    peg$currPos += 10;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e80);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 9) === peg$c78) {
                        s0 = peg$c78;
                        peg$currPos += 9;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e81);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c6) {
                            s0 = peg$c6;
                            peg$currPos += 8;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e8);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c79) {
                                s0 = peg$c79;
                                peg$currPos += 8;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e82);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c80) {
                                    s0 = peg$c80;
                                    peg$currPos += 8;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e83);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 8) === peg$c30) {
                                        s0 = peg$c30;
                                        peg$currPos += 8;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e32);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 8) === peg$c81) {
                                            s0 = peg$c81;
                                            peg$currPos += 8;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e84);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 8) === peg$c82) {
                                                s0 = peg$c82;
                                                peg$currPos += 8;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e85);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 8) === peg$c83) {
                                                    s0 = peg$c83;
                                                    peg$currPos += 8;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e86);
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 8) === peg$c84) {
                                                        s0 = peg$c84;
                                                        peg$currPos += 8;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e87);
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 8) === peg$c85) {
                                                            s0 = peg$c85;
                                                            peg$currPos += 8;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$e88);
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 7) === peg$c15) {
                                                                s0 = peg$c15;
                                                                peg$currPos += 7;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$e17);
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 7) === peg$c21) {
                                                                    s0 = peg$c21;
                                                                    peg$currPos += 7;
                                                                } else {
                                                                    s0 = peg$FAILED;
                                                                    if (peg$silentFails === 0) peg$fail(peg$e23);
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 7) === peg$c86) {
                                                                        s0 = peg$c86;
                                                                        peg$currPos += 7;
                                                                    } else {
                                                                        s0 = peg$FAILED;
                                                                        if (peg$silentFails === 0) peg$fail(peg$e89);
                                                                    }
                                                                    if (s0 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 6) === peg$c87) {
                                                                            s0 = peg$c87;
                                                                            peg$currPos += 6;
                                                                        } else {
                                                                            s0 = peg$FAILED;
                                                                            if (peg$silentFails === 0) peg$fail(peg$e90);
                                                                        }
                                                                        if (s0 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 6) === peg$c88) {
                                                                                s0 = peg$c88;
                                                                                peg$currPos += 6;
                                                                            } else {
                                                                                s0 = peg$FAILED;
                                                                                if (peg$silentFails === 0) peg$fail(peg$e91);
                                                                            }
                                                                            if (s0 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 6) === peg$c26) {
                                                                                    s0 = peg$c26;
                                                                                    peg$currPos += 6;
                                                                                } else {
                                                                                    s0 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) peg$fail(peg$e28);
                                                                                }
                                                                                if (s0 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 6) === peg$c3) {
                                                                                        s0 = peg$c3;
                                                                                        peg$currPos += 6;
                                                                                    } else {
                                                                                        s0 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) peg$fail(peg$e5);
                                                                                    }
                                                                                    if (s0 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 6) === peg$c29) {
                                                                                            s0 = peg$c29;
                                                                                            peg$currPos += 6;
                                                                                        } else {
                                                                                            s0 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) peg$fail(peg$e31);
                                                                                        }
                                                                                        if (s0 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 6) === peg$c70) {
                                                                                                s0 = peg$c70;
                                                                                                peg$currPos += 6;
                                                                                            } else {
                                                                                                s0 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) peg$fail(peg$e72);
                                                                                            }
                                                                                            if (s0 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 6) === peg$c20) {
                                                                                                    s0 = peg$c20;
                                                                                                    peg$currPos += 6;
                                                                                                } else {
                                                                                                    s0 = peg$FAILED;
                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e22);
                                                                                                }
                                                                                                if (s0 === peg$FAILED) {
                                                                                                    if (input.substr(peg$currPos, 6) === peg$c36) {
                                                                                                        s0 = peg$c36;
                                                                                                        peg$currPos += 6;
                                                                                                    } else {
                                                                                                        s0 = peg$FAILED;
                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e38);
                                                                                                    }
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                        if (input.substr(peg$currPos, 6) === peg$c14) {
                                                                                                            s0 = peg$c14;
                                                                                                            peg$currPos += 6;
                                                                                                        } else {
                                                                                                            s0 = peg$FAILED;
                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e16);
                                                                                                        }
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                            if (input.substr(peg$currPos, 5) === peg$c5) {
                                                                                                                s0 = peg$c5;
                                                                                                                peg$currPos += 5;
                                                                                                            } else {
                                                                                                                s0 = peg$FAILED;
                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e7);
                                                                                                            }
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                if (input.substr(peg$currPos, 5) === peg$c25) {
                                                                                                                    s0 = peg$c25;
                                                                                                                    peg$currPos += 5;
                                                                                                                } else {
                                                                                                                    s0 = peg$FAILED;
                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e27);
                                                                                                                }
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                    if (input.substr(peg$currPos, 5) === peg$c18) {
                                                                                                                        s0 = peg$c18;
                                                                                                                        peg$currPos += 5;
                                                                                                                    } else {
                                                                                                                        s0 = peg$FAILED;
                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e20);
                                                                                                                    }
                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                        if (input.substr(peg$currPos, 5) === peg$c28) {
                                                                                                                            s0 = peg$c28;
                                                                                                                            peg$currPos += 5;
                                                                                                                        } else {
                                                                                                                            s0 = peg$FAILED;
                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e30);
                                                                                                                        }
                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                            if (input.substr(peg$currPos, 5) === peg$c89) {
                                                                                                                                s0 = peg$c89;
                                                                                                                                peg$currPos += 5;
                                                                                                                            } else {
                                                                                                                                s0 = peg$FAILED;
                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e92);
                                                                                                                            }
                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                if (input.substr(peg$currPos, 5) === peg$c8) {
                                                                                                                                    s0 = peg$c8;
                                                                                                                                    peg$currPos += 5;
                                                                                                                                } else {
                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e10);
                                                                                                                                }
                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                    if (input.substr(peg$currPos, 5) === peg$c90) {
                                                                                                                                        s0 = peg$c90;
                                                                                                                                        peg$currPos += 5;
                                                                                                                                    } else {
                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e93);
                                                                                                                                    }
                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                        if (input.substr(peg$currPos, 4) === peg$c19) {
                                                                                                                                            s0 = peg$c19;
                                                                                                                                            peg$currPos += 4;
                                                                                                                                        } else {
                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e21);
                                                                                                                                        }
                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                            if (input.substr(peg$currPos, 4) === peg$c17) {
                                                                                                                                                s0 = peg$c17;
                                                                                                                                                peg$currPos += 4;
                                                                                                                                            } else {
                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e19);
                                                                                                                                            }
                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                if (input.substr(peg$currPos, 4) === peg$c23) {
                                                                                                                                                    s0 = peg$c23;
                                                                                                                                                    peg$currPos += 4;
                                                                                                                                                } else {
                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e25);
                                                                                                                                                }
                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                    if (input.substr(peg$currPos, 4) === peg$c91) {
                                                                                                                                                        s0 = peg$c91;
                                                                                                                                                        peg$currPos += 4;
                                                                                                                                                    } else {
                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e94);
                                                                                                                                                    }
                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                        if (input.substr(peg$currPos, 4) === peg$c27) {
                                                                                                                                                            s0 = peg$c27;
                                                                                                                                                            peg$currPos += 4;
                                                                                                                                                        } else {
                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e29);
                                                                                                                                                        }
                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                            if (input.substr(peg$currPos, 4) === peg$c13) {
                                                                                                                                                                s0 = peg$c13;
                                                                                                                                                                peg$currPos += 4;
                                                                                                                                                            } else {
                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e15);
                                                                                                                                                            }
                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                if (input.substr(peg$currPos, 4) === peg$c37) {
                                                                                                                                                                    s0 = peg$c37;
                                                                                                                                                                    peg$currPos += 4;
                                                                                                                                                                } else {
                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e39);
                                                                                                                                                                }
                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                    if (input.substr(peg$currPos, 4) === peg$c22) {
                                                                                                                                                                        s0 = peg$c22;
                                                                                                                                                                        peg$currPos += 4;
                                                                                                                                                                    } else {
                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e24);
                                                                                                                                                                    }
                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                        if (input.substr(peg$currPos, 3) === peg$c11) {
                                                                                                                                                                            s0 = peg$c11;
                                                                                                                                                                            peg$currPos += 3;
                                                                                                                                                                        } else {
                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e13);
                                                                                                                                                                        }
                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                            if (input.substr(peg$currPos, 3) === peg$c24) {
                                                                                                                                                                                s0 = peg$c24;
                                                                                                                                                                                peg$currPos += 3;
                                                                                                                                                                            } else {
                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e26);
                                                                                                                                                                            }
                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                if (input.substr(peg$currPos, 2) === peg$c12) {
                                                                                                                                                                                    s0 = peg$c12;
                                                                                                                                                                                    peg$currPos += 2;
                                                                                                                                                                                } else {
                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e14);
                                                                                                                                                                                }
                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                    if (input.substr(peg$currPos, 2) === peg$c7) {
                                                                                                                                                                                        s0 = peg$c7;
                                                                                                                                                                                        peg$currPos += 2;
                                                                                                                                                                                    } else {
                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e9);
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseidentifier() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 76;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        if (peg$r1.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e95);
        }
        if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$r2.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e96);
            }
            while(s5 !== peg$FAILED){
                s4.push(s5);
                if (peg$r2.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e96);
                }
            }
            s3 = [
                s3,
                s4
            ];
            s2 = s3;
        } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s2 = peg$f105(s1);
            if (s2) s2 = undefined;
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f106(s1);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseconstant() {
        var s0;
        var key = peg$currPos * 105 + 77;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsedecimal_floating_constant();
        if (s0 === peg$FAILED) {
            s0 = peg$parseinteger_constant();
            if (s0 === peg$FAILED) {
                s0 = peg$parseenumeration_constant();
                if (s0 === peg$FAILED) s0 = peg$parsecharacter_constant();
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinteger_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 78;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsedecimal_constant();
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 === peg$FAILED) {
            s1 = peg$parseoctal_constant();
            if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                s2 = peg$parsehexadecimal_constant();
                if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
                else s1 = s2;
                if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 48) {
                        s1 = peg$c92;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e97);
                    }
                }
            }
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseinteger_suffix();
            if (s3 === peg$FAILED) s3 = null;
            s2 = input.substring(s2, peg$currPos);
            peg$savedPos = s0;
            s0 = peg$f107(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedecimal_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 79;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsenonzero_digit();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsedigit();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsedigit();
            }
            s1 = [
                s1,
                s2
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsenonzero_digit() {
        var s0, s1;
        var key = peg$currPos * 105 + 80;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r3.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e98);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedigit() {
        var s0, s1;
        var key = peg$currPos * 105 + 81;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r4.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e99);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseoctal_constant() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 82;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
            s1 = peg$c92;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e97);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parseoctal_digit();
            if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parseoctal_digit();
            }
            else s3 = peg$FAILED;
            if (s3 !== peg$FAILED) s2 = input.substring(s2, peg$currPos);
            else s2 = s3;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f108(s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseoctal_digit() {
        var s0, s1;
        var key = peg$currPos * 105 + 83;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r5.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e100);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 84;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parsehexadecimal_prefix();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsehexadecimal_digit();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsehexadecimal_digit();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_prefix() {
        var s0;
        var key = peg$currPos * 105 + 85;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 2) === peg$c93) {
            s0 = peg$c93;
            peg$currPos += 2;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e101);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c94) {
                s0 = peg$c94;
                peg$currPos += 2;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e102);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_digit() {
        var s0, s1;
        var key = peg$currPos * 105 + 86;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r6.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e103);
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseinteger_suffix() {
        var s0, s1, s2;
        var key = peg$currPos * 105 + 87;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseunsigned_suffix();
        if (s1 !== peg$FAILED) {
            s2 = peg$parselong_long_suffix();
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseunsigned_suffix();
            if (s1 !== peg$FAILED) {
                s2 = peg$parselong_suffix();
                if (s2 === peg$FAILED) s2 = null;
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parselong_long_suffix();
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseunsigned_suffix();
                    if (s2 === peg$FAILED) s2 = null;
                    s1 = [
                        s1,
                        s2
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parselong_suffix();
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseunsigned_suffix();
                        if (s2 === peg$FAILED) s2 = null;
                        s1 = [
                            s1,
                            s2
                        ];
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseunsigned_suffix() {
        var s0;
        var key = peg$currPos * 105 + 88;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 117) {
            s0 = peg$c95;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e104);
        }
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 85) {
                s0 = peg$c96;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e105);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselong_suffix() {
        var s0;
        var key = peg$currPos * 105 + 89;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.charCodeAt(peg$currPos) === 108) {
            s0 = peg$c97;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e106);
        }
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 76) {
                s0 = peg$c98;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e107);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parselong_long_suffix() {
        var s0;
        var key = peg$currPos * 105 + 90;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 2) === peg$c99) {
            s0 = peg$c99;
            peg$currPos += 2;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e108);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c100) {
                s0 = peg$c100;
                peg$currPos += 2;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e109);
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsedecimal_floating_constant() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 91;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        s3 = peg$parsefractional_constant();
        if (s3 !== peg$FAILED) {
            s4 = peg$parseexponent_part();
            if (s4 === peg$FAILED) s4 = null;
            s3 = [
                s3,
                s4
            ];
            s2 = s3;
        } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parsefloating_suffix();
            if (s3 === peg$FAILED) s3 = null;
            s2 = input.substring(s2, peg$currPos);
            peg$savedPos = s0;
            s0 = peg$f109(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parsedigit();
            if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsedigit();
            }
            else s3 = peg$FAILED;
            if (s3 !== peg$FAILED) {
                s4 = peg$parseexponent_part();
                if (s4 !== peg$FAILED) {
                    s3 = [
                        s3,
                        s4
                    ];
                    s2 = s3;
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
            else s1 = s2;
            if (s1 !== peg$FAILED) {
                s2 = peg$parsefloating_suffix();
                if (s2 === peg$FAILED) s2 = null;
                peg$savedPos = s0;
                s0 = peg$f110(s1, s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefractional_constant() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 92;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsedigit();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsedigit();
        }
        if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c71;
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e73);
        }
        if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsedigit();
            if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsedigit();
            }
            else s3 = peg$FAILED;
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedigit();
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                s2 = peg$parsedigit();
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                    s2 = peg$c71;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e73);
                }
                if (s2 !== peg$FAILED) {
                    s1 = [
                        s1,
                        s2
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseexponent_part() {
        var s0, s1, s2, s3, s4;
        var key = peg$currPos * 105 + 93;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 101) {
            s1 = peg$c101;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e110);
        }
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 69) {
                s1 = peg$c102;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e111);
            }
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
                s2 = peg$c62;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e64);
            }
            if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                    s2 = peg$c63;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e65);
                }
            }
            if (s2 === peg$FAILED) s2 = null;
            s3 = [];
            s4 = peg$parsedigit();
            if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsedigit();
            }
            else s3 = peg$FAILED;
            if (s3 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2,
                    s3
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsefloating_suffix() {
        var s0;
        var key = peg$currPos * 105 + 94;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (peg$r7.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e112);
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseenumeration_constant() {
        var s0, s1, s2;
        var key = peg$currPos * 105 + 95;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s2 = peg$f111(s1);
            if (s2) s2 = peg$FAILED;
            else s2 = undefined;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f112(s1);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsecharacter_constant() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 96;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c103;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e113);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsec_char();
            if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                    s3 = peg$c103;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e113);
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f113(s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsec_char() {
        var s0, s1;
        var key = peg$currPos * 105 + 97;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r8.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e114);
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f114(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseextended_source_character_set();
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f115(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) s0 = peg$parseescape_sequence();
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseescape_sequence() {
        var s0;
        var key = peg$currPos * 105 + 98;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$parsesimple_escape_sequence();
        if (s0 === peg$FAILED) {
            s0 = peg$parseoctal_escape_sequence();
            if (s0 === peg$FAILED) s0 = peg$parsehexadecimal_escape_sequence();
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsesimple_escape_sequence() {
        var s0, s1;
        var key = peg$currPos * 105 + 99;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c104) {
            s1 = peg$c104;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e115);
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f116();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c105) {
                s1 = peg$c105;
                peg$currPos += 2;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e116);
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f117();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c106) {
                    s1 = peg$c106;
                    peg$currPos += 2;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e117);
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f118();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c107) {
                        s1 = peg$c107;
                        peg$currPos += 2;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e118);
                    }
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f119();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c108) {
                            s1 = peg$c108;
                            peg$currPos += 2;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e119);
                        }
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f120();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            if (input.substr(peg$currPos, 2) === peg$c109) {
                                s1 = peg$c109;
                                peg$currPos += 2;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e120);
                            }
                            if (s1 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$f121();
                            }
                            s0 = s1;
                            if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                if (input.substr(peg$currPos, 2) === peg$c110) {
                                    s1 = peg$c110;
                                    peg$currPos += 2;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e121);
                                }
                                if (s1 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$f122();
                                }
                                s0 = s1;
                                if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    if (input.substr(peg$currPos, 2) === peg$c111) {
                                        s1 = peg$c111;
                                        peg$currPos += 2;
                                    } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e122);
                                    }
                                    if (s1 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$f123();
                                    }
                                    s0 = s1;
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        if (input.substr(peg$currPos, 2) === peg$c112) {
                                            s1 = peg$c112;
                                            peg$currPos += 2;
                                        } else {
                                            s1 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e123);
                                        }
                                        if (s1 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$f124();
                                        }
                                        s0 = s1;
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            if (input.substr(peg$currPos, 2) === peg$c113) {
                                                s1 = peg$c113;
                                                peg$currPos += 2;
                                            } else {
                                                s1 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e124);
                                            }
                                            if (s1 !== peg$FAILED) {
                                                peg$savedPos = s0;
                                                s1 = peg$f125();
                                            }
                                            s0 = s1;
                                            if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                if (input.substr(peg$currPos, 2) === peg$c114) {
                                                    s1 = peg$c114;
                                                    peg$currPos += 2;
                                                } else {
                                                    s1 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e125);
                                                }
                                                if (s1 !== peg$FAILED) {
                                                    peg$savedPos = s0;
                                                    s1 = peg$f126();
                                                }
                                                s0 = s1;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parseoctal_escape_sequence() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 100;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c115;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e126);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parseoctal_digit();
            while(s5 !== peg$FAILED){
                s4.push(s5);
                if (s4.length >= 3) s5 = peg$FAILED;
                else s5 = peg$parseoctal_digit();
            }
            if (s4.length < 1) {
                peg$currPos = s3;
                s3 = peg$FAILED;
            } else s3 = s4;
            if (s3 !== peg$FAILED) s2 = input.substring(s2, peg$currPos);
            else s2 = s3;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f127(s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsehexadecimal_escape_sequence() {
        var s0, s1, s2, s3, s4, s5;
        var key = peg$currPos * 105 + 101;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c116) {
            s1 = peg$c116;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e127);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parsehexadecimal_digit();
            while(s5 !== peg$FAILED){
                s4.push(s5);
                if (s4.length >= 2) s5 = peg$FAILED;
                else s5 = peg$parsehexadecimal_digit();
            }
            if (s4.length < 1) {
                peg$currPos = s3;
                s3 = peg$FAILED;
            } else s3 = s4;
            if (s3 !== peg$FAILED) s2 = input.substring(s2, peg$currPos);
            else s2 = s3;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f128(s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsestring_literal() {
        var s0, s1, s2, s3;
        var key = peg$currPos * 105 + 102;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c117;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e128);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parses_char();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parses_char();
            }
            if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c117;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e128);
            }
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f129(s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parses_char() {
        var s0, s1;
        var key = peg$currPos * 105 + 103;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        s0 = peg$currPos;
        if (peg$r9.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e129);
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f130(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) s0 = peg$parseescape_sequence();
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    function peg$parsepunctuator() {
        var s0;
        var key = peg$currPos * 105 + 104;
        var cached = peg$resultsCache[key];
        if (cached) {
            peg$currPos = cached.nextPos;
            return cached.result;
        }
        if (input.substr(peg$currPos, 4) === peg$c118) {
            s0 = peg$c118;
            peg$currPos += 4;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e130);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c119) {
                s0 = peg$c119;
                peg$currPos += 3;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e131);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c43) {
                    s0 = peg$c43;
                    peg$currPos += 3;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e45);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c44) {
                        s0 = peg$c44;
                        peg$currPos += 3;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e46);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c66) {
                            s0 = peg$c66;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$e68);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c67) {
                                s0 = peg$c67;
                                peg$currPos += 2;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$e69);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c38) {
                                    s0 = peg$c38;
                                    peg$currPos += 2;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$e40);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c39) {
                                        s0 = peg$c39;
                                        peg$currPos += 2;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$e41);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c40) {
                                            s0 = peg$c40;
                                            peg$currPos += 2;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$e42);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c41) {
                                                s0 = peg$c41;
                                                peg$currPos += 2;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$e43);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 2) === peg$c42) {
                                                    s0 = peg$c42;
                                                    peg$currPos += 2;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$e44);
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 2) === peg$c45) {
                                                        s0 = peg$c45;
                                                        peg$currPos += 2;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$e47);
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 2) === peg$c46) {
                                                            s0 = peg$c46;
                                                            peg$currPos += 2;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$e48);
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                            if (input.substr(peg$currPos, 2) === peg$c47) {
                                                                s0 = peg$c47;
                                                                peg$currPos += 2;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$e49);
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                                if (input.substr(peg$currPos, 2) === peg$c55) {
                                                                    s0 = peg$c55;
                                                                    peg$currPos += 2;
                                                                } else {
                                                                    s0 = peg$FAILED;
                                                                    if (peg$silentFails === 0) peg$fail(peg$e57);
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                    if (input.substr(peg$currPos, 2) === peg$c54) {
                                                                        s0 = peg$c54;
                                                                        peg$currPos += 2;
                                                                    } else {
                                                                        s0 = peg$FAILED;
                                                                        if (peg$silentFails === 0) peg$fail(peg$e56);
                                                                    }
                                                                    if (s0 === peg$FAILED) {
                                                                        if (input.substr(peg$currPos, 2) === peg$c56) {
                                                                            s0 = peg$c56;
                                                                            peg$currPos += 2;
                                                                        } else {
                                                                            s0 = peg$FAILED;
                                                                            if (peg$silentFails === 0) peg$fail(peg$e58);
                                                                        }
                                                                        if (s0 === peg$FAILED) {
                                                                            if (input.substr(peg$currPos, 2) === peg$c57) {
                                                                                s0 = peg$c57;
                                                                                peg$currPos += 2;
                                                                            } else {
                                                                                s0 = peg$FAILED;
                                                                                if (peg$silentFails === 0) peg$fail(peg$e59);
                                                                            }
                                                                            if (s0 === peg$FAILED) {
                                                                                if (input.substr(peg$currPos, 2) === peg$c61) {
                                                                                    s0 = peg$c61;
                                                                                    peg$currPos += 2;
                                                                                } else {
                                                                                    s0 = peg$FAILED;
                                                                                    if (peg$silentFails === 0) peg$fail(peg$e63);
                                                                                }
                                                                                if (s0 === peg$FAILED) {
                                                                                    if (input.substr(peg$currPos, 2) === peg$c60) {
                                                                                        s0 = peg$c60;
                                                                                        peg$currPos += 2;
                                                                                    } else {
                                                                                        s0 = peg$FAILED;
                                                                                        if (peg$silentFails === 0) peg$fail(peg$e62);
                                                                                    }
                                                                                    if (s0 === peg$FAILED) {
                                                                                        if (input.substr(peg$currPos, 2) === peg$c72) {
                                                                                            s0 = peg$c72;
                                                                                            peg$currPos += 2;
                                                                                        } else {
                                                                                            s0 = peg$FAILED;
                                                                                            if (peg$silentFails === 0) peg$fail(peg$e74);
                                                                                        }
                                                                                        if (s0 === peg$FAILED) {
                                                                                            if (input.substr(peg$currPos, 2) === peg$c50) {
                                                                                                s0 = peg$c50;
                                                                                                peg$currPos += 2;
                                                                                            } else {
                                                                                                s0 = peg$FAILED;
                                                                                                if (peg$silentFails === 0) peg$fail(peg$e52);
                                                                                            }
                                                                                            if (s0 === peg$FAILED) {
                                                                                                if (input.substr(peg$currPos, 2) === peg$c49) {
                                                                                                    s0 = peg$c49;
                                                                                                    peg$currPos += 2;
                                                                                                } else {
                                                                                                    s0 = peg$FAILED;
                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e51);
                                                                                                }
                                                                                                if (s0 === peg$FAILED) {
                                                                                                    if (input.substr(peg$currPos, 2) === peg$c120) {
                                                                                                        s0 = peg$c120;
                                                                                                        peg$currPos += 2;
                                                                                                    } else {
                                                                                                        s0 = peg$FAILED;
                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e132);
                                                                                                    }
                                                                                                    if (s0 === peg$FAILED) {
                                                                                                        if (input.substr(peg$currPos, 2) === peg$c121) {
                                                                                                            s0 = peg$c121;
                                                                                                            peg$currPos += 2;
                                                                                                        } else {
                                                                                                            s0 = peg$FAILED;
                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e133);
                                                                                                        }
                                                                                                        if (s0 === peg$FAILED) {
                                                                                                            if (input.substr(peg$currPos, 2) === peg$c122) {
                                                                                                                s0 = peg$c122;
                                                                                                                peg$currPos += 2;
                                                                                                            } else {
                                                                                                                s0 = peg$FAILED;
                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e134);
                                                                                                            }
                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                if (input.substr(peg$currPos, 2) === peg$c123) {
                                                                                                                    s0 = peg$c123;
                                                                                                                    peg$currPos += 2;
                                                                                                                } else {
                                                                                                                    s0 = peg$FAILED;
                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e135);
                                                                                                                }
                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                    if (input.substr(peg$currPos, 2) === peg$c124) {
                                                                                                                        s0 = peg$c124;
                                                                                                                        peg$currPos += 2;
                                                                                                                    } else {
                                                                                                                        s0 = peg$FAILED;
                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e136);
                                                                                                                    }
                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                        if (input.substr(peg$currPos, 2) === peg$c125) {
                                                                                                                            s0 = peg$c125;
                                                                                                                            peg$currPos += 2;
                                                                                                                        } else {
                                                                                                                            s0 = peg$FAILED;
                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e137);
                                                                                                                        }
                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                            if (input.charCodeAt(peg$currPos) === 91) {
                                                                                                                                s0 = peg$c34;
                                                                                                                                peg$currPos++;
                                                                                                                            } else {
                                                                                                                                s0 = peg$FAILED;
                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e36);
                                                                                                                            }
                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                if (input.charCodeAt(peg$currPos) === 93) {
                                                                                                                                    s0 = peg$c35;
                                                                                                                                    peg$currPos++;
                                                                                                                                } else {
                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e37);
                                                                                                                                }
                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                    if (input.charCodeAt(peg$currPos) === 40) {
                                                                                                                                        s0 = peg$c9;
                                                                                                                                        peg$currPos++;
                                                                                                                                    } else {
                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e11);
                                                                                                                                    }
                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                        if (input.charCodeAt(peg$currPos) === 41) {
                                                                                                                                            s0 = peg$c10;
                                                                                                                                            peg$currPos++;
                                                                                                                                        } else {
                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e12);
                                                                                                                                        }
                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                            if (input.charCodeAt(peg$currPos) === 123) {
                                                                                                                                                s0 = peg$c1;
                                                                                                                                                peg$currPos++;
                                                                                                                                            } else {
                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e3);
                                                                                                                                            }
                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                if (input.charCodeAt(peg$currPos) === 125) {
                                                                                                                                                    s0 = peg$c2;
                                                                                                                                                    peg$currPos++;
                                                                                                                                                } else {
                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e4);
                                                                                                                                                }
                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 46) {
                                                                                                                                                        s0 = peg$c71;
                                                                                                                                                        peg$currPos++;
                                                                                                                                                    } else {
                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e73);
                                                                                                                                                    }
                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 38) {
                                                                                                                                                            s0 = peg$c53;
                                                                                                                                                            peg$currPos++;
                                                                                                                                                        } else {
                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e55);
                                                                                                                                                        }
                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 42) {
                                                                                                                                                                s0 = peg$c33;
                                                                                                                                                                peg$currPos++;
                                                                                                                                                            } else {
                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e35);
                                                                                                                                                            }
                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 43) {
                                                                                                                                                                    s0 = peg$c62;
                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                } else {
                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e64);
                                                                                                                                                                }
                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 45) {
                                                                                                                                                                        s0 = peg$c63;
                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                    } else {
                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e65);
                                                                                                                                                                    }
                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 126) {
                                                                                                                                                                            s0 = peg$c69;
                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                        } else {
                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e71);
                                                                                                                                                                        }
                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 33) {
                                                                                                                                                                                s0 = peg$c68;
                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                            } else {
                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e70);
                                                                                                                                                                            }
                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 47) {
                                                                                                                                                                                    s0 = peg$c64;
                                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                                } else {
                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e66);
                                                                                                                                                                                }
                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 37) {
                                                                                                                                                                                        s0 = peg$c65;
                                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                                    } else {
                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e67);
                                                                                                                                                                                    }
                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 60) {
                                                                                                                                                                                            s0 = peg$c58;
                                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                                        } else {
                                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e60);
                                                                                                                                                                                        }
                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 62) {
                                                                                                                                                                                                s0 = peg$c59;
                                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                                            } else {
                                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e61);
                                                                                                                                                                                            }
                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 94) {
                                                                                                                                                                                                    s0 = peg$c52;
                                                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                                                } else {
                                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e54);
                                                                                                                                                                                                }
                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 124) {
                                                                                                                                                                                                        s0 = peg$c51;
                                                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                                                    } else {
                                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e53);
                                                                                                                                                                                                    }
                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 63) {
                                                                                                                                                                                                            s0 = peg$c48;
                                                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                                                        } else {
                                                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e50);
                                                                                                                                                                                                        }
                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 58) {
                                                                                                                                                                                                                s0 = peg$c16;
                                                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e18);
                                                                                                                                                                                                            }
                                                                                                                                                                                                            if (s0 === peg$FAILED) {
                                                                                                                                                                                                                if (input.charCodeAt(peg$currPos) === 59) {
                                                                                                                                                                                                                    s0 = peg$c4;
                                                                                                                                                                                                                    peg$currPos++;
                                                                                                                                                                                                                } else {
                                                                                                                                                                                                                    s0 = peg$FAILED;
                                                                                                                                                                                                                    if (peg$silentFails === 0) peg$fail(peg$e6);
                                                                                                                                                                                                                }
                                                                                                                                                                                                                if (s0 === peg$FAILED) {
                                                                                                                                                                                                                    if (input.charCodeAt(peg$currPos) === 61) {
                                                                                                                                                                                                                        s0 = peg$c32;
                                                                                                                                                                                                                        peg$currPos++;
                                                                                                                                                                                                                    } else {
                                                                                                                                                                                                                        s0 = peg$FAILED;
                                                                                                                                                                                                                        if (peg$silentFails === 0) peg$fail(peg$e34);
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                    if (s0 === peg$FAILED) {
                                                                                                                                                                                                                        if (input.charCodeAt(peg$currPos) === 44) {
                                                                                                                                                                                                                            s0 = peg$c31;
                                                                                                                                                                                                                            peg$currPos++;
                                                                                                                                                                                                                        } else {
                                                                                                                                                                                                                            s0 = peg$FAILED;
                                                                                                                                                                                                                            if (peg$silentFails === 0) peg$fail(peg$e33);
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                        if (s0 === peg$FAILED) {
                                                                                                                                                                                                                            if (input.charCodeAt(peg$currPos) === 35) {
                                                                                                                                                                                                                                s0 = peg$c126;
                                                                                                                                                                                                                                peg$currPos++;
                                                                                                                                                                                                                            } else {
                                                                                                                                                                                                                                s0 = peg$FAILED;
                                                                                                                                                                                                                                if (peg$silentFails === 0) peg$fail(peg$e138);
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        peg$resultsCache[key] = {
            nextPos: peg$currPos,
            result: s0
        };
        return s0;
    }
    const thisParser = this; // reference to the parser object itself (to get some variables)
    function getCurrPosition() {
        const loc = range();
        return {
            start: thisParser.tokenPositions.get(loc.start).start,
            end: thisParser.tokenPositions.get(Math.max(loc.start, loc.end - 1)).end
        };
    }
    function throwErrorWithLocation(message) {
        const e = new Error(message);
        e.location = location();
        throw e;
    }
    /**
   * Helper function to create and return a Node with position and type information
   */ function generateNode(type, data) {
        return {
            type: type,
            position: getCurrPosition(),
            ...data
        };
    }
    const C_Keywords = new Set([
        "auto",
        "extern",
        "break",
        "float",
        "case",
        "for",
        "char",
        "goto",
        "const",
        "if",
        "continue",
        "inline",
        "default",
        "int",
        "do",
        "long",
        "double",
        "register",
        "else",
        "restrict",
        "enum",
        "return",
        "short",
        "signed",
        "sizeof",
        "static",
        "struct",
        "switch",
        "typedef",
        "union",
        "unsigned",
        "void",
        "volatile",
        "while",
        "_Alignas",
        "_Alignof",
        "_Atomic",
        "_Bool",
        "_Complex",
        "_Generic",
        "_Imaginary",
        "_Noreturn",
        "_Static_assert",
        "_Thread_local"
    ]);
    const warnings = [];
    // add a warning to warnings
    function warn(message) {
        warnings.push({
            message: message,
            position: getCurrPosition()
        });
    }
    // any non-syntax related compilation errors detected during parsing
    const compilationErrors = [];
    function error(message) {
        compilationErrors.push({
            message: message,
            position: getCurrPosition()
        });
    }
    // this object is used to keep track of symbols, and identify whether they represent a variable/function or type (defined by struct/enum/typedef)
    // this is critical for identifying if an identifier is a typename defined by typedef or a variable -> needed for resolving "typedef ambiguity"
    // it is also used for resolving pointers to incomplete types (pointing to structs that are not yet defined)
    let symbolTable = {
        // 2 separate namespaces as per 6.2.3 of C17 standard
        identifiers: {},
        tags: {}
    };
    function addIdentifierToSymbolTable(name, symbolEntry) {
        if (name in symbolTable.identifiers) symbolTable.identifiers[name].push(symbolEntry);
        else symbolTable.identifiers[name] = [
            symbolEntry
        ];
        return {
            name: name,
            symbolEntry: symbolEntry
        }; // returns details of the added symbol, to be removed at end of scope
    }
    function addTagToSymbolTable(name, symbolEntry) {
        if (name in symbolTable.tags) symbolTable.tags[name].push(symbolEntry);
        else symbolTable.tags[name] = [
            symbolEntry
        ];
        return {
            name: name,
            symbolEntry: symbolEntry
        }; // returns details of the added symbol, to be removed at end of scope
    }
    function isIdentifierAType(name) {
        if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) return false;
        const entries = symbolTable.identifiers[name];
        return entries[entries.length - 1].type === "type";
    }
    function isIdentifierDefined(name) {
        return name in symbolTable.identifiers && symbolTable.identifiers[name].length > 0;
    }
    function getIdentifierSymbolEntry(name) {
        if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) throwErrorWithLocation(`'${name}' not declared`);
        const entries = symbolTable.identifiers[name];
        return entries[entries.length - 1];
    }
    function isTagDefined(name) {
        return name in symbolTable.tags && symbolTable.tags[name].length > 0;
    }
    function getTagSymbolEntry(name) {
        if (!(name in symbolTable.tags) || symbolTable.tags[name].length <= 0) throwErrorWithLocation(`'${name}' not declared`);
        const entries = symbolTable.tags[name];
        return entries[entries.length - 1];
    }
    // pop off the latest symbol entry for a symbol (to be done at end of scopes)
    function removeIdentifierSymbolEntry(name) {
        if (!(name in symbolTable.identifiers) || symbolTable.identifiers[name].length <= 0) throwErrorWithLocation(`'${name}' not declared`);
        symbolTable.identifiers[name].pop();
    }
    function removeTagSymbolEntry(name) {
        if (!(name in symbolTable.tags) || symbolTable.tags[name].length <= 0) throwErrorWithLocation(`'${name}' undeclared`);
        return symbolTable.tags[name].pop();
    }
    /**
   *  Try to resolve the incomplete pointers given. Return whatever is still unresolved.
   */ function resolveIncompletePointers(incompletePointers) {
        const unresolvedIncompletePointers = [];
        for (const incompletePointer of incompletePointers)if (isTagDefined(incompletePointer.pointeeType.tag)) // incomplete pointee type was defined - now complete
        incompletePointer.pointeeType = getTagSymbolEntry(incompletePointer.pointeeType.tag).dataType;
        else // incomplete pointee type still not defined
        unresolvedIncompletePointers.push(incompletePointer);
        return unresolvedIncompletePointers;
    }
    /**
   * Remove the identifiers and tags that a given declaration created.
   * Also resolves incomplete pointers if the declaration resolves them. (declaration defines an incomplete type that a incomplete pointer points to)
   * Returns any remainig unresolved incomplete pointers.
   * 
   * Also checks for any redeclaration by checking if a given identifier/tag is removed more than once in the scope containing this declaration
   * @param removedTagsInScope object containing the tags that were removed in the scope containg this declaration mapped to the type of tag (struct or enum)
   * @param removedIdentifiersInScope
   */ function removeDeclarationIdentifiersAndTags(declaration, existingIncompletePointers, removedTagsInScope, removedIdentifiersInScope, isRootScope) {
        let incompletePointers = existingIncompletePointers ?? [];
        if (declaration.incompletePointers) // add the incomplete pointers from the declaration itself
        incompletePointers.push(...declaration.incompletePointers);
        incompletePointers = resolveIncompletePointers(incompletePointers);
        // remove identifiers
        for (const identifierDefinition of declaration.identifierDefinitions){
            // check if identifiers were declared before
            if (identifierDefinition.name in removedIdentifiersInScope) {
                if (!(identifierDefinition.symbolEntry.type === "type" && removedIdentifiersInScope[identifierDefinition.name].type === "type") || JSON.stringify(identifierDefinition.symbolEntry.dataType) !== JSON.stringify(removedIdentifiersInScope[identifierDefinition.name].dataType)) {
                    // in all causes, unless the previous declaration was a typedef that declared as the same type, then there is a redeclaration error.
                    if (isRootScope) {
                        if (identifierDefinition.symbolEntry.type !== "variable" || removedIdentifiersInScope[identifierDefinition.name].type !== "variable" || JSON.stringify(identifierDefinition.symbolEntry.dataType) !== JSON.stringify(removedIdentifiersInScope[identifierDefinition.name].dataType)) // in root scope it is allowed to have the 2 declarations with linkage (object/function) as long as they declare the same type
                        error(`redeclaration of '${identifierDefinition.name}' with conflicting type`);
                    } else error(`redeclaration of '${identifierDefinition.name}'`);
                }
            }
            removedIdentifiersInScope[identifierDefinition.name] = identifierDefinition.symbolEntry;
            removeIdentifierSymbolEntry(identifierDefinition.name);
        }
        // remove tags
        if (declaration.tagDefinitions) for (const tagDefinition of declaration.tagDefinitions){
            if (tagDefinition.name in removedTagsInScope) {
                if (removedTagsInScope[tagDefinition.name].type === tagDefinition.symbolEntry.type) // redefinition of enum / struct
                error(`redefinition of '${removedTagsInScope[tagDefinition.name].type} ${tagDefinition.name}'`);
                else if (removedTagsInScope[tagDefinition.name].type !== "incomplete" || removedTagsInScope[tagDefinition.name].subtype !== tagDefinition.symbolEntry.type) // there is only an error is the previous tag was not incomplete or it was incomplete and its declaerd a different type of tag
                error(`redefinition of '${tagDefinition.name}' as wrong kind of tag`);
            }
            removeTagSymbolEntry(tagDefinition.name);
            removedTagsInScope[tagDefinition.name] = tagDefinition.symbolEntry.dataType;
        }
        return incompletePointers;
    }
    function createBlockNode(statements) {
        // remove the declarations that were made in this block from the scope and unpack declarations
        const unpackedBlockStatements = [];
        let unresolvedIncompletePointers = [];
        const removedIdentifiers = {};
        const removedTags = {};
        for (const statement of statements){
            const { unpackedStatements: unpackedStatements, incompletePointers: incompletePointers } = unpackScopedStatement(statement, unresolvedIncompletePointers, removedTags, removedIdentifiers);
            unpackedBlockStatements.push(...unpackedStatements);
            unresolvedIncompletePointers = incompletePointers;
        }
        return generateNode("Block", {
            statements: unpackedBlockStatements,
            incompletePointers: unresolvedIncompletePointers
        });
    }
    /**
   * Unpacks statements in a scope (block, switch scope).
   */ function unpackScopedStatement(statement, unresolvedIncompletePointers, removedTags, removedIdentifiers) {
        const unpackedStatements = [];
        let incompletePointers = unresolvedIncompletePointers;
        if (statement === null) ;
        else if (statement.type === "Declaration") {
            unpackedStatements.push(...statement.declarations);
            // add any incompletepointers from the declaration
            incompletePointers = removeDeclarationIdentifiersAndTags(statement, incompletePointers, removedTags, removedIdentifiers);
        } else if (statement.type === "Block" || statement.type === "SwitchStatement") {
            // bring up all the incomplete pointers from the nested block
            incompletePointers.push(...statement.incompletePointers);
            delete statement.incompletePointers;
            unpackedStatements.push(statement);
        } else unpackedStatements.push(statement);
        return {
            unpackedStatements: unpackedStatements,
            incompletePointers: incompletePointers
        };
    }
    /**
   * Performs similarly to createBlockNode - has to remove any declared symbols 
   * as a new scope is defined in the switch statement block.
   */ function createSwitchStatementNode(targetExpression, cases, defaultStatements) {
        const switchStatementNode = generateNode("SwitchStatement", {
            targetExpression: targetExpression,
            cases: [],
            defaultStatements: [],
            incompletePointers: []
        });
        const removedTags = {};
        const removedIdentifiers = {};
        for (const switchCase of cases){
            const switchStatementCase = {
                type: "SwitchStatementCase",
                position: switchCase.position,
                conditionMatch: switchCase.conditionMatch,
                statements: []
            };
            for (const statement of switchCase.statements){
                const { unpackedStatements: unpackedStatements, incompletePointers: incompletePointers } = unpackScopedStatement(statement, switchStatementNode.incompletePointers, removedTags, removedIdentifiers);
                switchStatementCase.statements.push(...unpackedStatements);
                switchStatementNode.incompletePointers = incompletePointers;
            }
            switchStatementNode.cases.push(switchStatementCase);
        }
        for (const statement of defaultStatements){
            const { unpackedStatements: unpackedStatements, incompletePointers: incompletePointers } = unpackScopedStatement(statement, switchStatementNode.incompletePointers, removedTags, removedIdentifiers);
            switchStatementNode.defaultStatements.push(...unpackedStatements);
            switchStatementNode.incompletePointers = incompletePointers;
        }
        return switchStatementNode;
    }
    /**
   * Needed to handle ambiguity between identifier and keyword.
   */ function isStringAKeyword(str) {
        return C_Keywords.has(str);
    }
    /**
   * Create a datatype that represents an incomplete type - a struct/enum that has not yet been defined, but has been referenced in a pointer.
   */ function createIncompleteDataType(type, name) {
        return {
            type: "incomplete",
            subtype: type,
            tag: name
        };
    }
    /**
   * Creates the Root node. Since Root node is created at the top of the parse tree, this function is run after the whole proram is parsed.
   * Thus any cleanup/extra logic that requires information which is only completely available after parsing can be done here.
   */ function createRootNode(children) {
        const unpackedChildren = [];
        let unresolvedIncompletePointers = [];
        const removedTags = {};
        const removedIdentifiers = {};
        for (const child of children){
            if (child.type === "Declaration") {
                unpackedChildren.push(...child.declarations);
                unresolvedIncompletePointers = removeDeclarationIdentifiersAndTags(child, unresolvedIncompletePointers, removedTags, removedIdentifiers, true);
            } else if (child.type === "FunctionDefinition") {
                if (child.incompletePointers) unresolvedIncompletePointers.push(...child.incompletePointers);
                delete child.incompletePointers;
                unpackedChildren.push(child);
            } else // shoudlnt happen
            error("Unknown child in root node");
        }
        return generateNode("Root", {
            children: unpackedChildren
        });
    }
    function generateIntegerConstant(value, suffix) {
        let correctedSuffix;
        if (suffix.length > 0) {
            correctedSuffix = suffix.toLowerCase();
            if (correctedSuffix.contains("ll")) {
                // in this implementation long long and long are identical
                if (correctedSuffix.contains("u")) correctedSuffix = "ul";
                else correctedSuffix = "l";
            }
        } else correctedSuffix = null;
        return generateNode("IntegerConstant", {
            value: BigInt(value),
            suffix: correctedSuffix
        });
    }
    function generateFloatConstant(value, suffix) {
        return generateNode("FloatConstant", {
            value: Number(value),
            suffix: suffix === "f" || suffix === "F" ? "f" : null
        });
    }
    /**
   * Process declarations that do not have a declarator - i.e they should be declaring a struct/enum type.
   */ function processDeclarationWithoutDeclarator(declarationSpecifiers) {
        const { enumDeclarations: enumDeclarations, tagDefinitions: tagDefinitions, storageClass: storageClass, incompletePointers: incompletePointers, hasTypeDefSpecifier: hasTypeDefSpecifier, constPresent: constPresent, noType: noType } = unpackDeclarationSpecifiers(declarationSpecifiers, true);
        const identifierDefinitions = [];
        const declarations = [];
        // if no tags (struct or enum) were declared, then this violates 6.7/2 of C17 standard.
        if (typeof tagDefinitions === "undefined" || tagDefinitions.length === 0) {
            if (noType) {
                if (constPresent) throwErrorWithLocation("useless type qualifier in empty declaration");
                if (storageClass) throwErrorWithLocation("useless storage class qualifier in empty declaration");
            } else throwErrorWithLocation("empty declaration");
            return generateNode("Declaration", {
                declarations: [],
                identifierDefinitions: []
            });
        }
        if (storageClass) warn("useless storage class qualifier in empty declaration");
        // add all enum variables that could have been defined in enum specifier
        if (typeof enumDeclarations !== "undefined") enumDeclarations.forEach((enumDeclaration)=>{
            enumDeclaration.enumerators.forEach((enumerator)=>{
                identifierDefinitions.push(addIdentifierToSymbolTable(enumerator.name, {
                    type: "variable",
                    dataType: createPrimaryDataType("signed int")
                }));
            });
            declarations.push(enumDeclaration);
        });
        return generateNode("Declaration", {
            declarations: declarations,
            tagDefinitions: tagDefinitions,
            identifierDefinitions: identifierDefinitions,
            incompletePointers: incompletePointers
        });
    }
    /**
   * Builds and returns a tree of binary operations which involves the 2 operaands (left and right expressions), and a operator
   * @param firstExpr first expression in the operation expression e.g. "2" in "2 + 3 + 4"
   * @param exprsWithOperatorArr an array of arrays of size 2 which contain an operator in first index and the expr in 2nd index. e.g: [["+", 3], ["+", 4]]
   */ function createLeftToRightBinaryExpressionTree(firstExpr, exprsWithOperatorArr) {
        let currNode = firstExpr;
        for (const operation of exprsWithOperatorArr)// create a new operation node
        currNode = generateNode("BinaryExpression", {
            leftExpr: currNode,
            rightExpr: operation[1],
            operator: operation[0]
        });
        return currNode;
    }
    function createUnaryExpressionNode(expr, operator) {
        // special handling for negated constants, just negate the value of constant
        if (operator === "-" && (expr.type === "IntegerConstant" || expr.type === "FloatConstant")) return {
            ...expr,
            value: -expr.value
        };
        return generateNode("UnaryExpression", {
            operator: operator,
            expression: expr
        });
    }
    // Creates a PrimaryDataType object.
    function createPrimaryDataType(primaryDataType) {
        return {
            type: "primary",
            primaryDataType: primaryDataType
        };
    }
    function createEnumDataType(tag) {
        return {
            type: "enum",
            tag: tag
        };
    }
    function createArrayDataType(elementDataType, numElements) {
        return {
            type: "array",
            elementDataType: elementDataType,
            numElements: numElements
        };
    }
    function createInitializerList(values) {
        values = values ?? [];
        return generateNode("InitializerList", {
            values: values
        });
    }
    function createInitializerSingle(value) {
        return generateNode("InitializerSingle", {
            value: value
        });
    }
    // Evaluates the string of postfix expressions to generate a complete tree of unary expression nodes
    // Follows left to right associativity.
    function createPostfixExpressionNode(firstExpr, operations) {
        let currNode = firstExpr;
        for (const operation of operations){
            if (operation.type === "ArrayElementExpr") // array element expr are equivalent to pointer dereference expression A[B] => *(A + B)
            currNode = generateNode("PointerDereference", {
                expr: {
                    type: "BinaryExpression",
                    leftExpr: currNode,
                    rightExpr: operation.index,
                    operator: "+"
                }
            });
            else if (operation.type === "StructPointerMemberAccess") // similar to array element expr, a->x is equivalent to *a.x
            currNode = generateNode("StructMemberAccess", {
                expr: {
                    type: "PointerDereference",
                    expr: currNode
                },
                fieldTag: operation.fieldTag
            });
            else currNode = {
                ...operation,
                expr: currNode
            };
        }
        currNode.position = getCurrPosition();
        return currNode;
    }
    // Evaluates the string of prefix expressions to generate a complete tree of unary expression nodes
    // Follows right to left associativity
    // @param firstExpr refers to the rightmost expression
    function createPrefixExpressionNode(firstExpr, operations) {
        let currNode = firstExpr;
        for(let i = operations.length - 1; i >= 0; --i){
            const { type: type, ...rest } = operations[i];
            currNode = generateNode(type, {
                ...rest,
                expr: currNode
            });
        }
        return currNode;
    }
    function createAssignmentNode(lvalue, assignedExpression, assignmentOperator) {
        if (assignmentOperator.length > 1) // compond assignment operator
        return generateNode("Assignment", {
            lvalue: lvalue,
            expr: {
                type: "BinaryExpression",
                leftExpr: lvalue,
                rightExpr: assignedExpression,
                operator: assignmentOperator[0]
            }
        });
        else return generateNode("Assignment", {
            lvalue: lvalue,
            expr: assignedExpression
        });
    }
    /**
   * Given an array of pointers ("*"), create a tree of PointerDeclarators, ending in the directDeclarator.
   */ function createPointerDeclaratorNode(pointers, directDeclarator) {
        let currNode = directDeclarator;
        for (const pointer of pointers)currNode = {
            type: "PointerDeclarator",
            isConst: pointer.isConst,
            directDeclarator: currNode
        };
        if (directDeclarator.functionDefinitionInfo) {
            currNode.functionDefinitionInfo = directDeclarator.functionDefinitionInfo;
            delete directDeclarator.functionDefinitionInfo;
        }
        return currNode;
    }
    function createFunctionDeclarator(parameterDeclarations) {
        if (typeof parameterDeclarations === "undefined") return generateNode("FunctionDeclarator", {
            parameters: [],
            functionDefinitionInfo: {
                parameterNames: [],
                enumDeclarations: [],
                tagDefinitions: [],
                incompletePointers: []
            }
        });
        return generateNode("FunctionDeclarator", {
            parameters: parameterDeclarations.dataTypes,
            functionDefinitionInfo: {
                parameterNames: parameterDeclarations.names,
                enumDeclarations: parameterDeclarations.enumDeclarations,
                tagDefinitions: parameterDeclarations.tagDefinitions,
                incompletePointers: parameterDeclarations.incompletePointers
            }
        });
    }
    // evaluate the delclarator suffixes of direct_declarator
    // this is used to evaluate declarators which have [] or () suffixes which indicate
    // that they are array or function suffixes respectively
    function evaluateDeclaratorSuffixes(directDeclarator, declaratorSuffixes) {
        let currNode = directDeclarator;
        for (const suffix of declaratorSuffixes){
            // some error checking
            if (suffix.type === "FunctionDeclarator") {
                // you can only have string of consecutive array declarators
                if (currNode.type === "FunctionDeclarator") error("Cannot have a function returning a function");
                // you cannot have an array of functions
                if (currNode.type === "ArrayDeclarator") error("Cannot have an array of functions");
            } else // suffix is "ArrayDeclarator"
            if (currNode.type === "FunctionDeclarator") // cannot have a function returning array
            error("Cannot have a function returning an array");
            currNode = {
                directDeclarator: currNode,
                ...suffix
            };
        }
        return currNode;
    }
    /**
   * Unpack and process declaration specifiers
   * @returns { dataType: DataType | { type: "void" }, enumDeclarations?: { type: "EnumDeclaration", enumerators: { name: string, value?: Expression }[]}[], tagDefinition?: { name: string, dataType: DataType }, storageClass: "auto" | "static", hasTypeDefSpecifier: boolean, incompletePointers?: PointerDataType[]}
   */ function unpackDeclarationSpecifiers(declarationSpecifiers, reportErrors = false) {
        const typeSpecifiers = [];
        let storageClass;
        let isConst = false; // only type qualifier that is supported
        let hasTypeDefSpecifier = false;
        function declarationSpecifierError(message) {
            if (reportErrors) error(message);
        }
        declarationSpecifiers.forEach((specifier)=>{
            switch(specifier.type){
                case "TypeSpecifier":
                    typeSpecifiers.push(specifier.specifier);
                    break;
                case "TypeQualifier":
                    if (specifier.qualifier !== "const") // should not happen
                    declarationSpecifierError(`Unknown type qualifier '${specifier.qualifier}'`);
                    isConst = true;
                    break;
                case "StorageClassSpecifier":
                    if (storageClass) // a storage class specifier already specified
                    declarationSpecifierError(`multiple storage class specifiers: '${storageClass}' and '${specifier.specifier}'`);
                    if (hasTypeDefSpecifier) declarationSpecifierError(`multiple storage class specifiers in declaration specifiers: 'typedef' and '${specifier.specifier}'`);
                    storageClass = specifier.specifier;
                    break;
                case "TypeDefSpecifier":
                    if (storageClass) declarationSpecifierError(`multiple storage class specifiers in declaration specifiers: '${specifier.specifier}' and 'typedef'`);
                    if (hasTypeDefSpecifier) declarationSpecifierError("duplicate 'typedef'");
                    hasTypeDefSpecifier = true;
            }
        });
        if (typeSpecifiers.length < 1) return {
            dataType: createPrimaryDataType("signed int"),
            noType: true,
            storageClass: storageClass,
            constPresent: isConst
        }; // placeholder data type (other compilers would default to int, but full standard compliance means an error)
        const { dataType: dataType, enumDeclarations: enumDeclarations, tagDefinitions: tagDefinitions, incompletePointers: incompletePointers } = processTypeSpecifiers(typeSpecifiers);
        if (isConst) dataType.isConst = true;
        return {
            dataType: dataType,
            enumDeclarations: enumDeclarations,
            tagDefinitions: tagDefinitions,
            incompletePointers: incompletePointers,
            storageClass: storageClass,
            hasTypeDefSpecifier: hasTypeDefSpecifier,
            constPresent: isConst // only used when processing declarations with no declarator
        };
    }
    /**
   * Processes a list of typeSpecifiers, to extract a dataType that they represent, as well as any enum variable definitions, and struct/enum type definitions
   * @returns { dataType: DataType | { type: "void" }, enumDeclarations?: { type: "EnumDeclaration" enumerators: { name: string, value?: Expression }[] }[], tagDefinitions?: { name: string, tagSymbolEntry: { type: "struct" | "enum", dataType: DataType} } }
   * dataType is the datatype indicated by the typespecifiers
   * enumDeclarations are any enum variables declared with the enum specifiers
   * tagDefinitions are any structs that are being
   */ function processTypeSpecifiers(typeSpecifiers) {
        const firstTypeSpecifier = typeSpecifiers[0];
        if (firstTypeSpecifier.type === "StructTypeSpecifier" || firstTypeSpecifier.type === "EnumTypeSpecifier" || firstTypeSpecifier.type === "VoidTypeSpecifier" || firstTypeSpecifier.type === "UserNamedTypeSpecifier") {
            if (typeSpecifiers.length > 1) // cannot have any more specifiers
            error("Two or more data types in declaration specifiers");
            if (firstTypeSpecifier.type === "StructTypeSpecifier") {
                const structSpecifier = firstTypeSpecifier.specifier;
                if (structSpecifier.type === "AnonymousStruct") // a struct may have an enum declared within it
                return {
                    dataType: structSpecifier.dataType,
                    enumDeclarations: structSpecifier.enumDeclarations,
                    tagDefinitions: structSpecifier.tagDefinitions,
                    incompletePointers: structSpecifier.incompletePointers
                };
                else if (structSpecifier.type === "NamedStructDefinition") // within the struct there may have been more struct/enum tags defined
                // tag has already been added within createStructSpecifier()
                return {
                    dataType: structSpecifier.dataType,
                    tagDefinitions: structSpecifier.tagDefinitions,
                    enumDeclarations: structSpecifier.enumDeclarations,
                    incompletePointers: structSpecifier.incompletePointers
                };
                else if (structSpecifier.type === "NamedStructReference") {
                    // retrieve type from symbol table if it exists and was also a struct
                    if (isTagDefined(structSpecifier.tag) && getTagSymbolEntry(structSpecifier.tag).type === "struct") {
                        const symbolEntry = getTagSymbolEntry(structSpecifier.tag);
                        return {
                            dataType: symbolEntry.dataType
                        };
                    } else {
                        const incompleteType = createIncompleteDataType("struct", structSpecifier.tag);
                        const symbolEntry = {
                            type: "struct",
                            dataType: incompleteType
                        };
                        const tagDefinition = addTagToSymbolTable(structSpecifier.tag, symbolEntry);
                        return {
                            dataType: incompleteType,
                            tagDefinitions: [
                                tagDefinition
                            ]
                        }; // incomplete type for now, to be resolved later when struct is defined
                    }
                }
            } else if (firstTypeSpecifier.type === "EnumTypeSpecifier") {
                const enumSpecifier = firstTypeSpecifier.specifier;
                if (enumSpecifier.type === "NamedDefinedEnum") {
                    // a new enum has been defined
                    const newTagSymbolEntry = {
                        type: "enum",
                        dataType: createEnumDataType(enumSpecifier.tag)
                    };
                    addTagToSymbolTable(enumSpecifier.tag, newTagSymbolEntry);
                    enumSpecifier.enumerators.forEach((enumerator)=>{
                        addIdentifierToSymbolTable(enumerator.name, {
                            type: "variable",
                            dataType: createEnumDataType(enumSpecifier.tag)
                        });
                    });
                    return {
                        dataType: createEnumDataType(enumSpecifier.tag),
                        enumDeclarations: [
                            {
                                type: "EnumDeclaration",
                                enumerators: enumSpecifier.enumerators
                            }
                        ],
                        tagDefinitions: [
                            {
                                name: enumSpecifier.tag,
                                symbolEntry: newTagSymbolEntry
                            }
                        ]
                    }; // all enums defined as having signed int type
                } else if (enumSpecifier.type === "AnonymousEnum") {
                    enumSpecifier.enumerators.forEach((enumerator)=>{
                        addIdentifierToSymbolTable(enumerator.name, {
                            type: "variable",
                            dataType: createEnumDataType(enumSpecifier.tag)
                        });
                    });
                    return {
                        dataType: createEnumDataType(null),
                        enumDeclarations: [
                            {
                                type: "EnumDeclaration",
                                enumerators: enumSpecifier.enumerators
                            }
                        ]
                    };
                } else if (enumSpecifier.type === "NamedEnumReference") {
                    if (isTagDefined(enumSpecifier.tag) && getTagSymbolEntry(enumSpecifier.tag).type === "enum") {
                        const symbolEntry = getTagSymbolEntry(enumSpecifier.tag);
                        return {
                            dataType: symbolEntry.dataType
                        };
                    } else {
                        const incompleteType = createIncompleteDataType("enum", enumSpecifier.tag);
                        const symbolEntry = {
                            type: "enum",
                            dataType: incompleteType
                        };
                        const tagDefinition = addTagToSymbolTable(enumSpecifier.tag, symbolEntry);
                        return {
                            dataType: incompleteType,
                            tagDefinitions: [
                                tagDefinition
                            ]
                        };
                    }
                }
            } else if (firstTypeSpecifier.type === "VoidTypeSpecifier") return {
                dataType: {
                    type: "void"
                }
            };
            else if (firstTypeSpecifier.type === "UserNamedTypeSpecifier") {
                if (!isIdentifierAType(firstTypeSpecifier.typeName)) error(`undeclared type '${firstTypeSpecifier.typeName}'`);
                return {
                    dataType: getIdentifierSymbolEntry(firstTypeSpecifier.typeName).dataType
                };
            }
        } else if (firstTypeSpecifier.type === "UnknownTypeSpecifier") throwErrorWithLocation(`unknown type name '${firstTypeSpecifier.typeName}'`);
        else {
            // only dealing with primary data types now
            let lengthSpecifier;
            let intSignSpecifier;
            let primaryDataTypeSpecifier;
            for (const specifier of typeSpecifiers){
                if (specifier.type === "PrimaryTypeSpecifier") {
                    if (primaryDataTypeSpecifier) // error if primary data type already given
                    error("Two or more data types in declaration specifiers");
                    primaryDataTypeSpecifier = specifier.specifier;
                } else if (specifier.type === "PrimaryDataTypeLengthSpecifier") {
                    if (lengthSpecifier) error(`Both '${lengthSpecifier}' and '${specifier.specifier}' in declaration specifiers`);
                    lengthSpecifier = specifier.specifier;
                } else if (specifier.type === "IntegerSignSpecifier") {
                    if (intSignSpecifier) error(`Both '${intSignSpecifier}' and '${specifier.specifier}' in declaration specifiers`);
                    intSignSpecifier = specifier.specifier;
                }
            }
            if (!primaryDataTypeSpecifier && !lengthSpecifier && !intSpecifier) error("type specifier required in declaration specifiers");
            if (primaryDataTypeSpecifier === "float" || primaryDataTypeSpecifier === "double") {
                if (intSignSpecifier) error(`Both '${intSignSpecifier}' and '${primaryDataTypeSpecifier}' in declaration specifiers`);
                return {
                    dataType: createPrimaryDataType(primaryDataTypeSpecifier)
                };
            } else if (primaryDataTypeSpecifier === "char") {
                const intSignPrefix = intSignSpecifier ? intSignSpecifier + " " : "signed "; // integral types are signed by default
                if (lengthSpecifier) error(`Both '${lengthSpecifier}' and '${primaryDataTypeSpecifier}' in declaration specifiers`);
                return {
                    dataType: createPrimaryDataType(intSignPrefix + "char")
                };
            } else {
                // default primary data type is int
                const intSignPrefix = intSignSpecifier ? intSignSpecifier + " " : "signed "; // integral types are signed by default
                if (lengthSpecifier) return {
                    dataType: createPrimaryDataType(intSignPrefix + lengthSpecifier)
                };
                else // just int
                return {
                    dataType: createPrimaryDataType(intSignPrefix + "int")
                };
            }
        }
    }
    // Unpacks a series of { declarations: Declaration, incompletePointers: PointerDataType } objects into
    // one singular object { declarations: Declaration, incompletePointers: PointerDataType }
    function unpackDeclarations(declarations) {
        const unpackedResult = {
            declarations: [],
            incompletePointers: []
        };
        declarations.forEach(({ declarations: declarations, incompletePointers: incompletePointers })=>{
            unpackedResult.declarations.push(...declarations);
            unpackedResult.incompletePointers.push(...incompletePointers);
        });
        return unpackedResult;
    }
    // Similar to unpackDeclarations, with enumDeclarations and tagDefinitions also being unpacked
    function unpackStructDeclarations(declarations) {
        const unpackedResult = {
            declarations: [],
            incompletePointers: [],
            enumDeclarations: [],
            tagDefinitions: []
        };
        declarations.forEach(({ declarations: declarations, incompletePointers: incompletePointers, enumDeclarations: enumDeclarations, tagDefinitions: tagDefinitions })=>{
            unpackedResult.declarations.push(...declarations);
            if (incompletePointers) unpackedResult.incompletePointers.push(...incompletePointers);
            if (enumDeclarations) unpackedResult.enumDeclarations.push(...enumDeclarations);
            if (tagDefinitions) unpackedResult.tagDefinitions.push(...tagDefinitions);
        });
        return unpackedResult;
    }
    /**
   * Called after a new struct is declared.
   * @returns { dataType: StructDataType, incompletePointers: PointerDataType[], enumDeclarations: { type: "EnumeratorDeclaration", enumerators: { name: string, value: number}[]}[], tagDefinitions }
   * 
   */ function createStructSpecifier(unpackedFieldDeclarations, tag) {
        const structDataType = {
            type: "struct",
            tag: tag,
            fields: []
        };
        // add the declarations of each field to the struct
        if (unpackedFieldDeclarations.declarations) unpackedFieldDeclarations.declarations.forEach((declaration)=>{
            structDataType.fields.push({
                tag: declaration.name,
                dataType: declaration.dataType
            });
        });
        // resolve all incomplete pointers which can be resolved
        const incompletePointers = [];
        unpackedFieldDeclarations.incompletePointers.forEach((incompletePointer)=>{
            const pointeeTag = incompletePointer.pointeeType.tag;
            const tagType = incompletePointer.pointeeType.subtype;
            if (pointeeTag === tag) {
                // this is a pointer that points to the struct it is within
                if (tagType !== "struct") error(`'${pointeeTag}' declared as wrong kind of tag`);
                delete incompletePointer.pointeeType;
                incompletePointer.type = "struct self pointer";
            } else if (isTagDefined(pointeeTag)) {
                const symbolEntry = getTagSymbolEntry(pointeeTag);
                if (symbolEntry.type !== tagType) error(`'${pointeeTag}' declared as wrong kind of tag`);
                // incomplete pointer is now complete (pointing to complete type)
                incompletePointer.pointeeType = symbolEntry.dataType;
            } else // still incomplete
            incompletePointers.push(incompletePointer.pointeeType);
        });
        // add this new struct (if named) thats been declared to the tagDefinitions & symboltable
        const tagDefinitions = unpackedFieldDeclarations.tagDefinitions ?? [];
        if (tag) {
            const symbolEntry = {
                type: "struct",
                dataType: structDataType
            };
            const tagDefinition = addTagToSymbolTable(tag, symbolEntry);
            tagDefinitions.push(tagDefinition);
        }
        return {
            dataType: structDataType,
            incompletePointers: incompletePointers,
            enumDeclarations: unpackedFieldDeclarations.enumDeclarations,
            tagDefinitions: tagDefinitions
        };
    }
    function createEmptyStructSpecifier(tag) {
        error("struct has no members");
        return {
            dataType: {
                type: "struct",
                tag: tag,
                fields: []
            },
            incompletePointers: [],
            enumDeclarations: [],
            tagDefinitions: []
        };
    }
    // Recursively traverses a tree of declarators to create a DataType object and extract the name of the symbol with this dataType,
    // returning the object with type: { name: string, dataType: DataType, incompletePointer?: PointerDataType }
    // this function is able to evaluate declarators used in function declarations that do not have a symbol as well.
    // optionally takes a param @isFunctionParam that indicates that this declarator is used in a function parameter
    function convertDeclaratorIntoDataTypeAndSymbolName(declarator, typeSpecifierDataType, isFunctionParam) {
        const result = {
            functionDefinitionInfo: declarator.functionDefinitionInfo
        };
        let currNode = result;
        // helper function to add datatype to currNode
        function addDataType(dataTypeToAdd) {
            // only pointers and functions can have null type specifier - void type
            if (dataTypeToAdd.type === "void") {
                if (typeof currNode.type === "undefined" || currNode.type === "primary") error(`Variable or field declared as void`);
                else if (currNode.type === "array") error(`Declaration of array of void type`);
            }
            if (currNode.type === "array") currNode.elementDataType = dataTypeToAdd;
            else if (currNode.type === "pointer") currNode.pointeeType = dataTypeToAdd;
            else if (currNode.type === "function") currNode.returnType = dataTypeToAdd;
            else currNode.dataType = dataTypeToAdd;
        }
        function recursiveHelper(declarator) {
            if (declarator.type === "SymbolDeclarator") {
                // all non-abstract declarations will end with a symbol (based on parsing rules)
                result.name = declarator.symbolName;
                return;
            } else if (declarator.type === "AbstractDeclarator") {
                // recursive tail of symboless declaration that can only be used in function declarations
                result.name = null;
                return;
            } else // all other declarators require more traversal
            recursiveHelper(declarator.directDeclarator);
            if (declarator.type === "PointerDeclarator") {
                const pointerType = {
                    type: "pointer",
                    isConst: declarator.isConst
                };
                addDataType(pointerType);
                currNode = pointerType;
            } else if (declarator.type === "FunctionDeclarator") {
                const functionType = {
                    type: "function",
                    parameters: declarator.parameters,
                    parameterNames: declarator.parameterNames
                };
                // some error checks
                if (currNode.type === "FunctionDeclarator") error("Cannot declare a function returning a function");
                else if (currNode.type === "ArrayDeclarator") error("Cannot declare an array of functions");
                addDataType(functionType);
                currNode = functionType;
            } else if (declarator.type === "ArrayDeclarator") {
                const arrayType = {
                    type: "array",
                    numElements: declarator.numElements
                };
                if (currNode.type === "FunctionDeclarator") error("Cannot declare a function returning an array");
                addDataType(arrayType);
                currNode = arrayType;
            } else error("Unknown declarator type");
        }
        recursiveHelper(declarator);
        // Only pointers can point to incomplete types
        if (typeSpecifierDataType.type === "incomplete") {
            if (currNode.type !== "pointer") error(`'${typeSpecifierDataType.tag}' is an incomplete type`);
            else // keep track that this pointer datatype as incomplete
            result.incompletePointer = currNode;
        }
        addDataType(typeSpecifierDataType);
        if (isFunctionParam && result.dataType.type === "array") // function parameters that are arrays are implictly converted into pointers to the underlying array element type
        result.dataType = {
            type: "pointer",
            pointeeType: result.dataType.elementDataType
        };
        return result;
    }
    /**
   * Creates intiializer list from string literal.
   * @param chars array of characters in the string, already in numeric form
   */ function generateInitializerListFromStringLiteral(chars) {
        return generateNode("InitializerList", {
            values: chars.map((char)=>({
                    type: "InitializerSingle",
                    value: {
                        type: "IntegerConstant",
                        value: BigInt(char),
                        suffix: null
                    }
                }))
        });
    }
    /**
   * Removes all the identifiers and tags(structs/enums) that were introduced to the symboltable inside parameter declarations of a function.
   */ function removeFunctionParamIdentifiersAndTags(tagDefinitions, enumDeclarations, parameterNames) {
        // remove all struct/enum tags
        const removedTags = new Set();
        for (const tagDefinition of tagDefinitions){
            if (removedTags.has(tagDefinition.name)) error(`redefinition of '${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}'`);
            removedTags.add(tagDefinition.name);
            removeTagSymbolEntry(tagDefinition.name);
        }
        const removedIdentifiers = new Set();
        // remove all enumerator identifiers defined in params
        for (const enumDeclaration of enumDeclarations)enumDeclaration.enumerators.forEach((e)=>{
            if (removedIdentifiers.has(e.name)) error(`'${e.name}' redeclared as different kind of symbol`);
            removedIdentifiers.add(e.name);
            removeIdentifierSymbolEntry(e.name);
        });
        // remove all parameter identifiers, no need check for redefintion as it was done in unpackParameters() already
        for (const paramName of parameterNames)if (paramName !== null) removeIdentifierSymbolEntry(paramName);
    }
    /**
   * Processes declarations.
   * Returns the declarations, as well as the dataType objects that are pointers to incomplete types
   * @returns { type: "Declaration", declarations: Declaration[], incompletePointers: PointerDataType[], tagDefinitions: { name: string, symbolEntry: { type: "struct" | "enum", dataType: DataType } }[], identifierDefinitions: { name: string, symbolEntry: { type: "type" | "variable", dataType: DataType } }[] }
   * identifierDefinitions is { name: string, symbolEntry: SymbolEntry } that represents each declared identifier
   * tagDefinitions is { name: string, symbolEntry: SymbolEntry } that represents each declared tag
   */ function processDeclaration(declarationSpecifiers, declarators) {
        const declarations = [];
        const identifierDefinitions = [];
        const { enumDeclarations: enumDeclarations, tagDefinitions: tagDefinitions, hasTypeDefSpecifier: hasTypeDefSpecifier, incompletePointers: incompletePointersFromSpecifiers, noType: noType } = unpackDeclarationSpecifiers(declarationSpecifiers, true);
        if (noType) error("at least 1 type specifier required in declaration specifiers of declaration");
        const incompletePointers = incompletePointersFromSpecifiers ?? [];
        // add all enum fields as enum declarations to the array of all declarations
        if (typeof enumDeclarations !== "undefined") enumDeclarations.forEach((enumDeclaration)=>{
            declarations.push(enumDeclaration);
            // enumerator identifiers were already added to the symboltable, just track their identifier definitions
            for (const enumerator of enumDeclaration.enumerators)identifierDefinitions.push({
                name: enumerator.name,
                symbolEntry: getIdentifierSymbolEntry(enumerator.name)
            });
        });
        declarators.forEach((declarator)=>{
            const { declaration: declaration, incompletePointer: incompletePointer } = evaluateDeclarator(declarationSpecifiers, declarator);
            // actually a typedef declaration
            if (hasTypeDefSpecifier) {
                if (declaration.initializer) error("typedef is initialized");
                identifierDefinitions.push(addIdentifierToSymbolTable(declaration.name, {
                    type: "type",
                    dataType: declaration.dataType
                }));
            } else {
                identifierDefinitions.push(addIdentifierToSymbolTable(declaration.name, {
                    type: "variable",
                    dataType: declaration.dataType
                }));
                declarations.push(declaration);
                // remove all tags and identifiers that were introduced in the parameters if this were a function declaration
                if (declarator.functionDefinitionInfo) {
                    removeFunctionParamIdentifiersAndTags(declarator.functionDefinitionInfo.tagDefinitions, declarator.functionDefinitionInfo.enumDeclarations, declarator.functionDefinitionInfo.parameterNames);
                    // delete this functionDefinition field from declarator - it is not needed
                    delete declarator.functionDefinitionInfo;
                }
            }
            if (incompletePointer) incompletePointers.push(incompletePointer);
        });
        return generateNode("Declaration", {
            declarations: declarations,
            incompletePointers: incompletePointers,
            identifierDefinitions: identifierDefinitions,
            tagDefinitions: tagDefinitions
        });
    }
    // similar to processDeclarations, with added enumeratorDeclaration as a result field (no longer incorporated into declarations)
    function processStructDeclaration(declarationSpecifiers, declarators) {
        const declarations = [];
        const incompletePointers = [];
        const { enumDeclarations: enumDeclarations, tagDefinitions: tagDefinitions, storageClass: storageClass, hasTypeDefSpecifier: hasTypeDefSpecifier } = unpackDeclarationSpecifiers(declarationSpecifiers, true);
        if (storageClass || hasTypeDefSpecifier) error("Struct field cannot have storage class specifier");
        declarators.forEach((declarator)=>{
            const { declaration: declaration, incompletePointer: incompletePointer } = evaluateDeclarator(declarationSpecifiers, declarator);
            declarations.push(declaration);
            if (incompletePointer) incompletePointers.push(incompletePointer);
        });
        return {
            declarations: declarations,
            incompletePointers: incompletePointers,
            enumDeclarations: enumDeclarations,
            tagDefinitions: tagDefinitions
        };
    }
    // evaluates the return of init_declarator or declarator with the given array of declaration specifiers, to return a declaration
    // return type: { declaration: Declaration, incompletePointer?: PointerDataType }
    function evaluateDeclarator(declarationSpecifiers, declarator) {
        const { dataType: typeSpecifierDataType, storageClass: storageClass } = unpackDeclarationSpecifiers(declarationSpecifiers);
        const { name: name, dataType: dataType, incompletePointer: incompletePointer, functionDefinitionInfo: functionDefinitionInfo } = convertDeclaratorIntoDataTypeAndSymbolName(declarator, typeSpecifierDataType);
        const declarationNode = generateNode("Declaration", {
            name: name,
            storageClass: storageClass ?? "auto",
            dataType: dataType,
            initializer: declarator.initializer
        });
        if (declarationNode.dataType.type === "array") {
            if (typeof declarationNode.initializer !== "undefined") {
                if (declarationNode.initializer.type !== "InitializerList") {
                    if (declarationNode.initializer.value.type === "StringLiteral") declarationNode.initializer = generateInitializerListFromStringLiteral(declarationNode.initializer.value.chars);
                    else error("Invalid initializer for array");
                }
                // Array size deduction based on initializer list size
                if (typeof declarationNode.dataType.numElements === "undefined") declarationNode.dataType.numElements = generateNode("IntegerConstant", {
                    value: BigInt(declarationNode.initializer.values.length)
                });
            } else if (typeof declarationNode.dataType.numElements === "undefined") // no intializer provided, if numElements not defined, then it is set to 1 - TODO: provide warning to user
            declarationNode.dataType.numElements = generateNode("IntegerConstant", {
                value: 1n
            });
        }
        return {
            declaration: declarationNode,
            incompletePointer: incompletePointer,
            functionDefinitionInfo: functionDefinitionInfo
        };
    }
    // Process function parameter.
    // @returns { type: "ParameterDeclaration", name: string | null, dataType: DataType, enumDeclarations, tagDefinitions, incompletePointers }
    function processParameterDeclaration(declarationSpecifiers, declarator) {
        const { dataType: typeSpecifierDataType, enumDeclarations: enumDeclarations, tagDefinitions: tagDefinitions, incompletePointers: incompletePointers, storageClass: storageClass, hasTypeDefSpecifier: hasTypeDefSpecifier, noType: noType } = unpackDeclarationSpecifiers(declarationSpecifiers, true);
        if (noType) error("at least 1 type specifier required in declaration specifiers of declaration");
        if (storageClass || hasTypeDefSpecifier) error(`Cannot specify storage class for function parameter`);
        if (declarator === null) // abstractDeclarator was null
        return generateNode("ParameterDeclaration", {
            name: null,
            dataType: typeSpecifierDataType,
            enumDeclarations: enumDeclarations,
            tagDefinitions: tagDefinitions,
            incompletePointers: incompletePointers
        });
        const { name: name, dataType: dataType, incompletePointer: incompletePointer } = convertDeclaratorIntoDataTypeAndSymbolName(declarator, typeSpecifierDataType, true);
        if (incompletePointer) incompletePointers.push(incompletePointer);
        // add this parameter to symbol table
        addIdentifierToSymbolTable(name, {
            type: "variable",
            dataType: dataType
        });
        if (enumDeclarations) for (const enumDeclaration of enumDeclarations)// add any declared enum variables
        enumDeclaration.enumerator.forEach((enumerator)=>{
            addIdentifierToSymbolTable(enumerator.name, {
                type: "variable",
                dataType: createPrimaryDataType("signed int")
            });
        });
        return generateNode("ParameterDeclaration", {
            name: name,
            dataType: dataType,
            enumDeclarations: enumDeclarations,
            tagDefinitions: tagDefinitions,
            incompletePointers: incompletePointers
        });
    }
    /**
   * Used to generate the DataType for type_name rule.
   * Functionally very similar to convertParameterDeclarationToDataTypeAndSymbolName.
   */ function generateDataTypeFromSpecifierAndAbstractDeclarators(declarationSpecifiers, declarator) {
        const { dataType: typeSpecifierDataType } = unpackDeclarationSpecifiers(declarationSpecifiers);
        if (declarator === null) // abstractDeclarator was null
        return typeSpecifierDataType;
        return convertDeclaratorIntoDataTypeAndSymbolName(declarator, typeSpecifierDataType).dataType;
    }
    // extracts out all the datatype, names, enumDeclarations, tagDefinitions and incompletePointers from a set of parameterDeclarations
    function unpackParameters(parameterDeclarations) {
        const dataTypes = [];
        const names = [];
        const enumDeclarations = [];
        const tagDefinitions = [];
        const incompletePointers = [];
        const setOfIdentifiers = new Set();
        const setOfTags = new Set();
        parameterDeclarations.forEach((paramDeclaration)=>{
            if (paramDeclaration.name !== null && setOfIdentifiers.has(paramDeclaration.name)) error(`redefinition of parameter '${paramDeclaration.name}'`);
            dataTypes.push(paramDeclaration.dataType);
            names.push(paramDeclaration.name);
            setOfIdentifiers.add(paramDeclaration.name);
            if (paramDeclaration.enumDeclarations) {
                enumDeclarations.forEach((enumDeclaration)=>{
                    enumDeclaration.enumerators.forEach((enumerator)=>{
                        if (setOfIdentifiers.has(enumerator.name)) error(`'${enumerator.name}' redeclared as different kind of symbol`);
                        setOfIdentifiers.add(enumerator.name);
                    });
                });
                enumDeclarations.push(...paramDeclaration.enumDeclarations);
            }
            if (paramDeclaration.tagDefinitions) {
                tagDefinitions.forEach((tagDefinition)=>{
                    if (setOfTags.has(tagDefinition.name)) error(`redefinition of '${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}'`);
                });
                tagDefinitions.push(...paramDeclaration.tagDefinitions);
            }
            if (paramDeclaration.incompletePointers) incompletePointers.push(...paramDeclaration.incompletePointers);
        });
        return {
            names: names,
            dataTypes: dataTypes,
            enumDeclarations: enumDeclarations,
            tagDefinitions: tagDefinitions,
            incompletePointers: incompletePointers
        };
    }
    function generateFunctionDefinitionNode(declarationSpecifiers, declarator, body) {
        const { declaration: declaration, functionDefinitionInfo: functionDefinitionInfo } = evaluateDeclarator(declarationSpecifiers, declarator);
        const dataType = declaration.dataType;
        const name = declaration.name;
        if (!functionDefinitionInfo || dataType.type !== "function") error("compound statement can only follow a function declarator");
        addIdentifierToSymbolTable(declaration.name, {
            type: "variable",
            dataType: dataType
        });
        const incompletePointers = body.incompletePointers;
        delete body.incompletePointers;
        // remove all tagDefinitions and identifiers declared in params from symboltable
        removeFunctionParamIdentifiersAndTags(functionDefinitionInfo.tagDefinitions, functionDefinitionInfo.enumDeclarations, functionDefinitionInfo.parameterNames);
        return generateNode("FunctionDefinition", {
            type: "FunctionDefinition",
            name: name,
            dataType: dataType,
            body: body,
            parameterNames: functionDefinitionInfo.parameterNames,
            incompletePointers: incompletePointers
        });
    }
    /**
   * Used to create a ForLoop node whose clause is a declaration.
   */ function createDeclarationForLoopNode(declaration, condition, update, body) {
        const { declarations: declarations, incompletePointers: incompletePointers, identifierDefinitions: identifierDefinitions, tagDefinitions: tagDefinitions } = declaration;
        // tagDefinitions not allowed in for loop
        if (tagDefinitions) for (const tagDefinition of tagDefinitions)error(`'${tagDefinition.tagSymbolEntry.type} ${tagDefinition.name}' declared in 'for' loop initialization`);
        // no need to handle incmplete pointers since there is no possibility of declaring them in a tag 
        // checks on declarations
        for (const declaration of declarations){
            if (declaration.type === "EnumDeclaration") // enum declarations not allowed in for loop clause
            for (const enumerator of declaration.enumerators)error(`Declaration of non-variable '${enumerator.name}' in for loop initial declaration`);
            else if (declaration.storageClass !== "auto" && declaration.storageClass !== "register") error(`Declaration of ${declaration.storageClass} variable '${declaration.name}' in for loop initial declaration`);
        }
        // remove all identifiers that were declared in for loop clause
        const removedIdentifiers = new Set();
        for (const identifierDefinition of identifierDefinitions)if (identifierDefinition.name !== null) {
            if (removedIdentifiers.has(identifierDefinition.name)) error(`redeclaration of variable ${identifierDefinition.name}`);
            removedIdentifiers.add(identifierDefinition.name);
            removeIdentifierSymbolEntry(identifierDefinition.name);
        }
        return generateNode("ForLoop", {
            clause: {
                type: "Declaration",
                value: declarations
            },
            condition: condition,
            update: update,
            body: body
        });
    }
    function addIncludedModuleDefinitions(includedModuleName) {
        addIncludedModuleFunctionDefinitions(includedModuleName);
        addIncludedModuleStructDefinitions(includedModuleName);
    }
    function addIncludedModuleFunctionDefinitions(includedModuleName) {
        if (!(includedModuleName in thisParser.moduleRepository.modules)) // included module is not found
        error(`Included module "${includedModuleName}" does not exist`);
        // add all the defined structs in the module
        Object.entries(thisParser.moduleRepository.modules[includedModuleName].moduleFunctions).forEach(([name, fnDataType])=>{
            addIdentifierToSymbolTable(name, {
                type: "variable",
                dataType: fnDataType
            });
        });
    }
    function addIncludedModuleStructDefinitions(includedModuleName) {
        if (!(includedModuleName in thisParser.moduleRepository.modules)) // included module is not found
        error(`Included module "${includedModuleName}" does not exist`);
        // add all the defined structs in the module
        thisParser.moduleRepository.modules[includedModuleName].moduleDeclaredStructs.forEach((s)=>{
            addTagToSymbolTable(s.tag, {
                type: "struct",
                dataType: s
            });
        });
    }
    function createSizeOfDataTypeExpression(dataType) {
        if (dataType.type === "incomplete") error("invalid application of 'sizeof' to incomplete type");
        return generateNode("SizeOfExpression", {
            subtype: "dataType",
            dataType: dataType
        });
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
$998a69218af07240$exports = {
    SyntaxError: $998a69218af07240$var$peg$SyntaxError,
    parse: $998a69218af07240$var$peg$parse
};


function $812b9a955e75cbf9$export$2e2bcd8739ae039(sourceCode, moduleRepository) {
    try {
        // eslint-disable-next-line
        // @ts-ignore
        (0, (/*@__PURE__*/$parcel$interopDefault($998a69218af07240$exports))).moduleRepository = moduleRepository; // make moduleRepository available to parser object
        const preprocessedOutput = (0, (/*@__PURE__*/$parcel$interopDefault($270755782b82f804$exports))).parse(sourceCode);
        // eslint-disable-next-line
        // @ts-ignore
        (0, (/*@__PURE__*/$parcel$interopDefault($1470c0288d19cc19$exports))).falseNewlinePositions = (0, (/*@__PURE__*/$parcel$interopDefault($270755782b82f804$exports))).falseNewlinePositions;
        const lexedOutput = (0, (/*@__PURE__*/$parcel$interopDefault($1470c0288d19cc19$exports))).parse(preprocessedOutput);
        // eslint-disable-next-line
        // @ts-ignore
        (0, (/*@__PURE__*/$parcel$interopDefault($998a69218af07240$exports))).tokenPositions = (0, (/*@__PURE__*/$parcel$interopDefault($1470c0288d19cc19$exports))).tokenPositions;
        try {
            const { rootNode: rootNode, compilationErrors: compilationErrors, warnings: warnings } = (0, (/*@__PURE__*/$parcel$interopDefault($998a69218af07240$exports))).parse(lexedOutput);
            if (compilationErrors.length > 0) // this handles any errors that were detected but didnt stop parsing
            throw new (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)(sourceCode, compilationErrors);
            return {
                cAstRoot: rootNode,
                warnings: warnings.map((w)=>(0, $28ac839a9eca26f5$export$9a24d8f7b932fdc5)(w.message, sourceCode, w.position))
            };
        } catch (e) {
            // catch syntax errors detected by peggy js
            // or any error that required immediately ending of parsing
            if ("location" in e) {
                // parser locations from syntax errors (or any thrown immediate errors) need to be adjusted
                if (!(0, (/*@__PURE__*/$parcel$interopDefault($1470c0288d19cc19$exports))).tokenPositions.has(e.location.start.offset)) // in case the location was a artificial whitespace separating tokens
                throw new (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)(sourceCode, [
                    {
                        message: "syntax error in program",
                        position: {
                            start: {
                                offset: 0,
                                line: 0,
                                column: 0
                            },
                            end: {
                                offset: 0,
                                line: 0,
                                column: 0
                            }
                        }
                    }
                ]);
                const adjustedLocation = {
                    start: (0, (/*@__PURE__*/$parcel$interopDefault($1470c0288d19cc19$exports))).tokenPositions.get(e.location.start.offset).start,
                    end: (0, (/*@__PURE__*/$parcel$interopDefault($1470c0288d19cc19$exports))).tokenPositions.get(Math.max(e.location.start.offset, e.location.end.offset - 1)).end
                };
                throw new (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)(sourceCode, [
                    {
                        message: e.message,
                        position: adjustedLocation
                    }
                ]);
            }
            throw e;
        }
    } catch (e) {
        // catch any other errors
        if (!(e instanceof (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)) && "location" in e) throw new (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)(sourceCode, [
            {
                message: e.message,
                position: e.location
            }
        ]);
        throw e;
    }
}


/**
 * C AST Processor Module.
 */ /**
 * Utility functions for processing C functions.
 */ 
class $5577eaa48f4a17ce$export$34c280ece72e7eaa {
    constructor(name, scope, offset){
        this.name = name;
        this.scope = scope;
        this.offset = offset;
    }
    toString() {
        return `${this.scope}::${this.name}::${this.offset.toString()}`;
    }
}
class $5577eaa48f4a17ce$export$ab3828307dd6d09 {
    addVariable(name, entry) {
        const scopedName = this.getScopedName(name);
        this.addressMap.set(new $5577eaa48f4a17ce$export$34c280ece72e7eaa(name, scopedName, entry.offset).toString(), entry);
    }
    // getVariableAddress(name: string): MemoryAddressEntry | undefined {
    //   const scopedName = this.getScopedName(name);
    //   if (this.addressMap.has(scopedName)) {
    //     return this.addressMap.get(scopedName);
    //   }
    //   if (this.addressMap.has(name)) {
    //     return this.addressMap.get(name);
    //   }
    //   return undefined;
    // }
    // getEffectiveAddress(name: string): number | undefined {
    //   const entry = this.getVariableAddress(name);
    //   if (!entry) return undefined;
    //   return entry.absoluteAddress !== undefined
    //     ? entry.absoluteAddress
    //     : entry.offset;
    // }
    pushScope(scopeName) {
        this.scopeChain.push(scopeName);
    }
    popScope() {
        return this.scopeChain.pop();
    }
    getScopedName(name) {
        if (this.scopeChain.length === 0) return name;
        return this.scopeChain[this.scopeChain.length - 1];
    // return `${this.scopeChain.join(".")}.${name}`;
    }
    static buildFromSymbolTable(symbolTable, getDataTypeSize) {
        const map = new $5577eaa48f4a17ce$export$ab3828307dd6d09();
        function processSymbolTable(table, isGlobal) {
            if (!isGlobal) map.pushScope(getFunctionNameFromSymbolTable(table));
            for (const [name, entry] of Object.entries(table.symbols))if (entry.type === "localVariable" || entry.type === "dataSegmentVariable") {
                const varEntry = entry;
                map.addVariable(name, {
                    name: name,
                    offset: varEntry.offset,
                    isGlobal: entry.type === "dataSegmentVariable",
                    size: getDataTypeSize(varEntry.dataType),
                    dataType: varEntry.dataType
                });
            }
            if (!isGlobal) map.popScope();
        }
        function getFunctionNameFromSymbolTable(table) {
            return "function_" + Math.random().toString(36).substring(2, 9);
        }
        processSymbolTable($5577eaa48f4a17ce$var$getRootSymbolTable(symbolTable), true);
        $5577eaa48f4a17ce$var$processFunctionScopes(symbolTable, processSymbolTable);
        return map;
    }
    debugPrint() {
        console.log("=== Memory Address Map ===");
        // Convert the Map to an array for easier logging
        const entries = [];
        this.addressMap.forEach((entry, name)=>{
            const parts = name.split("::");
            if (!parts[1]) throw new Error("Cannot parse MemoryAddressKey");
            entries.push([
                parts[1],
                entry
            ]);
        });
        // Sort by address for cleaner output
        entries.sort((a, b)=>a[1].offset - b[1].offset);
        entries.forEach(([name, entry])=>{
            console.log(`${name.padEnd(20)} | ${entry.isGlobal ? "Global" : "Local"} | ` + `Offset: ${entry.offset} | Size: ${entry.size} bytes`);
        });
        console.log("========================");
    }
    getAddressMap() {
        return this.addressMap;
    }
    constructor(){
        this.addressMap = new Map();
        this.scopeChain = [];
    }
}
function $5577eaa48f4a17ce$var$getRootSymbolTable(symbolTable) {
    let current = symbolTable;
    while(current.parentTable !== null)current = current.parentTable;
    return current;
}
function $5577eaa48f4a17ce$var$processFunctionScopes(symbolTable, processFn) {
    const functionNames = [];
    for (const [name, entry] of Object.entries(symbolTable.symbols))if (entry.type === "function") functionNames.push(name);
    console.log(`Found ${functionNames.length} functions to process`);
    for (const entry of symbolTable.functionTable)if (entry.isDefined) {
        const functionName = entry.functionName;
        console.log(`Processing local variables for function: ${functionName}`);
        processFn(symbolTable, false);
    }
}


/**
 * Some utility functions used by the processor when working with data types.
 */ 
/**
 * Definitions of various utility functions used for processing the C AST expressions.
 */ 


/**
 * Definition of function to process Expression expr s.
 */ 

/**
 * Definitions of various utility functions.
 */ 



function $278774b275ed49b9$export$41f976199fdafdab(condition, symbolTable) {
    const processedCondition = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(condition, symbolTable);
    const dataTypeOfConditionExpression = $278774b275ed49b9$export$eb27e3f48ee2e547({
        expression: processedCondition,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    if (!(0, $5320ef4601c98354$export$a01621f73ef8c07a)(dataTypeOfConditionExpression)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`used '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(dataTypeOfConditionExpression)}' where scalar is required`);
    return processedCondition.exprs[0];
}
function $278774b275ed49b9$export$4b396cbbbd0b4959(offset) {
    return {
        type: "IntegerConstant",
        dataType: (0, $cd849de488b21116$export$882db9e1117e2725),
        value: BigInt(offset),
        position: {
            start: {
                line: 0,
                column: 0,
                offset: 0
            },
            end: {
                line: 0,
                column: 0,
                offset: 0
            }
        }
    };
}
function $278774b275ed49b9$export$eb27e3f48ee2e547({ expression: expression, convertArrayToPointer: convertArrayToPointer, convertFunctionToPointer: convertFunctionToPointer }) {
    if (convertArrayToPointer && expression.originalDataType.type === "array") return (0, $5320ef4601c98354$export$922e76e1a79867f2)(expression.originalDataType);
    if (convertFunctionToPointer && expression.originalDataType.type === "function") return (0, $5320ef4601c98354$export$109fc3df051c8810)(expression.originalDataType);
    return expression.originalDataType;
}
function $278774b275ed49b9$export$6b66ad629d132504(functionName, functionDataType, symbolTable) {
    const indexInFunctionTable = symbolTable.getFunctionIndex(functionName);
    return {
        originalDataType: functionDataType,
        exprs: [
            {
                type: "FunctionTableIndex",
                index: $278774b275ed49b9$export$4b396cbbbd0b4959(indexInFunctionTable),
                dataType: "pointer",
                position: {
                    start: {
                        line: 0,
                        column: 0,
                        offset: 0
                    },
                    end: {
                        line: 0,
                        column: 0,
                        offset: 0
                    }
                }
            }
        ]
    };
}
function $278774b275ed49b9$export$90b7432f092d8baf(dataType) {
    return dataType.type === "pointer" && dataType.pointeeType.type === "function";
}
function $278774b275ed49b9$export$8130297edc0f94cf(dataType) {
    if (!$278774b275ed49b9$export$90b7432f092d8baf(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("called object is not a function or function pointer");
    return dataType.pointeeType;
}



/**
 * Utility functions relating to the handling of variable related nodes.
 */ 



function $ad114c17e3ec942a$var$isAllowableLValueType(dataType, specialCase = false) {
    return (0, $5320ef4601c98354$export$a01621f73ef8c07a)(dataType) || dataType.type === "struct" || specialCase && (dataType.type === "array" || dataType.type === "function");
}
function $ad114c17e3ec942a$export$eb6df2cfd9d662f1(expression, dataType, symbolTable, specialCase = false) {
    if (expression.type === "IdentifierExpression") {
        const symbolEntry = symbolTable.getSymbolEntry(expression.name);
        if (symbolEntry.type !== "dataSegmentVariable" && symbolEntry.type !== "localVariable") // enumerator / function symbol entries cannot be lvalue
        return false;
    }
    return (expression.type === "IdentifierExpression" || expression.type === "PointerDereference" || expression.type === "StructMemberAccess") && $ad114c17e3ec942a$var$isAllowableLValueType(dataType, specialCase);
}
function $ad114c17e3ec942a$export$812debddbb699ddf(expression, dataType, symbolTable, specialCase = false) {
    return !dataType.isConst && $ad114c17e3ec942a$export$eb6df2cfd9d662f1(expression, dataType, symbolTable, specialCase) && (dataType.type !== "struct" || $ad114c17e3ec942a$export$3b62aaa538d69da7(dataType));
}
function $ad114c17e3ec942a$export$3b62aaa538d69da7(dataType) {
    if (dataType.isConst) return false;
    for (const field of dataType.fields){
        if (field.isConst || field.dataType.type === "struct" && !$ad114c17e3ec942a$export$3b62aaa538d69da7(field.dataType)) return false;
    }
    return true;
}
function $ad114c17e3ec942a$export$ac7287207bedb81b(assignmentNode, symbolTable) {
    // the memory load instructions from processing the expression being assigned to as an expression
    const assignedMemoryLoadExprs = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(assignmentNode.lvalue, symbolTable);
    const lvalueDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: assignedMemoryLoadExprs
    });
    const assignee = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(assignmentNode.expr, symbolTable);
    const assigneeDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: assignee,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    if (lvalueDataType.type === "array" || lvalueDataType.type === "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`assignment to expression with type '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(lvalueDataType)}'`);
    if (!$ad114c17e3ec942a$export$eb6df2cfd9d662f1(assignmentNode.lvalue, lvalueDataType, symbolTable)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`assignment to expression that is not a lvalue`);
    if (!$ad114c17e3ec942a$export$812debddbb699ddf(assignmentNode.lvalue, lvalueDataType, symbolTable)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`assignment to non-modifiable lvalue with type '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(lvalueDataType)}'`);
    if (!(0, $5320ef4601c98354$export$88c71d9ac972f61)(lvalueDataType, assignee)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`cannot assign expression with type '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(lvalueDataType)}' to '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(assigneeDataType)}'`);
    const result = {
        memoryStoreStatements: [],
        memoryLoadExpressions: assignedMemoryLoadExprs.exprs,
        dataType: assignedMemoryLoadExprs.originalDataType
    };
    // assigned and assignee number of primary data expression should match in length
    console.assert(assignedMemoryLoadExprs.exprs.length === assignee.exprs.length, "getAssignmentMemoryStoreNodes: assigned and assignee number of primary data expression should match in length");
    // merely need to convert each memoryload into a store of the corresponding assignee expression
    for(let i = 0; i < assignedMemoryLoadExprs.exprs.length; ++i){
        const memoryLoadExpr = assignedMemoryLoadExprs.exprs[i];
        const assigneeValue = assignee.exprs[i];
        if (memoryLoadExpr.type !== "MemoryLoad") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("lvalue required as left operand of assignment", assignmentNode.position);
        result.memoryStoreStatements.push({
            type: "MemoryStore",
            address: memoryLoadExpr.address,
            value: assigneeValue,
            dataType: memoryLoadExpr.dataType,
            position: memoryLoadExpr.position
        });
    }
    return result;
}



/**
 * Some helper functions regarding the processing of constants.
 */ 

function $e3d15c53d7bc5411$export$5ab497d4db862f91(value, dataType) {
    let newValue = value;
    // handle integer overflows
    if ((0, $7f0b08f9e0a6f0f6$export$a2c4a82997e90594)(dataType) && newValue > $e3d15c53d7bc5411$var$getMaxValueOfSignedIntType(dataType)) newValue = newValue % ($e3d15c53d7bc5411$var$getMaxValueOfSignedIntType(dataType) + 1n);
    else if ((0, $7f0b08f9e0a6f0f6$export$671a30a0694c3dec)(dataType) && newValue > $e3d15c53d7bc5411$var$getMaxValueOfUnsignedIntType(dataType)) newValue = newValue % ($e3d15c53d7bc5411$var$getMaxValueOfUnsignedIntType(dataType) + 1n);
    else if (dataType === "pointer" && newValue > 2 ** ((0, $cd849de488b21116$export$11182fd140e7ea9f) * 8) - 1) // just some implementation defined behaviour
    // although assigning int values to pointer types directly is undefined behaviour and should not be done.
    // TODO: check this
    newValue = newValue % 2n ** (BigInt((0, $cd849de488b21116$export$11182fd140e7ea9f)) * 8n);
    return newValue;
}
/**
 * Returns the maximum value of a signed int type.
 */ function $e3d15c53d7bc5411$var$getMaxValueOfSignedIntType(val) {
    return 2n ** (BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[val]) * 8n - 1n) - 1n;
}
function $e3d15c53d7bc5411$var$getMinValueOfSignedIntType(val) {
    return -(2n ** (BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[val]) * 8n - 1n));
}
function $e3d15c53d7bc5411$var$getMaxValueOfUnsignedIntType(val) {
    return 2n ** (BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[val]) * 8n) - 1n;
}
/**
 * Logic for handling when the value of a constant is a very negative number that lies out of a range of a maxNegativeValue.
 * This, according to the standard, is signed integer overflow which is undefined. Thus the logic here is specific to this compiler
 * implementation, and is made to function similarly to other compilers.
 */ function $e3d15c53d7bc5411$var$capNegativeValue(value, integerType) {
    const minNegativeValue = -(2n ** (BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[integerType]) * 8n)) - 1n;
    if (value >= minNegativeValue) // no overflow
    return value;
    const diff = minNegativeValue - value;
    return 2n ** (BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[integerType]) * 8n - 1n) - diff % (2n ** BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[integerType]) * 8n);
}
/**
 * Handles signed integer constant values which are too large. This in undefined behaviour as per standard, hence this handling is specific to this compiler, meant to mimic existing compilers.
 */ function $e3d15c53d7bc5411$var$handlePositiveSignedIntegerOverflow(value, signedType) {
    const maxVal = $e3d15c53d7bc5411$var$getMaxValueOfSignedIntType(signedType);
    if (value <= maxVal) // no overflow
    return value;
    const diff = value - maxVal;
    return $e3d15c53d7bc5411$var$getMinValueOfSignedIntType(signedType) + (diff % 2n ** (BigInt((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[signedType]) * 8n) - 1n);
}
/**
 * Performs capping of excessively large or negative integer values used for constants. This is needed to prevent wasm errors.
 * For unsigned types, this will be wraparound. (defined behaviour)
 * For signed types with positive value, it will also be wraparound (undefined behaviour)
 * For signed types with negative value, it excessively negative numbers will "wrap" by moving from most neagtive to most positive. E.g. for 8 bits, -129 becomes 127
 */ function $e3d15c53d7bc5411$var$getCappedIntegerValue(value, dataType) {
    if (value > 0) {
        if ((0, $7f0b08f9e0a6f0f6$export$671a30a0694c3dec)(dataType)) return value % $e3d15c53d7bc5411$var$getMaxValueOfUnsignedIntType(dataType);
        else return $e3d15c53d7bc5411$var$handlePositiveSignedIntegerOverflow(value, dataType);
    } else if (value < 0) return $e3d15c53d7bc5411$var$capNegativeValue(value, dataType);
    else return value;
}
/**
 * If the constant overflows float (double corresponds to js number type, so that is already handled), need to cap it to ensure there is no wasm error. This is undefined behaviour, but meant to mimic existing compilers.
 */ function $e3d15c53d7bc5411$var$getCappedFloatValue(value, dataType) {
    if (dataType === "float") return Math.fround(value);
    return value;
}
/**
 * Cap the values of constants that have overflowing values to avoid wasm runtime errors.
 */ function $e3d15c53d7bc5411$var$getCappedConstantValue(constant, dataType) {
    if (constant.type === "IntegerConstant") return $e3d15c53d7bc5411$var$getCappedIntegerValue(constant.value, dataType);
    else // floating point constant
    return $e3d15c53d7bc5411$var$getCappedFloatValue(constant.value, dataType);
}
/**
 * Sets the dataType of a constant (like a literal number "123") as per 6.4.4.1 of C17 standard.
 * Caps the values of the constants if necessary.
 */ function $e3d15c53d7bc5411$var$getDataTypeOfConstant(constant) {
    if (constant.type === "IntegerConstant") {
        if (constant.suffix === "ul") return "unsigned long";
        else if (constant.suffix === "u") {
            if (constant.value <= $e3d15c53d7bc5411$var$getMaxValueOfUnsignedIntType("unsigned int")) return "unsigned int";
            else return "unsigned long";
        } else if (constant.suffix === "l") return "signed long";
        else // no suffix
        if (constant.value < 0) {
            if (constant.value >= $e3d15c53d7bc5411$var$getMinValueOfSignedIntType("signed int")) return "signed int";
            else if (constant.value >= $e3d15c53d7bc5411$var$getMinValueOfSignedIntType("signed long")) return "signed long";
            else // integer is too negative
            // TODO: possibly inform user with warning here
            return "signed long";
        } else {
            if (constant.value <= $e3d15c53d7bc5411$var$getMaxValueOfSignedIntType("signed int")) return "signed int";
            else if (constant.value <= $e3d15c53d7bc5411$var$getMaxValueOfSignedIntType("signed long")) return "signed long";
            else // integer is too large
            // TODO: possibly inform user with warning here
            return "signed long";
        }
    } else {
        // handle float constant
        if (constant.suffix === "f") return "float";
        else // by default all float constants are doubles if "f"/"F" suffix is not specified
        return "double";
    }
}
function $e3d15c53d7bc5411$export$2e2bcd8739ae039(constant) {
    const dataType = $e3d15c53d7bc5411$var$getDataTypeOfConstant(constant);
    const cappedValue = $e3d15c53d7bc5411$var$getCappedConstantValue(constant, dataType);
    return {
        type: constant.type,
        value: cappedValue,
        dataType: dataType
    };
}




/**
 * Definition of visitor function for statements.
 */ 











/**
 * Some utility functions for converting variable intializers into byte strings.
 */ 



function $c031121e0d12b198$export$2edf0d7a23f64057(dataType) {
    let byteStr = "";
    if (dataType.type === "primary" || dataType.type === "pointer" || dataType.type === "enum" || dataType.type === "struct self pointer") {
        const numOfBytes = (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
        for(let i = 0; i < numOfBytes; ++i)byteStr += "\\00";
    } else if (dataType.type === "array") {
        const numElements = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(dataType.numElements).value;
        const elementZeroStr = $c031121e0d12b198$export$2edf0d7a23f64057(dataType.elementDataType);
        for(let i = 0; i < numElements; i++)byteStr += elementZeroStr;
    } else if (dataType.type === "struct") dataType.fields.forEach((field)=>{
        byteStr += field.dataType.type === "struct self pointer" ? $c031121e0d12b198$export$2edf0d7a23f64057({
            // just initialize the zero pointer like any other pointer
            type: "pointer",
            pointeeType: {
                type: "void"
            }
        }) : $c031121e0d12b198$export$2edf0d7a23f64057(field.dataType);
    });
    else if (dataType.type === "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("cannot initialize a function data type");
    return byteStr;
}
function $c031121e0d12b198$export$8c4138854bdcb152(constant, targetDataType) {
    // shouldnt be assigning ints to pointer. THis is a constraint violation TODO: consider an error here to user based on a flag set on compiler
    if (targetDataType === "pointer") targetDataType = "unsigned int";
    if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(targetDataType)) {
        targetDataType;
        if (constant.type === "FloatConstant") // need to truncate the value
        return $c031121e0d12b198$export$1be7e9cc7e681ce2(BigInt(Math.trunc(constant.value)), (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[targetDataType]);
        else return $c031121e0d12b198$export$1be7e9cc7e681ce2(constant.value, (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[targetDataType]);
    } else {
        targetDataType;
        if (constant.type === "IntegerConstant") // Number will automatically handle converting to the next representable value TODO: check if this is next highest or lowest
        return $c031121e0d12b198$var$convertFloatNumberToByteString(Number(constant.value), targetDataType);
        else // need to get a float byte string
        return $c031121e0d12b198$var$convertFloatNumberToByteString(constant.value, targetDataType);
    }
}
function $c031121e0d12b198$export$1be7e9cc7e681ce2(integer, numOfBytes) {
    if (integer < 0) // convert to 2's complement equivalent in terms of positive number
    integer = 2n ** (BigInt(numOfBytes) * 8n) + integer;
    const hexString = integer.toString(16);
    const strSplit = hexString.split("");
    if (hexString.length % 2 == 1) strSplit.splice(0, 0, "0");
    let finalStr = "";
    for(let i = strSplit.length - 1; i >= 0; i = i - 2)finalStr += "\\" + strSplit[i - 1] + strSplit[i];
    // fill up rest of the bytes with zeroes if the integer needs fewer bytes than numOfBytes to represent
    const goalSize = numOfBytes * 3;
    while(finalStr.length < goalSize)finalStr += "\\00";
    // truncate the integer by taking lowest numOfBytes bytes
    return finalStr.slice(0, 3 * numOfBytes);
}
function $c031121e0d12b198$var$convertFloatNumberToByteString(floatValue, targetDataType) {
    const buffer = new ArrayBuffer((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[targetDataType]);
    let integerValue;
    if (targetDataType === "float") {
        const float32Arr = new Float32Array(buffer);
        const uint32Arr = new Uint32Array(buffer);
        // if the floatValue is out of range, this will set it to infinity. Whereas if not exactly representable, it will also round up to next representable.
        float32Arr[0] = floatValue;
        integerValue = uint32Arr[0];
    } else {
        const float64Arr = new Float64Array(buffer);
        const uint64Arr = new BigUint64Array(buffer);
        float64Arr[0] = floatValue;
        integerValue = uint64Arr[0];
    }
    // convert the integer view of the float variable to a byte string
    return $c031121e0d12b198$export$1be7e9cc7e681ce2(BigInt(integerValue), (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[targetDataType]);
}





function $aa6e51d54352829d$export$2e2bcd8739ae039(enumDeclaration, symbolTable) {
    let currValue = 0n;
    enumDeclaration.enumerators.forEach((enumerator)=>{
        if (typeof enumerator.value !== "undefined" && enumerator.value !== null) {
            const value = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(enumerator.value).value;
            if (typeof value !== "bigint") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`enumerator value for '${enumerator.name}' is not an integer constant`);
            currValue = value;
        }
        symbolTable.addEnumeratorEntry(enumerator.name, currValue++);
    });
}



function $de78ebef6c7c100a$export$f3f7c2f7637d5845(declaration, symbolTable, enclosingFunc) {
    if (declaration.type === "Declaration") {
        let symbolEntry = symbolTable.addEntry(declaration);
        if (symbolEntry.type !== "function") {
            const varEntry = symbolEntry;
            (0, $8c698c0438819abb$export$8f5345d7eb869598).getAddressMap().addVariable(declaration.name, {
                name: declaration.name,
                offset: varEntry.offset,
                isGlobal: varEntry.type === "dataSegmentVariable",
                size: (0, $5320ef4601c98354$export$1713163196af6553)(declaration.dataType),
                dataType: declaration.dataType
            });
        }
        if (symbolEntry.type === "function" && typeof declaration.initializer !== "undefined") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`function '${declaration.name}' is initialized like a variable`);
        if (typeof enclosingFunc !== "undefined") enclosingFunc.sizeOfLocals += (0, $5320ef4601c98354$export$1713163196af6553)(declaration.dataType);
        symbolEntry; // definitely not dealing with a function declaration already
        // We have already allocated space for data segment variables, no more memory statements are needed
        if (typeof declaration.initializer !== "undefined" && symbolEntry.type !== "dataSegmentVariable") return $de78ebef6c7c100a$export$3bfb4b35e5043c1c(symbolEntry, declaration.initializer, symbolTable);
        else return [];
    } else if (declaration.type === "EnumDeclaration") {
        (0, $aa6e51d54352829d$export$2e2bcd8739ae039)(declaration, symbolTable);
        return [];
    } else {
        console.assert(false, "Unknown declaration type");
        return [];
    }
}
/**
 * Some basic checks for invalid initialization.
 */ function $de78ebef6c7c100a$var$runInitializerChecks(dataType, initializer) {
    if ((0, $5320ef4601c98354$export$a01621f73ef8c07a)(dataType)) {
        if (initializer.type === "InitializerList" && initializer.values.length > 1) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("excess elements in scalar intializer"); // undefined behaviour, for not throw TODO: perhaps toggle based on flag
    } else if (dataType.type === "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`function cannot be initialized like a variable`);
    else if (dataType.type === "array" && initializer.type === "InitializerSingle") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("invalid intializer for aggregate type");
}
function $de78ebef6c7c100a$var$createStructSelfPointerDataType(struct) {
    return {
        type: "pointer",
        pointeeType: struct
    };
}
function $de78ebef6c7c100a$export$8338518b683b1457(lvalue, expr) {
    if (!(0, $5320ef4601c98354$export$88c71d9ac972f61)(lvalue, expr)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`incompatible types when initializing type '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(lvalue)}' using type '${(0, $5320ef4601c98354$export$19913cd95b069dcd)((0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: expr,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    }))}'`);
}
function $de78ebef6c7c100a$export$3bfb4b35e5043c1c(variableSymbolEntry, initializer, symbolTable) {
    const memoryStoreStatements = [];
    let currOffset = variableSymbolEntry.offset; // offset to use for address in memory store statements
    $de78ebef6c7c100a$var$runInitializerChecks(variableSymbolEntry.dataType, initializer);
    let structBeingFilled; // the current struct being filled, used for struct self pointer logic
    function helper(dataType, initializer, offset) {
        if (dataType.type === "primary" || dataType.type === "pointer" || dataType.type === "enum" || dataType.type === "struct self pointer") {
            let scalarDataType;
            if (dataType.type === "pointer" || dataType.type === "struct self pointer") scalarDataType = "pointer";
            else if (dataType.type === "enum") scalarDataType = (0, $cd849de488b21116$export$58b6502def2a4d77);
            else scalarDataType = dataType.primaryDataType;
            if (initializer.type === "InitializerSingle") {
                const processedExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(initializer.value, symbolTable);
                if (dataType.type === "struct self pointer") $de78ebef6c7c100a$export$8338518b683b1457($de78ebef6c7c100a$var$createStructSelfPointerDataType(structBeingFilled), processedExpr);
                else $de78ebef6c7c100a$export$8338518b683b1457(dataType, processedExpr);
                memoryStoreStatements.push({
                    type: "MemoryStore",
                    address: {
                        type: "LocalAddress",
                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                        dataType: "pointer",
                        position: initializer.position
                    },
                    value: processedExpr.exprs[0],
                    dataType: scalarDataType,
                    position: initializer.position
                });
                currOffset += (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
            } else if (offset >= initializer.values.length) {
                let zeroExpression;
                if (dataType.type !== "struct self pointer" && (0, $5320ef4601c98354$export$db1d6bf10724bb3f)(dataType)) zeroExpression = {
                    type: "FloatConstant",
                    value: 0,
                    dataType: dataType.primaryDataType,
                    position: initializer.position
                };
                else zeroExpression = {
                    type: "IntegerConstant",
                    value: 0n,
                    dataType: dataType.type === "pointer" || dataType.type === "struct self pointer" ? (0, $cd849de488b21116$export$bfaa7c08c18ee972) : dataType.type === "enum" ? (0, $cd849de488b21116$export$58b6502def2a4d77) : dataType.primaryDataType,
                    position: initializer.position
                };
                memoryStoreStatements.push({
                    type: "MemoryStore",
                    address: {
                        type: "LocalAddress",
                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                        dataType: "pointer",
                        position: initializer.position
                    },
                    value: zeroExpression,
                    dataType: scalarDataType,
                    position: initializer.position
                });
                currOffset += (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
            } else {
                // unpack the element at offset of the list until hit a single
                let firstInitializer = initializer.values[offset++];
                while(firstInitializer.type === "InitializerList"){
                    if (firstInitializer.values.length === 0) {
                        // empty initializer list
                        let zeroExpression;
                        if (dataType.type !== "struct self pointer" && (0, $5320ef4601c98354$export$db1d6bf10724bb3f)(dataType)) zeroExpression = {
                            type: "FloatConstant",
                            value: 0,
                            dataType: dataType.primaryDataType,
                            position: initializer.position
                        };
                        else zeroExpression = {
                            type: "IntegerConstant",
                            value: 0n,
                            dataType: dataType.type === "pointer" || dataType.type === "struct self pointer" ? (0, $cd849de488b21116$export$bfaa7c08c18ee972) : dataType.type === "enum" ? (0, $cd849de488b21116$export$58b6502def2a4d77) : dataType.primaryDataType,
                            position: initializer.position
                        };
                        memoryStoreStatements.push({
                            type: "MemoryStore",
                            address: {
                                type: "LocalAddress",
                                offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                                dataType: "pointer",
                                position: initializer.position
                            },
                            value: zeroExpression,
                            dataType: scalarDataType,
                            position: initializer.position
                        });
                        currOffset += (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
                        return offset;
                    } else if (firstInitializer.values.length > 1) // excess elements
                    throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("excess elements in initializer");
                    firstInitializer = firstInitializer.values[0];
                }
                const processedExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(firstInitializer.value, symbolTable);
                // check assignability
                if (dataType.type === "struct self pointer") $de78ebef6c7c100a$export$8338518b683b1457($de78ebef6c7c100a$var$createStructSelfPointerDataType(structBeingFilled), processedExpr);
                else $de78ebef6c7c100a$export$8338518b683b1457(dataType, processedExpr);
                memoryStoreStatements.push({
                    type: "MemoryStore",
                    address: {
                        type: "LocalAddress",
                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                        dataType: "pointer",
                        position: processedExpr.exprs[0].position
                    },
                    value: processedExpr.exprs[0],
                    dataType: scalarDataType,
                    position: processedExpr.exprs[0].position
                });
                currOffset += (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
            }
        } else if (dataType.type === "array") {
            if (initializer.type === "InitializerSingle") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("invalid initializer for aggregate type");
            const numElements = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(dataType.numElements).value;
            for(let i = 0; i < numElements; i++){
                if (dataType.elementDataType.type === "pointer" || dataType.elementDataType.type === "primary") // same initializer list, offset shld incr by 1
                offset = helper(dataType.elementDataType, initializer, offset);
                else if (dataType.elementDataType.type === "struct") {
                    if (offset < initializer.values.length && initializer.values[offset].type === "InitializerSingle") {
                        // special handling in case the current initializer at offset is a struct expression
                        const processedExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(initializer.values[offset].value, symbolTable);
                        if (processedExpr.originalDataType.type === "struct") {
                            $de78ebef6c7c100a$export$8338518b683b1457(dataType.elementDataType, processedExpr);
                            const unpackedStruct = (0, $5320ef4601c98354$export$8b795b2cde35800)(dataType.elementDataType);
                            for(let i = 0; i < unpackedStruct.length; ++i){
                                const primaryExpr = processedExpr.exprs[i];
                                const primaryMemoryObj = unpackedStruct[i];
                                memoryStoreStatements.push({
                                    type: "MemoryStore",
                                    address: {
                                        type: "LocalAddress",
                                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                                        dataType: "pointer",
                                        position: primaryExpr.position
                                    },
                                    value: primaryExpr,
                                    dataType: primaryMemoryObj.dataType,
                                    position: primaryExpr.position
                                });
                                currOffset += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(primaryMemoryObj.dataType);
                            }
                            ++offset;
                            continue;
                        }
                    }
                    if (offset >= initializer.values.length || initializer.values[offset].type === "InitializerSingle") // sub aggregate will take from the same "level" of initializer list, offset will be incremented
                    offset = helper(dataType.elementDataType, initializer, offset);
                    else helperWithExcessInitializerCheck(dataType.elementDataType, initializer.values[offset++]); // fresh offset for sub aggregate
                } else if (dataType.elementDataType.type === "array") {
                    if (offset >= initializer.values.length || initializer.values[offset].type === "InitializerSingle") // sub aggregate will take from the same "level" of initializer list, offset will be incremented
                    offset = helper(dataType.elementDataType, initializer, offset);
                    else helperWithExcessInitializerCheck(dataType.elementDataType, initializer.values[offset++]);
                } else if (dataType.elementDataType.type === "function") // should not be possible
                throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("cannot have array of functions");
            }
        } else if (dataType.type === "struct") {
            if (initializer.type === "InitializerSingle") {
                const processedExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(initializer.value, symbolTable);
                // handle direct initialization of struct with another struct
                $de78ebef6c7c100a$export$8338518b683b1457(dataType, processedExpr);
                const unpackedStruct = (0, $5320ef4601c98354$export$8b795b2cde35800)(dataType);
                for(let i = 0; i < unpackedStruct.length; ++i){
                    const primaryExpr = processedExpr.exprs[i];
                    const primaryMemoryObj = unpackedStruct[i];
                    memoryStoreStatements.push({
                        type: "MemoryStore",
                        address: {
                            type: "LocalAddress",
                            offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                            dataType: "pointer",
                            position: primaryExpr.position
                        },
                        value: primaryExpr,
                        dataType: primaryMemoryObj.dataType,
                        position: primaryExpr.position
                    });
                    currOffset += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(primaryMemoryObj.dataType);
                }
                return offset;
            }
            structBeingFilled = dataType;
            for (const field of dataType.fields)if (initializer.values[offset].type === "InitializerSingle") // same initializer list, offset shld incr by 1
            offset = helper(field.dataType, initializer, offset);
            else helperWithExcessInitializerCheck(field.dataType, initializer.values[offset++]);
        }
        return offset;
    }
    function helperWithExcessInitializerCheck(dataType, initializer) {
        const finalOffset = helper(dataType, initializer, 0);
        if (initializer.type === "InitializerList" && finalOffset < initializer.values.length) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("excess elements in initializer");
    }
    helperWithExcessInitializerCheck(variableSymbolEntry.dataType, initializer);
    return memoryStoreStatements;
}
function $de78ebef6c7c100a$export$6a9ae9430f0feed9(declaration, symbolTable) {
    if (declaration.type === "Declaration") $de78ebef6c7c100a$export$f3c64fd403ce8bb1(declaration, symbolTable);
    else if (declaration.type === "EnumDeclaration") (0, $aa6e51d54352829d$export$2e2bcd8739ae039)(declaration, symbolTable);
    else console.assert(false, "Unknown declaration type");
}
function $de78ebef6c7c100a$export$f3c64fd403ce8bb1(node, symbolTable) {
    const symbolEntry = symbolTable.addEntry(node);
    if (node.dataType.type === "function") {
        if (typeof node.initializer !== "undefined") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`function '${node.name}' is initialized like a variable`);
        return;
    }
    // sanity check
    if (symbolEntry.type === "localVariable") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("processDataSegmentVariableDeclaration: symbol entry has type 'localVariable'");
}
function $de78ebef6c7c100a$var$checkCompileTimeInitializer(initializerValue) {
    if (!(0, $4a3275d19fa7fc08$export$960381d950ae61d4)(initializerValue)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("initializer element is not constant");
}
function $de78ebef6c7c100a$export$122b46d757fa097c(dataType, initializer, symbolTable) {
    let byteStr = "";
    function helper(dataType, initializer, offset) {
        if (dataType.type === "primary" || dataType.type === "pointer" || dataType.type === "enum" || dataType.type === "struct self pointer") {
            let scalarDataType;
            if (dataType.type === "pointer" || dataType.type === "struct self pointer") scalarDataType = "pointer";
            else if (dataType.type === "enum") scalarDataType = (0, $cd849de488b21116$export$58b6502def2a4d77);
            else scalarDataType = dataType.primaryDataType;
            if (initializer.type === "InitializerSingle") {
                // special handling for string literal
                if (initializer.value.type === "StringLiteral") {
                    const dataSegmentOffset = symbolTable.addDataSegmentObject(initializer.value.chars);
                    byteStr += (0, $c031121e0d12b198$export$1be7e9cc7e681ce2)(BigInt(dataSegmentOffset), (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[0, $cd849de488b21116$export$bfaa7c08c18ee972]);
                } else {
                    $de78ebef6c7c100a$var$checkCompileTimeInitializer(initializer.value);
                    const processedConstant = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(initializer.value);
                    byteStr += (0, $c031121e0d12b198$export$8c4138854bdcb152)(processedConstant, scalarDataType);
                }
            } else if (offset >= initializer.values.length) byteStr += (0, $c031121e0d12b198$export$2edf0d7a23f64057)(dataType);
            else {
                // unpack the element at offset of the list until hit a single
                let firstInitializer = initializer.values[offset++];
                while(firstInitializer.type === "InitializerList"){
                    if (firstInitializer.values.length === 0) {
                        // empty initializer
                        byteStr += (0, $c031121e0d12b198$export$2edf0d7a23f64057)(dataType);
                        return offset;
                    } else if (firstInitializer.values.length > 1) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("excess elements in initializer");
                    firstInitializer = firstInitializer.values[0];
                }
                $de78ebef6c7c100a$var$checkCompileTimeInitializer(firstInitializer.value);
                const processedConstant = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(firstInitializer.value);
                byteStr += (0, $c031121e0d12b198$export$8c4138854bdcb152)(processedConstant, scalarDataType);
            }
        } else if (dataType.type === "array") {
            if (initializer.type === "InitializerSingle") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("invalid initializer for aggregate type");
            const numElements = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(dataType.numElements).value;
            for(let i = 0; i < numElements; i++){
                if (dataType.elementDataType.type === "pointer" || dataType.elementDataType.type === "primary") // same initializer list, offset shld incr by 1
                offset = helper(dataType.elementDataType, initializer, offset);
                else if (dataType.elementDataType.type === "array" || dataType.elementDataType.type === "struct") {
                    if (offset >= initializer.values.length || initializer.values[offset].type === "InitializerSingle") // sub aggregate will take from the same "level" of initializer list, offset will be incremented
                    offset = helper(dataType.elementDataType, initializer, offset);
                    else helperWithExcessInitializerCheck(dataType.elementDataType, initializer.values[offset++]); // fresh offset for sub aggregate
                }
            }
        } else if (dataType.type === "struct") {
            if (initializer.type === "InitializerSingle") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("invalid initializer for aggregate type");
            for (const field of dataType.fields){
                if (field.dataType.type === "pointer" || field.dataType.type === "primary") // same initializer list, offset shld incr by 1
                offset = helper(field.dataType, initializer, offset);
                else if (field.dataType.type === "array" || field.dataType.type === "struct") {
                    if (offset >= initializer.values.length || initializer.values[offset].type === "InitializerSingle") // sub aggregate will take from the same "level" of initializer list, offset will be incremented
                    offset = helper(field.dataType, initializer, offset);
                    else helperWithExcessInitializerCheck(field.dataType, initializer.values[offset++]); // fresh offset for sub aggregate
                } else if (field.dataType.type === "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("function is not valid field of struct");
            }
        } else if (dataType.type === "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("cannot initialize function type");
        return offset;
    }
    function helperWithExcessInitializerCheck(dataType, initializer) {
        const finalOffset = helper(dataType, initializer, 0);
        if (initializer.type === "InitializerList" && finalOffset < initializer.values.length) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("excess elements in initializer");
    }
    if (initializer === null) return (0, $c031121e0d12b198$export$2edf0d7a23f64057)(dataType);
    helperWithExcessInitializerCheck(dataType, initializer);
    return byteStr;
}





let $e5f32705ab2cc688$export$cce7aaa89215f32b = [];
function $e5f32705ab2cc688$export$5ecd17fec0dc7499() {
    $e5f32705ab2cc688$export$cce7aaa89215f32b = [];
}
function $e5f32705ab2cc688$export$8cf0d8363c40fe56(message, position) {
    $e5f32705ab2cc688$export$cce7aaa89215f32b.push({
        message: message,
        position: position
    });
}


// some auxillary information used during processing
let $cf264a5b1eb44de7$var$auxInfo = {
    inLoop: false,
    inSwitch: false
};
function $cf264a5b1eb44de7$export$f7e4aa58fa839c4e() {
    $cf264a5b1eb44de7$var$auxInfo = {
        inLoop: false,
        inSwitch: false
    };
}
function $cf264a5b1eb44de7$var$processLoopBody(bodyStaement, symbolTable, enclosingFunc) {
    const originalInLoop = $cf264a5b1eb44de7$var$auxInfo.inLoop;
    $cf264a5b1eb44de7$var$auxInfo.inLoop = true;
    const body = $cf264a5b1eb44de7$export$2e2bcd8739ae039(bodyStaement, symbolTable, enclosingFunc);
    $cf264a5b1eb44de7$var$auxInfo.inLoop = originalInLoop;
    return body;
}
function $cf264a5b1eb44de7$export$2e2bcd8739ae039(node, symbolTable, enclosingFunc) {
    try {
        if (node.type === "Block") {
            const blockSymbolTable = new (0, $c5c9ce8d51254f39$export$777871f1ccd7bbc3)(symbolTable);
            const statements = [];
            node.statements.forEach((child)=>{
                const result = $cf264a5b1eb44de7$export$2e2bcd8739ae039(child, blockSymbolTable, enclosingFunc);
                if (result === null) return;
                else if (Array.isArray(result)) // A block was visited, returning an array of StatementP
                result.forEach((statement)=>statements.push(statement));
                else statements.push(result);
            });
            return statements;
        } else if (node.type === "ForLoop") {
            let clause;
            let forLoopSymbolTable = symbolTable;
            if (node.clause !== null && node.clause.type === "Declaration") {
                // create new scope for this declaration
                forLoopSymbolTable = new (0, $c5c9ce8d51254f39$export$777871f1ccd7bbc3)(symbolTable);
                clause = [];
                for (const declaration of node.clause.value)clause.push(...(0, $de78ebef6c7c100a$export$f3f7c2f7637d5845)(declaration, forLoopSymbolTable, enclosingFunc));
            } else if (node.clause !== null && node.clause.type === "Expression") clause = $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.clause.value, forLoopSymbolTable, enclosingFunc);
            else clause = [];
            const processedForLoopNode = {
                type: "ForLoop",
                clause: clause,
                condition: node.condition !== null ? (0, $278774b275ed49b9$export$41f976199fdafdab)(node.condition, forLoopSymbolTable) : null,
                update: node.update !== null ? $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.update, forLoopSymbolTable, enclosingFunc) : [],
                body: $cf264a5b1eb44de7$var$processLoopBody(node.body, forLoopSymbolTable, enclosingFunc),
                position: node.position
            };
            return [
                processedForLoopNode
            ];
        } else if (node.type === "DoWhileLoop" || node.type === "WhileLoop") return [
            {
                type: node.type,
                condition: (0, $278774b275ed49b9$export$41f976199fdafdab)(node.condition, symbolTable),
                body: $cf264a5b1eb44de7$var$processLoopBody(node.body, symbolTable, enclosingFunc),
                position: node.position
            }
        ];
        else if (node.type === "ReturnStatement") {
            // there must be an enclosing func
            if (typeof enclosingFunc === "undefined") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("return statement is not valid outside of a function", node.position);
            if (typeof node.value === "undefined") return [
                {
                    type: "ReturnStatement",
                    position: node.position
                }
            ];
            // there is an expression to return, break up the return into series of memory stores of the expression
            // in the return memory object locations
            return (0, $b7e59eb4969f10fd$export$733f767a80574592)(node.value, symbolTable);
        } else if (node.type === "SelectionStatement") return [
            {
                type: "SelectionStatement",
                condition: (0, $278774b275ed49b9$export$41f976199fdafdab)(node.condition, symbolTable),
                ifStatements: $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.ifStatement, symbolTable, enclosingFunc),
                elseStatements: node.elseStatement ? $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.elseStatement, symbolTable, enclosingFunc) : null,
                position: node.position
            }
        ];
        else if (node.type === "BreakStatement") {
            if (!$cf264a5b1eb44de7$var$auxInfo.inLoop && !$cf264a5b1eb44de7$var$auxInfo.inSwitch) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("break statement not within a switch or loop body");
            return [
                {
                    type: node.type,
                    position: node.position
                }
            ];
        // start of processing Expression nodes which may have side effects
        } else if (node.type === "ContinueStatement") {
            if (!$cf264a5b1eb44de7$var$auxInfo.inLoop) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("continue statement not within a loop body");
            return [
                {
                    type: node.type,
                    position: node.position
                }
            ];
        // start of processing Expression nodes which may have side effects
        } else if (node.type === "SwitchStatement") {
            const processedTargetExpression = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(node.targetExpression, symbolTable);
            const dataTypeOfTargetExpression = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: processedTargetExpression
            });
            if (!(0, $5320ef4601c98354$export$25d6369c8c841882)(dataTypeOfTargetExpression)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("switch quantity is not an integer");
            if (node.cases.length === 0 && node.defaultStatements.length === 0) // empty switch statement, just process the expression as block item
            return $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.targetExpression, symbolTable, enclosingFunc);
            const originalInSwitch = $cf264a5b1eb44de7$var$auxInfo.inSwitch;
            $cf264a5b1eb44de7$var$auxInfo.inSwitch = true;
            const processedCases = [];
            for (const switchStatementCase of node.cases){
                const dataTypeOfLabel = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                    expression: (0, $551bb05b84852d99$export$2e2bcd8739ae039)(switchStatementCase.conditionMatch, symbolTable, enclosingFunc)
                });
                if (!(0, $5320ef4601c98354$export$25d6369c8c841882)(dataTypeOfLabel)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("case value not an integer constant expression", switchStatementCase.position);
                const evaluatedConstant = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(switchStatementCase.conditionMatch);
                const processedStatements = [];
                for (const statement of switchStatementCase.statements)processedStatements.push(...$cf264a5b1eb44de7$export$2e2bcd8739ae039(statement, symbolTable, enclosingFunc));
                // the conditon of each switch case is adjusted to be a relational expression: targetExpression == case value
                const dataTypeOfSwitchCaseOperandAndTarget = (0, $553cdff61180334d$export$aeff407985fcdd14)(dataTypeOfTargetExpression, dataTypeOfLabel, "==").primaryDataType;
                processedCases.push({
                    condition: {
                        type: "BinaryExpression",
                        leftExpr: processedTargetExpression.exprs[0],
                        rightExpr: evaluatedConstant,
                        operator: "==",
                        operandTargetDataType: dataTypeOfSwitchCaseOperandAndTarget,
                        dataType: dataTypeOfSwitchCaseOperandAndTarget,
                        position: switchStatementCase.position
                    },
                    statements: processedStatements,
                    position: switchStatementCase.position
                });
            }
            const processedDefaultStatements = [];
            for (const defaultStatement of node.defaultStatements)processedDefaultStatements.push(...$cf264a5b1eb44de7$export$2e2bcd8739ae039(defaultStatement, symbolTable, enclosingFunc));
            $cf264a5b1eb44de7$var$auxInfo.inSwitch = originalInSwitch;
            return [
                {
                    type: "SwitchStatement",
                    targetExpression: processedTargetExpression.exprs[0],
                    cases: processedCases,
                    defaultStatements: processedDefaultStatements,
                    position: node.position
                }
            ];
        } else if (node.type === "Assignment") return (0, $ad114c17e3ec942a$export$ac7287207bedb81b)(node, symbolTable).memoryStoreStatements;
        else if (node.type === "FunctionCall") // in this context, the return (if any) of the functionCall is ignored, as it is used as a statement
        return [
            (0, $b7e59eb4969f10fd$export$ef60bcd1c93fe004)(node, symbolTable).functionCallP
        ];
        else if (node.type === "PrefixExpression" || node.type === "PostfixExpression") {
            if (node.operator === "++" || node.operator === "--") // only increment and decrement expressions become statements
            return (0, $553cdff61180334d$export$2ae654d1d3591e24)(node, symbolTable).storeNodes;
            else {
                // NOTE: commented out to disable removal of "redundant" statements
                // processExpression(node, symbolTable, enclosingFunc);
                // return [];
                const processed = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(node, symbolTable, enclosingFunc);
                return [
                    {
                        type: "ExpressionStatement",
                        expr: processed.exprs[0],
                        position: processed.exprs[0].position
                    }
                ];
            }
        } else if (node.type === "CommaSeparatedExpressions") {
            const processedExpressions = [];
            node.expressions.forEach((e)=>{
                processedExpressions.push(...$cf264a5b1eb44de7$export$2e2bcd8739ae039(e, symbolTable, enclosingFunc));
            });
            return processedExpressions;
        } else if (node.type === "ConditionalExpression") {
            (0, $551bb05b84852d99$export$2e2bcd8739ae039)(node, symbolTable, enclosingFunc);
            // break this conditional into a simple if else expression (expressions inside condtional may have side effects)
            return [
                {
                    type: "SelectionStatement",
                    condition: (0, $278774b275ed49b9$export$41f976199fdafdab)(node.condition, symbolTable),
                    ifStatements: $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.trueExpression, symbolTable, enclosingFunc),
                    elseStatements: $cf264a5b1eb44de7$export$2e2bcd8739ae039(node.falseExpression, symbolTable, enclosingFunc),
                    position: node.position
                }
            ];
        } else if (node.type === "AddressOfExpression" || node.type === "BinaryExpression" || node.type === "FloatConstant" || node.type === "IntegerConstant" || node.type === "IdentifierExpression" || node.type === "PointerDereference" || node.type === "SizeOfExpression" || node.type === "StructMemberAccess") {
            (0, $e5f32705ab2cc688$export$8cf0d8363c40fe56)("statement with no effect", node.position);
            // NOTE: commented out to disable removal of "redundant" statements
            // processExpression(node, symbolTable, enclosingFunc);
            // all these expression statements can be safely ignored as they have no side effects
            // return [];
            const processed = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(node, symbolTable, enclosingFunc);
            return [
                {
                    type: "ExpressionStatement",
                    expr: processed.exprs[0],
                    position: processed.exprs[0].position
                }
            ];
        } else if (node.type === "StringLiteral") {
            (0, $e5f32705ab2cc688$export$8cf0d8363c40fe56)("statement with no effect", node.position);
            return [];
        } else if (node.type === "Declaration" || node.type === "EnumDeclaration") return (0, $de78ebef6c7c100a$export$f3f7c2f7637d5845)(node, symbolTable, enclosingFunc);
        else throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`unhandled C AST node: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(node)}`);
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$f75c42204311f6de) && e.position === null) e.addPositionInfo(node.position);
        throw e;
    }
}



/**
 * This file contains various utility functions to help in checking the fulfillment of constraints of different language features.
 */ 



function $7fa195c2e9d4847a$export$56a6d0cab5953511(expression, processedUnderlyingExpr, symbolTable) {
    const dataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedUnderlyingExpr
    });
    // must be real or pointer type and be modifiable lvalue
    if (!(0, $5320ef4601c98354$export$a01621f73ef8c07a)(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`wrong type argument to ${expression.operator === "++" ? "increment" : "decrement"}`);
    if (!(0, $ad114c17e3ec942a$export$812debddbb699ddf)(expression.expr, dataType, symbolTable)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`argument to ${expression.operator === "++" ? "increment" : "decrement"} is not a modifiable lvalue`);
}
function $7fa195c2e9d4847a$export$5a8f095b299f46c0(binaryExpr, processedLeftExpr, processedRightExpr) {
    const leftDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedLeftExpr,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    const rightDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedRightExpr,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    function throwBinaryExpressionInvalidOperandsError() {
        throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`invalid operands to binary '${binaryExpr.operator}' (have '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(leftDataType)}' and '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(rightDataType)}')`);
    }
    function checkBothOperandsHaveType(checker) {
        return checker(leftDataType) && checker(rightDataType);
    }
    function checkOperandsTypeCombination(checker1, checker2) {
        return checker1(leftDataType) && checker2(rightDataType) || checker2(leftDataType) && checker1(rightDataType);
    }
    function checkPointerCompatibilityIgnoringQualifiers() {
        return checkBothOperandsHaveType((0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)) && (0, $5320ef4601c98354$export$827aa09e8bb8706a)(leftDataType, rightDataType, true);
    }
    switch(binaryExpr.operator){
        case "*":
        case "/":
            if (!checkBothOperandsHaveType((0, $5320ef4601c98354$export$90c3ec6c2230fc55))) throwBinaryExpressionInvalidOperandsError();
            break;
        case "%":
            if (!checkBothOperandsHaveType((0, $5320ef4601c98354$export$25d6369c8c841882))) throwBinaryExpressionInvalidOperandsError();
            break;
        case "+":
            if (!(checkBothOperandsHaveType((0, $5320ef4601c98354$export$90c3ec6c2230fc55)) || checkOperandsTypeCombination((0, $5320ef4601c98354$export$facab95c4a7fe39d), (0, $5320ef4601c98354$export$25d6369c8c841882)))) throwBinaryExpressionInvalidOperandsError();
            break;
        case "-":
            if (!(checkBothOperandsHaveType((0, $5320ef4601c98354$export$90c3ec6c2230fc55)) || (0, $5320ef4601c98354$export$facab95c4a7fe39d)(leftDataType) && (0, $5320ef4601c98354$export$25d6369c8c841882)(rightDataType) || checkPointerCompatibilityIgnoringQualifiers())) throwBinaryExpressionInvalidOperandsError();
            break;
        case ">>":
        case "<<":
            if (!checkBothOperandsHaveType((0, $5320ef4601c98354$export$25d6369c8c841882))) throwBinaryExpressionInvalidOperandsError();
            break;
        case ">":
        case "<":
        case "<=":
        case ">=":
            if (!(checkBothOperandsHaveType((0, $5320ef4601c98354$export$5b58f4d23d0747c2)) || checkPointerCompatibilityIgnoringQualifiers())) throwBinaryExpressionInvalidOperandsError();
            break;
        case "==":
        case "!=":
            if (!(checkBothOperandsHaveType((0, $5320ef4601c98354$export$90c3ec6c2230fc55)) || checkPointerCompatibilityIgnoringQualifiers() || checkOperandsTypeCombination((0, $5320ef4601c98354$export$d9dc9de95b4ea5f4), (0, $5320ef4601c98354$export$7aeb852ee71637ec)) || (0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)(leftDataType) && (0, $5320ef4601c98354$export$1b3c7a16549b154a)(processedRightExpr) || (0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)(rightDataType) && (0, $5320ef4601c98354$export$1b3c7a16549b154a)(processedLeftExpr))) throwBinaryExpressionInvalidOperandsError();
            break;
        case "&":
        case "^":
        case "|":
            if (!checkBothOperandsHaveType((0, $5320ef4601c98354$export$25d6369c8c841882))) throwBinaryExpressionInvalidOperandsError();
            break;
        case "&&":
        case "||":
            if (!checkBothOperandsHaveType((0, $5320ef4601c98354$export$a01621f73ef8c07a))) throw throwBinaryExpressionInvalidOperandsError();
    }
}
function $7fa195c2e9d4847a$export$35f6d94ab0cdeb18(processedCondition, processedTrueExpression, processedFalseExpression) {
    // check condition
    const dataTypeOfConditionExpression = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedCondition,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    if (!(0, $5320ef4601c98354$export$a01621f73ef8c07a)(dataTypeOfConditionExpression)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`used '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(dataTypeOfConditionExpression)}' in first operand of conditional expression where scalar is required`);
    const dataTypeOfTrueOperand = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedTrueExpression,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    const dataTypeOfFalseOperand = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedFalseExpression,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    // check 2nd and 3rd operand constraints
    if (!((0, $5320ef4601c98354$export$90c3ec6c2230fc55)(dataTypeOfTrueOperand) && (0, $5320ef4601c98354$export$90c3ec6c2230fc55)(dataTypeOfFalseOperand) || (0, $5320ef4601c98354$export$827aa09e8bb8706a)(dataTypeOfTrueOperand, dataTypeOfFalseOperand, true) || (0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)(dataTypeOfTrueOperand) && ((0, $5320ef4601c98354$export$1b3c7a16549b154a)(processedFalseExpression) || (0, $5320ef4601c98354$export$7aeb852ee71637ec)(dataTypeOfFalseOperand)) || (0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)(dataTypeOfFalseOperand) && ((0, $5320ef4601c98354$export$1b3c7a16549b154a)(processedTrueExpression) || (0, $5320ef4601c98354$export$7aeb852ee71637ec)(dataTypeOfTrueOperand)))) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`type mismatch in conditional expression (have '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(dataTypeOfTrueOperand)}' and '${(0, $5320ef4601c98354$export$19913cd95b069dcd)(dataTypeOfFalseOperand)}')`);
}


function $551bb05b84852d99$export$2e2bcd8739ae039(expr, symbolTable, enclosingFunc) {
    try {
        if (expr.type === "Assignment") {
            const { memoryStoreStatements: memoryStoreStatements, memoryLoadExpressions: memoryLoadExpressions, dataType: dataType } = (0, $ad114c17e3ec942a$export$ac7287207bedb81b)(expr, symbolTable);
            return {
                originalDataType: dataType,
                exprs: [
                    // first expr has all the assignment nodes TODO: see if any better way
                    {
                        type: "PreStatementExpression",
                        statements: memoryStoreStatements,
                        expr: memoryLoadExpressions[0],
                        dataType: memoryLoadExpressions[0].dataType,
                        position: memoryLoadExpressions[0].position
                    },
                    ...memoryLoadExpressions.slice(1)
                ]
            };
        } else if (expr.type === "BinaryExpression") {
            const processedLeftExpr = $551bb05b84852d99$export$2e2bcd8739ae039(expr.leftExpr, symbolTable);
            const processedLeftExprDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: processedLeftExpr,
                convertArrayToPointer: true,
                convertFunctionToPointer: true
            });
            const processedRightExpr = $551bb05b84852d99$export$2e2bcd8739ae039(expr.rightExpr, symbolTable);
            const processedRightExprDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: processedRightExpr,
                convertArrayToPointer: true,
                convertFunctionToPointer: true
            });
            (0, $7fa195c2e9d4847a$export$5a8f095b299f46c0)(expr, processedLeftExpr, processedRightExpr);
            // at this point all the operands can only be scalar data types
            const binaryExpressionDataType = (0, $553cdff61180334d$export$aeff407985fcdd14)(processedLeftExprDataType, processedRightExprDataType, expr.operator);
            const operandTargetDataType = (0, $553cdff61180334d$export$60a4dbab6386febc)(processedLeftExprDataType, processedRightExprDataType, expr.operator);
            let leftExpr = processedLeftExpr.exprs[0];
            let rightExpr = processedRightExpr.exprs[0];
            // account for pointer type arithmetic - already checked that it must be '+' or '-' in determineDataTypeOfBinaryExpression
            if (processedLeftExprDataType.type === "pointer" && processedRightExprDataType.type === "primary") rightExpr = {
                type: "BinaryExpression",
                operator: "*",
                leftExpr: rightExpr,
                rightExpr: {
                    type: "IntegerConstant",
                    value: BigInt((0, $5320ef4601c98354$export$1713163196af6553)(processedLeftExprDataType.pointeeType)),
                    dataType: rightExpr.dataType,
                    position: rightExpr.position
                },
                position: rightExpr.position,
                dataType: rightExpr.dataType,
                operandTargetDataType: rightExpr.dataType
            };
            else if (processedRightExprDataType.type === "pointer" && processedLeftExprDataType.type === "primary") leftExpr = {
                type: "BinaryExpression",
                operator: "*",
                leftExpr: leftExpr,
                rightExpr: {
                    type: "IntegerConstant",
                    value: BigInt((0, $5320ef4601c98354$export$1713163196af6553)(processedRightExprDataType.pointeeType)),
                    dataType: leftExpr.dataType,
                    position: rightExpr.position
                },
                position: leftExpr.position,
                dataType: leftExpr.dataType,
                operandTargetDataType: leftExpr.dataType
            };
            if (processedRightExprDataType.type === "pointer" && processedLeftExprDataType.type === "pointer" && expr.operator === "-") // special handling for subtraction between pointers, need to divide result by underlying type size
            return {
                originalDataType: binaryExpressionDataType,
                exprs: [
                    {
                        type: "BinaryExpression",
                        leftExpr: {
                            type: "BinaryExpression",
                            leftExpr: leftExpr,
                            rightExpr: rightExpr,
                            operator: expr.operator,
                            dataType: binaryExpressionDataType.type === "pointer" ? "pointer" : binaryExpressionDataType.primaryDataType,
                            operandTargetDataType: "pointer",
                            position: leftExpr.position
                        },
                        operator: "/",
                        rightExpr: {
                            type: "IntegerConstant",
                            value: BigInt((0, $5320ef4601c98354$export$1713163196af6553)(processedRightExprDataType.pointeeType)),
                            dataType: (0, $cd849de488b21116$export$882db9e1117e2725),
                            position: rightExpr.position
                        },
                        dataType: (0, $cd849de488b21116$export$882db9e1117e2725),
                        operandTargetDataType: (0, $cd849de488b21116$export$882db9e1117e2725),
                        position: expr.position
                    }
                ]
            };
            return {
                originalDataType: binaryExpressionDataType,
                exprs: [
                    {
                        type: "BinaryExpression",
                        leftExpr: leftExpr,
                        rightExpr: rightExpr,
                        operator: expr.operator,
                        dataType: binaryExpressionDataType.type === "pointer" ? "pointer" : binaryExpressionDataType.primaryDataType,
                        operandTargetDataType: operandTargetDataType.type === "pointer" ? "pointer" : operandTargetDataType.primaryDataType,
                        position: expr.position
                    }
                ]
            };
        } else if (expr.type === "IntegerConstant" || expr.type === "FloatConstant") {
            const processedConstant = (0, $e3d15c53d7bc5411$export$2e2bcd8739ae039)(expr);
            return {
                originalDataType: {
                    type: "primary",
                    primaryDataType: processedConstant.dataType
                },
                exprs: [
                    processedConstant
                ]
            };
        } else if (expr.type === "FunctionCall") {
            const { functionCallP: functionCallStatement, returnType: funcReturnType } = (0, $b7e59eb4969f10fd$export$ef60bcd1c93fe004)(expr, symbolTable);
            if (funcReturnType.type === "void") // trying to use a function call as an expression in context that expects a return object
            throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("void value not ignored as it should be");
            // start curr offset at negative of the size of the return obj
            let currOffset = -(0, $5320ef4601c98354$export$1713163196af6553)(funcReturnType);
            const returnObjectMemoryLoads = [];
            (0, $5320ef4601c98354$export$8b795b2cde35800)(funcReturnType).forEach((returnObj)=>{
                returnObjectMemoryLoads.push({
                    type: "MemoryLoad",
                    address: {
                        type: "ReturnObjectAddress",
                        subtype: "load",
                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                        dataType: "pointer",
                        position: expr.position
                    },
                    dataType: returnObj.dataType,
                    position: expr.position
                });
                currOffset += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(returnObj.dataType);
            });
            // regardless of return type, all function call expression have a preStatementExpression
            return {
                originalDataType: funcReturnType,
                exprs: [
                    {
                        type: "PreStatementExpression",
                        // run function call before loading return values
                        statements: [
                            functionCallStatement
                        ],
                        dataType: returnObjectMemoryLoads[0].dataType,
                        expr: returnObjectMemoryLoads[0],
                        position: expr.position
                    },
                    ...returnObjectMemoryLoads.slice(1)
                ]
            };
        } else if (expr.type === "PrefixExpression") return (0, $553cdff61180334d$export$6c6c91bee4d2e1d5)(expr, symbolTable);
        else if (expr.type === "PostfixExpression") return (0, $553cdff61180334d$export$382824ef9c3227d3)(expr, symbolTable);
        else if (expr.type === "IdentifierExpression") {
            const symbolEntry = symbolTable.getSymbolEntry(expr.name);
            if (!symbolEntry) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`'${expr.name}' undeclared`);
            // a function becomes a pointer to a function
            if (symbolEntry.type === "function") return (0, $278774b275ed49b9$export$6b66ad629d132504)(expr.name, symbolEntry.dataType, symbolTable);
            if (symbolEntry.type === "enumerator") // enumerator values are just compile-time constants
            return {
                originalDataType: symbolEntry.dataType,
                exprs: [
                    {
                        type: "IntegerConstant",
                        value: symbolEntry.value,
                        dataType: symbolEntry.dataType.primaryDataType,
                        position: expr.position
                    }
                ]
            };
            if (symbolEntry.dataType.type === "array") // arrays are treated as pointer
            return {
                originalDataType: symbolEntry.dataType,
                exprs: [
                    {
                        type: symbolEntry.type === "dataSegmentVariable" ? "DataSegmentAddress" : "LocalAddress",
                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(symbolEntry.offset),
                        dataType: "pointer",
                        position: expr.position
                    }
                ]
            };
            else {
                const unpackedDataType = (0, $5320ef4601c98354$export$8b795b2cde35800)(symbolEntry.dataType);
                return {
                    originalDataType: symbolEntry.dataType,
                    exprs: unpackedDataType.map((primaryDataObject)=>({
                            type: "MemoryLoad",
                            address: {
                                type: symbolEntry.type === "dataSegmentVariable" ? "DataSegmentAddress" : "LocalAddress",
                                offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(symbolEntry.offset + primaryDataObject.offset),
                                dataType: "pointer",
                                position: expr.position
                            },
                            dataType: primaryDataObject.dataType,
                            position: expr.position
                        }))
                };
            }
        } else if (expr.type === "AddressOfExpression") {
            if (expr.expr.type === "IdentifierExpression") {
                // taking the address of a symbol - could be a variable or function
                const identifier = expr.expr.name;
                const symbolEntry = symbolTable.getSymbolEntry(identifier);
                if (symbolEntry.type === "function") return (0, $278774b275ed49b9$export$6b66ad629d132504)(expr.expr.name, symbolEntry.dataType, symbolTable);
                if (symbolEntry.type === "enumerator" || !(0, $ad114c17e3ec942a$export$eb6df2cfd9d662f1)(expr.expr, symbolEntry.dataType, symbolTable, true)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("lvalue required as unary '&' operand");
                // If function pointer, dont increase the pointer nesting, just return processed identifier expression
                if ((0, $278774b275ed49b9$export$90b7432f092d8baf)(symbolEntry.dataType)) return $551bb05b84852d99$export$2e2bcd8739ae039(expr.expr, symbolTable, enclosingFunc);
                return {
                    originalDataType: {
                        type: "pointer",
                        pointeeType: symbolEntry.dataType
                    },
                    exprs: [
                        {
                            type: symbolEntry.type === "dataSegmentVariable" ? "DataSegmentAddress" : "LocalAddress",
                            offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(symbolEntry.offset),
                            dataType: "pointer",
                            position: expr.position
                        }
                    ]
                };
            } else if (expr.expr.type === "PointerDereference") return $551bb05b84852d99$export$2e2bcd8739ae039(expr.expr.expr, symbolTable); // simply return the expression within the deref expression (& cancels *)
            else throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("lvalue required for unary '&' operand");
        } else if (expr.type === "PointerDereference") {
            // process the expression being dereferenced first
            const derefedExpression = $551bb05b84852d99$export$2e2bcd8739ae039(expr.expr, symbolTable);
            const derefedExpressionDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: derefedExpression,
                convertArrayToPointer: true,
                convertFunctionToPointer: true
            });
            if (derefedExpressionDataType.type !== "pointer") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`cannot dereference non-pointer type`);
            if ((0, $5320ef4601c98354$export$7aeb852ee71637ec)(derefedExpressionDataType)) {
                (0, $e5f32705ab2cc688$export$8cf0d8363c40fe56)("dereferencing void pointer", expr.position);
                return {
                    originalDataType: derefedExpressionDataType.pointeeType,
                    exprs: []
                };
            }
            // if the derefed expression a function pointer, it remains one
            if ((0, $278774b275ed49b9$export$90b7432f092d8baf)(derefedExpressionDataType)) return derefedExpression;
            if (derefedExpressionDataType.pointeeType.type === "primary" || derefedExpressionDataType.pointeeType.type === "pointer") return {
                originalDataType: derefedExpressionDataType.pointeeType,
                exprs: [
                    {
                        type: "MemoryLoad",
                        address: {
                            type: "DynamicAddress",
                            address: derefedExpression.exprs[0],
                            dataType: "pointer",
                            position: derefedExpression.exprs[0].position
                        },
                        dataType: derefedExpressionDataType.pointeeType.type === "pointer" ? "pointer" : derefedExpressionDataType.pointeeType.primaryDataType,
                        position: expr.position
                    }
                ]
            };
            else if (derefedExpressionDataType.pointeeType.type === "array") // the resultant data type of the whole dereference expression should be pointer to the array element type, as arrays are treated as pointers
            return {
                originalDataType: derefedExpressionDataType.pointeeType,
                exprs: [
                    {
                        type: "DynamicAddress",
                        address: derefedExpression.exprs[0],
                        dataType: "pointer",
                        position: derefedExpression.exprs[0].position
                    }
                ]
            };
            else {
                const unpackedStruct = (0, $5320ef4601c98354$export$8b795b2cde35800)(derefedExpressionDataType.pointeeType);
                return {
                    originalDataType: derefedExpressionDataType.pointeeType,
                    exprs: unpackedStruct.map((primaryDataObject)=>({
                            type: "MemoryLoad",
                            address: {
                                type: "DynamicAddress",
                                address: {
                                    type: "BinaryExpression",
                                    leftExpr: derefedExpression.exprs[0],
                                    rightExpr: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(primaryDataObject.offset),
                                    operator: "+",
                                    operandTargetDataType: "pointer",
                                    dataType: "pointer",
                                    position: expr.position
                                },
                                dataType: "pointer",
                                position: expr.position
                            },
                            dataType: primaryDataObject.dataType,
                            position: expr.position
                        }))
                };
            }
        } else if (expr.type === "SizeOfExpression") {
            let dataTypeToGetSizeOf;
            if (expr.subtype === "expression") // sizeof used on expression
            dataTypeToGetSizeOf = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: $551bb05b84852d99$export$2e2bcd8739ae039(expr.expr, symbolTable)
            });
            else // sizeof used on datatype
            dataTypeToGetSizeOf = expr.dataType;
            // check constraints are met as per 6.5.3.4/1 of C17 standard
            // incomplete pointer check already done at parser
            if (dataTypeToGetSizeOf.type === "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("invalid application of 'sizeof' to function type");
            return {
                originalDataType: {
                    type: "primary",
                    primaryDataType: (0, $cd849de488b21116$export$f089f2422e95b42b)
                },
                exprs: [
                    {
                        type: "IntegerConstant",
                        value: BigInt((0, $5320ef4601c98354$export$1713163196af6553)(dataTypeToGetSizeOf)),
                        dataType: (0, $cd849de488b21116$export$f089f2422e95b42b),
                        position: expr.position
                    }
                ]
            };
        } else if (expr.type === "StructMemberAccess") {
            const processedExpr = $551bb05b84852d99$export$2e2bcd8739ae039(expr.expr, symbolTable); // process the underlying expression being operated on
            const dataTypeOfExpr = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: processedExpr,
                convertArrayToPointer: true,
                convertFunctionToPointer: true
            });
            if (dataTypeOfExpr.type !== "struct") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`request for member '${expr.fieldTag}' in something that is not a structure`);
            const { fieldIndex: fieldIndex, fieldDataType: fieldDataType } = (0, $5320ef4601c98354$export$24ed50fc59c5d0ff)(dataTypeOfExpr, expr.fieldTag);
            if (fieldDataType.type === "array") {
                // treat array field as just a pointer
                const dataTypeOfPointer = {
                    type: "pointer",
                    pointeeType: fieldDataType.elementDataType
                };
                if (processedExpr.exprs[0].type === "PreStatementExpression") {
                    // handle special case of accessing struct field of a returned struct from function call
                    // the prestaetments need to be incorporated, even if the first primary expression (exprs[0]) is not
                    let memoryLoadExpr; // the memoryload that the pointer value is being derived from
                    if (fieldIndex === 0) {
                        const memLoad = processedExpr.exprs[0].expr;
                        if (memLoad.type !== "MemoryLoad") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`request for member '${expr.fieldTag}' in something that is not a structure or union`);
                        memoryLoadExpr = memLoad;
                    } else {
                        const memLoad = processedExpr.exprs[fieldIndex];
                        if (memLoad.type !== "MemoryLoad") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`request for member '${expr.fieldTag}' in something that is not a structure or union`);
                        memoryLoadExpr = memLoad;
                    }
                    return {
                        originalDataType: dataTypeOfPointer,
                        exprs: [
                            {
                                type: "PreStatementExpression",
                                statements: processedExpr.exprs[0].statements,
                                expr: {
                                    type: "DynamicAddress",
                                    address: memoryLoadExpr.address,
                                    dataType: "pointer",
                                    position: memoryLoadExpr.position
                                },
                                dataType: "pointer",
                                position: memoryLoadExpr.position
                            }
                        ]
                    };
                }
                return {
                    originalDataType: {
                        type: "pointer",
                        pointeeType: fieldDataType.elementDataType
                    },
                    exprs: [
                        {
                            type: "DynamicAddress",
                            address: processedExpr.exprs[fieldIndex].address,
                            dataType: "pointer",
                            position: processedExpr.exprs[fieldIndex].position
                        }
                    ]
                };
            } else {
                // procssedExpr already consists of accessing the whole struct (all primary memory object loads)
                // just use field index to access the right ones
                const memoryLoadExprs = [];
                let totalBytesLoaded = 0;
                let currLoadIndex = fieldIndex;
                if (processedExpr.exprs[0].type === "PreStatementExpression") {
                    // special case - if the first expression is a prestatement, then it is probably a function call, need to make sure that the statements from the prestatement are included
                    const loadExpr = processedExpr.exprs[currLoadIndex++];
                    if (loadExpr.type === "PreStatementExpression") {
                        // fieldIndex could be 0, so loadExpr and exprs[0] could be the same prestatementexpression
                        memoryLoadExprs.push(loadExpr);
                        totalBytesLoaded += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(loadExpr.expr.dataType);
                    } else if (loadExpr.type === "MemoryLoad") {
                        memoryLoadExprs.push({
                            type: "PreStatementExpression",
                            statements: processedExpr.exprs[0].statements,
                            expr: loadExpr,
                            dataType: loadExpr.dataType,
                            position: loadExpr.position
                        });
                        totalBytesLoaded += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(loadExpr.dataType);
                    } else throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`request for member '${expr.fieldTag}' in something that is not a structure or union`);
                }
                while(totalBytesLoaded < (0, $5320ef4601c98354$export$1713163196af6553)(fieldDataType)){
                    if (processedExpr.exprs[currLoadIndex].type !== "MemoryLoad") // only "MemoryLoads" can possibly indicate an lvalue
                    throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`request for member '${expr.fieldTag}' in something that is not a structure or union`);
                    totalBytesLoaded += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(processedExpr.exprs[currLoadIndex].dataType);
                    memoryLoadExprs.push(processedExpr.exprs[currLoadIndex++]);
                }
                return {
                    originalDataType: fieldDataType.type === "struct self pointer" ? {
                        type: "pointer",
                        pointeeType: dataTypeOfExpr
                    } // datatype is a pointer to the struct itself
                     : fieldDataType,
                    exprs: memoryLoadExprs
                };
            }
        } else if (expr.type === "CommaSeparatedExpressions") {
            // only last expression becomes a true Expression (one where a value is expected)
            // process the first expressions as statements
            const processedLastExpr = $551bb05b84852d99$export$2e2bcd8739ae039(expr.expressions[expr.expressions.length - 1], symbolTable);
            const precedingExpressionsAsStatements = [];
            for(let i = 0; i < expr.expressions.length - 1; ++i)precedingExpressionsAsStatements.push(...(0, $cf264a5b1eb44de7$export$2e2bcd8739ae039)(expr.expressions[i], symbolTable, enclosingFunc));
            return {
                originalDataType: processedLastExpr.originalDataType,
                exprs: [
                    {
                        type: "PreStatementExpression",
                        statements: precedingExpressionsAsStatements,
                        expr: processedLastExpr.exprs[0],
                        dataType: processedLastExpr.exprs[0].dataType,
                        position: processedLastExpr.exprs[0].position
                    },
                    ...processedLastExpr.exprs.slice(1)
                ]
            };
        } else if (expr.type === "ConditionalExpression") {
            const processedCondition = $551bb05b84852d99$export$2e2bcd8739ae039(expr.condition, symbolTable, enclosingFunc);
            const processedTrueExpression = $551bb05b84852d99$export$2e2bcd8739ae039(expr.trueExpression, symbolTable);
            const dataTypeOfTrueExpression = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: processedTrueExpression,
                convertArrayToPointer: true,
                convertFunctionToPointer: true
            });
            const processedFalseExpression = $551bb05b84852d99$export$2e2bcd8739ae039(expr.falseExpression, symbolTable);
            const dataTypeOfFalseExpression = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
                expression: processedFalseExpression,
                convertArrayToPointer: true,
                convertFunctionToPointer: true
            });
            (0, $7fa195c2e9d4847a$export$35f6d94ab0cdeb18)(processedCondition, processedTrueExpression, processedFalseExpression);
            const resultDataType = (0, $553cdff61180334d$export$a2ccd70e211437f7)(dataTypeOfTrueExpression, dataTypeOfFalseExpression);
            return {
                originalDataType: resultDataType,
                exprs: processedTrueExpression.exprs.map((truePrimaryExpr, index)=>({
                        type: "ConditionalExpression",
                        condition: processedCondition.exprs[0],
                        trueExpression: truePrimaryExpr,
                        falseExpression: processedFalseExpression.exprs[index],
                        dataType: resultDataType.type === "primary" ? resultDataType.primaryDataType : resultDataType.type === "pointer" ? "pointer" : truePrimaryExpr.dataType,
                        position: truePrimaryExpr.position
                    }))
            };
        } else if (expr.type === "StringLiteral") {
            // allocate the string in datasegment
            const dataSegmentOffset = symbolTable.addDataSegmentObject(expr.chars);
            return {
                originalDataType: {
                    type: "pointer",
                    pointeeType: {
                        type: "primary",
                        primaryDataType: "signed char"
                    }
                },
                exprs: [
                    {
                        type: "DataSegmentAddress",
                        offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(dataSegmentOffset),
                        dataType: "pointer",
                        position: expr.position
                    }
                ]
            };
        } else // this should not happen
        throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`unhandled Expression: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(expr)}`);
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$f75c42204311f6de) && e.position === null) e.addPositionInfo(expr.position);
        throw e;
    }
}





function $553cdff61180334d$var$isRelationalOperator(op) {
    return op === "!=" || op === "<" || op === "<=" || op === "==" || op === ">=" || op === ">";
}
function $553cdff61180334d$var$isLogicalOperator(op) {
    return op === "&&" || op === "||";
}
function $553cdff61180334d$export$cede45fa5aa8b63b(dataType) {
    if (dataType.type !== "pointer" && dataType.type !== "primary" && dataType.type !== "array") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("non scalar data type");
    return dataType.type === "pointer" || dataType.type === "array" ? "pointer" : dataType.primaryDataType;
}
function $553cdff61180334d$export$a2ccd70e211437f7(leftExprDataType, rightExprDataType) {
    if ((0, $5320ef4601c98354$export$90c3ec6c2230fc55)(leftExprDataType) && (0, $5320ef4601c98354$export$90c3ec6c2230fc55)(rightExprDataType)) return $553cdff61180334d$export$e89a1d915328d799(leftExprDataType, rightExprDataType);
    if (leftExprDataType.type === "struct" || leftExprDataType.type === "void") return leftExprDataType;
    if ((0, $5320ef4601c98354$export$7aeb852ee71637ec)(leftExprDataType) || (0, $5320ef4601c98354$export$7aeb852ee71637ec)(rightExprDataType)) return {
        type: "pointer",
        pointeeType: {
            isConst: leftExprDataType.isConst || rightExprDataType.isConst,
            type: "void"
        }
    };
    // at least one of the operands must be non void pointer (other might be the same pointer, of a null pointer constant)
    if ((0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)(leftExprDataType)) return {
        ...leftExprDataType,
        isConst: leftExprDataType.isConst || rightExprDataType.isConst
    };
    if ((0, $5320ef4601c98354$export$d9dc9de95b4ea5f4)(rightExprDataType)) return {
        ...rightExprDataType,
        isConst: leftExprDataType.isConst || rightExprDataType.isConst
    };
    // shouldnt happen
    throw new Error("determineConditionalExpressionDataType(): error in function");
}
function $553cdff61180334d$export$60a4dbab6386febc(leftExprDataType, rightExprDataType, operator) {
    // no need to check for validity of operand types, as this will have been checked before the function was called
    // if either data type are pointers, then target data type is pointer (unsigned int)
    // if both are pointer, it can only be a subtraction, in which case the resultant data type is PTRDIFF
    if (leftExprDataType.type === "pointer" && rightExprDataType.type === "pointer") return {
        type: "primary",
        primaryDataType: (0, $cd849de488b21116$export$882db9e1117e2725)
    };
    else if (leftExprDataType.type === "pointer") return leftExprDataType;
    else if (rightExprDataType.type === "pointer") return rightExprDataType;
    else if (operator === "<<" || operator === ">>") return leftExprDataType;
    return $553cdff61180334d$export$e89a1d915328d799(leftExprDataType, rightExprDataType);
}
function $553cdff61180334d$export$e89a1d915328d799(leftExprDataType, rightExprDataType) {
    if ((0, $5320ef4601c98354$export$db1d6bf10724bb3f)(leftExprDataType) && (0, $5320ef4601c98354$export$db1d6bf10724bb3f)(rightExprDataType)) {
        // take more higher ranking float type
        if ((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[leftExprDataType.primaryDataType] > (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[rightExprDataType.primaryDataType]) return leftExprDataType;
        else return rightExprDataType;
    } else if ((0, $5320ef4601c98354$export$db1d6bf10724bb3f)(leftExprDataType)) // float types have greater precedence than any integer types
    return leftExprDataType;
    else if ((0, $5320ef4601c98354$export$db1d6bf10724bb3f)(rightExprDataType)) return rightExprDataType;
    else {
        if ((0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[leftExprDataType.primaryDataType] > (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[rightExprDataType.primaryDataType]) return leftExprDataType;
        else return rightExprDataType;
    }
}
function $553cdff61180334d$export$aeff407985fcdd14(leftExprDataType, rightExprDataType, operator) {
    if ($553cdff61180334d$var$isRelationalOperator(operator) || $553cdff61180334d$var$isLogicalOperator(operator)) return {
        type: "primary",
        primaryDataType: "signed int"
    };
    return $553cdff61180334d$export$60a4dbab6386febc(leftExprDataType, rightExprDataType, operator);
}
function $553cdff61180334d$export$2ae654d1d3591e24(expr, symbolTable) {
    const binaryOperator = expr.operator === "++" ? "+" : "-";
    const processedExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(expr.expr, symbolTable);
    (0, $7fa195c2e9d4847a$export$56a6d0cab5953511)(expr, processedExpr, symbolTable);
    const dataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedExpr
    });
    // do some checks on the operand
    // simply use the load exprs from the processed expr to create the memory store staements
    if (processedExpr.exprs[0].type !== "MemoryLoad") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`lvalue required for '${expr.operator}' expression`);
    else if (processedExpr.exprs.length > 1) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`'${expr.operator}' expression operand must be a scalar type`);
    else if ((0, $5320ef4601c98354$export$7aeb852ee71637ec)(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`cannot perform arithmetic on void pointer`);
    let amountToIncrementBy;
    if (dataType.type === "pointer") amountToIncrementBy = BigInt((0, $5320ef4601c98354$export$1713163196af6553)(dataType.pointeeType));
    else if (dataType.type === "array") // need increment the underying expression (a pointer) by size of array
    amountToIncrementBy = BigInt((0, $5320ef4601c98354$export$1713163196af6553)(dataType));
    else amountToIncrementBy = 1n;
    const memoryLoad = processedExpr.exprs[0];
    const memoryStoreNodes = [
        {
            type: "MemoryStore",
            address: memoryLoad.address,
            value: {
                type: "BinaryExpression",
                leftExpr: memoryLoad,
                rightExpr: {
                    type: "IntegerConstant",
                    value: amountToIncrementBy,
                    dataType: "signed int",
                    position: memoryLoad.position
                },
                dataType: memoryLoad.dataType,
                operandTargetDataType: memoryLoad.dataType,
                operator: binaryOperator,
                position: memoryLoad.position
            },
            dataType: memoryLoad.dataType,
            position: memoryLoad.position
        }
    ];
    return {
        loadNode: memoryLoad,
        storeNodes: memoryStoreNodes,
        dataType: dataType
    };
}
function $553cdff61180334d$export$6c6c91bee4d2e1d5(prefixExpression, symbolTable) {
    if (prefixExpression.operator === "++" || prefixExpression.operator === "--") {
        const { loadNode: loadNode, storeNodes: storeNodes, dataType: dataType } = $553cdff61180334d$export$2ae654d1d3591e24(prefixExpression, symbolTable);
        return {
            originalDataType: dataType,
            exprs: [
                {
                    type: "PreStatementExpression",
                    statements: storeNodes,
                    expr: loadNode,
                    dataType: loadNode.dataType,
                    position: loadNode.position
                }
            ]
        };
    } else {
        const processedExpression = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(prefixExpression.expr, symbolTable);
        const dataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
            expression: processedExpression
        });
        // check constraints for each opeartor as per 6.5.3.3/1 of C standard
        if ((prefixExpression.operator === "+" || prefixExpression.operator === "-") && !(0, $5320ef4601c98354$export$90c3ec6c2230fc55)(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`wrong type argument to unary '${prefixExpression.operator}' expression; arithmetic type required`);
        else if (prefixExpression.operator === "~" && !(0, $5320ef4601c98354$export$25d6369c8c841882)(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`wrong type argument in unary '${prefixExpression.operator}' expression; integer type required`);
        else if (prefixExpression.operator === "!" && !(0, $5320ef4601c98354$export$a01621f73ef8c07a)(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`wrong type argument in unary '${prefixExpression.operator}' expression; scalar type required`);
        if (prefixExpression.operator === "+") {
            // "+" does nothing except integer promotion
            processedExpression.originalDataType = (0, $5320ef4601c98354$export$33c67e91126bcea2)(processedExpression.originalDataType);
            return processedExpression;
        } else {
            let resultDataType;
            switch(prefixExpression.operator){
                case "-":
                case "~":
                    resultDataType = (0, $5320ef4601c98354$export$33c67e91126bcea2)(processedExpression.originalDataType);
                    break;
                case "!":
                    resultDataType = {
                        type: "primary",
                        primaryDataType: "signed int"
                    };
            }
            return {
                originalDataType: resultDataType,
                exprs: [
                    {
                        type: "UnaryExpression",
                        operator: prefixExpression.operator,
                        expr: processedExpression.exprs[0],
                        dataType: processedExpression.exprs[0].dataType,
                        position: processedExpression.exprs[0].position
                    }
                ]
            };
        }
    }
}
function $553cdff61180334d$export$382824ef9c3227d3(postfixExpression, symbolTable) {
    const { loadNode: loadNode, storeNodes: storeNodes, dataType: dataType } = $553cdff61180334d$export$2ae654d1d3591e24(postfixExpression, symbolTable);
    return {
        originalDataType: dataType,
        exprs: [
            {
                type: "PostStatementExpression",
                statements: storeNodes,
                expr: loadNode,
                dataType: loadNode.dataType,
                position: loadNode.position
            }
        ]
    };
}





function $4a3275d19fa7fc08$export$83aec769090ee796(a, operator, b) {
    const isNonZero = (x)=>typeof x === "bigint" ? x !== 0n : x !== 0;
    switch(operator){
        // arithmetic operators
        case "+":
            return a + b;
        case "-":
            return a - b;
        case "*":
            return a * b;
        case "/":
            return a / b;
        case "%":
            return a % b;
        // logical operators
        case "&&":
            return isNonZero(a) && isNonZero(b) ? 1 : 0;
        case "||":
            return isNonZero(a) || isNonZero(b) ? 1 : 0;
        // relational operator
        case "<":
            return a < b ? 1 : 0;
        case "<=":
            return a <= b ? 1 : 0;
        case "!=":
            return a !== b ? 1 : 0;
        case "==":
            return a === b ? 1 : 0;
        case ">=":
            return a >= b ? 1 : 0;
        case ">":
            return a > b ? 1 : 0;
        // bitwise binary operator
        case ">>":
            return a >> b;
        case "<<":
            return a << b;
        case "&":
            return a & b;
        case "|":
            return a | b;
        case "^":
            return a ^ b;
    }
}
function $4a3275d19fa7fc08$export$865e368bb7818fa8(a, operator) {
    switch(operator){
        // Arithmetic unary opreators
        case "++":
            return a + 1;
        case "--":
            return a - 1;
        // Prefix Operators
        case "!":
            if (typeof a === "bigint") return a === 0n ? 1n : 0n;
            else return a === 0 ? 1 : 0;
        case "~":
            if (typeof a === "bigint") return ~a;
            else throw new Error("Bitwise NOT (~) operator can only be applied to integer types");
        case "-":
            return -a;
        case "+":
            return a;
    }
}
function $4a3275d19fa7fc08$export$960381d950ae61d4(expr) {
    if (expr.type === "FloatConstant" || expr.type === "IntegerConstant") return true;
    else if (expr.type === "BinaryExpression") return $4a3275d19fa7fc08$export$960381d950ae61d4(expr.leftExpr) && $4a3275d19fa7fc08$export$960381d950ae61d4(expr.rightExpr);
    else if (expr.type === "PrefixExpression" || expr.type === "PostfixExpression") return $4a3275d19fa7fc08$export$960381d950ae61d4(expr.expr);
    return false;
}
function $4a3275d19fa7fc08$export$2e2bcd8739ae039(expr) {
    if (expr.type === "FloatConstant" || expr.type === "IntegerConstant") // alerady a constant
    return (0, $e3d15c53d7bc5411$export$2e2bcd8739ae039)(expr);
    else if (expr.type === "BinaryExpression") {
        // binary expressions
        const evaluatedLeftExpr = $4a3275d19fa7fc08$export$2e2bcd8739ae039(expr.leftExpr);
        const evaluatedRightExpr = $4a3275d19fa7fc08$export$2e2bcd8739ae039(expr.rightExpr);
        let value = $4a3275d19fa7fc08$export$83aec769090ee796(evaluatedLeftExpr.value, expr.operator, evaluatedRightExpr.value);
        const dataType = (0, $553cdff61180334d$export$aeff407985fcdd14)({
            type: "primary",
            primaryDataType: evaluatedLeftExpr.dataType
        }, {
            type: "primary",
            primaryDataType: evaluatedRightExpr.dataType
        }, expr.operator);
        if (dataType.type !== "primary") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("invalid compile-time expression");
        if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(dataType.primaryDataType)) {
            // need to cap integer values correctly
            value = (0, $e3d15c53d7bc5411$export$5ab497d4db862f91)(value, dataType.primaryDataType);
            return {
                type: "IntegerConstant",
                dataType: dataType.primaryDataType,
                value: value,
                position: expr.position
            };
        } else // the result of the binary expression is a floating point
        return {
            type: "FloatConstant",
            dataType: dataType.primaryDataType,
            value: value,
            position: expr.position
        };
    } else if (expr.type === "PrefixExpression" || expr.type === "PostfixExpression") {
        // unary expressions
        const evaluatedExpr = $4a3275d19fa7fc08$export$2e2bcd8739ae039(expr.expr);
        const dataType = evaluatedExpr.dataType;
        let value = $4a3275d19fa7fc08$export$865e368bb7818fa8(evaluatedExpr.value, expr.operator);
        if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(dataType)) {
            // need to cap integer values correctly
            value = (0, $e3d15c53d7bc5411$export$5ab497d4db862f91)(value, dataType);
            return {
                type: "IntegerConstant",
                dataType: dataType,
                value: value,
                position: expr.position
            };
        } else // the result of the binary expression is a floating point
        return {
            type: "FloatConstant",
            dataType: dataType,
            value: value,
            position: expr.position
        };
    } else throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("cannot evaluate non compile-time constant type at compile-time");
}





function $5320ef4601c98354$var$getNumberOfElementsInArray(dataType) {
    try {
        const numElementsConstant = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(dataType.numElements);
        if (numElementsConstant.type === "FloatConstant") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("array size must be an integer-type");
        return Number(numElementsConstant.value);
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$f75c42204311f6de)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("Array size must be compile-time constant expression (Variable Length Arrays not supported)");
        else throw e;
    }
}
function $5320ef4601c98354$export$1713163196af6553(dataType) {
    if (dataType.type === "primary" || dataType.type === "pointer" || dataType.type === "struct self pointer") return (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(dataType.type === "pointer" || dataType.type === "struct self pointer" ? "pointer" : dataType.primaryDataType);
    else if (dataType.type === "array") return $5320ef4601c98354$var$getNumberOfElementsInArray(dataType) * $5320ef4601c98354$export$1713163196af6553(dataType.elementDataType);
    else if (dataType.type === "struct") return dataType.fields.reduce((sum, field)=>sum + (field.dataType.type === "struct self pointer" ? (0, $cd849de488b21116$export$11182fd140e7ea9f) : $5320ef4601c98354$export$1713163196af6553(field.dataType)), 0);
    else if (dataType.type === "enum") return (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[0, $cd849de488b21116$export$58b6502def2a4d77];
    else if (dataType.type === "void") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`void value not ignored as it should be`);
    else throw new Error(`getDataTypeSize(): unhandled data type: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(dataType)}`);
}
function $5320ef4601c98354$export$a01621f73ef8c07a(dataType) {
    return dataType.type === "primary" || dataType.type === "pointer" || dataType.type === "enum"; // enums are signed ints, thus scalar
}
function $5320ef4601c98354$export$5b58f4d23d0747c2(dataType) {
    return $5320ef4601c98354$export$a01621f73ef8c07a(dataType);
}
function $5320ef4601c98354$export$25d6369c8c841882(dataType) {
    return dataType.type === "primary" && (0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(dataType.primaryDataType) || dataType.type === "enum";
}
function $5320ef4601c98354$export$db1d6bf10724bb3f(dataType) {
    return dataType.type === "primary" && (0, $7f0b08f9e0a6f0f6$export$4a7e02d8ef2dc77a)(dataType.primaryDataType);
}
function $5320ef4601c98354$export$90c3ec6c2230fc55(dataType) {
    return dataType.type === "primary" || dataType.type === "enum";
}
function $5320ef4601c98354$export$7aeb852ee71637ec(dataType) {
    return dataType.type === "pointer" && dataType.pointeeType.type === "void";
}
function $5320ef4601c98354$export$facab95c4a7fe39d(dataType) {
    return dataType.type === "pointer" && dataType.pointeeType.type !== "void";
}
function $5320ef4601c98354$export$d9dc9de95b4ea5f4(dataType) {
    return dataType.type === "pointer";
}
function $5320ef4601c98354$export$922e76e1a79867f2(dataType) {
    return {
        type: "pointer",
        pointeeType: dataType.elementDataType,
        isConst: dataType.isConst
    };
}
function $5320ef4601c98354$export$109fc3df051c8810(fn) {
    return {
        type: "pointer",
        pointeeType: fn
    };
}
function $5320ef4601c98354$export$19913cd95b069dcd(dataType) {
    if (dataType.type === "primary") return `${dataType.isConst ? "const " : ""}${dataType.primaryDataType}`;
    else if (dataType.type === "array") return `${dataType.isConst ? "const " : ""}array with size ${(0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(dataType.numElements).value} of ${$5320ef4601c98354$export$19913cd95b069dcd(dataType.elementDataType)}`;
    else if (dataType.type === "pointer") return `${dataType.isConst ? "const " : ""}pointer to ${$5320ef4601c98354$export$19913cd95b069dcd(dataType.pointeeType)}`;
    else if (dataType.type === "function") return `function (${dataType.parameters.map($5320ef4601c98354$export$19913cd95b069dcd).join(", ")}) returning ${$5320ef4601c98354$export$19913cd95b069dcd(dataType.returnType)}`;
    else if (dataType.type === "struct") return `struct ${dataType.tag ? dataType.tag : " "}`;
    else if (dataType.type === "enum") return `enum ${dataType.tag}`;
    else if (dataType.type === "void") return `void`;
    else {
        console.assert(false, "stringifyDataType() unreachable else");
        return "";
    }
}
/**
 * Returns true if 2 struct fields are compatible (equivalent).
 */ function $5320ef4601c98354$var$checkStructFieldCompatibility(a, b, ignoreQualifiers = false) {
    if (a.tag !== b.tag) return false;
    if (a.dataType.type === "struct self pointer") {
        if (b.dataType.type !== "struct self pointer") return false;
        return true;
    } else {
        if (b.dataType.type === "struct self pointer") return false;
        return $5320ef4601c98354$export$827aa09e8bb8706a(a.dataType, b.dataType, ignoreQualifiers);
    }
}
function $5320ef4601c98354$export$827aa09e8bb8706a(a, b, ignoreQualifiers = false) {
    if (a.type !== b.type || !ignoreQualifiers && a.isConst && !b.isConst || b.isConst && !a.isConst) return false;
    if (a.type === "primary" && b.type === "primary") return a.primaryDataType === b.primaryDataType;
    else if (a.type === "array" && b.type === "array") return (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(a.numElements).value === (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(b.numElements).value && $5320ef4601c98354$export$827aa09e8bb8706a(a.elementDataType, b.elementDataType, ignoreQualifiers);
    else if (a.type === "function" && b.type === "function") {
        // check return type compatibility
        if (a.returnType.type === "void") {
            if (b.returnType.type !== "void") return false;
        } else {
            if (b.returnType.type === "void" || !$5320ef4601c98354$export$827aa09e8bb8706a(a.returnType, b.returnType, ignoreQualifiers)) return false;
        }
        if (a.parameters.length !== b.parameters.length) return false;
        for(let i = 0; i < a.parameters.length; ++i){
            if (!$5320ef4601c98354$export$827aa09e8bb8706a(a.parameters[i], b.parameters[i], ignoreQualifiers)) return false;
        }
        return true;
    } else if (a.type === "struct" && b.type === "struct") {
        if (a.tag !== b.tag) return false;
        if (a.fields.length !== b.fields.length) return false;
        for(let i = 0; i < a.fields.length; ++i){
            if (!$5320ef4601c98354$var$checkStructFieldCompatibility(a.fields[i], b.fields[i], ignoreQualifiers)) return false;
        }
        return true;
    } else if (a.type === "pointer" && b.type === "pointer") {
        if ($5320ef4601c98354$export$7aeb852ee71637ec(a) && $5320ef4601c98354$export$7aeb852ee71637ec(b)) return true;
        if ($5320ef4601c98354$export$7aeb852ee71637ec(a) || $5320ef4601c98354$export$7aeb852ee71637ec(b)) return false;
        return $5320ef4601c98354$export$827aa09e8bb8706a(a.pointeeType, b.pointeeType, ignoreQualifiers);
    } else if (a.type === "enum" && b.type === "enum") // all enums in this implementation are equivalent to "signed int" and thus are compatibile with one another
    return true;
    else if (a.type === "void" && b.type === "void") return true;
    else {
        console.assert(false, "checkDataTypeCompatibility(): Unhandled case");
        return false;
    }
}
function $5320ef4601c98354$export$8b795b2cde35800(dataType) {
    let currOffset = 0;
    const memoryObjects = [];
    function recursiveHelper(dataType) {
        if (dataType.type === "primary") {
            memoryObjects.push({
                dataType: dataType.primaryDataType,
                offset: currOffset
            });
            currOffset += $5320ef4601c98354$export$1713163196af6553(dataType);
        } else if (dataType.type === "pointer") {
            memoryObjects.push({
                dataType: "pointer",
                offset: currOffset
            });
            currOffset += $5320ef4601c98354$export$1713163196af6553(dataType);
        } else if (dataType.type === "array") {
            const numElements = $5320ef4601c98354$var$getNumberOfElementsInArray(dataType);
            for(let i = 0; i < numElements; ++i)recursiveHelper(dataType.elementDataType);
        } else if (dataType.type === "struct") {
            for (const field of dataType.fields)if (field.dataType.type === "struct self pointer") {
                // pointer to the struct itself
                memoryObjects.push({
                    dataType: "pointer",
                    offset: currOffset
                });
                currOffset += $5320ef4601c98354$export$1713163196af6553(dataType);
            } else recursiveHelper(field.dataType);
        } else if (dataType.type === "enum") {
            memoryObjects.push({
                dataType: (0, $cd849de488b21116$export$58b6502def2a4d77),
                offset: currOffset
            });
            currOffset += $5320ef4601c98354$export$1713163196af6553(dataType);
        } else // should not happen
        throw new Error(`unpackDataType(): Invalid data type to unpack: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(dataType)}`);
    }
    recursiveHelper(dataType);
    return memoryObjects;
}
/**
 * Returns the number of primary objects that compose a data type.
 */ function $5320ef4601c98354$var$getDataTypeNumberOfPrimaryObjects(dataType) {
    if (dataType.type === "primary" || dataType.type === "pointer" || dataType.type === "enum") return 1;
    else if (dataType.type === "array") try {
        const numElementsConstant = (0, $4a3275d19fa7fc08$export$2e2bcd8739ae039)(dataType.numElements);
        if (numElementsConstant.type === "FloatConstant") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("array size must be an integer-type");
        return $5320ef4601c98354$var$getDataTypeNumberOfPrimaryObjects(dataType.elementDataType) * Number(numElementsConstant.value);
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$f75c42204311f6de)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("array size must be compile-time constant expression (Variable Length Arrays not supported)");
        else throw e;
    }
    else if (dataType.type === "struct") return dataType.fields.reduce((sum, field)=>sum + (field.dataType.type === "struct self pointer" ? 1 : $5320ef4601c98354$var$getDataTypeNumberOfPrimaryObjects(field.dataType)), 0);
    else throw new Error(`getDataTypeNumberOfPrimaryObjects(): unhandled data type: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(dataType)}`);
}
function $5320ef4601c98354$export$24ed50fc59c5d0ff(structDataType, fieldTag) {
    let currIndex = 0;
    for (const field of structDataType.fields){
        if (fieldTag === field.tag) return {
            fieldIndex: currIndex,
            fieldDataType: field.dataType
        };
        currIndex += field.dataType.type === "struct self pointer" ? 1 : $5320ef4601c98354$var$getDataTypeNumberOfPrimaryObjects(field.dataType);
    }
    throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`struct${structDataType.tag !== null ? " " + structDataType.tag : ""} has no member named '${fieldTag}'`);
}
function $5320ef4601c98354$export$e4c716771fc2ed5d(dataType) {
    const functionDetails = {
        sizeOfParams: 0,
        sizeOfReturn: 0,
        parameters: [],
        returnObjects: null
    };
    if (dataType.returnType.type !== "void") {
        if (dataType.returnType.type === "array") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("array is not a valid return type from a function");
        functionDetails.sizeOfReturn += $5320ef4601c98354$export$1713163196af6553(dataType.returnType);
        functionDetails.returnObjects = $5320ef4601c98354$export$8b795b2cde35800(dataType.returnType).map((scalarDataType)=>({
                dataType: scalarDataType.dataType,
                offset: scalarDataType.offset
            }));
    }
    let offset = 0;
    for (const param of dataType.parameters){
        // sanity check, as parser should have converted all array params into pointers.
        if (param.type === "array") console.assert(param.type !== "array", "Compiler error: The type of a function parameter should not be an array after parsing");
        const dataTypeSize = $5320ef4601c98354$export$1713163196af6553(param);
        offset -= dataTypeSize;
        functionDetails.sizeOfParams += dataTypeSize;
        const unpackedParam = $5320ef4601c98354$export$8b795b2cde35800(param).map((scalarDataType)=>({
                dataType: scalarDataType.dataType,
                offset: offset + scalarDataType.offset
            }));
        // need to load unpacked param in reverse order, as in stack frame creation, the highest address subobject of an aggregate type gets loaded first as the stack frame grows from high to low address
        functionDetails.parameters.push(...unpackedParam.reverse());
    }
    return functionDetails;
}
function $5320ef4601c98354$export$1b3c7a16549b154a(expr) {
    return expr.exprs[0].type === "IntegerConstant" && Number(expr.exprs[0].value) === 0;
}
function $5320ef4601c98354$export$88c71d9ac972f61(lvalue, expr) {
    if (lvalue.type === "array" || lvalue.type === "function" || lvalue.type === "void") return false;
    const exprDataType = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: expr,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    // assigning null pointer constant
    if (lvalue.type === "pointer" && $5320ef4601c98354$export$1b3c7a16549b154a(expr)) return true;
    return $5320ef4601c98354$export$90c3ec6c2230fc55(lvalue) && $5320ef4601c98354$export$90c3ec6c2230fc55(exprDataType) || lvalue.type === "struct" && $5320ef4601c98354$export$827aa09e8bb8706a(lvalue, exprDataType) || lvalue.type === "pointer" && exprDataType.type === "pointer" && $5320ef4601c98354$export$19c30b9adb9252d8(lvalue, exprDataType);
}
function $5320ef4601c98354$export$19c30b9adb9252d8(left, right) {
    if ($5320ef4601c98354$export$7aeb852ee71637ec(left) || $5320ef4601c98354$export$7aeb852ee71637ec(right)) return true;
    if (!left.pointeeType.isConst && right.pointeeType.isConst) // right pointer has more pointee qualifiers than left
    return false;
    return $5320ef4601c98354$export$827aa09e8bb8706a(left.pointeeType, right.pointeeType, true);
}
function $5320ef4601c98354$export$3a13bceb06e8b38e(dataType, fieldTag) {
    for (const field of dataType.fields){
        if (field.tag === fieldTag) return true;
    }
    return false;
}
const $5320ef4601c98354$var$integerPromotableTypes = new Set([
    "unsigned char",
    "signed char",
    "unsigned short",
    "signed short"
]);
function $5320ef4601c98354$export$33c67e91126bcea2(dataType) {
    if ($5320ef4601c98354$export$25d6369c8c841882(dataType) && $5320ef4601c98354$var$integerPromotableTypes.has(dataType.primaryDataType)) return {
        type: "primary",
        primaryDataType: "signed int"
    };
    return dataType;
}


class $8c698c0438819abb$var$MemoryManager {
    constructor(){
        this.addressMap = new (0, $5577eaa48f4a17ce$export$ab3828307dd6d09)();
    }
    reload() {
        if ($8c698c0438819abb$var$MemoryManager.instance) $8c698c0438819abb$var$MemoryManager.instance = new $8c698c0438819abb$var$MemoryManager();
    }
    static getInstance() {
        if (!$8c698c0438819abb$var$MemoryManager.instance) $8c698c0438819abb$var$MemoryManager.instance = new $8c698c0438819abb$var$MemoryManager();
        return $8c698c0438819abb$var$MemoryManager.instance;
    }
    initFromSymbolTable(symbolTable) {
        this.addressMap = (0, $5577eaa48f4a17ce$export$ab3828307dd6d09).buildFromSymbolTable(symbolTable, (0, $5320ef4601c98354$export$1713163196af6553));
    }
    // public getSymbolTable(): Map<>
    // public getVariableAddress(name: string): number | undefined {
    //   const entry = this.addressMap.getVariableAddress(name);
    //   return entry?.offset;
    // }
    getAddressMap() {
        return this.addressMap;
    }
    enterScope(scopeName) {
        this.addressMap.pushScope(scopeName);
    }
    exitScope() {
        this.addressMap.popScope();
    }
}
const $8c698c0438819abb$export$8f5345d7eb869598 = $8c698c0438819abb$var$MemoryManager.getInstance();







class $c5c9ce8d51254f39$export$777871f1ccd7bbc3 {
    constructor(parentTable){
        this.currentFunctionName = "";
        this.symbols = {};
        if (parentTable) {
            this.externalFunctions = parentTable.externalFunctions;
            this.parentTable = parentTable;
            this.dataSegmentByteStr = parentTable.dataSegmentByteStr;
            this.dataSegmentOffset = parentTable.dataSegmentOffset;
            this.functionTable = parentTable.functionTable;
            this.functionTableIndexes = parentTable.functionTableIndexes;
        } else {
            this.externalFunctions = {};
            this.parentTable = null;
            // Initial value to reserve for the null space
            this.dataSegmentByteStr = {
                value: "\\d0\\e0\\b0\\f0"
            };
            // 4 Bytes are reserved for the null space
            this.dataSegmentOffset = {
                value: 4
            };
            this.functionTable = [];
            this.functionTableIndexes = {};
        }
        if (!parentTable || parentTable.parentTable === null) // all tables take the previous tables offset except the top 2 level parenttables
        // root table (1st level) is the global scope
        // 2nd level table is function scope
        this.currOffset = {
            value: 0
        };
        else this.currOffset = parentTable.currOffset;
    }
    /**
   * Add all the functions of imoprted modules to global scope.
   */ setExternalFunctions(includedModules, moduleRepository) {
        this.externalFunctions = {};
        for (const moduleName of includedModules)Object.keys(moduleRepository.modules[moduleName].moduleFunctions).forEach((funcName)=>{
            this.addFunctionEntry(funcName, moduleRepository.modules[moduleName].moduleFunctions[funcName].functionType, true);
            this.setFunctionIsDefinedFlag(funcName);
        });
        return this.externalFunctions;
    }
    isExternalFunction(funcName) {
        return funcName in this.externalFunctions;
    }
    addEntry(declaration) {
        if (declaration.dataType.type === "function") return this.addFunctionEntry(declaration.name, declaration.dataType);
        else {
            if (this.parentTable === null || declaration.storageClass === "static") {
                // the declaration is either a global or static
                // allocate space for and the initializer bytes for this declared object in data segment
                const byteStr = (0, $de78ebef6c7c100a$export$122b46d757fa097c)(declaration.dataType, typeof declaration.initializer === "undefined" ? null : declaration.initializer, this);
                this.dataSegmentByteStr.value += byteStr;
            }
            return this.addVariableEntry(declaration.name, declaration.dataType, declaration.storageClass);
        }
    }
    addEnumeratorEntry(enumeratorName, enumeratorValue) {
        const entry = {
            type: "enumerator",
            dataType: {
                type: "primary",
                primaryDataType: (0, $cd849de488b21116$export$58b6502def2a4d77)
            },
            value: enumeratorValue
        };
        this.symbols[enumeratorName] = entry;
        return entry;
    }
    /**
   * Allocate bytes on data segment
   * Adds the initializing bytes to the dataSegmentByteStr as well.
   * @params the array of bytes (in demical numeric form) to put on data segment.
   * @returns offset in data segment of the allocated object.
   */ addDataSegmentObject(bytes) {
        bytes.forEach((byte)=>{
            this.dataSegmentByteStr.value += (0, $c031121e0d12b198$export$1be7e9cc7e681ce2)(BigInt(byte), 1);
        });
        const offset = this.dataSegmentOffset.value;
        this.dataSegmentOffset.value += bytes.length;
        return offset;
    }
    addVariableEntry(name, dataType, storageClass) {
        if (name in this.symbols) {
            // given variable already exists in given scope
            // multiple declarations only allowed outside of function bodies
            if (this.parentTable !== null) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`redeclaration of ${name}`);
            const symbolEntry = this.symbols[name];
            if (symbolEntry.type === "function" || symbolEntry.type === "enumerator") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`redeclaration of ${name}`);
            if ((0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(symbolEntry.dataType) !== (0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(dataType)) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`conflicting types for ${name}:  redeclared as "${(0, $5320ef4601c98354$export$19913cd95b069dcd)(dataType)}" instead of ${(0, $5320ef4601c98354$export$19913cd95b069dcd)(symbolEntry.dataType)}`); //TODO: stringify there datatype in english instead of just printing json
            return this.symbols[name];
        }
        let entry;
        if (this.parentTable === null) {
            // the offset grows inthe positive direction (low to high adress) for globals
            entry = {
                type: "dataSegmentVariable",
                dataType: dataType,
                offset: this.dataSegmentOffset.value
            };
            this.dataSegmentOffset.value += (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
        } else {
            if (storageClass === "static") {
                entry = {
                    type: "dataSegmentVariable",
                    dataType: dataType,
                    offset: this.dataSegmentOffset.value
                };
                this.dataSegmentOffset.value += (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
            } else if (storageClass === "auto") {
                // offset grows in negative direction (high to low adderss) for locals
                this.currOffset.value -= (0, $5320ef4601c98354$export$1713163196af6553)(dataType);
                entry = {
                    type: "localVariable",
                    dataType: dataType,
                    offset: this.currOffset.value
                };
            } else throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("addVariableEntry(): Unhandled storage class");
        }
        this.symbols[name] = entry;
        const varEntry = entry;
        (0, $8c698c0438819abb$export$8f5345d7eb869598).getAddressMap().addVariable(name, {
            name: name,
            offset: varEntry.offset,
            isGlobal: varEntry.type === "dataSegmentVariable",
            size: (0, $5320ef4601c98354$export$1713163196af6553)(dataType),
            dataType: varEntry.dataType
        });
        return entry;
    }
    addFunctionEntry(name, dataType, isExternalFunction) {
        if (!isExternalFunction && name in this.symbols) {
            // function was already declared before
            // simple check that symbol is a function and the params and return types match
            if (this.symbols[name].type !== "function") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`redeclaration of ${name} as different kind of symbol: function instead of variable`);
            return this.symbols[name];
        }
        const entry = {
            type: "function",
            dataType: dataType,
            functionDetails: (0, $5320ef4601c98354$export$e4c716771fc2ed5d)(dataType)
        };
        if (isExternalFunction) this.externalFunctions[name] = entry;
        else this.symbols[name] = entry;
        this.functionTable.push({
            functionName: name,
            functionDetails: entry.functionDetails,
            isDefined: false
        });
        this.functionTableIndexes[name] = this.functionTable.length - 1;
        return entry;
    }
    hasSymbol(name) {
        let curr = this;
        while(curr !== null){
            if (name in curr.symbols) return true;
            curr = curr.parentTable;
        }
        if (name in this.externalFunctions) return true;
        return false;
    }
    /**
   * Look up the symbol starting from the lowest symbol table (most recent).
   */ getSymbolEntry(name) {
        let curr = this;
        while(curr !== null){
            if (name in curr.symbols) return curr.symbols[name];
            curr = curr.parentTable;
        }
        if (name in this.externalFunctions) return this.externalFunctions[name];
        throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`'${name}' undeclared`);
    }
    /**
   * Returns the index of function with given name in the functionTable
   */ getFunctionIndex(name) {
        return this.functionTableIndexes[name];
    }
    /**
   * Set the isDefined flag for the given function to true.
   */ setFunctionIsDefinedFlag(functionName) {
        this.functionTable[this.getFunctionIndex(functionName)].isDefined = true;
    }
    enterFunctionScope(functionName) {
        this.currentFunctionName = functionName;
        (0, $8c698c0438819abb$export$8f5345d7eb869598).enterScope(functionName);
    }
    exitFunctionScope() {
        this.currentFunctionName = "";
        (0, $8c698c0438819abb$export$8f5345d7eb869598).exitScope();
    }
}








function $b7e59eb4969f10fd$export$2e2bcd8739ae039(node, symbolTable) {
    symbolTable.addFunctionEntry(node.name, node.dataType);
    symbolTable.setFunctionIsDefinedFlag(node.name);
    if (node.dataType.returnType.type === "array") throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("arrays cannot be returned from a function");
    const funcSymbolTable = new (0, $c5c9ce8d51254f39$export$777871f1ccd7bbc3)(symbolTable);
    (0, $8c698c0438819abb$export$8f5345d7eb869598).enterScope(node.name);
    // add all the params to the symbol table
    for(let i = 0; i < node.parameterNames.length; ++i)funcSymbolTable.addVariableEntry(node.parameterNames[i], node.dataType.parameters[i], "auto");
    const functionDefinitionNode = {
        type: "FunctionDefinition",
        name: node.name,
        sizeOfLocals: 0,
        body: [],
        dataType: node.dataType,
        position: node.position
    };
    // visit body
    const body = (0, $cf264a5b1eb44de7$export$2e2bcd8739ae039)(node.body, funcSymbolTable, functionDefinitionNode);
    functionDefinitionNode.body = body; // body is a Block, an array of StatementP will be returned
    (0, $8c698c0438819abb$export$8f5345d7eb869598).exitScope();
    return functionDefinitionNode;
}
function $b7e59eb4969f10fd$export$733f767a80574592(expr, symbolTable) {
    const statements = [];
    const processedExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(expr, symbolTable);
    // TODO: data type check
    // if (
    //   enclosingFunc.dataType.returnType !== null &&
    //   !checkDataTypeCompatibility(
    //     processedExpr.originalDataType,
    //     enclosingFunc.dataType.returnType
    //   )
    // ) {
    //   throw new ProcessingError(
    //     `Data type of expression being returned does not match declared function returntype - expression type: ${toJson(
    //       processedExpr.originalDataType
    //     )} declared type: ${toJson(enclosingFunc.dataType.returnType)}`
    //   );
    // }
    let currOffset = 0;
    processedExpr.exprs.forEach((expr)=>{
        statements.push({
            type: "MemoryStore",
            value: expr,
            dataType: expr.dataType,
            address: {
                type: "ReturnObjectAddress",
                subtype: "store",
                offset: (0, $278774b275ed49b9$export$4b396cbbbd0b4959)(currOffset),
                dataType: "pointer",
                position: expr.position
            },
            position: expr.position
        });
        currOffset += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(expr.dataType);
    });
    statements.push({
        type: "ReturnStatement",
        position: expr.position
    });
    return statements;
}
function $b7e59eb4969f10fd$export$ef60bcd1c93fe004(node, symbolTable) {
    // direct call of a function
    if (node.expr.type === "IdentifierExpression" && symbolTable.getSymbolEntry(node.expr.name).type === "function") {
        const symbolEntry = symbolTable.getSymbolEntry(node.expr.name);
        return {
            functionCallP: {
                type: "FunctionCall",
                calledFunction: {
                    type: "DirectlyCalledFunction",
                    functionName: node.expr.name,
                    position: node.position
                },
                functionDetails: symbolEntry.functionDetails,
                args: $b7e59eb4969f10fd$var$processFunctionCallArgs(node.args, symbolEntry.dataType, symbolTable),
                position: node.position
            },
            returnType: symbolEntry.dataType.returnType
        };
    }
    // indirect call of function from an expression that is a function pointer
    const processedCalledExpr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(node.expr, symbolTable);
    const dataTypeOfCalledExpr = (0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
        expression: processedCalledExpr,
        convertArrayToPointer: true,
        convertFunctionToPointer: true
    });
    const functionDataType = (0, $278774b275ed49b9$export$8130297edc0f94cf)(dataTypeOfCalledExpr);
    return {
        returnType: functionDataType.returnType,
        functionCallP: {
            type: "FunctionCall",
            calledFunction: {
                type: "IndirectlyCalledFunction",
                functionAddress: processedCalledExpr.exprs[0],
                position: processedCalledExpr.exprs[0].position
            },
            functionDetails: (0, $5320ef4601c98354$export$e4c716771fc2ed5d)(functionDataType),
            args: $b7e59eb4969f10fd$var$processFunctionCallArgs(node.args, functionDataType, symbolTable),
            position: processedCalledExpr.exprs[0].position
        }
    };
}
function $b7e59eb4969f10fd$var$processFunctionCallArgs(args, fnDataType, symbolTable) {
    const argExpressions = [];
    const argExpressionWrappers = [];
    for (const arg of args){
        const expr = (0, $551bb05b84852d99$export$2e2bcd8739ae039)(arg, symbolTable);
        argExpressionWrappers.push(expr);
        // each inidividual expression is concatenated in reverse order, as stack grows from high to low,
        // whereas indiviudal primary data types within larger aggergates go from low to high (reverse direction)
        argExpressions.push(...expr.exprs.reverse());
    }
    $b7e59eb4969f10fd$var$checkFunctionCallArgsAreCompatible(fnDataType, argExpressionWrappers);
    return argExpressions;
}
/**
 * For a function call with given args,
 * Checks that for adherence to  Constraint 2 in 6.5.2.2 of C17 standard.
 * 1. the number of arguments shall agree with the number of parameters
 * 2. Each argument shall have a type such that its value may be assigned to an object with the unqualified version of the type of its corresponding parameter.
 */ function $b7e59eb4969f10fd$var$checkFunctionCallArgsAreCompatible(fnDataType, args) {
    if (args.length != fnDataType.parameters.length) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("number of arguments provided to function call does not match number of parameters specfied in prototype");
    for(let i = 0; i < args.length; ++i){
        if (!(0, $5320ef4601c98354$export$88c71d9ac972f61)(fnDataType.parameters[i], args[i])) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)(`cannot assign function call argument to parameter\nFunction parameter type: "${(0, $5320ef4601c98354$export$19913cd95b069dcd)(fnDataType.parameters[i])}"\nFunction argument type: "${(0, $5320ef4601c98354$export$19913cd95b069dcd)((0, $278774b275ed49b9$export$eb27e3f48ee2e547)({
            expression: args[i],
            convertArrayToPointer: true,
            convertFunctionToPointer: true
        }))}"`);
    }
}








function $3bbec8f49ad76a86$export$2e2bcd8739ae039(ast, moduleRepository) {
    (0, $e5f32705ab2cc688$export$5ecd17fec0dc7499)();
    const includedModules = [];
    const symbolTable = new (0, $c5c9ce8d51254f39$export$777871f1ccd7bbc3)();
    const processedExternalFunctions = symbolTable.setExternalFunctions(ast.includedModules, moduleRepository);
    const processedAst = {
        type: "Root",
        functions: [],
        dataSegmentByteStr: "",
        dataSegmentSizeInBytes: 0,
        externalFunctions: [],
        functionTable: [],
        position: ast.position
    };
    // save the processed details of external functions
    for (const moduleName of ast.includedModules){
        includedModules.push(moduleName);
        Object.keys(moduleRepository.modules[moduleName].moduleFunctions).forEach((moduleFunctionName)=>{
            processedAst.externalFunctions.push({
                moduleName: moduleName,
                name: moduleFunctionName,
                parameters: processedExternalFunctions[moduleFunctionName].functionDetails.parameters,
                returnObjects: processedExternalFunctions[moduleFunctionName].functionDetails.returnObjects
            });
        });
    }
    ast.children.forEach((child)=>{
        // special handling for function definitions
        (0, $cf264a5b1eb44de7$export$f7e4aa58fa839c4e)();
        if (child.type === "FunctionDefinition") processedAst.functions.push((0, $b7e59eb4969f10fd$export$2e2bcd8739ae039)(child, symbolTable));
        else (0, $de78ebef6c7c100a$export$6a9ae9430f0feed9)(child, symbolTable);
    });
    // check for presence of main function
    if (!symbolTable.hasSymbol("main")) throw new (0, $28ac839a9eca26f5$export$f75c42204311f6de)("main function not defined");
    $3bbec8f49ad76a86$var$debugPrintMemoryMap(); // Add this function call
    processedAst.dataSegmentByteStr = symbolTable.dataSegmentByteStr.value;
    processedAst.dataSegmentSizeInBytes = symbolTable.dataSegmentOffset.value;
    processedAst.functionTable = symbolTable.functionTable;
    return {
        astRootNode: processedAst,
        includedModules: includedModules,
        warnings: $e5f32705ab2cc688$export$cce7aaa89215f32b
    };
}
function $3bbec8f49ad76a86$var$debugPrintMemoryMap() {
    console.log("\n=== MEMORY ADDRESS MAP ===");
    console.log("Variable Name         | Scope           | Offset | Size");
    console.log("----------------------------------------------------");
    const addressMap = (0, $8c698c0438819abb$export$8f5345d7eb869598).getAddressMap();
    const map = addressMap.getAddressMap();
    // Group entries by scope for better organization
    const globalEntries = [];
    const localEntriesByFunction = {};
    map.forEach((entry, name)=>{
        // Check if this is a scoped name (contains a dot)
        // const scopeMatch = name.name.match(/^(.+)\.(.+)$/);
        const scopeMatch = name.split("::");
        const varName = scopeMatch[1];
        const functionName = scopeMatch[0];
        if (entry.isGlobal && varName) globalEntries.push([
            varName,
            entry
        ]);
        else if (varName && functionName) {
            if (!localEntriesByFunction[functionName]) localEntriesByFunction[functionName] = [];
            // Store with the real variable name (without scope prefix)
            localEntriesByFunction[functionName].push([
                varName,
                entry
            ]);
        } else if (varName) {
            // Local variable without proper scope - fallback
            if (!localEntriesByFunction["unknown"]) localEntriesByFunction["unknown"] = [];
            localEntriesByFunction["unknown"].push([
                varName,
                entry
            ]);
        } else throw new Error("Error parsing MemoryAddressKey");
    });
    // Print all variables in a flat list but with their scope displayed
    const allEntries = [];
    // Add global variables
    globalEntries.forEach(([name, entry])=>{
        allEntries.push([
            name,
            "global",
            entry
        ]);
    });
    // Add local variables with their function name as scope
    Object.entries(localEntriesByFunction).forEach(([functionName, entries])=>{
        entries.forEach(([name, entry])=>{
            allEntries.push([
                name,
                functionName,
                entry
            ]);
        });
    });
    // Sort by scope and then by offset
    allEntries.sort((a, b)=>{
        if (a[1] !== b[1]) {
            // Sort global scope first
            if (a[1] === "global") return -1;
            if (b[1] === "global") return 1;
            // Then alphabetically by function name
            return a[1].localeCompare(b[1]);
        }
        // Within same scope, sort by offset
        return a[2].offset - b[2].offset;
    });
    // Print the sorted entries
    allEntries.forEach(([name, scope, entry])=>{
        console.log(`${name.padEnd(20)} | ${scope.padEnd(15)} | ` + `${entry.offset.toString().padEnd(6)} | ${entry.size} bytes`);
    });
    console.log("=============================================\n");
}


/**
 * WAT Generator module for generating a WAT string from WAT AST.
 */ 
const $a07e14860cba76ca$export$31f128b41878cc25 = "$func_type";
const $a07e14860cba76ca$export$545253cb95f4a9e2 = "function_table"; // table name for exporting table of functions of wasm module



/**
 * Utility functions for WAT generation.
 */ 





function $4791223424586fac$export$2e2bcd8739ae039(node) {
    if (node.type === "GlobalSet") return `(global.set $${node.name} ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.value)})`;
    else if (node.type === "LocalSet") return `(local.set $${node.name} ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.value)})`;
    else if (node.type === "FunctionCall") return `(call $${node.name} ${(0, $c5b9558d5ed8096b$export$3de41e8aa11d8d2a)(node.stackFrameSetup)}) ${(0, $c5b9558d5ed8096b$export$3de41e8aa11d8d2a)(node.stackFrameTearDown)}`;
    else if (node.type === "IndirectFunctionCall") return `(call_indirect (type ${0, $a07e14860cba76ca$export$31f128b41878cc25}) ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.index)} ${(0, $c5b9558d5ed8096b$export$3de41e8aa11d8d2a)(node.stackFrameSetup)}) ${(0, $c5b9558d5ed8096b$export$3de41e8aa11d8d2a)(node.stackFrameTearDown)}`;
    else if (node.type === "RegularFunctionCall") return `(call $${node.name}${(0, $c5b9558d5ed8096b$export$31d5ca1ed663dcb4)(node.args)})`;
    else if (node.type === "SelectionStatement") {
        const n = node;
        return `(if ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(n.condition)} (then ${n.actions.map((action)=>$4791223424586fac$export$2e2bcd8739ae039(action)).join(" ")})${n.elseStatements.length > 0 ? " (else" + n.elseStatements.map((statement)=>$4791223424586fac$export$2e2bcd8739ae039(statement)).join(" ") + ")" : ""})`;
    } else if (node.type === "ReturnStatement") return `(return)`;
    else if (node.type === "Loop") return `(loop $${node.label}${node.body.length > 0 ? " " + node.body.map((line)=>$4791223424586fac$export$2e2bcd8739ae039(line)).join(" ") : ""})`;
    else if (node.type === "Block") return `(block $${node.label}${node.body.length > 0 ? " " + node.body.map((line)=>$4791223424586fac$export$2e2bcd8739ae039(line)).join(" ") : ""})`;
    else if (node.type === "Branch") return `(br $${node.label})`;
    else if (node.type === "BranchIf") return `(br_if $${node.label} ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.condition)})`;
    else if (node.type === "MemoryGrow") return `(drop (memory.grow ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.pagesToGrowBy)}))`;
    else if (node.type === "MemoryStore") return `(${(0, $c5b9558d5ed8096b$export$c804800911a56d78)(node.wasmDataType, node.numOfBytes)} ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.addr)} ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.value)})`;
    else if (node.type === "MemoryStoreFromWasmStack") // need to use psuedoregister R2 to temporarily store value from virtual stack,
    // then put store address on virtual stack followed by loading from psuedoregister R2.
    // This is needed to provide the intsructions in correct order to store instruction.
    return `(${(0, $c5b9558d5ed8096b$export$c804800911a56d78)(node.wasmDataType, node.numOfBytes)} (global.set $${(0, $c5b9558d5ed8096b$export$c12c606a5ff7737f)(node.wasmDataType)}) ${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(node.addr)} (global.get $${(0, $c5b9558d5ed8096b$export$c12c606a5ff7737f)(node.wasmDataType)}))`;
    else if (node.type === "BranchTable") return (0, $c5b9558d5ed8096b$export$769a0536a887017f)(node);
    else if (node.type === "Nop") return "(nop)";
    else throw new (0, $28ac839a9eca26f5$export$565260f5d002fcc9)(`Unhandled statement: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(node)}`);
}


function $c5b9558d5ed8096b$export$7c5add1b4f493d2(line, indentation) {
    return "	".repeat(indentation) + line + "\n";
}
function $c5b9558d5ed8096b$export$eb0410a831069a96(block, indentation) {
    let watStr = "";
    for (const line of block.split("\n"))watStr += $c5b9558d5ed8096b$export$7c5add1b4f493d2(line, indentation);
    return watStr;
}
function $c5b9558d5ed8096b$export$fd51a0cc82da4b19(varType, numOfBytes) {
    if ((varType === "i32" || varType === "f32") && numOfBytes === 4 || (varType === "i64" || varType === "f64") && numOfBytes === 8) return `${varType}.load`;
    return `${varType}.load${(numOfBytes * 8).toString()}_s`;
}
function $c5b9558d5ed8096b$export$c804800911a56d78(varType, numOfBytes) {
    if ((varType === "i32" || varType === "f32") && numOfBytes === 4 || (varType === "i64" || varType === "f64") && numOfBytes === 8) return `${varType}.store`;
    return `${varType}.store${(numOfBytes * 8).toString()}`;
}
function $c5b9558d5ed8096b$export$31d5ca1ed663dcb4(exprs) {
    if (exprs.length === 0) return "";
    let argsStr = "";
    for (const arg of exprs)argsStr += (0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(arg) + " ";
    return " " + argsStr.trim();
}
function $c5b9558d5ed8096b$export$3de41e8aa11d8d2a(statements) {
    return statements.map((s)=>(0, $4791223424586fac$export$2e2bcd8739ae039)(s)).join(" ");
}
function $c5b9558d5ed8096b$export$769a0536a887017f(branchTable) {
    let indexes = "";
    for(let i = 0; i <= branchTable.maxIndex; ++i)indexes += `${i} `;
    return `(br_table ${indexes}${(0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(branchTable.indexExpression)})`;
}
function $c5b9558d5ed8096b$export$c12c606a5ff7737f(wasmDataType) {
    switch(wasmDataType){
        case "i32":
            return 0, $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa;
        case "i64":
            return 0, $c5715c2f7f6b98cf$export$c9ffbac498cd6b64;
        case "f32":
            return 0, $c5715c2f7f6b98cf$export$481ea1bf91221f3c;
        case "f64":
            return 0, $c5715c2f7f6b98cf$export$def4b9b37a9e587e;
    }
}


function $d92d3561a73fb9bc$export$2e2bcd8739ae039(node) {
    if (node.type === "IntegerConst") return `(${node.wasmDataType}.const ${node.value.toString()})`;
    else if (node.type === "FloatConst") {
        let valueStr = node.value.toString();
        if (node.value === Infinity) // special handling for infinity values
        valueStr = "inf";
        return `(${node.wasmDataType}.const ${valueStr})`;
    } else if (node.type === "LocalGet") return `(local.get $${node.name}})`;
    else if (node.type === "GlobalGet") return `(global.get $${node.name})`;
    else if (node.type === "BinaryExpression") return `(${node.instruction} ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.leftExpr)} ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.rightExpr)})`;
    else if (node.type === "BooleanExpression") {
        if (node.isNegated) return `(${node.wasmDataType}.eq (${node.wasmDataType}.const 0) ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.expr)})`;
        else return `(${node.wasmDataType}.ne (${node.wasmDataType}.const 0) ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.expr)})`;
    } else if (node.type === "MemorySize") return "(memory.size)";
    else if (node.type === "MemoryLoad") return `(${(0, $c5b9558d5ed8096b$export$fd51a0cc82da4b19)(node.wasmDataType, node.numOfBytes)} ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.addr)})`;
    else if (node.type === "NumericWrapper") return `(${node.instruction} ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.expr)})`;
    else if (node.type === "NegateFloatExpression") return `(${node.wasmDataType}.neg ${node.expr})`;
    else if (node.type === "PostStatementExpression") return `${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.expr)} ${(0, $c5b9558d5ed8096b$export$3de41e8aa11d8d2a)(node.statements)}`;
    else if (node.type === "PreStatementExpression") return `${(0, $c5b9558d5ed8096b$export$3de41e8aa11d8d2a)(node.statements)} ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.expr)}`;
    else if (node.type === "ConditionalExpression") return `(if (result ${node.wasmDataType}) ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.condition)} (then ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.trueExpression)}) (else ${$d92d3561a73fb9bc$export$2e2bcd8739ae039(node.falseExpression)}))`;
    else throw new (0, $28ac839a9eca26f5$export$565260f5d002fcc9)(`Unhandled WAT AST node: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(node)}`);
}




function $df2c68a1897a685b$export$38d6b8478af371c3(module, baseIndentation = 0) {
    let watStr = (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)("(module", baseIndentation);
    // add the memory import
    watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(import "js" "mem" (memory ${(0, $7f0b08f9e0a6f0f6$export$7f687b7d9f9da81c)(module.dataSegmentSize)}))`, baseIndentation + 1);
    // add the imported functions
    for (const importedFunction of module.importedFunctions)watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(import ${importedFunction.importPath.map((s)=>`"${s}"`).join(" ")} (func $${importedFunction.name}${importedFunction.wasmParamTypes.length > 0 ? " " + importedFunction.wasmParamTypes.map((param)=>`(param ${param})`).join(" ") : ""}${importedFunction.returnWasmTypes.length > 0 ? " " + importedFunction.returnWasmTypes.map((r)=>`(result ${r})`).join(" ") : ""}))`, baseIndentation + 1);
    for (const importedGlobal of module.importedGlobalWasmVariables)watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(global $${importedGlobal.name} (import "js" "${importedGlobal.name}") (${importedGlobal.isConst ? "" : "mut"} ${importedGlobal.wasmDataType}))`, baseIndentation + 1);
    // add the table of functions
    watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(import "js" "function_table" (table ${module.functionTable.size} funcref))`, baseIndentation + 1);
    // add all the wasm global variable declarations
    for (const global of module.globalWasmVariables)watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(global $${global.name} (${global.isConst ? "" : "mut"} ${global.wasmDataType}) ${global.initializerValue ? (0, $d92d3561a73fb9bc$export$2e2bcd8739ae039)(global.initializerValue) : ""})`, baseIndentation + 1);
    // add all the global variables (in linear memory) intiializations
    watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(data (i32.const 0) "${module.dataSegmentByteStr}")`, baseIndentation + 1);
    // add the type of all user defined functions (to wasm the functions simply take no params, no return (memory model handles these))
    watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(type ${(0, $a07e14860cba76ca$export$31f128b41878cc25)} (func))`, baseIndentation + 1);
    // add all functions into the table
    for (const f of module.functionTable.elements)watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(elem (i32.const ${f.index}) $${f.functionName})`, baseIndentation + 1);
    // add all the function definitions
    for (const functionName of Object.keys(module.functions)){
        const func = module.functions[functionName];
        watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(`(func $${func.name}`, baseIndentation + 1);
        for (const statement of func.body)watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)((0, $4791223424586fac$export$2e2bcd8739ae039)(statement), baseIndentation + 2);
        watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(")", baseIndentation + 1);
    }
    watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)("(start $main)", 1);
    watStr += (0, $c5b9558d5ed8096b$export$7c5add1b4f493d2)(")", 0);
    return watStr;
}



async function $35ff0e651cf79adf$export$244319998795f476(wat) {
    const w = await (0, $hgUW1$wabt)();
    return w.parseWat("a", wat).toBinary({}).buffer;
}


/**
 * Translator module which performs translation of C AST to WAT AST.
 */ /**
 * Various utility functions with different uses will be defined here.
 */ 


/**
 * Defines functions for evaluating C AST expression nodes and converting them to corresponding WAT AST nodes.
 */ 




/**
 * Translate a binary expression into corresponding WAT AST nodes based on operator.
 */ 


function $26245c0224f6918a$export$2e2bcd8739ae039(binaryExpr, enclosingLoopDetails) {
    // special handling for && and || since wasm does not have native instructions for these operations
    if (binaryExpr.operator === "&&" || binaryExpr.operator === "||") // need to convert the left and right expr to boolean expression (1 or 0) before doing bitwise AND or OR
    return {
        type: "BinaryExpression",
        leftExpr: {
            type: "BooleanExpression",
            expr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(binaryExpr.leftExpr, binaryExpr.leftExpr.dataType, enclosingLoopDetails),
            wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(binaryExpr.leftExpr.dataType)
        },
        rightExpr: {
            type: "BooleanExpression",
            expr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(binaryExpr.rightExpr, binaryExpr.rightExpr.dataType, enclosingLoopDetails),
            wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(binaryExpr.rightExpr.dataType)
        },
        instruction: $26245c0224f6918a$export$f078dd35a743883(binaryExpr.operator, binaryExpr.dataType)
    };
    return {
        type: "BinaryExpression",
        // perform implicit arithmetic type conversions
        leftExpr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(binaryExpr.leftExpr, binaryExpr.operandTargetDataType, enclosingLoopDetails),
        rightExpr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(binaryExpr.rightExpr, binaryExpr.operandTargetDataType, enclosingLoopDetails),
        instruction: $26245c0224f6918a$export$f078dd35a743883(binaryExpr.operator, binaryExpr.operandTargetDataType)
    };
}
const $26245c0224f6918a$var$binaryOperatorToInstructionMap = {
    "+": "add",
    "-": "sub",
    "*": "mul",
    "/": "div",
    "%": "rem",
    "<": "lt",
    "<=": "le",
    "!=": "ne",
    "==": "eq",
    ">=": "ge",
    ">": "gt",
    "&&": "and",
    "||": "or",
    "&": "and",
    "|": "or",
    "<<": "shl",
    ">>": "shr",
    "^": "xor"
};
const $26245c0224f6918a$var$signedUnsignedVariantOps = [
    "div",
    "rem",
    "lt",
    "le",
    "gt",
    "ge",
    "shr"
];
function $26245c0224f6918a$var$isOperationWithUnsignedSignedVariant(op) {
    return $26245c0224f6918a$var$signedUnsignedVariantOps.includes(op);
}
function $26245c0224f6918a$export$f078dd35a743883(operator, dataType) {
    const op = $26245c0224f6918a$var$binaryOperatorToInstructionMap[operator];
    const instruction = `${(0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(dataType)}.${op}`;
    if ($26245c0224f6918a$var$isOperationWithUnsignedSignedVariant(op)) {
        // these instructions have unsigned vs signed variants for integers
        if ((0, $7f0b08f9e0a6f0f6$export$671a30a0694c3dec)(dataType) || dataType === "pointer") return instruction + "_u";
        if ((0, $7f0b08f9e0a6f0f6$export$a2c4a82997e90594)(dataType)) return instruction + "_s";
        // floats have no sign prefix
        return instruction;
    }
    return instruction;
}




/**
 * Definition of function to translate function calls.
 */ 



function $59841e7e5e39ede7$export$2e2bcd8739ae039(node) {
    // translate the arguments
    const functionArgs = [];
    for(let i = 0; i < node.functionDetails.parameters.length; ++i)functionArgs.push((0, $72a75c5e992738ef$export$2e2bcd8739ae039)(node.args[i], node.functionDetails.parameters[i].dataType));
    const stackFrameSetup = (0, $c5715c2f7f6b98cf$export$c70596a3916eac5a)(node.functionDetails, functionArgs);
    const stackFrameTearDown = (0, $c5715c2f7f6b98cf$export$706753d3eb71dffe)(node.functionDetails);
    if (node.calledFunction.type === "DirectlyCalledFunction") return {
        type: "FunctionCall",
        name: node.calledFunction.functionName,
        stackFrameSetup: stackFrameSetup,
        stackFrameTearDown: stackFrameTearDown
    };
    else if (node.calledFunction.type === "IndirectlyCalledFunction") return {
        type: "IndirectFunctionCall",
        index: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(node.calledFunction.functionAddress, (0, $cd849de488b21116$export$bfaa7c08c18ee972)),
        stackFrameSetup: stackFrameSetup,
        stackFrameTearDown: stackFrameTearDown
    };
    else {
        console.assert(false, "translateFunctionCall(): unreachable block");
        throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("");
    }
}



function $f3a7dc9eb467117f$export$1156a4a1118b2091(prv) {
    if (typeof prv !== "undefined") return {
        currLoopNumber: prv.currLoopNumber + 1,
        currBlockNumber: prv.currBlockNumber + 1
    };
    else return {
        currLoopNumber: 0,
        currBlockNumber: 0
    };
}
function $f3a7dc9eb467117f$export$9c01799218156015(enclosingLoopDetails) {
    return `loop${enclosingLoopDetails ? enclosingLoopDetails.currLoopNumber : 0}`;
}
function $f3a7dc9eb467117f$export$4a6daa29cbb446b(enclosingLoopDetails) {
    return `block${enclosingLoopDetails ? enclosingLoopDetails.currBlockNumber : 0}`;
}




const $b49beb1d3fc3498e$export$ed4660ce5597f406 = "func_block"; //name for the block that holds entire body of each function. Used for implementing return statements.





function $ae27ab179b027af5$export$2e2bcd8739ae039(switchStatement, enclosingLoopDetails) {
    const numberOfBlocks = switchStatement.cases.length + (switchStatement.defaultStatements.length > 0 ? 1 : 0) + 1; // add 1 for the additional inner block that holds the branch itself
    // construct the nested series of conditional expressions for getting correct index of block to jump to
    const defaultExpressionIndex = (0, $696814606849cc9f$export$46ad71386f22d9a7)(numberOfBlocks - 2, "i32"); // the default expression index
    let currExpression = defaultExpressionIndex;
    for(let i = switchStatement.cases.length - 1; i >= 0; --i)currExpression = {
        type: "ConditionalExpression",
        condition: (0, $696814606849cc9f$export$52db786ae745d5b3)(switchStatement.cases[i].condition),
        trueExpression: (0, $696814606849cc9f$export$46ad71386f22d9a7)(i, "i32"),
        falseExpression: currExpression,
        wasmDataType: "i32"
    };
    // start constructing the blocks
    const brTableBlock = {
        type: "Block",
        label: `switch_block_0`,
        body: [
            {
                type: "BranchTable",
                maxIndex: numberOfBlocks - 2,
                indexExpression: currExpression
            }
        ]
    };
    let newEnclosingLoopDetails;
    if (enclosingLoopDetails) newEnclosingLoopDetails = {
        currBlockNumber: enclosingLoopDetails.currBlockNumber + 1,
        currLoopNumber: enclosingLoopDetails.currLoopNumber
    };
    else newEnclosingLoopDetails = {
        currBlockNumber: 0,
        currLoopNumber: 0
    };
    let currBlock = brTableBlock;
    let i = 0;
    for(; i < switchStatement.cases.length; ++i)currBlock = {
        type: "Block",
        label: `switch_block_${i + 1}`,
        body: [
            currBlock,
            ...switchStatement.cases[i].statements.map((statement)=>(0, $89999bd610f73bf6$export$2e2bcd8739ae039)(statement, newEnclosingLoopDetails))
        ]
    };
    // add the last block for default case
    currBlock = {
        type: "Block",
        label: (0, $f3a7dc9eb467117f$export$4a6daa29cbb446b)(newEnclosingLoopDetails),
        body: [
            currBlock,
            ...switchStatement.defaultStatements.map((statement)=>(0, $89999bd610f73bf6$export$2e2bcd8739ae039)(statement, newEnclosingLoopDetails))
        ]
    };
    return currBlock;
}


function $89999bd610f73bf6$export$2e2bcd8739ae039(statement, enclosingLoopDetails) {
    if (statement.type === "MemoryStore") return {
        type: "MemoryStore",
        addr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(statement.address, statement.address.dataType, enclosingLoopDetails),
        value: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(statement.value, statement.dataType, enclosingLoopDetails),
        wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(statement.dataType),
        numOfBytes: (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(statement.dataType)
    };
    else if (statement.type === "FunctionCall") return (0, $59841e7e5e39ede7$export$2e2bcd8739ae039)(statement);
    else if (statement.type === "SelectionStatement") return {
        type: "SelectionStatement",
        condition: (0, $696814606849cc9f$export$52db786ae745d5b3)(statement.condition),
        actions: statement.ifStatements.map((s)=>$89999bd610f73bf6$export$2e2bcd8739ae039(s, enclosingLoopDetails)),
        elseStatements: statement.elseStatements ? statement.elseStatements.map((s)=>$89999bd610f73bf6$export$2e2bcd8739ae039(s, enclosingLoopDetails)) : []
    };
    else if (statement.type === "DoWhileLoop") {
        const newEnclosingLoopDetails = (0, $f3a7dc9eb467117f$export$1156a4a1118b2091)(enclosingLoopDetails);
        const loopLabel = (0, $f3a7dc9eb467117f$export$9c01799218156015)(newEnclosingLoopDetails);
        const blockLabel = (0, $f3a7dc9eb467117f$export$4a6daa29cbb446b)(newEnclosingLoopDetails);
        const body = statement.body.map((s)=>$89999bd610f73bf6$export$2e2bcd8739ae039(s, newEnclosingLoopDetails));
        body.push({
            type: "BranchIf",
            label: loopLabel,
            condition: (0, $696814606849cc9f$export$52db786ae745d5b3)(statement.condition)
        });
        return {
            type: "Block",
            label: blockLabel,
            body: [
                {
                    type: "Loop",
                    label: loopLabel,
                    body: body
                }
            ]
        };
    } else if (statement.type === "WhileLoop") {
        const newEnclosingLoopDetails = (0, $f3a7dc9eb467117f$export$1156a4a1118b2091)(enclosingLoopDetails);
        const loopLabel = (0, $f3a7dc9eb467117f$export$9c01799218156015)(newEnclosingLoopDetails);
        const blockLabel = (0, $f3a7dc9eb467117f$export$4a6daa29cbb446b)(newEnclosingLoopDetails);
        const negatedCondition = (0, $696814606849cc9f$export$52db786ae745d5b3)(statement.condition, true);
        const body = [];
        // branch out of the loop if the condition is not met
        body.push({
            type: "BranchIf",
            label: blockLabel,
            condition: negatedCondition
        });
        statement.body.forEach((s)=>body.push($89999bd610f73bf6$export$2e2bcd8739ae039(s, newEnclosingLoopDetails)));
        // add the branching statement at end of loop body
        body.push({
            type: "Branch",
            label: loopLabel
        });
        return {
            type: "Block",
            label: blockLabel,
            body: [
                {
                    type: "Loop",
                    label: loopLabel,
                    body: body
                }
            ]
        };
    } else if (statement.type === "ForLoop") {
        const newEnclosingLoopDetails = (0, $f3a7dc9eb467117f$export$1156a4a1118b2091)(enclosingLoopDetails);
        const loopLabel = (0, $f3a7dc9eb467117f$export$9c01799218156015)(newEnclosingLoopDetails);
        const blockLabel = (0, $f3a7dc9eb467117f$export$4a6daa29cbb446b)(newEnclosingLoopDetails);
        const negatedCondition = statement.condition !== null ? (0, $696814606849cc9f$export$52db786ae745d5b3)(statement.condition, true) : null;
        const loopBody = [];
        if (negatedCondition !== null) loopBody.push({
            type: "BranchIf",
            label: blockLabel,
            condition: negatedCondition
        });
        // add for loop body
        statement.body.forEach((s)=>loopBody.push($89999bd610f73bf6$export$2e2bcd8739ae039(s, newEnclosingLoopDetails)));
        // add the for loop update expression
        statement.update.forEach((s)=>loopBody.push($89999bd610f73bf6$export$2e2bcd8739ae039(s, newEnclosingLoopDetails)));
        // add the branching statement at end of loop body
        loopBody.push({
            type: "Branch",
            label: loopLabel
        });
        const blockBody = [];
        // push on the clause statements
        statement.clause.forEach((s)=>blockBody.push($89999bd610f73bf6$export$2e2bcd8739ae039(s, newEnclosingLoopDetails)));
        blockBody.push({
            type: "Loop",
            label: loopLabel,
            body: loopBody
        });
        return {
            type: "Block",
            label: blockLabel,
            body: blockBody
        };
    } else if (statement.type === "ReturnStatement") // branch out of the block holding the function body
    return {
        type: "Branch",
        label: (0, $b49beb1d3fc3498e$export$ed4660ce5597f406)
    };
    else if (statement.type === "BreakStatement") {
        if (typeof enclosingLoopDetails === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Break statement cannot be present outside a loop or switch body");
        return {
            type: "Branch",
            label: (0, $f3a7dc9eb467117f$export$4a6daa29cbb446b)(enclosingLoopDetails)
        };
    } else if (statement.type === "ContinueStatement") {
        if (typeof enclosingLoopDetails === "undefined") throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Continue statement cannot be present outside a loop body");
        return {
            type: "Branch",
            label: (0, $f3a7dc9eb467117f$export$9c01799218156015)(enclosingLoopDetails)
        };
    } else if (statement.type === "SwitchStatement") // psuedo-register 2 is used for holding the switch block index
    return (0, $ae27ab179b027af5$export$2e2bcd8739ae039)(statement);
    else if (statement.type === "ExpressionStatement") return {
        type: "Nop"
    };
    else throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("Unhandled statement");
}


/**
 * Definition of function to handle unary expressions
 */ 




function $7f3e79585a697ebc$export$2e2bcd8739ae039(unaryExpr, enclosingLoopDetails) {
    if (unaryExpr.operator === "-") {
        if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(unaryExpr.dataType)) return {
            type: "BinaryExpression",
            instruction: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType) + ".add",
            leftExpr: {
                type: "BinaryExpression",
                instruction: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType) + ".sub",
                leftExpr: (0, $696814606849cc9f$export$d70e7abb2c53b540)((0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType)),
                rightExpr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(unaryExpr.expr, unaryExpr.dataType, enclosingLoopDetails)
            },
            rightExpr: {
                type: "IntegerConst",
                wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType),
                value: 1n
            }
        };
        else if ((0, $7f0b08f9e0a6f0f6$export$4a7e02d8ef2dc77a)(unaryExpr.dataType)) return {
            type: "NegateFloatExpression",
            wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType),
            expr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(unaryExpr.expr, unaryExpr.dataType, enclosingLoopDetails)
        };
        else throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)("'-' prefix operator is only valid on arithmetic types");
    } else if (unaryExpr.operator === "!") return {
        type: "BooleanExpression",
        wasmDataType: "i32",
        expr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(unaryExpr.expr, unaryExpr.dataType, enclosingLoopDetails),
        isNegated: true
    };
    else if (unaryExpr.operator === "~") {
        if (!(0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(unaryExpr.dataType)) // bitwise complement is undefined on non integral types
        throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`Wrong type argument to bitwise-complement - type used: ${unaryExpr.dataType}`);
        return {
            type: "BinaryExpression",
            leftExpr: {
                type: "IntegerConst",
                wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType),
                value: -1n
            },
            rightExpr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(unaryExpr.expr, unaryExpr.dataType, enclosingLoopDetails),
            instruction: `${(0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(unaryExpr.dataType)}.xor`
        };
    } else throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`translateUnaryExpression error: unknown unary operator: ${unaryExpr.operator}`);
}



function $72a75c5e992738ef$export$2e2bcd8739ae039(expr, targetType, enclosingLoopDetails) {
    function translateExpressionHelper() {
        if (expr.type === "BinaryExpression") return (0, $26245c0224f6918a$export$2e2bcd8739ae039)(expr, enclosingLoopDetails);
        else if (expr.type === "IntegerConstant" || expr.type === "FloatConstant") return (0, $38f155c1835676cf$export$76e37b29c165f299)(expr);
        else if (expr.type === "PreStatementExpression") return {
            type: "PreStatementExpression",
            statements: expr.statements.map((statement)=>(0, $89999bd610f73bf6$export$2e2bcd8739ae039)(statement, enclosingLoopDetails)),
            expr: $72a75c5e992738ef$export$2e2bcd8739ae039(expr.expr, expr.expr.dataType, enclosingLoopDetails)
        };
        else if (expr.type === "PostStatementExpression") return {
            type: "PostStatementExpression",
            statements: expr.statements.map((statement)=>(0, $89999bd610f73bf6$export$2e2bcd8739ae039)(statement, enclosingLoopDetails)),
            expr: $72a75c5e992738ef$export$2e2bcd8739ae039(expr.expr, expr.expr.dataType, enclosingLoopDetails)
        };
        else if (expr.type === "UnaryExpression") return (0, $7f3e79585a697ebc$export$2e2bcd8739ae039)(expr, enclosingLoopDetails);
        else if (expr.type === "DataSegmentAddress") // since data segment starts at memory address 0, simply return the offset expression
        return $72a75c5e992738ef$export$2e2bcd8739ae039(expr.offset, expr.offset.dataType, enclosingLoopDetails);
        else if (expr.type === "LocalAddress") // the locals start at BP
        return {
            type: "BinaryExpression",
            leftExpr: (0, $c5715c2f7f6b98cf$export$62a6d2b2e5cfb51b),
            rightExpr: $72a75c5e992738ef$export$2e2bcd8739ae039(expr.offset, expr.offset.dataType, enclosingLoopDetails),
            instruction: (0, $26245c0224f6918a$export$f078dd35a743883)("+", "pointer")
        };
        else if (expr.type === "DynamicAddress") return $72a75c5e992738ef$export$2e2bcd8739ae039(expr.address, expr.address.dataType, enclosingLoopDetails);
        else if (expr.type === "ReturnObjectAddress") {
            if (expr.subtype === "store") return (0, $c5715c2f7f6b98cf$export$bacc11ce78317fe7)("bp", "+", (0, $cd849de488b21116$export$75f214c74b100eb7) + Number(expr.offset.value));
            else return (0, $c5715c2f7f6b98cf$export$bacc11ce78317fe7)("sp", "+", Number(expr.offset.value));
        } else if (expr.type === "MemoryLoad") return {
            type: "MemoryLoad",
            addr: $72a75c5e992738ef$export$2e2bcd8739ae039(expr.address, expr.address.dataType, enclosingLoopDetails),
            wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(expr.dataType),
            numOfBytes: (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(expr.dataType)
        };
        else if (expr.type === "ConditionalExpression") return {
            type: "ConditionalExpression",
            condition: (0, $696814606849cc9f$export$52db786ae745d5b3)(expr.condition),
            trueExpression: $72a75c5e992738ef$export$2e2bcd8739ae039(expr.trueExpression, expr.dataType, enclosingLoopDetails),
            falseExpression: $72a75c5e992738ef$export$2e2bcd8739ae039(expr.falseExpression, expr.dataType, enclosingLoopDetails),
            wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(expr.dataType)
        };
        else if (expr.type === "FunctionTableIndex") return $72a75c5e992738ef$export$2e2bcd8739ae039(expr.index, (0, $cd849de488b21116$export$bfaa7c08c18ee972), enclosingLoopDetails); // translate the underlying integer constant
        else throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`Unhandled expression: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(expr)}`);
    }
    // add any type conversion wrapper on the WasmExpression node if needed
    return (0, $38f155c1835676cf$export$73a7428322d21b13)(expr.dataType, targetType, translateExpressionHelper());
}


function $696814606849cc9f$export$c511242ddefeb78(op, dataType) {
    if (dataType.type === "primary") return `${(0, $38f155c1835676cf$export$7d84eeb8f844a735)[dataType.primaryDataType]}.${op === "++" ? "add" : "sub"}`;
    else if (dataType.type === "pointer") return `${0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee}.${op === "++" ? "add" : "sub"}`;
    else // arithmetic is not defined for non ints or non pointers
    throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`arithmeticUnaryOperatorToInstruction(): Unsupported variable type: ${(0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(dataType)}`);
}
const $696814606849cc9f$export$bc29eef920cdd8ed = {
    i32: 4,
    i64: 8,
    f32: 4,
    f64: 8
};
function $696814606849cc9f$export$3258bd427d4cb532(wasmRoot) {
    // imported from JS runtime
    wasmRoot.importedGlobalWasmVariables.push({
        type: "ImportedGlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$f332087f5348159c),
        wasmDataType: "i32"
    });
    wasmRoot.importedGlobalWasmVariables.push({
        type: "ImportedGlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$a2134755a9a05802),
        wasmDataType: "i32"
    });
    // heap segment follows immediately after data segment
    // imported from JS runtime
    wasmRoot.importedGlobalWasmVariables.push({
        type: "ImportedGlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$cebe03d4d7130569),
        wasmDataType: "i32"
    });
    wasmRoot.globalWasmVariables.push({
        type: "GlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$9d26cc9a87da5961),
        wasmDataType: "i32",
        initializerValue: {
            type: "IntegerConst",
            wasmDataType: "i32",
            value: 0n
        }
    });
    wasmRoot.globalWasmVariables.push({
        type: "GlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$62d5dc7f93a31eaa),
        wasmDataType: "i32",
        initializerValue: {
            type: "IntegerConst",
            wasmDataType: "i32",
            value: 0n
        }
    });
    wasmRoot.globalWasmVariables.push({
        type: "GlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$c9ffbac498cd6b64),
        wasmDataType: "i64",
        initializerValue: {
            type: "IntegerConst",
            wasmDataType: "i64",
            value: 0n
        }
    });
    wasmRoot.globalWasmVariables.push({
        type: "GlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$481ea1bf91221f3c),
        wasmDataType: "f32",
        initializerValue: {
            type: "FloatConst",
            wasmDataType: "f32",
            value: 0
        }
    });
    wasmRoot.globalWasmVariables.push({
        type: "GlobalVariable",
        name: (0, $c5715c2f7f6b98cf$export$def4b9b37a9e587e),
        wasmDataType: "f64",
        initializerValue: {
            type: "FloatConst",
            wasmDataType: "f64",
            value: 0
        }
    });
}
function $696814606849cc9f$export$d70e7abb2c53b540(intType) {
    if (intType === "i32") return {
        type: "IntegerConst",
        value: 4294967295n,
        wasmDataType: "i32"
    };
    else return {
        type: "IntegerConst",
        value: 18446744073709551615n,
        wasmDataType: "i64"
    };
}
function $696814606849cc9f$export$52db786ae745d5b3(expression, isNegated) {
    return {
        type: "BooleanExpression",
        expr: (0, $72a75c5e992738ef$export$2e2bcd8739ae039)(expression, "signed int"),
        wasmDataType: "i32",
        isNegated: isNegated
    };
}
function $696814606849cc9f$export$46ad71386f22d9a7(value, wasmDataType) {
    return {
        type: "IntegerConst",
        wasmDataType: wasmDataType,
        value: BigInt(value)
    };
}
function $696814606849cc9f$export$85516d6a572c79dc(functionTable) {
    const wasmFunctionTable = {
        elements: [],
        size: functionTable.length
    };
    functionTable.forEach((f, index)=>{
        if (f.isDefined) wasmFunctionTable.elements.push({
            functionName: f.functionName,
            index: index
        });
    });
    return wasmFunctionTable;
}


/**
 * Defines the vist function for traversing the C AST and translating into WAT-AST.
 */ 


function $c16ad4ba2decb1c6$export$2e2bcd8739ae039(Cfunction) {
    // evaluate all parameters first
    // const params: WasmMemoryObject[] = [];
    // Cfunction.parameters.forEach((param) => {
    //   const localVar: WasmMemoryObject = {
    //     type: "LocalMemoryVariable",
    //     name: param.name,
    //     offset: symbolTable.currOffset.value + getDataTypeSize(param.dataType),
    //     dataType: param.dataType,
    //   };
    //   params.push(localVar);
    //   addToSymbolTable(symbolTable, localVar);
    // });
    const functionBody = [];
    // add the space allocation statements for local variables to function body
    functionBody.push((0, $c5715c2f7f6b98cf$export$3bca4f7b01025682)(Cfunction.sizeOfLocals));
    functionBody.push((0, $c5715c2f7f6b98cf$export$cf1dacee6dd21bf0)((0, $c5715c2f7f6b98cf$export$f332087f5348159c), Cfunction.sizeOfLocals));
    // create a block to hold all function body statements
    // returns will branch out of this block, so that the cleanup of stack will proceed before func exits
    functionBody.push({
        type: "Block",
        label: (0, $b49beb1d3fc3498e$export$ed4660ce5597f406),
        body: Cfunction.body.map((statement)=>(0, $89999bd610f73bf6$export$2e2bcd8739ae039)(statement))
    });
    // add the deallocation of locals
    functionBody.push((0, $c5715c2f7f6b98cf$export$3cd54ce42da7cee7)((0, $c5715c2f7f6b98cf$export$f332087f5348159c), Cfunction.sizeOfLocals));
    return {
        type: "Function",
        name: Cfunction.name,
        body: functionBody
    };
}








function $38bc18697d4c5c9f$export$2e2bcd8739ae039(moduleRepository, externalCFunctions) {
    const functionImports = [];
    const wrappedFunctions = [];
    for (const externalCFunction of externalCFunctions){
        const importedFunction = moduleRepository.modules[externalCFunction.moduleName].moduleFunctions[externalCFunction.name];
        // need to unpack the datatype of each parameter of this external function into primary data types -> wasm types, in param order
        // for aggregate parameters, their parameters should also remain in the same order as they were in the aggregate
        const wasmParams = [];
        for (const param of importedFunction.functionType.parameters){
            const unpackedDataType = (0, $5320ef4601c98354$export$8b795b2cde35800)(param);
            for (const scalarType of unpackedDataType)wasmParams.push((0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(scalarType.dataType));
        }
        console.assert(typeof importedFunction !== "undefined", "Translator: Imported function not found in module repository");
        functionImports.push({
            name: externalCFunction.name + "_imported",
            importPath: [
                importedFunction.parentImportedObject,
                externalCFunction.name
            ],
            wasmParamTypes: wasmParams,
            returnWasmTypes: externalCFunction.returnObjects ? externalCFunction.returnObjects.map((retObj)=>(0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(retObj.dataType)) : []
        });
        // create the function wrapper
        // function wrapper needs to first load up function args into virtual wasm stack from the real stack in linear memory
        // then store the function results from virtual stack into the real stack
        const functionWrapper = {
            type: "Function",
            name: externalCFunction.name,
            body: []
        };
        // the actual call to the imported function that the wrapper wraps
        const importedFunctionCall = {
            type: "RegularFunctionCall",
            name: externalCFunction.name + "_imported",
            args: []
        };
        // load up the function args
        let externalCFunctionParamIndex = 0;
        for (const dataType of importedFunction.functionType.parameters){
            const unpackedDataType = (0, $5320ef4601c98354$export$8b795b2cde35800)(dataType); // unpack the data type into series of primary object first
            externalCFunctionParamIndex += unpackedDataType.length; // the index of the next aggregate/primary param
            for(let i = 0; i < unpackedDataType.length; ++i){
                // the primary data type param corresponding to the param
                const correspondingExternalFunctionParam = externalCFunction.parameters[externalCFunctionParamIndex - 1 - i];
                // sanity check, should not occur
                if (unpackedDataType[i].dataType !== correspondingExternalFunctionParam.dataType) throw new (0, $28ac839a9eca26f5$export$1a55918bd746edde)(`Load of function args in import function wrapper: Data type of args and param do not match: arg: '${unpackedDataType[i].dataType}' vs param: '${correspondingExternalFunctionParam.dataType}' `);
                importedFunctionCall.args.push({
                    type: "MemoryLoad",
                    addr: (0, $c5715c2f7f6b98cf$export$bacc11ce78317fe7)((0, $c5715c2f7f6b98cf$export$a2134755a9a05802), "+", correspondingExternalFunctionParam.offset),
                    wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(correspondingExternalFunctionParam.dataType),
                    numOfBytes: (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(correspondingExternalFunctionParam.dataType)
                });
            }
        }
        functionWrapper.body.push(importedFunctionCall);
        // now all the return values of the imported function call are on the virtual wasm stack - need to load them into the real stack
        // this needs to be done back to front, as the top of virtualstack contains the last primary data object of the return object
        if (externalCFunction.returnObjects !== null) for(let i = externalCFunction.returnObjects.length - 1; i >= 0; --i){
            const returnObject = externalCFunction.returnObjects[i];
            functionWrapper.body.push({
                type: "MemoryStoreFromWasmStack",
                addr: (0, $c5715c2f7f6b98cf$export$bacc11ce78317fe7)("bp", "+", (0, $cd849de488b21116$export$75f214c74b100eb7) + returnObject.offset),
                wasmDataType: (0, $38f155c1835676cf$export$ef36b8ec4b08a62a)(returnObject.dataType),
                numOfBytes: (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(returnObject.dataType)
            });
        }
        wrappedFunctions.push(functionWrapper);
    }
    return {
        functionImports: functionImports,
        wrappedFunctions: wrappedFunctions
    };
}


function $edd1d19f265dea24$export$2e2bcd8739ae039(CAstRoot, moduleRepository) {
    const wasmRoot = {
        type: "Module",
        dataSegmentByteStr: CAstRoot.dataSegmentByteStr,
        globalWasmVariables: [],
        importedGlobalWasmVariables: [],
        functions: {},
        dataSegmentSize: CAstRoot.dataSegmentSizeInBytes,
        importedFunctions: [],
        functionTable: (0, $696814606849cc9f$export$85516d6a572c79dc)(CAstRoot.functionTable)
    };
    const processedImportedFunctions = (0, $38bc18697d4c5c9f$export$2e2bcd8739ae039)(moduleRepository, CAstRoot.externalFunctions);
    wasmRoot.importedFunctions = processedImportedFunctions.functionImports;
    // add function wrappers of imported functions
    processedImportedFunctions.wrappedFunctions.forEach((wrappedFunction)=>{
        wasmRoot.functions[wrappedFunction.name] = wrappedFunction;
    });
    CAstRoot.functions.forEach((func)=>{
        wasmRoot.functions[func.name] = (0, $c16ad4ba2decb1c6$export$2e2bcd8739ae039)(func);
    });
    (0, $696814606849cc9f$export$3258bd427d4cb532)(wasmRoot);
    return wasmRoot;
}



/**
 * Stack is implemented for control and stash registers.
 * Adapted from https://github.com/source-academy/js-slang/blob/master/src/cse-machine/stack.ts
 * and made to be immutable
 */ class $f474a90aa78bf710$export$694e0d28c7ffc90c {
    constructor(items = []){
        this.storage = items;
    }
    createNew(items) {
        return new $f474a90aa78bf710$export$694e0d28c7ffc90c(items);
    }
    setTo(otherStack) {}
    concat(item) {
        return this.createNew([
            ...this.storage,
            ...item
        ]);
    }
    push(item) {
        return this.createNew([
            ...this.storage,
            item
        ]);
    }
    getStack() {
        return [
            ...this.storage
        ];
    }
    some(predicate) {
        return this.storage.some(predicate);
    }
    pop() {
        if (this.isEmpty()) return [
            undefined,
            this
        ];
        const lastItem = this.storage[this.storage.length - 1];
        return [
            lastItem,
            this.createNew(this.storage.slice(0, -1))
        ];
    }
    getIdx(idx) {
        if (idx < 0 || idx >= this.storage.length) throw new Error("Stack out of bounds");
        return this.storage[idx];
    }
    peek() {
        if (this.isEmpty()) throw new Error("Cannot peek: stack is empty.");
        return this.storage[this.storage.length - 1];
    }
    /**
   * Returns a subarray of the last `depth` elements from the stack.
   * If depth is greater than the stack size, returns the whole stack.
   */ peekLast(depth) {
        if (this.storage.length < depth) throw new Error("PeekLast out of bounds");
        return this.storage.slice(this.storage.length - depth);
    }
    size() {
        return this.storage.length;
    }
    isEmpty() {
        return this.size() === 0;
    }
    toArray() {
        return this.storage;
    }
}


var $6267764a9e4139a0$export$c11d6cfb99c9fdfb;
(function(InstructionType) {
    InstructionType["BINARY_OP"] = "BINARY_OP";
    InstructionType["UNARY_OP"] = "UNARY_OP";
    InstructionType["BRANCH"] = "BRANCH";
    InstructionType["POP"] = "POP";
    InstructionType["MEMORY_STORE"] = "MEMORY_STORE";
    InstructionType["MEMORY_LOAD"] = "MEMORY_LOAD";
    InstructionType["WHILE"] = "WHILE";
    InstructionType["FORLOOP"] = "FORLOOP";
    InstructionType["STACKFRAMETEARDOWNINSTRUCTION"] = "STACKFRAMETEARDOWNINSTRUCTION";
    InstructionType["CALLINSTRUCTION"] = "CALLINSTRUCTION";
    InstructionType["FUNCTIONINDEXWRAPPER"] = "FUNCTIONINDEXWRAPPER";
    InstructionType["BREAK_MARK"] = "BREAK_MARK";
    InstructionType["CASE_JUMP"] = "CASE_JUMP";
    InstructionType["CASE_MARK"] = "CASE_MARK";
    InstructionType["CONTINUE_MARK"] = "CONTINUE_MARK";
})($6267764a9e4139a0$export$c11d6cfb99c9fdfb || ($6267764a9e4139a0$export$c11d6cfb99c9fdfb = {}));
const $6267764a9e4139a0$export$ec48ff0e1e703c7d = (operator, dataType, position)=>({
        type: "BINARY_OP",
        operator: operator,
        dataType: dataType,
        position: position
    });
const $6267764a9e4139a0$export$b229fa3c9b082d4f = (operator, position)=>({
        type: "UNARY_OP",
        operator: operator,
        position: position
    });
const $6267764a9e4139a0$export$7bbd9e64d7d89276 = (trueExpr, falseExpr, position)=>({
        type: "BRANCH",
        trueExpr: trueExpr,
        falseExpr: falseExpr,
        position: position
    });
const $6267764a9e4139a0$export$97ba93b9cbfc1a2a = ()=>({
        type: "POP",
        position: {
            start: {
                line: 0,
                column: 0,
                offset: 0
            },
            end: {
                line: 0,
                column: 0,
                offset: 0
            }
        }
    });
const $6267764a9e4139a0$export$1bc324c1a920826d = (dataType, position)=>({
        type: "MEMORY_STORE",
        dataType: dataType,
        position: position
    });
const $6267764a9e4139a0$export$6635a48965c3499e = (dataType, position)=>({
        type: "MEMORY_LOAD",
        dataType: dataType,
        position: position
    });
const $6267764a9e4139a0$export$f39db7568112fd08 = (condition, body, hasContinue, position)=>({
        type: "WHILE",
        condition: condition,
        body: body,
        hasContinue: hasContinue,
        position: position
    });
const $6267764a9e4139a0$export$1f66b719349452a8 = (body, update, condition, hasContinue, position)=>({
        type: "FORLOOP",
        body: body,
        update: update,
        condition: condition,
        hasContinue: hasContinue,
        position: position
    });
const $6267764a9e4139a0$export$d9305c39e55b1eb6 = (functionName, basePointer, stackPointer, position)=>({
        functionName: functionName,
        type: "STACKFRAMETEARDOWNINSTRUCTION",
        basePointer: basePointer,
        stackPointer: stackPointer,
        position: position
    });
const $6267764a9e4139a0$export$2f00d225c49b711d = (calledFunction, functionDetails, position)=>({
        type: "CALLINSTRUCTION",
        calledFunction: calledFunction,
        functionDetails: functionDetails,
        position: position
    });
const $6267764a9e4139a0$export$e8be8116a52d95e8 = ()=>({
        type: "FUNCTIONINDEXWRAPPER",
        position: {
            start: {
                line: 0,
                column: 0,
                offset: 0
            },
            end: {
                line: 0,
                column: 0,
                offset: 0
            }
        }
    });
const $6267764a9e4139a0$export$b05b23eadb7974c4 = ()=>({
        type: "BREAK_MARK",
        position: {
            start: {
                line: 0,
                column: 0,
                offset: 0
            },
            end: {
                line: 0,
                column: 0,
                offset: 0
            }
        }
    });
function $6267764a9e4139a0$export$ecb67aa3f8204e37(i) {
    return $6267764a9e4139a0$export$517b0c6d75337fc8(i) && i.type == "BREAK_MARK";
}
const $6267764a9e4139a0$export$ffaa6afe94c1fdbb = ()=>({
        type: "CONTINUE_MARK",
        position: {
            start: {
                line: 0,
                column: 0,
                offset: 0
            },
            end: {
                line: 0,
                column: 0,
                offset: 0
            }
        }
    });
function $6267764a9e4139a0$export$92eb496c5d233e76(i) {
    return $6267764a9e4139a0$export$517b0c6d75337fc8(i) && i.type == "CONTINUE_MARK";
}
const $6267764a9e4139a0$var$caseJumpInstruction = (caseValue, position)=>({
        type: "CASE_JUMP",
        caseValue: caseValue,
        position: position
    });
const $6267764a9e4139a0$var$caseMarkInstruction = (caseValue, position)=>({
        type: "CASE_MARK",
        caseValue: caseValue,
        position: position
    });
const $6267764a9e4139a0$var$DEFAULT_CASE_VALUE = -1;
const $6267764a9e4139a0$export$b43aee7b6f90d96b = ()=>{
    return $6267764a9e4139a0$export$9105b61d48bb9d0($6267764a9e4139a0$var$DEFAULT_CASE_VALUE);
};
const $6267764a9e4139a0$export$9105b61d48bb9d0 = (caseValue)=>{
    return {
        jumpInstruction: {
            type: "CASE_JUMP",
            caseValue: caseValue
        },
        markInstruction: {
            type: "CASE_MARK",
            caseValue: caseValue
        }
    };
};
function $6267764a9e4139a0$export$c4b69223939120f7(i) {
    return $6267764a9e4139a0$export$517b0c6d75337fc8(i) && i.type == "CASE_MARK";
}
function $6267764a9e4139a0$export$5ca3f3f6e16eec9d(instruction) {
    return instruction.caseValue === $6267764a9e4139a0$var$DEFAULT_CASE_VALUE;
}
function $6267764a9e4139a0$export$a55296325935d46e(jumpInstruction, markInstruction) {
    return jumpInstruction.caseValue === markInstruction.caseValue;
}
const $6267764a9e4139a0$export$517b0c6d75337fc8 = (item)=>{
    return item && typeof item === "object" && "type" in item && Object.values($6267764a9e4139a0$export$c11d6cfb99c9fdfb).includes(item.type);
};


class $45537d54220eef3f$export$7a7fa4424cb20976 extends (0, $f474a90aa78bf710$export$694e0d28c7ffc90c) {
    createNew(items) {
        return new $45537d54220eef3f$export$7a7fa4424cb20976(items);
    }
    canAvoidEnvInstr() {
        return true;
    }
    getTearDowns() {
        return this.storage.filter((item)=>(0, $6267764a9e4139a0$export$517b0c6d75337fc8)(item) && item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).STACKFRAMETEARDOWNINSTRUCTION);
    }
    getNumEnvDependentItems() {
        return this.numEnvDependentItems;
    }
    isInstruction(item) {
        return (0, $6267764a9e4139a0$export$517b0c6d75337fc8)(item);
    }
    isNode(item) {
        return !(0, $6267764a9e4139a0$export$517b0c6d75337fc8)(item);
    }
    copy() {
        return this;
    }
    toString() {
        if (this.isEmpty()) return "  <empty>";
        const controlItems = this.toArray();
        let result = "";
        for(let i = controlItems.length - 1; i >= 0; i--){
            const item = controlItems[i];
            const itemPosition = controlItems.length - i;
            if ((0, $6267764a9e4139a0$export$517b0c6d75337fc8)(item)) {
                if (item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BINARY_OP) result += `  ${itemPosition}. [Instruction] ${item.type}: '${item.operator}'\n`;
                else if (item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).UNARY_OP) result += `  ${itemPosition}. [Instruction] ${item.type}: '${item.operator}'\n`;
                else if (item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BRANCH || item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).POP || item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).WHILE || item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BREAK_MARK || item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CONTINUE_MARK) result += `  ${itemPosition}. [Instruction] ${item.type}\n`;
                else if (item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CASE_JUMP || item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CASE_MARK) result += `  ${itemPosition}. [Instruction] ${item.type}: '${item.caseValue}'\n`;
                else if (item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).MEMORY_LOAD || item.type === (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).MEMORY_STORE) result += `  ${itemPosition}. [Instruction] ${item.type}: '${item.dataType}'\n`;
                else result += `  ${itemPosition}. [Instruction] ${item.type}\n`;
            } else {
                const nodeItem = item;
                let additionalInfo = "";
                switch(nodeItem.type){
                    case "FunctionDefinition":
                        additionalInfo = nodeItem.name ? `: ${nodeItem.name}` : "";
                        break;
                    case "IntegerConstant":
                    case "FloatConstant":
                        additionalInfo = nodeItem.value !== undefined ? `: ${nodeItem.value}` : "";
                        break;
                    case "UnaryExpression":
                    case "BinaryExpression":
                        additionalInfo = nodeItem.operator ? `: '${nodeItem.operator}'` : "";
                        break;
                    case "MemoryAddress":
                        additionalInfo = `: ${nodeItem.hexValue}`;
                        break;
                }
                result += `  ${itemPosition}. [Node] ${nodeItem.type}${additionalInfo}\n`;
            }
        }
        return result.trimEnd();
    }
}



class $aedf17afe77f7184$export$8be94b08bb3c4aa3 extends (0, $f474a90aa78bf710$export$694e0d28c7ffc90c) {
    createNew(items) {
        return new $aedf17afe77f7184$export$8be94b08bb3c4aa3(items);
    }
    static isConstant(item) {
        return item.type === "IntegerConstant" || item.type === "FloatConstant";
    }
    static isMemoryAddress(value) {
        return value.type === "MemoryAddress";
    }
    toString() {
        if (this.isEmpty()) return "  <empty>";
        const stashItems = this.toArray();
        let result = "";
        for(let i = stashItems.length - 1; i >= 0; i--){
            const item = stashItems[i];
            const itemPosition = stashItems.length - i;
            let displayValue = "";
            switch(item.type){
                case "IntegerConstant":
                case "FloatConstant":
                    displayValue = `${item.value}`;
                    break;
                case "MemoryAddress":
                    displayValue = `MemoryAddress (${item.hexValue})`;
                    break;
                case "FunctionTableIndex":
                    displayValue = `FunctionTableIndex (${item.index.value})`;
                default:
                    break;
            }
            result += `  ${itemPosition}. ${displayValue}\n`;
        }
        return result.trimEnd();
    }
}





function $7831f17922f95070$export$1fd68fc40ac03f60(stmt) {
    if (Array.isArray(stmt)) return stmt.some((s)=>$7831f17922f95070$export$1fd68fc40ac03f60(s));
    switch(stmt.type){
        case "BreakStatement":
            return true;
        case "SelectionStatement":
            return $7831f17922f95070$export$1fd68fc40ac03f60(stmt.ifStatements) || (stmt.elseStatements ? $7831f17922f95070$export$1fd68fc40ac03f60(stmt.elseStatements) : false);
        default:
            return false;
    }
}
function $7831f17922f95070$export$8737284613612c48(stmt) {
    if (Array.isArray(stmt)) return stmt.some((s)=>$7831f17922f95070$export$8737284613612c48(s));
    switch(stmt.type){
        case "ContinueStatement":
            return true;
        case "SelectionStatement":
            return $7831f17922f95070$export$8737284613612c48(stmt.ifStatements) || (stmt.elseStatements ? $7831f17922f95070$export$8737284613612c48(stmt.elseStatements) : false);
        default:
            return false;
    }
}








const $aa3386e207fc8611$export$c1a271a97a079552 = {
    start: {
        line: 0,
        column: 0,
        offset: 0
    },
    end: {
        line: 0,
        column: 0,
        offset: 0
    }
};
function $aa3386e207fc8611$export$c92ae396da927a27(left, operator, right) {
    let cLeft = left;
    let cRight = right;
    let addressReturn = false;
    if ((0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isMemoryAddress(cLeft)) {
        cLeft = $aa3386e207fc8611$var$convertMemoryAddressToConstant(cLeft);
        addressReturn = true;
    }
    if ((0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isMemoryAddress(cRight)) {
        cRight = $aa3386e207fc8611$var$convertMemoryAddressToConstant(cRight);
        addressReturn = true;
    }
    const dataType = (0, $553cdff61180334d$export$aeff407985fcdd14)({
        type: "primary",
        primaryDataType: cLeft.dataType
    }, {
        type: "primary",
        primaryDataType: cRight.dataType
    }, operator);
    if (dataType.type !== "primary") throw new Error("invalid expression");
    let leftVal;
    let rightVal;
    /**
   * there is a need to ensure that both leftVal and rightVal are same types (both bigint or number)
   * so that performBinaryOperation will give a result as intended
   *
   * only for unsigned long and signed long we convert them into BigInt so that we get the full 64-bit range
   * this ensures that the calculations with longs produce the correct value and do not overflow
   *
   * for int, float and double we convert them to number so it adheres to the 32-bit range
   * this ensures that for bitwise operators, they give the correct wrong value
   */ if (dataType.primaryDataType === "unsigned long" || dataType.primaryDataType === "signed long") {
        leftVal = BigInt(cLeft.value);
        rightVal = BigInt(cRight.value);
    } else {
        leftVal = Number(cLeft.value);
        rightVal = Number(cRight.value);
    }
    const value = (0, $4a3275d19fa7fc08$export$83aec769090ee796)(leftVal, operator, rightVal);
    if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(dataType.primaryDataType)) {
        const valueInt = (0, $e3d15c53d7bc5411$export$5ab497d4db862f91)(typeof value === "bigint" ? value : BigInt(Math.floor(value)), dataType.primaryDataType);
        if (addressReturn) return (0, $615d1dd8a38a9293$export$32eac480e2ff4122)(valueInt);
        return {
            type: "IntegerConstant",
            dataType: dataType.primaryDataType,
            value: valueInt,
            position: $aa3386e207fc8611$export$c1a271a97a079552
        };
    }
    return {
        type: "FloatConstant",
        dataType: dataType.primaryDataType,
        value: value,
        position: $aa3386e207fc8611$export$c1a271a97a079552
    };
}
function $aa3386e207fc8611$var$convertMemoryAddressToConstant(address) {
    return {
        type: "IntegerConstant",
        value: address.value,
        dataType: "unsigned int",
        position: $aa3386e207fc8611$export$c1a271a97a079552
    };
}
function $aa3386e207fc8611$export$57332ffc9c92a549(item) {
    return item.value !== 0n;
}


function $615d1dd8a38a9293$export$32eac480e2ff4122(value) {
    return {
        type: "MemoryAddress",
        value: value,
        hexValue: `0x${value.toString(16).padStart(8, "0")}`
    };
}
function $615d1dd8a38a9293$export$20f70d5ec785445f(value) {
    // if ConstantP return itself
    if (value.type === "IntegerConstant" || value.type === "FloatConstant") return value;
    // if MemoryAddress convert it to an unsigned int (equivalent)
    return {
        type: "IntegerConstant",
        value: value.value,
        dataType: "unsigned int",
        position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
    };
}



const $4c069963d8c4e053$export$85b8210694d044d6 = {
    // ========== STATEMENTS ==========
    ExpressionStatement: (runtime, node)=>{
        const runtimeWithPop = runtime.pushInstruction([
            (0, $6267764a9e4139a0$export$97ba93b9cbfc1a2a)()
        ]);
        return runtimeWithPop.pushNode([
            node.expr
        ]);
    },
    SelectionStatement: (runtime, node)=>{
        const runtimeWithPushedInstruction = runtime.pushInstruction([
            (0, $6267764a9e4139a0$export$7bbd9e64d7d89276)(node.ifStatements, node.elseStatements ?? [], node.position)
        ]);
        return runtimeWithPushedInstruction.pushNode([
            node.condition
        ]);
    },
    // === ITERATION STATEMENTS ===
    DoWhileLoop: (runtime, node)=>{
        const hasBreak = (0, $7831f17922f95070$export$1fd68fc40ac03f60)(node.body);
        const hasContinue = (0, $7831f17922f95070$export$8737284613612c48)(node.body);
        let pRuntime = runtime;
        if (hasBreak) pRuntime = pRuntime.push([
            (0, $6267764a9e4139a0$export$b05b23eadb7974c4)()
        ]);
        pRuntime = pRuntime.push([
            node.condition,
            (0, $6267764a9e4139a0$export$f39db7568112fd08)(node.condition, node.body, hasContinue, node.position)
        ]);
        if (hasContinue) pRuntime = pRuntime.push([
            (0, $6267764a9e4139a0$export$ffaa6afe94c1fdbb)()
        ]);
        return pRuntime.push([
            ...node.body
        ]);
    },
    WhileLoop: (runtime, node)=>{
        const hasBreak = (0, $7831f17922f95070$export$1fd68fc40ac03f60)(node.body);
        const hasContinue = (0, $7831f17922f95070$export$8737284613612c48)(node.body);
        let pRuntime = runtime;
        if (hasBreak) pRuntime = pRuntime.push([
            (0, $6267764a9e4139a0$export$b05b23eadb7974c4)()
        ]);
        pRuntime = pRuntime.push([
            (0, $6267764a9e4139a0$export$f39db7568112fd08)(node.condition, node.body, hasContinue, node.position)
        ]);
        return pRuntime.push([
            node.condition
        ]);
    },
    ForLoop: (runtime, node)=>{
        const hasBreak = (0, $7831f17922f95070$export$1fd68fc40ac03f60)(node.body);
        const hasContinue = (0, $7831f17922f95070$export$8737284613612c48)(node.body);
        const condition = node.condition === null ? {
            type: "IntegerConstant",
            value: 1n,
            dataType: "signed int",
            position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
        } : node.condition;
        const forLoopInstr = (0, $6267764a9e4139a0$export$1f66b719349452a8)(node.body, node.update, condition, hasContinue, node.position);
        let pRuntime = runtime;
        if (hasBreak) pRuntime = pRuntime.push([
            (0, $6267764a9e4139a0$export$b05b23eadb7974c4)()
        ]);
        return pRuntime.push([
            ...node.clause,
            condition,
            forLoopInstr
        ]);
    },
    // === JUMP STATEMENTS ===
    ReturnStatement: (runtime, node)=>{
        const topControlItem = runtime.peekControl();
        if (topControlItem.type === "STACKFRAMETEARDOWNINSTRUCTION" || runtime.hasCompleted()) return runtime;
        else {
            const returnStatement = {
                type: "ReturnStatement",
                position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
            };
            const [_, popedRuntime] = runtime.popControl();
            const newRuntime = popedRuntime.push([
                returnStatement
            ]);
            return newRuntime;
        }
    },
    BreakStatement: (runtime, node)=>{
        let currRuntime = runtime;
        let foundBreakMark = false;
        while(!currRuntime.isControlEmpty()){
            const [item, newRuntime] = currRuntime.popNode();
            currRuntime = newRuntime;
            if ((0, $6267764a9e4139a0$export$ecb67aa3f8204e37)(item)) {
                foundBreakMark = true;
                break;
            }
        }
        if (!foundBreakMark) throw new Error("Unable to locate break mark");
        return currRuntime;
    },
    ContinueStatement: (runtime, node)=>{
        let currRuntime = runtime;
        let foundContinueMark = false;
        while(!currRuntime.isControlEmpty()){
            const [item, newRuntime] = currRuntime.popNode();
            currRuntime = newRuntime;
            if ((0, $6267764a9e4139a0$export$92eb496c5d233e76)(item)) {
                foundContinueMark = true;
                break;
            }
        }
        if (!foundContinueMark) throw new Error("Unable to locate continue mark");
        return currRuntime;
    },
    /**
   * Followed from: https://stackoverflow.com/questions/68406541/how-cases-get-evaluated-in-switch-statements-c
   */ SwitchStatement: (runtime, node)=>{
        const hasBreak = (0, $7831f17922f95070$export$1fd68fc40ac03f60)([
            ...node.cases.flatMap((c)=>c.statements),
            ...node.defaultStatements
        ]);
        const conditions = [];
        const statements = [];
        for(let i = 0; i < node.cases.length; i++){
            const caseItem = node.cases[i];
            const casePair = (0, $6267764a9e4139a0$export$9105b61d48bb9d0)(i);
            conditions.push(caseItem.condition.rightExpr);
            conditions.push(casePair.jumpInstruction);
            statements.push(casePair.markInstruction);
            statements.push(...caseItem.statements);
        }
        if (node.defaultStatements) {
            const defaultPair = (0, $6267764a9e4139a0$export$b43aee7b6f90d96b)();
            conditions.push(defaultPair.jumpInstruction);
            statements.push(defaultPair.markInstruction);
            statements.push(...node.defaultStatements);
        }
        let updatedRuntime = runtime;
        if (hasBreak) updatedRuntime = updatedRuntime.push([
            (0, $6267764a9e4139a0$export$b05b23eadb7974c4)()
        ]);
        return updatedRuntime.push(statements).push(conditions).push([
            node.targetExpression
        ]);
    },
    // ========== MEMORY ==========
    MemoryLoad: (runtime, node)=>{
        return runtime.push([
            node.address,
            (0, $6267764a9e4139a0$export$6635a48965c3499e)(node.dataType, node.position)
        ]);
    },
    FunctionTableIndex: (runtime, node)=>{
        const newRuntime = runtime.pushValue(node);
        return newRuntime;
    },
    MemoryStore: (runtime, node)=>{
        return runtime.push([
            node.value,
            node.address,
            (0, $6267764a9e4139a0$export$1bc324c1a920826d)(node.dataType, (0, $aa3386e207fc8611$export$c1a271a97a079552)),
            (0, $6267764a9e4139a0$export$97ba93b9cbfc1a2a)()
        ]);
    },
    LocalAddress: (runtime, node)=>{
        return runtime.pushValue((0, $615d1dd8a38a9293$export$32eac480e2ff4122)(BigInt(runtime.getPointers().basePointer.value) + node.offset.value));
    },
    DataSegmentAddress: (runtime, node)=>{
        return runtime.pushValue((0, $615d1dd8a38a9293$export$32eac480e2ff4122)(node.offset.value));
    },
    ReturnObjectAddress: (runtime, node)=>{
        if (node.subtype === "load") return runtime.pushValue((0, $615d1dd8a38a9293$export$32eac480e2ff4122)(BigInt(runtime.getPointers().stackPointer.value) + node.offset.value));
        else return runtime.pushValue((0, $615d1dd8a38a9293$export$32eac480e2ff4122)(BigInt(runtime.getPointers().basePointer.value) + node.offset.value));
    },
    DynamicAddress: (runtime, node)=>{
        return runtime.pushNode([
            node.address
        ]);
    },
    FunctionCall: (runtime, node)=>{
        // push order: stack frame tear down instruction, call instruction (contains function details information, and function call information),
        // arguments
        const pointers = runtime.getPointers();
        if (node.calledFunction.type === "DirectlyCalledFunction") {
            const calledFunction = node.calledFunction;
            calledFunction;
            const index = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functionTable.findIndex((x)=>x.functionName === calledFunction.functionName);
            const funcDetails = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functions.find((x)=>x.name === calledFunction.functionName);
            if (index === -1) throw new Error(`Function not found: ${calledFunction.functionName}`);
            const targetPosition = funcDetails?.position || (0, $aa3386e207fc8611$export$c1a271a97a079552);
            const funcIndex = {
                type: "FunctionTableIndex",
                index: {
                    type: "IntegerConstant",
                    value: BigInt(index),
                    dataType: "unsigned int",
                    position: targetPosition
                },
                position: targetPosition,
                dataType: "pointer"
            };
            const newRuntime = runtime.push([
                ...node.args,
                funcIndex,
                (0, $6267764a9e4139a0$export$2f00d225c49b711d)(node.calledFunction, node.functionDetails, targetPosition),
                (0, $6267764a9e4139a0$export$d9305c39e55b1eb6)(calledFunction.functionName, pointers.basePointer.value, pointers.stackPointer.value, targetPosition)
            ]);
            return newRuntime;
        } else throw new Error("TODO: Implement indirectly called function");
    },
    // ========== EXPRESSIONS ==========
    IntegerConstant: (runtime, node)=>{
        return runtime.pushValue(node);
    },
    FloatConstant: (runtime, node)=>{
        return runtime.pushValue(node);
    },
    BinaryExpression: (runtime, node)=>{
        const runtimeWithInstruction = runtime.pushInstruction([
            (0, $6267764a9e4139a0$export$ec48ff0e1e703c7d)(node.operator, node.dataType, node.position)
        ]);
        const runtimeWithRight = runtimeWithInstruction.pushNode([
            node.rightExpr
        ]);
        const newRuntime = runtime.push([
            node.leftExpr,
            node.rightExpr,
            (0, $6267764a9e4139a0$export$ec48ff0e1e703c7d)(node.operator, node.dataType, node.position)
        ]);
        return runtimeWithRight.pushNode([
            node.leftExpr
        ]);
    },
    UnaryExpression: (runtime, node)=>{
        const runtimeWithInstruction = runtime.pushInstruction([
            (0, $6267764a9e4139a0$export$b229fa3c9b082d4f)(node.operator, node.position)
        ]);
        return runtimeWithInstruction.pushNode([
            node.expr
        ]);
    },
    PreStatementExpression: (runtime, node)=>{
        const newRuntime = runtime.push([
            ...node.statements,
            node.expr
        ]);
        return newRuntime;
    },
    PostStatementExpression: (runtime, node)=>{
        const newRuntime = runtime.push([
            node.expr,
            ...node.statements
        ]);
        return newRuntime;
    },
    ConditionalExpression: (runtime, node)=>{
        const runtimeWithInstruction = runtime.pushInstruction([
            (0, $6267764a9e4139a0$export$7bbd9e64d7d89276)([
                node.trueExpression
            ], [
                node.falseExpression
            ], node.position)
        ]);
        return runtimeWithInstruction.pushNode([
            node.condition
        ]);
    }
};









const $ca4a859fe993d49f$export$4547c04865e84cd6 = {
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).UNARY_OP]: (runtime, instruction)=>{
        const [operand, runtimeAfterPop] = runtime.popValue();
        if (!(0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(operand)) throw new Error(`Unary operation '${instruction.operator} requires an operand, but stash is empty'`);
        /**
     * Bottom evaluation is same as in ~src\processor\evaluateCompileTimeExpression.ts
     * performUnaryOperation has been fixed to support "!" and "~"
     */ const dataType = operand.dataType;
        let value = (0, $4a3275d19fa7fc08$export$865e368bb7818fa8)(operand.value, instruction.operator);
        if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(dataType)) {
            value = (0, $e3d15c53d7bc5411$export$5ab497d4db862f91)(value, dataType);
            return runtimeAfterPop.pushValue({
                type: "IntegerConstant",
                dataType: dataType,
                value: value,
                position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
            });
        } else return runtimeAfterPop.pushValue({
            type: "FloatConstant",
            dataType: dataType,
            value: value,
            position: operand.position
        });
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BINARY_OP]: (runtime, instruction)=>{
        const [right, runtimeAfterPopRight] = runtime.popValue();
        const [left, runtimeAfterPopLeft] = runtimeAfterPopRight.popValue();
        if (!((0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(left) || (0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isMemoryAddress(left)) || !((0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(right) || (0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isMemoryAddress(right))) throw new Error(`Binary operator '${instruction.operator}' encountered operands that are not a constant or an address`);
        return runtimeAfterPopLeft.pushValue((0, $aa3386e207fc8611$export$c92ae396da927a27)(left, instruction.operator, right));
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BRANCH]: (runtime, instruction)=>{
        const [condition, runtimeWithPoppedValue] = runtime.popValue();
        if (!(0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(condition)) throw new Error("Branch instruction expects a boolean");
        const isTrue = (0, $aa3386e207fc8611$export$57332ffc9c92a549)(condition);
        if (isTrue) return runtimeWithPoppedValue.pushNode(instruction.trueExpr);
        return runtimeWithPoppedValue.pushNode(instruction.falseExpr);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).MEMORY_STORE]: (runtime, instruction)=>{
        const [address, runtimeAfter] = runtime.popValue();
        const [value, _] = runtimeAfter.popValue();
        /**
     * Ensures that address is a MemoryAddress
     * Checks for mismatches between address, value and instruction dataTypes
     */ if (address.type !== "MemoryAddress") throw new Error(`Expected MemoryAddress, but got ${address.type}`);
        // if (value.type === "FunctionTableIndex") {
        //   throw new Error(`Did not expect FunctionTableIndex`);
        // }
        let newValue;
        if (value.type === "FunctionTableIndex") newValue = value.index;
        else newValue = value;
        return runtimeAfter.memoryWrite([
            {
                type: "RuntimeMemoryPair",
                address: address,
                value: newValue,
                dataType: instruction.dataType
            }
        ]);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).MEMORY_LOAD]: (runtime, instruction)=>{
        const [address, _] = runtime.popValue();
        if (address.type !== "MemoryAddress") throw new Error(`Expected MemoryAddress, but got ${address.type}`);
        return runtime.memoryLoad(address, instruction.dataType);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).STACKFRAMETEARDOWNINSTRUCTION]: (runtime, instruction)=>{
        const newRuntime = runtime.stackFrameTearDown(instruction.stackPointer, instruction.basePointer);
        return newRuntime;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).FUNCTIONINDEXWRAPPER]: (runtime, instruction)=>{
        const [index, popedRuntime] = runtime.popValue();
        let wrappedFunctionIndex;
        if (index.type === "IntegerConstant") wrappedFunctionIndex = {
            type: "FunctionTableIndex",
            index: index,
            dataType: "pointer",
            position: index.position
        };
        else if (index.type === "MemoryAddress") wrappedFunctionIndex = {
            type: "FunctionTableIndex",
            index: {
                type: "IntegerConstant",
                value: index.value,
                dataType: "unsigned int",
                position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
            },
            dataType: "pointer",
            position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
        };
        else if (index.type === "FunctionTableIndex") wrappedFunctionIndex = index;
        else throw new Error(`Wrong type for function index value in Function index wrapper, expected: IntegerConstant or MemoryAddress, got: ${index.type}`);
        const newRuntime = popedRuntime.pushValue(wrappedFunctionIndex);
        return newRuntime;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CALLINSTRUCTION]: (runtime, instruction)=>{
        let [functionAddress, poppedRuntime] = runtime.popValue();
        const numOfParameters = instruction.functionDetails.parameters.length;
        const parameters = [];
        for(let i = 0; i < numOfParameters; i++){
            const [parameter, newRuntime] = poppedRuntime.popValue();
            parameters.push(parameter);
            poppedRuntime = newRuntime;
        }
        parameters.reverse();
        if (functionAddress.type !== "FunctionTableIndex") throw new Error("Wrong function pointer type in Call instruction");
        const calledFunction = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functionTable[Number(functionAddress.index.value)];
        if ((0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functions.find((x)=>x.name === calledFunction.functionName)) {
            const func = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functions.find((x)=>x.name === calledFunction.functionName);
            if (!func) throw new Error("No function called: " + calledFunction.functionName);
            // Set up a new Stackframe
            const sizeOfParams = instruction.functionDetails.sizeOfParams;
            const sizeOfLocals = func.sizeOfLocals;
            const sizeOfReturn = instruction.functionDetails.sizeOfReturn;
            const writtenRuntime = poppedRuntime.stackFrameSetup(sizeOfParams, sizeOfLocals, sizeOfReturn, parameters);
            // push body statements
            const resultRuntime = writtenRuntime.push(func.body);
            return resultRuntime;
        } else {
            // Set up a new Stackframe
            const sizeOfParams = instruction.functionDetails.sizeOfParams;
            const sizeOfReturn = instruction.functionDetails.sizeOfReturn;
            const writtenRuntime = poppedRuntime.stackFrameSetup(sizeOfParams, 0, sizeOfReturn, parameters);
            // Copy current memory into the modules repository memory;
            writtenRuntime.writeToModulesMemory();
            let func = undefined, encapsulatingModule;
            for (const moduleName of (0, $bf9b58631501cd70$export$269330a1f1074312).includedModules){
                const module = (0, $bf9b58631501cd70$export$269330a1f1074312).modules.modules[moduleName];
                if (module.moduleFunctions[calledFunction.functionName]) {
                    func = module.moduleFunctions[calledFunction.functionName];
                    encapsulatingModule = module;
                    break;
                }
            }
            if (!func) throw new Error(`Function ${calledFunction.functionName} not found in included modules.`);
            const returnObjects = calledFunction.functionDetails.returnObjects;
            if (!returnObjects) {
                func.jsFunction.apply(encapsulatingModule, parameters.map((x)=>{
                    if (x.type === "IntegerConstant" || x.type === "FloatConstant" || x.type === "MemoryAddress") return Number(x.value);
                    else return Number(x.index);
                }));
                // Clone module repository memory after function call
                const finalRuntime = writtenRuntime.cloneModuleMemory();
                return finalRuntime;
            } else {
                const res = func.jsFunction.apply(encapsulatingModule, parameters.map((x)=>{
                    if (x.type === "IntegerConstant" || x.type === "FloatConstant" || x.type === "MemoryAddress") return Number(x.value);
                    else return Number(x.index);
                }));
                // Clone module repository memory after function call
                const finalRuntime = writtenRuntime.cloneModuleMemory();
                let results = [];
                // check if res is an array
                if (Array.isArray(res)) results = res;
                else results = [
                    res
                ];
                if (results.length !== returnObjects.length) throw new Error("results of external function length does not match returnObjects length");
                // Prepare memory store expressions for each return object address
                const memoryStoreExpressions = [];
                let currentOffSet = 0;
                for(let i = 0; i < results.length; i++){
                    let storedValue;
                    if (returnObjects[i].dataType === "float" || returnObjects[i].dataType === "double") storedValue = {
                        type: "FloatConstant",
                        value: Number(results[i]),
                        dataType: returnObjects[i].dataType,
                        position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
                    };
                    else storedValue = {
                        type: "IntegerConstant",
                        value: BigInt(results[i]),
                        dataType: returnObjects[i].dataType,
                        position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
                    };
                    const expression = {
                        type: "MemoryStore",
                        address: {
                            type: "ReturnObjectAddress",
                            subtype: "store",
                            offset: {
                                type: "IntegerConstant",
                                value: BigInt(currentOffSet),
                                dataType: "signed int",
                                position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
                            },
                            dataType: "pointer",
                            position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
                        },
                        position: (0, $aa3386e207fc8611$export$c1a271a97a079552),
                        dataType: returnObjects[i].dataType,
                        value: storedValue
                    };
                    memoryStoreExpressions.push(expression);
                    currentOffSet += (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(returnObjects[i].dataType);
                }
                const returnStatement = {
                    type: "ReturnStatement",
                    position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
                };
                return finalRuntime.push([
                    ...memoryStoreExpressions,
                    returnStatement
                ]);
            }
        }
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).POP]: (runtime, instruction)=>{
        const [_, runtimeAfterPop] = runtime.popValue();
        return runtimeAfterPop;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).WHILE]: (runtime, instruction)=>{
        let [condition, updatedRuntime] = runtime.popValue();
        if (!(0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(condition)) throw new Error("While instruction expects a boolean");
        const isTrue = (0, $aa3386e207fc8611$export$57332ffc9c92a549)(condition);
        if (!isTrue) return updatedRuntime;
        updatedRuntime = updatedRuntime.push([
            instruction.condition,
            instruction
        ]);
        if (instruction.hasContinue) updatedRuntime = updatedRuntime.push([
            (0, $6267764a9e4139a0$export$ffaa6afe94c1fdbb)()
        ]);
        return updatedRuntime.push(instruction.body);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).FORLOOP]: (runtime, instruction)=>{
        let [condition, updatedRuntime] = runtime.popValue();
        if (!(0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(condition)) throw new Error("While instruction expects a boolean");
        const isTrue = (0, $aa3386e207fc8611$export$57332ffc9c92a549)(condition);
        if (!isTrue) return updatedRuntime;
        updatedRuntime = updatedRuntime.push([
            ...instruction.update,
            instruction.condition,
            instruction
        ]);
        if (instruction.hasContinue) updatedRuntime = updatedRuntime.push([
            (0, $6267764a9e4139a0$export$ffaa6afe94c1fdbb)()
        ]);
        return updatedRuntime.push(instruction.body);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CASE_JUMP]: (runtime, instruction)=>{
        const [right, runtimeAfterPopRight] = runtime.popValue();
        let currRuntime = runtimeAfterPopRight;
        // if not default case jump instruction perform the below
        if (!(0, $6267764a9e4139a0$export$5ca3f3f6e16eec9d)(instruction)) {
            const [left, runtimeAfterPopLeft] = runtimeAfterPopRight.popValue();
            if (!(0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(left) || !(0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isConstant(right)) throw new Error(`Case jump requires 2 constants in stash`);
            // manually check for equality
            const isTrueValue = (0, $aa3386e207fc8611$export$c92ae396da927a27)(left, "==", right);
            if ((0, $aedf17afe77f7184$export$8be94b08bb3c4aa3).isMemoryAddress(isTrueValue)) throw new Error(`Case jump '${instruction.caseValue}' encountered a MemoryAddress`);
            const isTrue = (0, $aa3386e207fc8611$export$57332ffc9c92a549)(isTrueValue);
            // if not true, return stash after popping the case expression
            if (!isTrue) return runtimeAfterPopRight;
            currRuntime = runtimeAfterPopLeft;
        }
        let foundCaseMark = false;
        // if true jump to the respective case markpo
        while(!currRuntime.isControlEmpty()){
            const [item, newRuntime] = currRuntime.popNode();
            currRuntime = newRuntime;
            if ((0, $6267764a9e4139a0$export$c4b69223939120f7)(item) && (0, $6267764a9e4139a0$export$a55296325935d46e)(instruction, item)) {
                foundCaseMark = true;
                break;
            }
        }
        if (!foundCaseMark) throw new Error("Unable to locate associated case mark statement");
        return currRuntime;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CASE_MARK]: (runtime, instruction)=>{
        return runtime;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CONTINUE_MARK]: (runtime, instruction)=>{
        return runtime;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BREAK_MARK]: (runtime, instruction)=>{
        return runtime;
    }
};









function $0e3dcdadceadf815$export$479342ae9ee04fd1(byteStr) {
    const matches = byteStr.match(/\\([0-9a-fA-F]{2})/g);
    if (!matches) return new Uint8Array();
    const byteArray = new Uint8Array(matches.length);
    for(let i = 0; i < matches.length; ++i){
        const byteValue = parseInt(matches[i].slice(1), 16);
        byteArray[i] = byteValue;
    }
    return byteArray;
}
class $0e3dcdadceadf815$export$29d4d7bc03c348a5 {
    static #_ = this.cnt = 0;
    // Constructor to initiate the first runtime object
    constructor(dataSegmentByteStr, dataSegmentSizeInBytes, heapBuffer, stackBuffer){
        console.log($0e3dcdadceadf815$export$29d4d7bc03c348a5.cnt + 1);
        $0e3dcdadceadf815$export$29d4d7bc03c348a5.cnt++;
        this.dataSegmentSizeInBytes = dataSegmentSizeInBytes;
        this.dataSegmentByteStr = dataSegmentByteStr;
        this.heapBuffer = heapBuffer ?? 1 * (0, $cd849de488b21116$export$1e75eda4edae07f4);
        this.stackBuffer = stackBuffer ?? 1 * (0, $cd849de488b21116$export$1e75eda4edae07f4);
        const totalMemory = this.dataSegmentSizeInBytes + this.heapBuffer + this.stackBuffer;
        const initialPages = (0, $7f0b08f9e0a6f0f6$export$7f687b7d9f9da81c)(totalMemory);
        this.memory = new WebAssembly.Memory({
            initial: initialPages
        });
        this.sharedWasmGlobalVariables = {
            /**
       * stackPointer set to the highest address
       * basePointer set to the highest address
       * heapPointer set to after data portion
       */ stackPointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, (0, $cd849de488b21116$export$6c8528ef4d2c6a36) * initialPages),
            basePointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, (0, $cd849de488b21116$export$6c8528ef4d2c6a36) * initialPages),
            heapPointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, dataSegmentSizeInBytes + 4)
        };
        // Initiate the data segment that stores global and static values
        const dataSegmentByteArray = $0e3dcdadceadf815$export$479342ae9ee04fd1(dataSegmentByteStr);
        const view = new Uint8Array(this.memory.buffer);
        for(let i = 0; i < dataSegmentByteArray.length; i++)view[i] = dataSegmentByteArray[i];
    }
    // sets the values for stack pointer, base pointer, heap pointer
    // Coppies the current memory buffer and pointers on to Global Modules memory
    writeToModuleMemory() {
        const memoryView = new Uint8Array(this.memory.buffer);
        const moduleView = new Uint8Array((0, $bf9b58631501cd70$export$269330a1f1074312).modules.memory.buffer);
        if (memoryView.length !== moduleView.length) throw new Error(`Memory size mismatch: interpreter memory length (${memoryView.length}) does not match module memory length (${moduleView.length})`);
        for(let i = 0; i < memoryView.byteLength; i++)moduleView[i] = memoryView[i];
        (0, $bf9b58631501cd70$export$269330a1f1074312).modules.sharedWasmGlobalVariables.basePointer.value = this.sharedWasmGlobalVariables.basePointer.value;
        (0, $bf9b58631501cd70$export$269330a1f1074312).modules.sharedWasmGlobalVariables.heapPointer.value = this.sharedWasmGlobalVariables.heapPointer.value;
        (0, $bf9b58631501cd70$export$269330a1f1074312).modules.sharedWasmGlobalVariables.stackPointer.value = this.sharedWasmGlobalVariables.stackPointer.value;
    }
    // Create a new memory instance that has the same content as the modules memory
    cloneModuleMemory() {
        const resultMemory = this.clone();
        const moduleView = new Uint8Array((0, $bf9b58631501cd70$export$269330a1f1074312).modules.memory.buffer);
        const memoryView = new Uint8Array(resultMemory.memory.buffer);
        if (memoryView.byteLength !== moduleView.byteLength) throw new Error(`Memory size mismatch: interpreter memory length (${memoryView.length}) does not match module memory length (${moduleView.length})`);
        for(let i = 0; i < memoryView.byteLength; i++)memoryView[i] = moduleView[i];
        resultMemory.sharedWasmGlobalVariables.basePointer.value = (0, $bf9b58631501cd70$export$269330a1f1074312).modules.sharedWasmGlobalVariables.basePointer.value;
        resultMemory.sharedWasmGlobalVariables.heapPointer.value = (0, $bf9b58631501cd70$export$269330a1f1074312).modules.sharedWasmGlobalVariables.heapPointer.value;
        resultMemory.sharedWasmGlobalVariables.stackPointer.value = (0, $bf9b58631501cd70$export$269330a1f1074312).modules.sharedWasmGlobalVariables.stackPointer.value;
        return resultMemory;
    }
    setPointers(stackPointer, basePointer, heapPointer) {
        if (heapPointer > stackPointer) throw new Error("Segmentation fault: Heap pointer clashed with stack pointer");
        this.sharedWasmGlobalVariables = {
            stackPointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, stackPointer),
            basePointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, basePointer),
            heapPointer: new WebAssembly.Global({
                value: (0, $c5715c2f7f6b98cf$export$2759f7980f8ec3ee),
                mutable: true
            }, heapPointer)
        };
    }
    stackFrameSetup(sizeOfParams, sizeOfLocals, sizeOfReturn, parameters) {
        const newMemory = this.clone();
        const totalSize = sizeOfParams + sizeOfLocals + sizeOfReturn;
        const SP = this.sharedWasmGlobalVariables.stackPointer.value - totalSize;
        const BP = this.sharedWasmGlobalVariables.stackPointer.value - sizeOfReturn;
        newMemory.setPointers(SP, BP, this.sharedWasmGlobalVariables.heapPointer.value);
        let offset = 0;
        const writeParameters = parameters.map((writeObject)=>{
            if (writeObject.type !== "IntegerConstant" && writeObject.type !== "FloatConstant" && writeObject.type !== "MemoryAddress") throw new Error(`Did not expect ${writeObject.type} in stackFrameSetup`);
            const dataType = writeObject.type === "MemoryAddress" ? "pointer" : writeObject.dataType;
            const size = (0, $7f0b08f9e0a6f0f6$export$81e4f5d420beeafd)(dataType);
            offset -= size;
            const writeAddress = BigInt(offset) + BigInt(newMemory.sharedWasmGlobalVariables.basePointer.value);
            // if MemoryAddress convert it to a ConstantP
            const writeValue = (0, $615d1dd8a38a9293$export$20f70d5ec785445f)(writeObject);
            // ConstantP is stored as ConstantP
            return {
                type: "MemoryWriteInterface",
                address: writeAddress,
                dataType: dataType,
                value: writeValue
            };
        });
        return newMemory.write(writeParameters);
    }
    stackFrameTearDown(stackPointer, basePointer) {
        const newMemory = this.clone();
        newMemory.setPointers(stackPointer, basePointer, this.sharedWasmGlobalVariables.heapPointer.value);
        return newMemory;
    }
    checkOutOfBounds(address) {
        return address < 0 || address >= this.memory.buffer.byteLength;
    }
    // function to write a data type with a value to the memory in the address
    write(values) {
        const newMemory = this.clone();
        const newMemoryView = new Uint8Array(newMemory.memory.buffer);
        for (const value of values){
            const bytestr = (0, $c031121e0d12b198$export$8c4138854bdcb152)(value.value, value.dataType);
            const byteArray = $0e3dcdadceadf815$export$479342ae9ee04fd1(bytestr);
            if (this.checkOutOfBounds(value.address)) {
                console.log(value.address);
                console.log(byteArray.length);
                console.log(bytestr);
                console.log(value.dataType);
                throw new Error("Memory out of bounds");
            }
            for(let i = 0; i < Math.min(byteArray.length, this.memory.buffer.byteLength - Number(value.address)); i++)newMemoryView[i + Number(value.address)] = byteArray[i];
        }
        return newMemory;
    }
    load(address, dataType) {
        // handles pointers
        if (dataType === "pointer") {
            // Load pointer value as "unsigned int" as they occupy the same amount of space
            const size = (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)["unsigned int"];
            this.checkOutOfBounds(address.value);
            const view = new Uint8Array(this.memory.buffer);
            let value = 0n;
            for(let i = 0; i < Math.min(size, this.memory.buffer.byteLength - Number(address.value)); i++)value |= BigInt(view[Number(address.value) + i]) << BigInt(8 * i);
            // returns a MemoryAddress instead of a ConstantP
            return (0, $615d1dd8a38a9293$export$32eac480e2ff4122)(value);
        }
        // handles the rest of the ScalarCDataTypes
        const size = (0, $7f0b08f9e0a6f0f6$export$b5718ce31b3dbec7)[dataType];
        this.checkOutOfBounds(address.value);
        const view = new Uint8Array(this.memory.buffer);
        if ((0, $7f0b08f9e0a6f0f6$export$2f1f32faea3020ff)(dataType)) {
            let value = 0n;
            for(let i = 0; i < Math.min(size, this.memory.buffer.byteLength - Number(address.value)); i++)value |= BigInt(view[Number(address.value) + i]) << BigInt(8 * i);
            const signBit = 1n << BigInt(size * 8 - 1);
            const fullMask = 1n << BigInt(size * 8);
            if (value & signBit) value = value - fullMask;
            else value;
            return {
                type: "IntegerConstant",
                value: value,
                dataType: dataType,
                position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
            };
        } else if ((0, $7f0b08f9e0a6f0f6$export$4a7e02d8ef2dc77a)(dataType)) {
            const buffer = this.memory.buffer;
            const offset = Number(address.value);
            let floatValue;
            if (dataType === "float") floatValue = new DataView(buffer).getFloat32(offset, true);
            else floatValue = new DataView(buffer).getFloat64(offset, true);
            return {
                type: "FloatConstant",
                value: floatValue,
                dataType: dataType,
                position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
            };
        } else throw new Error("Unknown load value type");
    }
    clone() {
        return this;
    // const clone = new Memory(
    //   this.dataSegmentByteStr,
    //   this.dataSegmentSizeInBytes,
    //   this.heapBuffer,
    //   this.stackBuffer
    // )
    // const originalView = new Uint8Array(this.memory.buffer);
    // const cloneView = new Uint8Array(clone.memory.buffer);
    // cloneView.set(originalView);
    // clone.setPointers(
    //   this.sharedWasmGlobalVariables.stackPointer.value,
    //   this.sharedWasmGlobalVariables.basePointer.value,
    //   this.sharedWasmGlobalVariables.heapPointer.value
    // )
    // return clone;
    }
    getFormattedMemoryView(start = 0, end) {
        const memoryView = new Uint8Array(this.memory.buffer);
        const length = end ?? memoryView.length;
        const BP = Number(this.sharedWasmGlobalVariables.basePointer.value);
        const SP = Number(this.sharedWasmGlobalVariables.stackPointer.value);
        const HP = Number(this.sharedWasmGlobalVariables.heapPointer.value);
        const result = "";
        // result += "=== Memory Layout (partial) ===\n";
        // result += `Base Pointer (BP):  0x${BP.toString(10)} (${BP})\n`;
        // result += `Stack Pointer (SP): 0x${SP.toString(10)} (${SP})\n`;
        // result += `Heap Pointer (HP):  0x${HP.toString(10)} (${HP})\n`;
        // result += "================================\n";
        // const bytesPerRow = 16;
        // for (let i = start; i < Math.min(length, memoryView.length); i += bytesPerRow) {
        //   const bytes = memoryView.slice(i, i + bytesPerRow);
        //   const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' ');
        //   const ascii = Array.from(bytes).map(b => (b >= 32 && b < 127 ? String.fromCharCode(b) : '.')).join('');
        //   result += `0x${i.toString(16).padStart(8, '0')}: ${hex.padEnd(3 * bytesPerRow)} | ${ascii}\n`;
        // }
        return result;
    }
}



class $bf9b58631501cd70$export$269330a1f1074312 {
    constructor(control, stash, memory){
        this.stash = stash || new (0, $aedf17afe77f7184$export$8be94b08bb3c4aa3)();
        this.control = control || new (0, $45537d54220eef3f$export$7a7fa4424cb20976)();
        if (!memory) {
            if (!$bf9b58631501cd70$export$269330a1f1074312.astRootP) throw new Error("AST Root node not assigned");
            this.memory = new (0, $0e3dcdadceadf815$export$29d4d7bc03c348a5)($bf9b58631501cd70$export$269330a1f1074312.astRootP.dataSegmentByteStr, $bf9b58631501cd70$export$269330a1f1074312.astRootP.dataSegmentSizeInBytes);
        } else this.memory = memory;
    }
    next() {
        if (this.hasCompleted()) return new $bf9b58631501cd70$export$269330a1f1074312(this.control, this.stash, this.memory);
        const [item, newControl] = this.control.pop();
        const poppedRuntime = new $bf9b58631501cd70$export$269330a1f1074312(newControl, this.stash, this.memory);
        if ((0, $6267764a9e4139a0$export$517b0c6d75337fc8)(item)) return poppedRuntime.evaluateInstruction(item);
        else return poppedRuntime.evaluateNode(item);
    }
    evaluateNode(node) {
        const evaluator = (0, $4c069963d8c4e053$export$85b8210694d044d6)[node.type];
        if (evaluator) {
            const result = evaluator(this, node);
            return result;
        } else throw new Error(`Unknown node type ${node.type}`);
    }
    evaluateInstruction(instruction) {
        if ((0, $ca4a859fe993d49f$export$4547c04865e84cd6)[instruction.type]) {
            const result = (0, $ca4a859fe993d49f$export$4547c04865e84cd6)[instruction.type](this, instruction);
            return result;
        } else throw new Error("Unknown instruction type");
    }
    getFunction(name) {
        return $bf9b58631501cd70$export$269330a1f1074312.astRootP.functions.find((x)=>x.name === name);
    }
    // ===== MEMORY =====
    writeToModulesMemory() {
        this.memory.writeToModuleMemory();
    }
    cloneModuleMemory() {
        const newMemory = this.memory.cloneModuleMemory();
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control, this.stash, newMemory);
    }
    cloneMemory() {
        return this.memory.clone();
    }
    memoryWrite(pairs) {
        const memoryWriteInterfaceArr = pairs.map((pair)=>{
            const writeValue = (0, $615d1dd8a38a9293$export$20f70d5ec785445f)(pair.value);
            return {
                type: "MemoryWriteInterface",
                address: pair.address.value,
                value: writeValue,
                dataType: pair.dataType
            };
        });
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control, this.stash, this.memory.write(memoryWriteInterfaceArr));
    }
    memoryLoad(address, dataType) {
        const value = this.memory.load(address, dataType);
        const [_, newRuntime] = this.popValue();
        return newRuntime.pushValue(value);
    }
    stackFrameSetup(sizeOfParams, sizeOfLocals, sizeOfReturn, parameters) {
        const newMemory = this.memory.stackFrameSetup(sizeOfParams, sizeOfLocals, sizeOfReturn, parameters);
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control, this.stash, newMemory);
    }
    stackFrameTearDown(stackPointer, basePointer) {
        const newMemory = this.memory.stackFrameTearDown(stackPointer, basePointer);
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control, this.stash, newMemory);
    }
    getPointers() {
        return this.memory.sharedWasmGlobalVariables;
    }
    // Control functions
    // function to push general instruction/CNodeP onto the control
    push(item) {
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control.concat([
            ...item
        ].reverse()), this.stash, this.memory);
    }
    pushNode(node) {
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control.concat([
            ...node
        ].reverse()), this.stash, this.memory);
    }
    pushInstruction(instruction) {
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control.concat([
            ...instruction
        ].reverse()), this.stash, this.memory);
    }
    // STASH FUNCTIONS
    pushValue(value) {
        return new $bf9b58631501cd70$export$269330a1f1074312(this.control, this.stash.push(value), this.memory);
    }
    popNode() {
        const [node, newControl] = this.control.pop();
        if (node === undefined) throw new Error("Undefined popped node");
        return [
            node,
            new $bf9b58631501cd70$export$269330a1f1074312(newControl, this.stash, this.memory)
        ];
    }
    popValue() {
        const [value, newStash] = this.stash.pop();
        if (value === undefined) throw new Error("Undefined popped stash value");
        return [
            value,
            new $bf9b58631501cd70$export$269330a1f1074312(this.control, newStash, this.memory)
        ];
    }
    hasCompleted() {
        return this.control.isEmpty();
    }
    getResult() {
        return this.stash.isEmpty() ? null : this.stash.peek();
    }
    peekControl() {
        return this.control.peek();
    }
    popControl() {
        const [popedItem, newControl] = this.control.pop();
        const newRuntime = new $bf9b58631501cd70$export$269330a1f1074312(newControl, this.stash, this.memory);
        if (popedItem === undefined) throw new Error("Cannot pop control: no elements left");
        return [
            popedItem,
            newRuntime
        ];
    }
    isControlEmpty() {
        return this.control.isEmpty();
    }
    toString() {
        let result = "\n----- INTERPRETER STATE -----\n";
        result += "\nCONTROL:\n";
        result += this.control.toString();
        result += "\n\nSTASH:\n";
        result += this.stash.toString();
        result += "\n\nREGISTERED FUNCTIONS:\n";
        if ($bf9b58631501cd70$export$269330a1f1074312.astRootP.functions.length === 0) result += "  <none>";
        else for (const func of $bf9b58631501cd70$export$269330a1f1074312.astRootP.functions)result += `  ${func.name}\n`;
        result += "\n-----------------------------";
        result += this.memory.getFormattedMemoryView();
        return result;
    }
    getControl() {
        return this.control;
    }
    getStash() {
        return this.stash;
    }
    getMemory() {
        return this.memory;
    }
}






class $ab578cd88f2696dc$export$8949fddf10447898 {
    constructor(functionName, basePointer, memory){
        this.variablesMap = new Map();
        this.functionName = functionName;
        const addressMap = (0, $8c698c0438819abb$export$8f5345d7eb869598).getAddressMap();
        const map = addressMap.getAddressMap();
        console.log("LON ME MAY", map);
        map.forEach((entry, name)=>{
            const parts = name.split("::");
            const varName = parts[1];
            const scope = parts[0];
            if (scope === functionName) {
                const absoluteAddress = entry.offset + basePointer;
                const value = memory.load({
                    type: "MemoryAddress",
                    value: BigInt(absoluteAddress),
                    hexValue: absoluteAddress.toString(16)
                }, "signed int");
                if (value.type !== "IntegerConstant") throw new Error("Stackframe: Not implemented yet");
                this.variablesMap.set(varName, {
                    ...entry,
                    absoluteAddress: absoluteAddress,
                    value: Number(value.value)
                });
            }
        });
    }
}







class $8c91e30fbe002c74$export$e5b52c46a548ff03 {
    constructor(astRootNode, includedModules, moduleConfig, sourceCode){
        this.astRootNode = astRootNode;
        this.runtimeStack = []; // CURRENTLY NOT USED WITH HOW INTERPRETER IS SETUP
        this.includedModules = includedModules;
        this.moduleConfig = moduleConfig;
        this.sourceCode = sourceCode;
    }
    async interpretTillStep(targetStep) {
        (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP = this.astRootNode;
        (0, $bf9b58631501cd70$export$269330a1f1074312).includedModules = this.includedModules;
        (0, $bf9b58631501cd70$export$269330a1f1074312).sourceCode = this.sourceCode;
        const mainFunction = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functions.find((x)=>x.name === "main");
        if (!mainFunction) throw new Error("Main function not defined");
        // call main
        const initialRuntime = new (0, $bf9b58631501cd70$export$269330a1f1074312)(new (0, $45537d54220eef3f$export$7a7fa4424cb20976)([
            {
                type: "FunctionCall",
                calledFunction: {
                    type: "DirectlyCalledFunction",
                    functionName: "main",
                    position: this.astRootNode.position
                },
                functionDetails: {
                    sizeOfParams: 0,
                    sizeOfReturn: 4,
                    parameters: [],
                    returnObjects: [
                        {
                            dataType: "signed int",
                            offset: 0
                        }
                    ]
                },
                args: [],
                position: this.astRootNode.position
            }
        ]));
        (0, $bf9b58631501cd70$export$269330a1f1074312).modules = new (0, $d6c6ee2ce4472628$export$2e2bcd8739ae039)(initialRuntime.cloneMemory().memory, new WebAssembly.Table({
            element: "anyfunc",
            initial: 2
        }), this.moduleConfig);
        for (const moduleName of (0, $bf9b58631501cd70$export$269330a1f1074312).includedModules)if (typeof (0, $bf9b58631501cd70$export$269330a1f1074312).modules.modules[moduleName].instantiate !== "undefined") await (0, $bf9b58631501cd70$export$269330a1f1074312).modules.modules[moduleName].instantiate();
        this.runtimeStack.push(initialRuntime);
        let currentRuntime = initialRuntime;
        let currStep = 0;
        if (targetStep === -1) while(!currentRuntime.isControlEmpty()){
            currentRuntime = currentRuntime.next();
            this.runtimeStack.push(currentRuntime);
            currStep++;
        }
        else while(currStep !== targetStep){
            currentRuntime = currentRuntime.next();
            this.runtimeStack.push(currentRuntime);
            currStep++;
        }
        // setup environment for visualizer
        const tearDowns = currentRuntime.getControl().getTearDowns().reverse();
        let lastBasePointer = currentRuntime.getPointers().basePointer.value;
        const stackFrames = [];
        for(let i = 0; i < tearDowns.length; i++){
            if (tearDowns[i].type !== (0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).STACKFRAMETEARDOWNINSTRUCTION) throw new Error("Expected a StackFrameTearDown Instruction");
            console.log("TEAR DOWN GOT HERE: ", stackFrames[i]);
            stackFrames.push(new (0, $ab578cd88f2696dc$export$8949fddf10447898)(tearDowns[i].functionName, lastBasePointer, currentRuntime.getMemory()));
            lastBasePointer = tearDowns[i].basePointer;
        }
        return {
            astRoot: this.astRootNode,
            control: currentRuntime.getControl(),
            stash: currentRuntime.getStash(),
            memory: currentRuntime.getMemory(),
            step: currStep,
            stackFrames: stackFrames
        };
    }
    async interpret() {
        (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP = this.astRootNode;
        (0, $bf9b58631501cd70$export$269330a1f1074312).includedModules = this.includedModules;
        const mainFunction = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functions.find((x)=>x.name === "main");
        if (!mainFunction) throw new Error("Main function not defined");
        // call main
        console.log("Starting interpretation...");
        console.log(this.astRootNode.position);
        const initialRuntime = new (0, $bf9b58631501cd70$export$269330a1f1074312)(new (0, $45537d54220eef3f$export$7a7fa4424cb20976)([
            {
                type: "FunctionCall",
                calledFunction: {
                    type: "DirectlyCalledFunction",
                    functionName: "main",
                    position: (0, $aa3386e207fc8611$export$c1a271a97a079552)
                },
                functionDetails: {
                    sizeOfParams: 0,
                    sizeOfReturn: 4,
                    parameters: [],
                    returnObjects: [
                        {
                            dataType: "signed int",
                            offset: 0
                        }
                    ]
                },
                args: [],
                position: this.astRootNode.position
            }
        ]));
        (0, $bf9b58631501cd70$export$269330a1f1074312).modules = new (0, $d6c6ee2ce4472628$export$2e2bcd8739ae039)(initialRuntime.cloneMemory().memory, new WebAssembly.Table({
            element: "anyfunc",
            initial: 100
        }), this.moduleConfig);
        for (const moduleName of (0, $bf9b58631501cd70$export$269330a1f1074312).includedModules)if (typeof (0, $bf9b58631501cd70$export$269330a1f1074312).modules.modules[moduleName].instantiate !== "undefined") await (0, $bf9b58631501cd70$export$269330a1f1074312).modules.modules[moduleName].instantiate();
        this.runtimeStack.push(initialRuntime);
        let currentRuntime = initialRuntime;
        // console.log(currentRuntime.toString());
        while(!currentRuntime.hasCompleted()){
            currentRuntime = currentRuntime.next();
            // console.log(currentRuntime.toString());
            this.runtimeStack.push(currentRuntime);
        }
    }
    toString() {
        if (this.runtimeStack.length === 0) return "Runtime Stack: <empty>";
        let result = `Runtime Stack: ${this.runtimeStack.length} states\n`;
        for(let i = 0; i < this.runtimeStack.length; i++){
            result += `\n====== State ${i + 1} ======\n`;
            result += this.runtimeStack[i].toString();
            result += "\n";
        }
        return result;
    }
}





function $29d5c7e8e9cfab6e$export$67beed298888a38b(astRootNode, includedModules, moduleConfig, sourceCode) {
    const interpreter = new (0, $8c91e30fbe002c74$export$e5b52c46a548ff03)(astRootNode, includedModules, moduleConfig, sourceCode);
    interpreter.interpret();
}
async function $29d5c7e8e9cfab6e$export$3567556d58c2cae(astRootNode, includedModules, moduleConfig, targetStep, sourceCode) {
    const interpreter = new (0, $8c91e30fbe002c74$export$e5b52c46a548ff03)(astRootNode, includedModules, moduleConfig, sourceCode);
    (0, $8c698c0438819abb$export$8f5345d7eb869598).reload();
    return await interpreter.interpretTillStep(targetStep);
}
function $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem) {
    const codePosition = controlItem.position;
    // extract the code position at a line start and line end
    const lines = (0, $bf9b58631501cd70$export$269330a1f1074312).sourceCode.split("\n");
    const extractedCode = lines.slice(codePosition.start.line - 1, codePosition.end.line).filter((line)=>line.trim() !== "");
    if (extractedCode.length > 0) {
        extractedCode[0] = extractedCode[0].slice(codePosition.start.column - 1);
        extractedCode[extractedCode.length - 1] = extractedCode[extractedCode.length - 1].slice(0, codePosition.end.column - 1);
    }
    return extractedCode.join("\n");
}
function $29d5c7e8e9cfab6e$export$7b429031fe89ea9f(controlItem) {
    if ((0, $6267764a9e4139a0$export$517b0c6d75337fc8)(controlItem)) {
        const type = controlItem.type;
        const fn = $29d5c7e8e9cfab6e$export$e8a8d0ca26dbf9c6[type];
        if (fn) return fn(controlItem);
    } else {
        const type = controlItem.type;
        const fn = $29d5c7e8e9cfab6e$export$6b717a7b89b3aa[type];
        if (fn) return fn(controlItem);
    }
    throw new Error("Unknown instruction type");
}
const $29d5c7e8e9cfab6e$export$e8a8d0ca26dbf9c6 = {
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BINARY_OP]: (controlItem)=>{
        return "Binary operator: " + controlItem.operator;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BRANCH]: (controlItem)=>{
        const extractedCode = $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
        return "Branch instruction: " + extractedCode;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).BREAK_MARK]: (controlItem)=>{
        return "Break Mark";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CALLINSTRUCTION]: (controlItem)=>{
        return "Call Function";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CASE_JUMP]: (controlItem)=>{
        return "Case Jump";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CASE_MARK]: (controlItem)=>{
        return "Case Mark";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).CONTINUE_MARK]: (controlItem)=>{
        return "Continue Mark";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).FORLOOP]: (controlItem)=>{
        return "Loop: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).FUNCTIONINDEXWRAPPER]: (controlItem)=>{
        return "Function Index Wrapper";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).MEMORY_LOAD]: (controlItem)=>{
        return "Memory Load: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).MEMORY_STORE]: (controlItem)=>{
        return "Memory Store: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).POP]: (controlItem)=>{
        return "Pop";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).STACKFRAMETEARDOWNINSTRUCTION]: (controlItem)=>{
        return "Stack tear down";
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).UNARY_OP]: (controlItem)=>{
        return "Unary operation: " + controlItem.operator;
    },
    [(0, $6267764a9e4139a0$export$c11d6cfb99c9fdfb).WHILE]: (controlItem)=>{
        return "While loop: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    }
};
const $29d5c7e8e9cfab6e$export$6b717a7b89b3aa = {
    ExpressionStatement: (controlItem)=>{
        return "Expression: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    SelectionStatement: (controlItem)=>{
        return "Selection: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    DoWhileLoop: (controlItem)=>{
        return "DoWhile: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    WhileLoop: (controlItem)=>{
        return "WhileLoop: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    ForLoop: (controlItem)=>{
        return "ForLoop: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    ReturnStatement: (controlItem)=>{
        return "Return Statement: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    BreakStatement: (controlItem)=>{
        return "Break: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    ContinueStatement: (controlItem)=>{
        return "Continue Statement";
    },
    SwitchStatement: (controlItem)=>{
        return "Switch: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    MemoryLoad: (controlItem)=>{
        return "Memory Load Node: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    FunctionTableIndex: (controlItem)=>{
        const funcIndex = controlItem.index.value;
        if (funcIndex < 0 || funcIndex > (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functionTable.length) throw new Error("Index of desired function out of bounds");
        const funcName = (0, $bf9b58631501cd70$export$269330a1f1074312).astRootP.functionTable[Number(funcIndex)].functionName;
        return funcName;
    },
    MemoryStore: (controlItem)=>{
        return "Memory Store Node: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    LocalAddress: (controlItem)=>{
        return "Local Address: " + controlItem.offset.value.toString();
    },
    DataSegmentAddress: (controlItem)=>{
        return "Data Segment Address: " + controlItem.offset.value.toString();
    },
    ReturnObjectAddress: (controlItem)=>{
        return "Return Object Address: " + controlItem.offset.value.toString();
    },
    DynamicAddress: (controlItem)=>{
        return "Dynamic Address: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem.address);
    },
    FunctionCall: (controlItem)=>{
        return "Function call: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    IntegerConstant: (controlItem)=>{
        return controlItem.value.toString();
    },
    FloatConstant: (controlItem)=>{
        return controlItem.value.toString();
    },
    BinaryExpression: (controlItem)=>{
        return "Binary ExpressionP: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    UnaryExpression: (controlItem)=>{
        return "UnaryExpressionP: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    PreStatementExpression: (controlItem)=>{
        return "PreStatemetn: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    PostStatementExpression: (controlItem)=>{
        return "PostStatement: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    ConditionalExpression: (controlItem)=>{
        return "Conditional: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    },
    FunctionDefinition: (controlItem)=>{
        return "Function: " + $29d5c7e8e9cfab6e$export$5a4be6c31be3bdd2(controlItem);
    }
};


async function $c20cbec167d66736$export$ef7acd7185315e22(cSourceCode, moduleRepository) {
    try {
        const { cAstRoot: cAstRoot, warnings: warnings } = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
        const { astRootNode: astRootNode, includedModules: includedModules, warnings: processorWarnings } = (0, $3bbec8f49ad76a86$export$2e2bcd8739ae039)(cAstRoot, moduleRepository);
        warnings.push(...processorWarnings.map((w)=>(0, $28ac839a9eca26f5$export$9a24d8f7b932fdc5)(w.message, cSourceCode, w.position)));
        // interpret(astRootNode, cAstRoot.includedModules, moduleRepository.config); // here
        const wasmModule = (0, $edd1d19f265dea24$export$2e2bcd8739ae039)(astRootNode, moduleRepository);
        const output = await (0, $35ff0e651cf79adf$export$244319998795f476)((0, $df2c68a1897a685b$export$38d6b8478af371c3)(wasmModule));
        return {
            status: "success",
            wasm: output,
            dataSegmentSize: wasmModule.dataSegmentSize,
            functionTableSize: wasmModule.functionTable.size,
            importedModules: includedModules,
            warnings: warnings
        };
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$53d7a5fe44e5fb7e)) return {
            status: "failure",
            errorMessage: e.generateCompilationErrorMessage(cSourceCode)
        };
        if (e instanceof (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)) return {
            status: "failure",
            errorMessage: e.message
        };
        throw e;
    }
}
async function $c20cbec167d66736$export$fef61f332f2c0afc(cSourceCode, moduleRepository, targetStep) {
    try {
        const { cAstRoot: cAstRoot, warnings: warnings } = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
        const { astRootNode: astRootNode, includedModules: includedModules, warnings: processorWarnings } = (0, $3bbec8f49ad76a86$export$2e2bcd8739ae039)(cAstRoot, moduleRepository);
        warnings.push(...processorWarnings.map((w)=>(0, $28ac839a9eca26f5$export$9a24d8f7b932fdc5)(w.message, cSourceCode, w.position)));
        const outputContext = await (0, $29d5c7e8e9cfab6e$export$3567556d58c2cae)(astRootNode, cAstRoot.includedModules, moduleRepository.config, targetStep, cSourceCode);
        return {
            status: "success",
            context: outputContext,
            importedModules: includedModules
        };
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$53d7a5fe44e5fb7e)) return {
            status: "failure",
            errorMessage: e.generateCompilationErrorMessage(cSourceCode)
        };
        if (e instanceof (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)) return {
            status: "failure",
            errorMessage: e.message
        };
        throw e;
    }
}
function $c20cbec167d66736$export$7ed1e80d6eebb0bb(cSourceCode, moduleRepository) {
    try {
        const { cAstRoot: cAstRoot, warnings: warnings } = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
        const { astRootNode: astRootNode, warnings: processorWarnings } = (0, $3bbec8f49ad76a86$export$2e2bcd8739ae039)(cAstRoot, moduleRepository);
        warnings.push(...processorWarnings.map((w)=>(0, $28ac839a9eca26f5$export$9a24d8f7b932fdc5)(w.message, cSourceCode, w.position)));
        const wasmModule = (0, $edd1d19f265dea24$export$2e2bcd8739ae039)(astRootNode, moduleRepository);
        const output = (0, $df2c68a1897a685b$export$38d6b8478af371c3)(wasmModule);
        return {
            status: "success",
            watOutput: output,
            warnings: warnings
        };
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$53d7a5fe44e5fb7e)) return {
            status: "failure",
            errorMessage: e.generateCompilationErrorMessage(cSourceCode)
        };
        if (e instanceof (0, $28ac839a9eca26f5$export$f7dd392e51e3b514)) return {
            status: "failure",
            errorMessage: e.message
        };
        throw e;
    }
}
function $c20cbec167d66736$export$fbcbb0932d163f5c(cSourceCode, moduleRepository) {
    try {
        const parsedResult = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
        return (0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(parsedResult);
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$53d7a5fe44e5fb7e)) e.generateCompilationErrorMessage(cSourceCode);
        throw e;
    }
}
function $c20cbec167d66736$export$9d0f5d4929a5c5ad(cSourceCode, moduleRepository) {
    try {
        const { cAstRoot: cAstRoot } = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
        const { astRootNode: astRootNode } = (0, $3bbec8f49ad76a86$export$2e2bcd8739ae039)(cAstRoot, moduleRepository);
        return (0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(astRootNode);
    } catch (e) {
        if (e instanceof (0, $28ac839a9eca26f5$export$53d7a5fe44e5fb7e)) e.generateCompilationErrorMessage(cSourceCode);
        throw e;
    }
}
function $c20cbec167d66736$export$d54d1a0fdc0ee87e(cSourceCode, moduleRepository) {
    const { cAstRoot: cAstRoot } = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
    const { astRootNode: astRootNode } = (0, $3bbec8f49ad76a86$export$2e2bcd8739ae039)(cAstRoot, moduleRepository);
    //checkForErrors(cSourceCode, CAst, Object.keys(wasmModuleImports)); // use semantic analyzer to check for semantic errors
    const wasmAst = (0, $edd1d19f265dea24$export$2e2bcd8739ae039)(astRootNode, moduleRepository);
    return (0, $28ac839a9eca26f5$export$d5b7a8bf56ee1fe2)(wasmAst);
}
function $c20cbec167d66736$export$a0451f39bcc24e74(cSourceCode, moduleRepository, moduleConfig) {
    const { cAstRoot: cAstRoot } = (0, $812b9a955e75cbf9$export$2e2bcd8739ae039)(cSourceCode, moduleRepository);
    const { astRootNode: astRootNode } = (0, $3bbec8f49ad76a86$export$2e2bcd8739ae039)(cAstRoot, moduleRepository);
    (0, $29d5c7e8e9cfab6e$export$67beed298888a38b)(astRootNode, cAstRoot.includedModules, moduleConfig, cSourceCode);
}






const $149c1bd638913645$export$e6fa218cf6f57ac3 = new (0, $d6c6ee2ce4472628$export$2e2bcd8739ae039)(); // default repository containing module information without any custom configs or wasm memory
function $149c1bd638913645$export$7ed1e80d6eebb0bb(program) {
    return (0, $c20cbec167d66736$export$7ed1e80d6eebb0bb)(program, $149c1bd638913645$export$e6fa218cf6f57ac3);
}
function $149c1bd638913645$export$d54d1a0fdc0ee87e(program) {
    return (0, $c20cbec167d66736$export$d54d1a0fdc0ee87e)(program, $149c1bd638913645$export$e6fa218cf6f57ac3);
}
function $149c1bd638913645$export$a0451f39bcc24e74(program, modulesConfig) {
    return (0, $c20cbec167d66736$export$a0451f39bcc24e74)(program, $149c1bd638913645$export$e6fa218cf6f57ac3, modulesConfig);
}
async function $149c1bd638913645$export$fef61f332f2c0afc(program, modulesConfig, targetStep) {
    return await (0, $c20cbec167d66736$export$fef61f332f2c0afc)(program, $149c1bd638913645$export$e6fa218cf6f57ac3, targetStep);
}
async function $149c1bd638913645$export$ef7acd7185315e22(program) {
    const compilationResult = await (0, $c20cbec167d66736$export$ef7acd7185315e22)(program, $149c1bd638913645$export$e6fa218cf6f57ac3);
    // check if compilation failed
    if (compilationResult.status === "failure") return compilationResult;
    return compilationResult;
}
async function $149c1bd638913645$export$528d7c97418b1bdd(program, modulesConfig) {
    const compilationResult = await (0, $c20cbec167d66736$export$ef7acd7185315e22)(program, $149c1bd638913645$export$e6fa218cf6f57ac3);
    // check if compilation failed
    if (compilationResult.status === "failure") return compilationResult;
    const { wasm: wasm, dataSegmentSize: dataSegmentSize, functionTableSize: functionTableSize, importedModules: importedModules } = compilationResult;
    await $149c1bd638913645$export$9a15f6f70b6cc031(wasm, dataSegmentSize, functionTableSize, importedModules, modulesConfig);
    return compilationResult;
}
async function $149c1bd638913645$export$9a15f6f70b6cc031(wasm, dataSegmentSize, functionTableSize, importedModules, modulesConfig) {
    const numberOfInitialPagesNeeded = (0, $7f0b08f9e0a6f0f6$export$7f687b7d9f9da81c)(dataSegmentSize);
    const moduleRepository = new (0, $d6c6ee2ce4472628$export$2e2bcd8739ae039)(new WebAssembly.Memory({
        initial: numberOfInitialPagesNeeded
    }), new WebAssembly.Table({
        element: "anyfunc",
        initial: functionTableSize
    }), modulesConfig);
    moduleRepository.setStackPointerValue(numberOfInitialPagesNeeded * (0, $c5715c2f7f6b98cf$export$c1ad5496a9a8d12e));
    moduleRepository.setBasePointerValue(numberOfInitialPagesNeeded * (0, $c5715c2f7f6b98cf$export$c1ad5496a9a8d12e));
    moduleRepository.setHeapPointerValue(Math.ceil(dataSegmentSize / 4) * 4); // align to 4 bytes
    const wasmImports = await moduleRepository.createWasmImportsObject(importedModules);
    await WebAssembly.instantiate(wasm, wasmImports);
}
function $149c1bd638913645$export$9d0f5d4929a5c5ad(program) {
    return (0, $c20cbec167d66736$export$9d0f5d4929a5c5ad)(program, $149c1bd638913645$export$e6fa218cf6f57ac3);
}
function $149c1bd638913645$export$fbcbb0932d163f5c(program) {
    return (0, $c20cbec167d66736$export$fbcbb0932d163f5c)(program, $149c1bd638913645$export$e6fa218cf6f57ac3);
}


export {$149c1bd638913645$export$e6fa218cf6f57ac3 as defaultModuleRepository, $149c1bd638913645$export$7ed1e80d6eebb0bb as compileToWat, $149c1bd638913645$export$d54d1a0fdc0ee87e as generate_WAT_AST, $149c1bd638913645$export$a0451f39bcc24e74 as interpret_C_AST, $149c1bd638913645$export$fef61f332f2c0afc as evaluate, $149c1bd638913645$export$ef7acd7185315e22 as compile, $149c1bd638913645$export$528d7c97418b1bdd as compileAndRun, $149c1bd638913645$export$9a15f6f70b6cc031 as runWasm, $149c1bd638913645$export$9d0f5d4929a5c5ad as generate_processed_C_AST, $149c1bd638913645$export$fbcbb0932d163f5c as generate_C_AST, $6267764a9e4139a0$export$c11d6cfb99c9fdfb as InstructionType, $29d5c7e8e9cfab6e$export$7b429031fe89ea9f as controlItemToString};
//# sourceMappingURL=index.js.map
